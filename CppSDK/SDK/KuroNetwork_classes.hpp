#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: KuroNetwork

#include "Basic.hpp"

#include "KuroNetwork_structs.hpp"
#include "Engine_classes.hpp"
#include "CoreUObject_classes.hpp"
#include "JsEnv_structs.hpp"


namespace SDK
{

// Class KuroNetwork.KuroHttp
// 0x0000 (0x0030 - 0x0030)
class UKuroHttp final : public UBlueprintFunctionLibrary
{
public:
	static void Get(const class FString& URL, const TMap<class FString, class FString>& HeaderParam, TDelegate<void(bool bConnectedSuccessfully, int32 HttpResponseCode, const class FString& Data)> Handle, float InTimeoutSecs);
	static TMap<class FString, class FString> GetDefaultHeader();
	static void Post(const class FString& URL, const TMap<class FString, class FString>& HeaderParam, const class FString& Content, TDelegate<void(bool bConnectedSuccessfully, int32 HttpResponseCode, const class FString& Data)> Handle, float InTimeoutSecs);
	static void PostAli(const TMap<class FString, class FString>& QueryParameter, TDelegate<void(bool bConnectedSuccessfully, int32 HttpResponseCode, const class FString& Data)> Handle, float InTimeoutSecs);
	static void PostRpt(const class FString& ContentStr, bool IsGlobal, TDelegate<void(const class FString& Data, int32 LocalErrorCode, int32 RemoteErrorCode, int32 HttpResponseCode, bool bConnectedSuccessfully)> Handle, float InTimeoutSecs);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroHttp">();
	}
	static class UKuroHttp* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroHttp>();
	}
};
static_assert(alignof(UKuroHttp) == 0x000008, "Wrong alignment on UKuroHttp");
static_assert(sizeof(UKuroHttp) == 0x000030, "Wrong size on UKuroHttp");

// Class KuroNetwork.KuroHttpServerRequestProxy
// 0x0080 (0x00B0 - 0x0030)
class UKuroHttpServerRequestProxy final : public UObject
{
public:
	uint8                                         Pad_30[0x80];                                      // 0x0030(0x0080)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool GetHeader(const class FString& Key, TArray<class FString>* OutHeader);
	class FString GetRequest();
	void Response(const class FString& Json, const bool bSuccess);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroHttpServerRequestProxy">();
	}
	static class UKuroHttpServerRequestProxy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroHttpServerRequestProxy>();
	}
};
static_assert(alignof(UKuroHttpServerRequestProxy) == 0x000008, "Wrong alignment on UKuroHttpServerRequestProxy");
static_assert(sizeof(UKuroHttpServerRequestProxy) == 0x0000B0, "Wrong size on UKuroHttpServerRequestProxy");

// Class KuroNetwork.KuroHttpServerRouterProxy
// 0x0088 (0x00B8 - 0x0030)
class UKuroHttpServerRouterProxy final : public UObject
{
public:
	TDelegate<void(const class FString& ModuleName, const class UKuroHttpServerRequestProxy* RequestProxy)> HttpRequestDelegate; // 0x0030(0x0028)(ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
	uint8                                         Pad_58[0x60];                                      // 0x0058(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BindRoute(const class FString& ModuleName);
	void CreateRouter(const int32 Port);
	void StartServer();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroHttpServerRouterProxy">();
	}
	static class UKuroHttpServerRouterProxy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroHttpServerRouterProxy>();
	}
};
static_assert(alignof(UKuroHttpServerRouterProxy) == 0x000008, "Wrong alignment on UKuroHttpServerRouterProxy");
static_assert(sizeof(UKuroHttpServerRouterProxy) == 0x0000B8, "Wrong size on UKuroHttpServerRouterProxy");
static_assert(offsetof(UKuroHttpServerRouterProxy, HttpRequestDelegate) == 0x000030, "Member 'UKuroHttpServerRouterProxy::HttpRequestDelegate' has a wrong offset!");

// Class KuroNetwork.KuroKcpClient
// 0x0368 (0x0398 - 0x0030)
class UKuroKcpClient final : public UObject
{
public:
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void()>              OnConnectSuccess;                                  // 0x0038(0x0010)(ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
	TDelegate<void(int32 SeqNo, int16 RpdId, uint16 MessageId, const struct FArrayBuffer& MessageBuffer)> OnRecResp; // 0x0048(0x0028)(ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
	TDelegate<void(int32 SeqNo, int16 RpdId, uint32 ErrorCode, const struct FArrayBuffer& StringBuffer)> OnRecException; // 0x0070(0x0028)(ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
	TDelegate<void(int32 SeqNo, uint16 MessageId, const struct FArrayBuffer& MessageBuffer)> OnRecPush; // 0x0098(0x0028)(ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
	TDelegate<void(uint32 ErrorCode)>             OnRecTcpException;                                 // 0x00C0(0x0028)(ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
	TDelegate<void(int32 Code1, int32 Code2, int32 Code3, int32 Code4, int32 Code5)> OnError;        // 0x00E8(0x0028)(ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
	uint32                                        RemoteMtu;                                         // 0x0110(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UseNewResolveIp;                                   // 0x0114(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsMultiThreaded;                                   // 0x0115(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsTickDrivenOutside;                               // 0x0116(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          OpenSendVerify;                                    // 0x0117(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnTcpConnected;                                    // 0x0118(0x0010)(ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnTcpConnectFailed;                                // 0x0128(0x0010)(ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
	class UKuroTcpClient*                         TcpClient;                                         // 0x0138(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_140[0x258];                                    // 0x0140(0x0258)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CloseTcpConnect();
	void HandleKcpConnect(const uint32 NeedCrcCheck, const uint32 Conv);
	void HandleTcpConnected();
	void HandleTcpConnectFailed();
	void SendTcpMessage(int16 RpcId, int16 MsgId, const struct FArrayBuffer& ArrayBuffer);
	void SetEnType(uint8 Type, int16 MsgId);
	bool SetK(uint8 Type, const struct FArrayBuffer& KeyBuffer);
	void SetKcpMtu(int32 Mtu);
	void SetKcpNoDelay(int32 NoDelay, int32 Interval, int32 Resend, int32 Nc);
	void SetKcpSegmentSize(int32 SegmentSize);
	void SetKcpStream(bool bStream);
	void SetKcpWndSize(int32 SndWnd, int32 RcvWnd);
	void StartTcpConnect(const int32 Port);
	void TickOutside(float DeltaSeconds);

	bool IsTcpConnectStart() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroKcpClient">();
	}
	static class UKuroKcpClient* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroKcpClient>();
	}
};
static_assert(alignof(UKuroKcpClient) == 0x000008, "Wrong alignment on UKuroKcpClient");
static_assert(sizeof(UKuroKcpClient) == 0x000398, "Wrong size on UKuroKcpClient");
static_assert(offsetof(UKuroKcpClient, OnConnectSuccess) == 0x000038, "Member 'UKuroKcpClient::OnConnectSuccess' has a wrong offset!");
static_assert(offsetof(UKuroKcpClient, OnRecResp) == 0x000048, "Member 'UKuroKcpClient::OnRecResp' has a wrong offset!");
static_assert(offsetof(UKuroKcpClient, OnRecException) == 0x000070, "Member 'UKuroKcpClient::OnRecException' has a wrong offset!");
static_assert(offsetof(UKuroKcpClient, OnRecPush) == 0x000098, "Member 'UKuroKcpClient::OnRecPush' has a wrong offset!");
static_assert(offsetof(UKuroKcpClient, OnRecTcpException) == 0x0000C0, "Member 'UKuroKcpClient::OnRecTcpException' has a wrong offset!");
static_assert(offsetof(UKuroKcpClient, OnError) == 0x0000E8, "Member 'UKuroKcpClient::OnError' has a wrong offset!");
static_assert(offsetof(UKuroKcpClient, RemoteMtu) == 0x000110, "Member 'UKuroKcpClient::RemoteMtu' has a wrong offset!");
static_assert(offsetof(UKuroKcpClient, UseNewResolveIp) == 0x000114, "Member 'UKuroKcpClient::UseNewResolveIp' has a wrong offset!");
static_assert(offsetof(UKuroKcpClient, IsMultiThreaded) == 0x000115, "Member 'UKuroKcpClient::IsMultiThreaded' has a wrong offset!");
static_assert(offsetof(UKuroKcpClient, IsTickDrivenOutside) == 0x000116, "Member 'UKuroKcpClient::IsTickDrivenOutside' has a wrong offset!");
static_assert(offsetof(UKuroKcpClient, OpenSendVerify) == 0x000117, "Member 'UKuroKcpClient::OpenSendVerify' has a wrong offset!");
static_assert(offsetof(UKuroKcpClient, OnTcpConnected) == 0x000118, "Member 'UKuroKcpClient::OnTcpConnected' has a wrong offset!");
static_assert(offsetof(UKuroKcpClient, OnTcpConnectFailed) == 0x000128, "Member 'UKuroKcpClient::OnTcpConnectFailed' has a wrong offset!");
static_assert(offsetof(UKuroKcpClient, TcpClient) == 0x000138, "Member 'UKuroKcpClient::TcpClient' has a wrong offset!");

// Class KuroNetwork.KuroKcpTestWorker
// 0x0250 (0x0280 - 0x0030)
class UKuroKcpTestWorker final : public UObject
{
public:
	uint8                                         Pad_30[0x250];                                     // 0x0030(0x0250)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnConnectSuccess();
	void OnRecvException(int32 SeqNo, int16 RpcId, int32 ErrorCode, struct FArrayBuffer* MessageBuff);
	void OnRecvPush(int32 SeqNo, uint16 MessageId, struct FArrayBuffer* MessageBuff);
	void OnRecvResponse(int32 SeqNo, int16 RpcId, uint16 MessageId, struct FArrayBuffer* MessageBuff);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroKcpTestWorker">();
	}
	static class UKuroKcpTestWorker* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroKcpTestWorker>();
	}
};
static_assert(alignof(UKuroKcpTestWorker) == 0x000008, "Wrong alignment on UKuroKcpTestWorker");
static_assert(sizeof(UKuroKcpTestWorker) == 0x000280, "Wrong size on UKuroKcpTestWorker");

// Class KuroNetwork.KuroNetworkChange
// 0x0020 (0x0050 - 0x0030)
class UKuroNetworkChange final : public UObject
{
public:
	TMulticastInlineDelegate<void(uint8 NetworkTransportType)> NetworkChangeDelegate;                // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_40[0x10];                                      // 0x0040(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	uint8 GetNetworkType();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroNetworkChange">();
	}
	static class UKuroNetworkChange* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroNetworkChange>();
	}
};
static_assert(alignof(UKuroNetworkChange) == 0x000008, "Wrong alignment on UKuroNetworkChange");
static_assert(sizeof(UKuroNetworkChange) == 0x000050, "Wrong size on UKuroNetworkChange");
static_assert(offsetof(UKuroNetworkChange, NetworkChangeDelegate) == 0x000030, "Member 'UKuroNetworkChange::NetworkChangeDelegate' has a wrong offset!");

// Class KuroNetwork.KuroNetworkDetection
// 0x0000 (0x0030 - 0x0030)
class UKuroNetworkDetection final : public UObject
{
public:
	static void DetectionFinish(bool bSuccess);
	static class FString GetCurrentProxyAddress();
	static class FString GetDetectionConfig(const class FString& ServerName);
	static void ResolveDomainFinish();
	static void ResolveDomainName(const class FString& DomainName, TDelegate<void(int32 ErrorCode)> Callback);
	static void SetCDNConfig(const class FString& CDNConfig);
	static void TestUdpReachable(const class FString& IpAddress, const TArray<int32>& Ports, TDelegate<void(int32 SuccessCount, int32 ErrorCode)> ResultDelegate);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroNetworkDetection">();
	}
	static class UKuroNetworkDetection* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroNetworkDetection>();
	}
};
static_assert(alignof(UKuroNetworkDetection) == 0x000008, "Wrong alignment on UKuroNetworkDetection");
static_assert(sizeof(UKuroNetworkDetection) == 0x000030, "Wrong size on UKuroNetworkDetection");

// Class KuroNetwork.KuroNetworkSetting
// 0x0058 (0x0088 - 0x0030)
class UKuroNetworkSetting final : public UObject
{
public:
	class FString                                 AlAki;                                             // 0x0030(0x0010)(Edit, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 AlAks;                                             // 0x0040(0x0010)(Edit, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 RptPub;                                            // 0x0050(0x0010)(Edit, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 RptUrl;                                            // 0x0060(0x0010)(Edit, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 RptUrlGlobal;                                      // 0x0070(0x0010)(Edit, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          EnableDump;                                        // 0x0080(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UseNativeMethod;                                   // 0x0081(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_82[0x6];                                       // 0x0082(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroNetworkSetting">();
	}
	static class UKuroNetworkSetting* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroNetworkSetting>();
	}
};
static_assert(alignof(UKuroNetworkSetting) == 0x000008, "Wrong alignment on UKuroNetworkSetting");
static_assert(sizeof(UKuroNetworkSetting) == 0x000088, "Wrong size on UKuroNetworkSetting");
static_assert(offsetof(UKuroNetworkSetting, AlAki) == 0x000030, "Member 'UKuroNetworkSetting::AlAki' has a wrong offset!");
static_assert(offsetof(UKuroNetworkSetting, AlAks) == 0x000040, "Member 'UKuroNetworkSetting::AlAks' has a wrong offset!");
static_assert(offsetof(UKuroNetworkSetting, RptPub) == 0x000050, "Member 'UKuroNetworkSetting::RptPub' has a wrong offset!");
static_assert(offsetof(UKuroNetworkSetting, RptUrl) == 0x000060, "Member 'UKuroNetworkSetting::RptUrl' has a wrong offset!");
static_assert(offsetof(UKuroNetworkSetting, RptUrlGlobal) == 0x000070, "Member 'UKuroNetworkSetting::RptUrlGlobal' has a wrong offset!");
static_assert(offsetof(UKuroNetworkSetting, EnableDump) == 0x000080, "Member 'UKuroNetworkSetting::EnableDump' has a wrong offset!");
static_assert(offsetof(UKuroNetworkSetting, UseNativeMethod) == 0x000081, "Member 'UKuroNetworkSetting::UseNativeMethod' has a wrong offset!");

// Class KuroNetwork.KuroTcpClient
// 0x0070 (0x00A0 - 0x0030)
class alignas(0x10) UKuroTcpClient final : public UObject
{
public:
	uint8                                         Pad_30[0x30];                                      // 0x0030(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          IsTickDrivenOutside;                               // 0x0060(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_61[0x2F];                                      // 0x0061(0x002F)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<uint8>                                 RecvData;                                          // 0x0090(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)

public:
	void CloseSocket();
	void Connect(const class FString& Addr, int32 Port);
	void Disconnect();
	void Send(const TArray<uint8>& Data);
	void ShutDownSocket();
	void TickOutside(float DeltaSeconds);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroTcpClient">();
	}
	static class UKuroTcpClient* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroTcpClient>();
	}
};
static_assert(alignof(UKuroTcpClient) == 0x000010, "Wrong alignment on UKuroTcpClient");
static_assert(sizeof(UKuroTcpClient) == 0x0000A0, "Wrong size on UKuroTcpClient");
static_assert(offsetof(UKuroTcpClient, IsTickDrivenOutside) == 0x000060, "Member 'UKuroTcpClient::IsTickDrivenOutside' has a wrong offset!");
static_assert(offsetof(UKuroTcpClient, RecvData) == 0x000090, "Member 'UKuroTcpClient::RecvData' has a wrong offset!");

// Class KuroNetwork.SendHttpRequest
// 0x0020 (0x0058 - 0x0038)
class USendHttpRequest final : public UBlueprintAsyncActionBase
{
public:
	TMulticastInlineDelegate<void(int32 Code, const class FString& Data)> OnSuccess;                 // 0x0038(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(int32 Code, const class FString& Data)> OnFail;                    // 0x0048(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static class USendHttpRequest* HttpRequest(const class FString& URL, EHttpMethod Method, const class FString& PostBody);
	static class USendHttpRequest* HttpRequestEx(const class FString& URL, EHttpMethod Method, const class FString& PostBody, const class FString& HeaderParam);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SendHttpRequest">();
	}
	static class USendHttpRequest* GetDefaultObj()
	{
		return GetDefaultObjImpl<USendHttpRequest>();
	}
};
static_assert(alignof(USendHttpRequest) == 0x000008, "Wrong alignment on USendHttpRequest");
static_assert(sizeof(USendHttpRequest) == 0x000058, "Wrong size on USendHttpRequest");
static_assert(offsetof(USendHttpRequest, OnSuccess) == 0x000038, "Member 'USendHttpRequest::OnSuccess' has a wrong offset!");
static_assert(offsetof(USendHttpRequest, OnFail) == 0x000048, "Member 'USendHttpRequest::OnFail' has a wrong offset!");

}

