#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: KuroHotPatch

#include "Basic.hpp"

#include "KuroHotPatch_classes.hpp"
#include "KuroHotPatch_parameters.hpp"


namespace SDK
{

// Function KuroHotPatch.DownloaderProxy.Cancel
// (Final, Native, Public, BlueprintCallable)

void UDownloaderProxy::Cancel()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DownloaderProxy", "Cancel");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function KuroHotPatch.DownloaderProxy.GetContentLength
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int64                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int64 UDownloaderProxy::GetContentLength()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DownloaderProxy", "GetContentLength");

	Params::DownloaderProxy_GetContentLength Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroHotPatch.DownloaderProxy.GetReceivedSize
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int64                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int64 UDownloaderProxy::GetReceivedSize()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DownloaderProxy", "GetReceivedSize");

	Params::DownloaderProxy_GetReceivedSize Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroHotPatch.DownloaderProxy.GetSavedSize
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int64                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int64 UDownloaderProxy::GetSavedSize()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DownloaderProxy", "GetSavedSize");

	Params::DownloaderProxy_GetSavedSize Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroHotPatch.DownloaderProxy.GetTotalDownloadTime
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UDownloaderProxy::GetTotalDownloadTime()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DownloaderProxy", "GetTotalDownloadTime");

	Params::DownloaderProxy_GetTotalDownloadTime Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroHotPatch.DownloaderProxy.HasComplete
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDownloaderProxy::HasComplete()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DownloaderProxy", "HasComplete");

	Params::DownloaderProxy_HasComplete Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroHotPatch.DownloaderProxy.SetCompleteCallback
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TDelegate<void(uint8 DownloadState, int32 HttpState)>InCb                                                   (Parm, ZeroConstructor, NativeAccessSpecifierPublic)

void UDownloaderProxy::SetCompleteCallback(TDelegate<void(uint8 DownloadState, int32 HttpState)> InCb)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DownloaderProxy", "SetCompleteCallback");

	Params::DownloaderProxy_SetCompleteCallback Parms{};

	Parms.InCb = InCb;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroHotPatch.DownloaderProxy.SetProgressCallback
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TDelegate<void(int64 ThisTimeReceiveSize, int64 ReceivedSize, int64 SavedSize)>InCb                                                   (Parm, ZeroConstructor, NativeAccessSpecifierPublic)

void UDownloaderProxy::SetProgressCallback(TDelegate<void(int64 ThisTimeReceiveSize, int64 ReceivedSize, int64 SavedSize)> InCb)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DownloaderProxy", "SetProgressCallback");

	Params::DownloaderProxy_SetProgressCallback Parms{};

	Parms.InCb = InCb;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroHotPatch.DownloaderProxy.Start
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           Url                                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           SavePath                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           Suffix                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int64                                   InFileSize                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InLimitTime                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bForceNew                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    InCache                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           Sha1                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InTimeout                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bNewTick                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDownloaderProxy::Start(const class FString& Url, const class FString& SavePath, const class FString& Suffix, const int64 InFileSize, const float InLimitTime, const bool bForceNew, const bool InCache, const class FString& Sha1, const float InTimeout, const bool bNewTick)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DownloaderProxy", "Start");

	Params::DownloaderProxy_Start Parms{};

	Parms.Url = std::move(Url);
	Parms.SavePath = std::move(SavePath);
	Parms.Suffix = std::move(Suffix);
	Parms.InFileSize = InFileSize;
	Parms.InLimitTime = InLimitTime;
	Parms.bForceNew = bForceNew;
	Parms.InCache = InCache;
	Parms.Sha1 = std::move(Sha1);
	Parms.InTimeout = InTimeout;
	Parms.bNewTick = bNewTick;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroHotPatch.DownloaderProxy.UnbindCallback
// (Final, Native, Public, BlueprintCallable)

void UDownloaderProxy::UnbindCallback()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DownloaderProxy", "UnbindCallback");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function KuroHotPatch.KuroCheckFiles.Check
// (Final, Native, Public, BlueprintCallable)

void UKuroCheckFiles::Check()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KuroCheckFiles", "Check");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function KuroHotPatch.KuroCheckFiles.Clear
// (Final, Native, Public, BlueprintCallable)

void UKuroCheckFiles::Clear()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KuroCheckFiles", "Clear");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function KuroHotPatch.KuroConfigPatcher.UpdateConfigs
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           ConfigListPath                                         (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKuroConfigPatcher::UpdateConfigs(const class FString& ConfigListPath)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroConfigPatcher", "UpdateConfigs");

	Params::KuroConfigPatcher_UpdateConfigs Parms{};

	Parms.ConfigListPath = std::move(ConfigListPath);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroHotPatch.KuroBinPatch.BeginPatch
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           Diff                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           OldDir                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           NewDir                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKuroBinPatch::BeginPatch(const class FString& Diff, const class FString& OldDir, const class FString& NewDir)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KuroBinPatch", "BeginPatch");

	Params::KuroBinPatch_BeginPatch Parms{};

	Parms.Diff = std::move(Diff);
	Parms.OldDir = std::move(OldDir);
	Parms.NewDir = std::move(NewDir);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroHotPatch.KuroLauncherLibrary.CheckFileSha1
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           FilePath                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           CheckSha1Hash                                          (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKuroLauncherLibrary::CheckFileSha1(const class FString& FilePath, const class FString& CheckSha1Hash)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroLauncherLibrary", "CheckFileSha1");

	Params::KuroLauncherLibrary_CheckFileSha1 Parms{};

	Parms.FilePath = std::move(FilePath);
	Parms.CheckSha1Hash = std::move(CheckSha1Hash);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroHotPatch.KuroLauncherLibrary.ClearPatchPaks
// (Final, Native, Static, Public, BlueprintCallable)

void UKuroLauncherLibrary::ClearPatchPaks()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroLauncherLibrary", "ClearPatchPaks");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function KuroHotPatch.KuroLauncherLibrary.CloseShaderLibrary
// (Final, Native, Static, Public, BlueprintCallable)

void UKuroLauncherLibrary::CloseShaderLibrary()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroLauncherLibrary", "CloseShaderLibrary");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function KuroHotPatch.KuroLauncherLibrary.CopyFile
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           DstPath                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           SrcPath                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKuroLauncherLibrary::CopyFile(const class FString& DstPath, const class FString& SrcPath)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroLauncherLibrary", "CopyFile");

	Params::KuroLauncherLibrary_CopyFile Parms{};

	Parms.DstPath = std::move(DstPath);
	Parms.SrcPath = std::move(SrcPath);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroHotPatch.KuroLauncherLibrary.Decrypt
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FString                           InCipher                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           OutPlain                                               (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKuroLauncherLibrary::Decrypt(const class FString& InCipher, class FString* OutPlain)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroLauncherLibrary", "Decrypt");

	Params::KuroLauncherLibrary_Decrypt Parms{};

	Parms.InCipher = std::move(InCipher);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutPlain != nullptr)
		*OutPlain = std::move(Parms.OutPlain);

	return Parms.ReturnValue;
}


// Function KuroHotPatch.KuroLauncherLibrary.DeleteDirectory
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           DirPath                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKuroLauncherLibrary::DeleteDirectory(const class FString& DirPath)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroLauncherLibrary", "DeleteDirectory");

	Params::KuroLauncherLibrary_DeleteDirectory Parms{};

	Parms.DirPath = std::move(DirPath);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroHotPatch.KuroLauncherLibrary.DeleteFile
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           FilePath                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKuroLauncherLibrary::DeleteFile(const class FString& FilePath)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroLauncherLibrary", "DeleteFile");

	Params::KuroLauncherLibrary_DeleteFile Parms{};

	Parms.FilePath = std::move(FilePath);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroHotPatch.KuroLauncherLibrary.DoesDiskHaveEnoughSpace
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           CheckPath                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int64                                   CheckSize                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKuroLauncherLibrary::DoesDiskHaveEnoughSpace(const class FString& CheckPath, const int64 CheckSize)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroLauncherLibrary", "DoesDiskHaveEnoughSpace");

	Params::KuroLauncherLibrary_DoesDiskHaveEnoughSpace Parms{};

	Parms.CheckPath = std::move(CheckPath);
	Parms.CheckSize = CheckSize;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroHotPatch.KuroLauncherLibrary.Encrypt
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FString                           InPlain                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           OutCipher                                              (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKuroLauncherLibrary::Encrypt(const class FString& InPlain, class FString* OutCipher)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroLauncherLibrary", "Encrypt");

	Params::KuroLauncherLibrary_Encrypt Parms{};

	Parms.InPlain = std::move(InPlain);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutCipher != nullptr)
		*OutCipher = std::move(Parms.OutCipher);

	return Parms.ReturnValue;
}


// Function KuroHotPatch.KuroLauncherLibrary.GameSavedDir
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UKuroLauncherLibrary::GameSavedDir()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroLauncherLibrary", "GameSavedDir");

	Params::KuroLauncherLibrary_GameSavedDir Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroHotPatch.KuroLauncherLibrary.GetAppChangeList
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UKuroLauncherLibrary::GetAppChangeList()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroLauncherLibrary", "GetAppChangeList");

	Params::KuroLauncherLibrary_GetAppChangeList Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroHotPatch.KuroLauncherLibrary.GetAppInternalUseType
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UKuroLauncherLibrary::GetAppInternalUseType()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroLauncherLibrary", "GetAppInternalUseType");

	Params::KuroLauncherLibrary_GetAppInternalUseType Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroHotPatch.KuroLauncherLibrary.GetAppParallel
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UKuroLauncherLibrary::GetAppParallel()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroLauncherLibrary", "GetAppParallel");

	Params::KuroLauncherLibrary_GetAppParallel Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroHotPatch.KuroLauncherLibrary.GetAppReleaseType
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UKuroLauncherLibrary::GetAppReleaseType()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroLauncherLibrary", "GetAppReleaseType");

	Params::KuroLauncherLibrary_GetAppReleaseType Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroHotPatch.KuroLauncherLibrary.GetAppVersion
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UKuroLauncherLibrary::GetAppVersion()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroLauncherLibrary", "GetAppVersion");

	Params::KuroLauncherLibrary_GetAppVersion Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroHotPatch.KuroLauncherLibrary.GetConfig
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FString                           Key                                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           DefaultValue                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           OutStr                                                 (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKuroLauncherLibrary::GetConfig(const class FString& Key, const class FString& DefaultValue, class FString* OutStr)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroLauncherLibrary", "GetConfig");

	Params::KuroLauncherLibrary_GetConfig Parms{};

	Parms.Key = std::move(Key);
	Parms.DefaultValue = std::move(DefaultValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutStr != nullptr)
		*OutStr = std::move(Parms.OutStr);

	return Parms.ReturnValue;
}


// Function KuroHotPatch.KuroLauncherLibrary.GetFileSize
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           FilePath                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int64                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int64 UKuroLauncherLibrary::GetFileSize(const class FString& FilePath)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroLauncherLibrary", "GetFileSize");

	Params::KuroLauncherLibrary_GetFileSize Parms{};

	Parms.FilePath = std::move(FilePath);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroHotPatch.KuroLauncherLibrary.GetGConfigString
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FString                           Section                                                (ConstParm, Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           Key                                                    (ConstParm, Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           OutStr                                                 (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKuroLauncherLibrary::GetGConfigString(const class FString& Section, const class FString& Key, class FString* OutStr)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroLauncherLibrary", "GetGConfigString");

	Params::KuroLauncherLibrary_GetGConfigString Parms{};

	Parms.Section = std::move(Section);
	Parms.Key = std::move(Key);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutStr != nullptr)
		*OutStr = std::move(Parms.OutStr);

	return Parms.ReturnValue;
}


// Function KuroHotPatch.KuroLauncherLibrary.GetNetworkConnectionType
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// uint8                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

uint8 UKuroLauncherLibrary::GetNetworkConnectionType()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroLauncherLibrary", "GetNetworkConnectionType");

	Params::KuroLauncherLibrary_GetNetworkConnectionType Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroHotPatch.KuroLauncherLibrary.GetRemainPrecompileShaders
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UKuroLauncherLibrary::GetRemainPrecompileShaders()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroLauncherLibrary", "GetRemainPrecompileShaders");

	Params::KuroLauncherLibrary_GetRemainPrecompileShaders Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroHotPatch.KuroLauncherLibrary.GetTotalAndFreeSpace
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FString                           CheckPath                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int64                                   FreeSize                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int64                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int64 UKuroLauncherLibrary::GetTotalAndFreeSpace(const class FString& CheckPath, int64* FreeSize)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroLauncherLibrary", "GetTotalAndFreeSpace");

	Params::KuroLauncherLibrary_GetTotalAndFreeSpace Parms{};

	Parms.CheckPath = std::move(CheckPath);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (FreeSize != nullptr)
		*FreeSize = Parms.FreeSize;

	return Parms.ReturnValue;
}


// Function KuroHotPatch.KuroLauncherLibrary.GetTotalPrecompileShaders
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UKuroLauncherLibrary::GetTotalPrecompileShaders()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroLauncherLibrary", "GetTotalPrecompileShaders");

	Params::KuroLauncherLibrary_GetTotalPrecompileShaders Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroHotPatch.KuroLauncherLibrary.IsFirstIntoLauncher
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKuroLauncherLibrary::IsFirstIntoLauncher()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroLauncherLibrary", "IsFirstIntoLauncher");

	Params::KuroLauncherLibrary_IsFirstIntoLauncher Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroHotPatch.KuroLauncherLibrary.IsLocalPackaging
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKuroLauncherLibrary::IsLocalPackaging()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroLauncherLibrary", "IsLocalPackaging");

	Params::KuroLauncherLibrary_IsLocalPackaging Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroHotPatch.KuroLauncherLibrary.IsStartupMountSuccess
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKuroLauncherLibrary::IsStartupMountSuccess()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroLauncherLibrary", "IsStartupMountSuccess");

	Params::KuroLauncherLibrary_IsStartupMountSuccess Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroHotPatch.KuroLauncherLibrary.LogoutToLauncher
// (Final, Native, Static, Public, BlueprintCallable)

void UKuroLauncherLibrary::LogoutToLauncher()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroLauncherLibrary", "LogoutToLauncher");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function KuroHotPatch.KuroLauncherLibrary.MakeDirectory
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           DirPath                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKuroLauncherLibrary::MakeDirectory(const class FString& DirPath)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroLauncherLibrary", "MakeDirectory");

	Params::KuroLauncherLibrary_MakeDirectory Parms{};

	Parms.DirPath = std::move(DirPath);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroHotPatch.KuroLauncherLibrary.MoveFile
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           DstPath                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           SrcPath                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKuroLauncherLibrary::MoveFile(const class FString& DstPath, const class FString& SrcPath)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroLauncherLibrary", "MoveFile");

	Params::KuroLauncherLibrary_MoveFile Parms{};

	Parms.DstPath = std::move(DstPath);
	Parms.SrcPath = std::move(SrcPath);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroHotPatch.KuroLauncherLibrary.NeedClearPatchPaks
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKuroLauncherLibrary::NeedClearPatchPaks()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroLauncherLibrary", "NeedClearPatchPaks");

	Params::KuroLauncherLibrary_NeedClearPatchPaks Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroHotPatch.KuroLauncherLibrary.NeedHotPatch
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKuroLauncherLibrary::NeedHotPatch()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroLauncherLibrary", "NeedHotPatch");

	Params::KuroLauncherLibrary_NeedHotPatch Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroHotPatch.KuroLauncherLibrary.NeedRestartApp
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// uint8                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

uint8 UKuroLauncherLibrary::NeedRestartApp()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroLauncherLibrary", "NeedRestartApp");

	Params::KuroLauncherLibrary_NeedRestartApp Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroHotPatch.KuroLauncherLibrary.PreloadRequiredBp
// (Final, Native, Static, Public, BlueprintCallable)

void UKuroLauncherLibrary::PreloadRequiredBp()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroLauncherLibrary", "PreloadRequiredBp");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function KuroHotPatch.KuroLauncherLibrary.ReloadShaderLibrary
// (Final, Native, Static, Public, BlueprintCallable)

void UKuroLauncherLibrary::ReloadShaderLibrary()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroLauncherLibrary", "ReloadShaderLibrary");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function KuroHotPatch.KuroLauncherLibrary.ResetLauncher
// (Final, Native, Static, Public, BlueprintCallable)

void UKuroLauncherLibrary::ResetLauncher()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroLauncherLibrary", "ResetLauncher");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function KuroHotPatch.KuroLauncherLibrary.RestartApplication
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           ScriptContent                                          (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKuroLauncherLibrary::RestartApplication(const class FString& ScriptContent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroLauncherLibrary", "RestartApplication");

	Params::KuroLauncherLibrary_RestartApplication Parms{};

	Parms.ScriptContent = std::move(ScriptContent);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroHotPatch.KuroLauncherLibrary.ResumeCompileShader
// (Final, Native, Static, Public, BlueprintCallable)

void UKuroLauncherLibrary::ResumeCompileShader()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroLauncherLibrary", "ResumeCompileShader");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function KuroHotPatch.KuroLauncherLibrary.SetPrecompileShaderBatchMode
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   Mode                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKuroLauncherLibrary::SetPrecompileShaderBatchMode(int32 Mode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroLauncherLibrary", "SetPrecompileShaderBatchMode");

	Params::KuroLauncherLibrary_SetPrecompileShaderBatchMode Parms{};

	Parms.Mode = Mode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroHotPatch.KuroLauncherLibrary.SetRestartApp
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// uint8                                   RestartType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKuroLauncherLibrary::SetRestartApp(uint8 RestartType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroLauncherLibrary", "SetRestartApp");

	Params::KuroLauncherLibrary_SetRestartApp Parms{};

	Parms.RestartType = RestartType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroHotPatch.KuroLauncherLibrary.WillClearPatchPaks
// (Final, Native, Static, Public, BlueprintCallable)

void UKuroLauncherLibrary::WillClearPatchPaks()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroLauncherLibrary", "WillClearPatchPaks");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function KuroHotPatch.KuroPakMountStatic.AddSha1Check
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           FilePath                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           CheckSha1Hash                                          (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKuroPakMountStatic::AddSha1Check(const class FString& FilePath, const class FString& CheckSha1Hash)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroPakMountStatic", "AddSha1Check");

	Params::KuroPakMountStatic_AddSha1Check Parms{};

	Parms.FilePath = std::move(FilePath);
	Parms.CheckSha1Hash = std::move(CheckSha1Hash);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroHotPatch.KuroPakMountStatic.DeleteSha1CheckFailedFiles
// (Final, Native, Static, Public, BlueprintCallable)

void UKuroPakMountStatic::DeleteSha1CheckFailedFiles()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroPakMountStatic", "DeleteSha1CheckFailedFiles");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function KuroHotPatch.KuroPakMountStatic.GetSha1CheckFailedCount
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UKuroPakMountStatic::GetSha1CheckFailedCount()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroPakMountStatic", "GetSha1CheckFailedCount");

	Params::KuroPakMountStatic_GetSha1CheckFailedCount Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroHotPatch.KuroPakMountStatic.IsSha1CheckWorking
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKuroPakMountStatic::IsSha1CheckWorking()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroPakMountStatic", "IsSha1CheckWorking");

	Params::KuroPakMountStatic_IsSha1CheckWorking Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroHotPatch.KuroPakMountStatic.MakePakDirPatch
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           OldPakPath                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           DiffPath                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           NewPatchPath                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKuroPakMountStatic::MakePakDirPatch(const class FString& OldPakPath, const class FString& DiffPath, const class FString& NewPatchPath)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroPakMountStatic", "MakePakDirPatch");

	Params::KuroPakMountStatic_MakePakDirPatch Parms{};

	Parms.OldPakPath = std::move(OldPakPath);
	Parms.DiffPath = std::move(DiffPath);
	Parms.NewPatchPath = std::move(NewPatchPath);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroHotPatch.KuroPakMountStatic.MakePakPatch
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           OldPakPath                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           DiffPath                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           NewPatchPath                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKuroPakMountStatic::MakePakPatch(const class FString& OldPakPath, const class FString& DiffPath, const class FString& NewPatchPath)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroPakMountStatic", "MakePakPatch");

	Params::KuroPakMountStatic_MakePakPatch Parms{};

	Parms.OldPakPath = std::move(OldPakPath);
	Parms.DiffPath = std::move(DiffPath);
	Parms.NewPatchPath = std::move(NewPatchPath);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroHotPatch.KuroPakMountStatic.MountFromManifest
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           Path                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKuroPakMountStatic::MountFromManifest(const class FString& Path)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroPakMountStatic", "MountFromManifest");

	Params::KuroPakMountStatic_MountFromManifest Parms{};

	Parms.Path = std::move(Path);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroHotPatch.KuroPakMountStatic.MountGamePaks
// (Final, Native, Static, Public, BlueprintCallable)

void UKuroPakMountStatic::MountGamePaks()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroPakMountStatic", "MountGamePaks");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function KuroHotPatch.KuroPakMountStatic.MountMultiLangPaks
// (Final, Native, Static, Public, BlueprintCallable)

void UKuroPakMountStatic::MountMultiLangPaks()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroPakMountStatic", "MountMultiLangPaks");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function KuroHotPatch.KuroPakMountStatic.MountPak
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           Path                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Order                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKuroPakMountStatic::MountPak(const class FString& Path, int32 Order)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroPakMountStatic", "MountPak");

	Params::KuroPakMountStatic_MountPak Parms{};

	Parms.Path = std::move(Path);
	Parms.Order = Order;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroHotPatch.KuroPakMountStatic.MountStartupPaks
// (Final, Native, Static, Public, BlueprintCallable)

void UKuroPakMountStatic::MountStartupPaks()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroPakMountStatic", "MountStartupPaks");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function KuroHotPatch.KuroPakMountStatic.RemoveSha1Check
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           FilePath                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKuroPakMountStatic::RemoveSha1Check(const class FString& FilePath)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroPakMountStatic", "RemoveSha1Check");

	Params::KuroPakMountStatic_RemoveSha1Check Parms{};

	Parms.FilePath = std::move(FilePath);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroHotPatch.KuroPakMountStatic.ResetSha1CheckResult
// (Final, Native, Static, Public, BlueprintCallable)

void UKuroPakMountStatic::ResetSha1CheckResult()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroPakMountStatic", "ResetSha1CheckResult");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function KuroHotPatch.KuroPakMountStatic.Save
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           Path                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKuroPakMountStatic::Save(const class FString& Path)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroPakMountStatic", "Save");

	Params::KuroPakMountStatic_Save Parms{};

	Parms.Path = std::move(Path);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroHotPatch.KuroPakMountStatic.StartSha1Check
// (Final, Native, Static, Public, BlueprintCallable)

void UKuroPakMountStatic::StartSha1Check()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroPakMountStatic", "StartSha1Check");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function KuroHotPatch.KuroPakMountStatic.StopSha1Check
// (Final, Native, Static, Public, BlueprintCallable)

void UKuroPakMountStatic::StopSha1Check()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroPakMountStatic", "StopSha1Check");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function KuroHotPatch.KuroPakMountStatic.UnmountAllPaks
// (Final, Native, Static, Public, BlueprintCallable)

void UKuroPakMountStatic::UnmountAllPaks()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroPakMountStatic", "UnmountAllPaks");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function KuroHotPatch.KuroPakMountStatic.UnmountFromManifest
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           Path                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKuroPakMountStatic::UnmountFromManifest(const class FString& Path)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroPakMountStatic", "UnmountFromManifest");

	Params::KuroPakMountStatic_UnmountFromManifest Parms{};

	Parms.Path = std::move(Path);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroHotPatch.KuroPakMountStatic.UnmountPak
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           Path                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKuroPakMountStatic::UnmountPak(const class FString& Path)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroPakMountStatic", "UnmountPak");

	Params::KuroPakMountStatic_UnmountPak Parms{};

	Parms.Path = std::move(Path);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}

}

