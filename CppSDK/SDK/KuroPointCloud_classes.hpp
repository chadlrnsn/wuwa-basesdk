#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: KuroPointCloud

#include "Basic.hpp"

#include "Engine_classes.hpp"
#include "KuroPointCloud_structs.hpp"
#include "CoreUObject_structs.hpp"
#include "CoreUObject_classes.hpp"
#include "Niagara_classes.hpp"


namespace SDK
{

// Class KuroPointCloud.KuroPointCloudActor
// 0x0088 (0x0338 - 0x02B0)
class AKuroPointCloudActor final : public AActor
{
public:
	class UInstancedStaticMeshComponent*          InstancedStaticMeshComponent;                      // 0x02B0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UKuroPointCloudCache*                   PointCloudAsset;                                   // 0x02B8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PointNumToStopDivide;                              // 0x02C0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BoxLengthToStopDivide;                             // 0x02C4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InstanceScale;                                     // 0x02C8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2CC[0x4];                                      // 0x02CC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FKuroPointKdTree                       KdTree;                                            // 0x02D0(0x0058)(NativeAccessSpecifierPrivate)
	TArray<float>                                 CustomData;                                        // 0x0328(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	void BuildKdTreeData();
	void ClearMark();
	void MarkPointsInBox(const struct FBox& BoxWS);
	void UpdateIsm();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroPointCloudActor">();
	}
	static class AKuroPointCloudActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AKuroPointCloudActor>();
	}
};
static_assert(alignof(AKuroPointCloudActor) == 0x000008, "Wrong alignment on AKuroPointCloudActor");
static_assert(sizeof(AKuroPointCloudActor) == 0x000338, "Wrong size on AKuroPointCloudActor");
static_assert(offsetof(AKuroPointCloudActor, InstancedStaticMeshComponent) == 0x0002B0, "Member 'AKuroPointCloudActor::InstancedStaticMeshComponent' has a wrong offset!");
static_assert(offsetof(AKuroPointCloudActor, PointCloudAsset) == 0x0002B8, "Member 'AKuroPointCloudActor::PointCloudAsset' has a wrong offset!");
static_assert(offsetof(AKuroPointCloudActor, PointNumToStopDivide) == 0x0002C0, "Member 'AKuroPointCloudActor::PointNumToStopDivide' has a wrong offset!");
static_assert(offsetof(AKuroPointCloudActor, BoxLengthToStopDivide) == 0x0002C4, "Member 'AKuroPointCloudActor::BoxLengthToStopDivide' has a wrong offset!");
static_assert(offsetof(AKuroPointCloudActor, InstanceScale) == 0x0002C8, "Member 'AKuroPointCloudActor::InstanceScale' has a wrong offset!");
static_assert(offsetof(AKuroPointCloudActor, KdTree) == 0x0002D0, "Member 'AKuroPointCloudActor::KdTree' has a wrong offset!");
static_assert(offsetof(AKuroPointCloudActor, CustomData) == 0x000328, "Member 'AKuroPointCloudActor::CustomData' has a wrong offset!");

// Class KuroPointCloud.KuroPointCloudCache
// 0x0040 (0x0070 - 0x0030)
class UKuroPointCloudCache final : public UObject
{
public:
	TArray<struct FVector>                        PositionCache;                                     // 0x0030(0x0010)(Edit, ZeroConstructor, EditConst, Protected, NativeAccessSpecifierProtected)
	TArray<struct FQuat>                          RotationCache;                                     // 0x0040(0x0010)(Edit, ZeroConstructor, EditConst, Protected, NativeAccessSpecifierProtected)
	TArray<struct FVector>                        ScaleCache;                                        // 0x0050(0x0010)(Edit, ZeroConstructor, EditConst, Protected, NativeAccessSpecifierProtected)
	TArray<int32>                                 IndexCache;                                        // 0x0060(0x0010)(Edit, ZeroConstructor, EditConst, Protected, NativeAccessSpecifierProtected)

public:
	void UpdateFromData(const TArray<struct FVector>& Positions, const TArray<struct FQuat>& Rotations, const TArray<struct FVector>& Scales);
	void UpdateFromDataWithIndices(const TArray<struct FVector>& Positions, const TArray<struct FQuat>& Rotations, const TArray<struct FVector>& Scales, const TArray<int32>& Indices);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroPointCloudCache">();
	}
	static class UKuroPointCloudCache* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroPointCloudCache>();
	}
};
static_assert(alignof(UKuroPointCloudCache) == 0x000008, "Wrong alignment on UKuroPointCloudCache");
static_assert(sizeof(UKuroPointCloudCache) == 0x000070, "Wrong size on UKuroPointCloudCache");
static_assert(offsetof(UKuroPointCloudCache, PositionCache) == 0x000030, "Member 'UKuroPointCloudCache::PositionCache' has a wrong offset!");
static_assert(offsetof(UKuroPointCloudCache, RotationCache) == 0x000040, "Member 'UKuroPointCloudCache::RotationCache' has a wrong offset!");
static_assert(offsetof(UKuroPointCloudCache, ScaleCache) == 0x000050, "Member 'UKuroPointCloudCache::ScaleCache' has a wrong offset!");
static_assert(offsetof(UKuroPointCloudCache, IndexCache) == 0x000060, "Member 'UKuroPointCloudCache::IndexCache' has a wrong offset!");

// Class KuroPointCloud.KuroPointCloudInstance
// 0x0068 (0x0098 - 0x0030)
class UKuroPointCloudInstance final : public UObject
{
public:
	class UKuroPointCloudCache*                   PointCloudCache;                                   // 0x0030(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FKuroPointKdTree                       KdTree;                                            // 0x0038(0x0058)(NativeAccessSpecifierPrivate)
	class UKuroVirtualPointCloud2DQTree*          QTree2D;                                           // 0x0090(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void BuildFrom2DPoints(const TArray<struct FIntPoint>& InPoints, const struct FTransform& InPlaneToWorld, int32 MaxHeight);
	void BuildFromPointCloudData(const TArray<struct FVector>& Positions, const TArray<struct FQuat>& Rotations, const TArray<struct FVector>& Scales);
	void ResetData();

	struct FBox GetBound() const;
	int32 GetQueryPointsNum(const struct FKuroPointCloudInstanceQueryResult& QueryResult) const;
	bool GetQueryPointTransform(const struct FKuroPointCloudInstanceQueryResult& QueryResult, int32 Index_0, struct FVector* OutPosition, struct FQuat* OutRotation, struct FVector* OutScale) const;
	struct FKuroPointCloudInstanceQueryResult SphereQuery(const struct FVector& SphereCenter, float SphereRadius) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroPointCloudInstance">();
	}
	static class UKuroPointCloudInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroPointCloudInstance>();
	}
};
static_assert(alignof(UKuroPointCloudInstance) == 0x000008, "Wrong alignment on UKuroPointCloudInstance");
static_assert(sizeof(UKuroPointCloudInstance) == 0x000098, "Wrong size on UKuroPointCloudInstance");
static_assert(offsetof(UKuroPointCloudInstance, PointCloudCache) == 0x000030, "Member 'UKuroPointCloudInstance::PointCloudCache' has a wrong offset!");
static_assert(offsetof(UKuroPointCloudInstance, KdTree) == 0x000038, "Member 'UKuroPointCloudInstance::KdTree' has a wrong offset!");
static_assert(offsetof(UKuroPointCloudInstance, QTree2D) == 0x000090, "Member 'UKuroPointCloudInstance::QTree2D' has a wrong offset!");

// Class KuroPointCloud.KuroPointCloudStreamingConfig
// 0x0018 (0x0050 - 0x0038)
class UKuroPointCloudStreamingConfig final : public UPrimaryDataAsset
{
public:
	TArray<struct FKuroPointCloudStreamingCell>   StreamingCells;                                    // 0x0038(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         CellSize;                                          // 0x0048(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4C[0x4];                                       // 0x004C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ClearEmptyInstances();
	void SetInstanceData(int32 CellX, int32 CellY, class FName CollectionName, class UKuroPointCloudInstance* PointCloudInstance);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroPointCloudStreamingConfig">();
	}
	static class UKuroPointCloudStreamingConfig* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroPointCloudStreamingConfig>();
	}
};
static_assert(alignof(UKuroPointCloudStreamingConfig) == 0x000008, "Wrong alignment on UKuroPointCloudStreamingConfig");
static_assert(sizeof(UKuroPointCloudStreamingConfig) == 0x000050, "Wrong size on UKuroPointCloudStreamingConfig");
static_assert(offsetof(UKuroPointCloudStreamingConfig, StreamingCells) == 0x000038, "Member 'UKuroPointCloudStreamingConfig::StreamingCells' has a wrong offset!");
static_assert(offsetof(UKuroPointCloudStreamingConfig, CellSize) == 0x000048, "Member 'UKuroPointCloudStreamingConfig::CellSize' has a wrong offset!");

// Class KuroPointCloud.KuroPointCloudStreamingActor
// 0x0028 (0x02D8 - 0x02B0)
class AKuroPointCloudStreamingActor final : public AActor
{
public:
	class USceneComponent*                        SceneRoot;                                         // 0x02B0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UKuroPointCloudWorldComponent*          PointCloudWorldComponent;                          // 0x02B8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C0[0x18];                                     // 0x02C0(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroPointCloudStreamingActor">();
	}
	static class AKuroPointCloudStreamingActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AKuroPointCloudStreamingActor>();
	}
};
static_assert(alignof(AKuroPointCloudStreamingActor) == 0x000008, "Wrong alignment on AKuroPointCloudStreamingActor");
static_assert(sizeof(AKuroPointCloudStreamingActor) == 0x0002D8, "Wrong size on AKuroPointCloudStreamingActor");
static_assert(offsetof(AKuroPointCloudStreamingActor, SceneRoot) == 0x0002B0, "Member 'AKuroPointCloudStreamingActor::SceneRoot' has a wrong offset!");
static_assert(offsetof(AKuroPointCloudStreamingActor, PointCloudWorldComponent) == 0x0002B8, "Member 'AKuroPointCloudStreamingActor::PointCloudWorldComponent' has a wrong offset!");

// Class KuroPointCloud.KuroPointCloudStreamer
// 0x0090 (0x00C0 - 0x0030)
class UKuroPointCloudStreamer final : public UObject
{
public:
	class UKuroPointCloudStreamingConfig*         Config;                                            // 0x0030(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_38[0x50];                                      // 0x0038(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AKuroPointCloudStreamingActor*>  SpawnedActors;                                     // 0x0088(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<class AKuroPointCloudStreamingActor*>  ActorPool;                                         // 0x0098(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_A8[0x18];                                      // 0x00A8(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroPointCloudStreamer">();
	}
	static class UKuroPointCloudStreamer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroPointCloudStreamer>();
	}
};
static_assert(alignof(UKuroPointCloudStreamer) == 0x000008, "Wrong alignment on UKuroPointCloudStreamer");
static_assert(sizeof(UKuroPointCloudStreamer) == 0x0000C0, "Wrong size on UKuroPointCloudStreamer");
static_assert(offsetof(UKuroPointCloudStreamer, Config) == 0x000030, "Member 'UKuroPointCloudStreamer::Config' has a wrong offset!");
static_assert(offsetof(UKuroPointCloudStreamer, SpawnedActors) == 0x000088, "Member 'UKuroPointCloudStreamer::SpawnedActors' has a wrong offset!");
static_assert(offsetof(UKuroPointCloudStreamer, ActorPool) == 0x000098, "Member 'UKuroPointCloudStreamer::ActorPool' has a wrong offset!");

// Class KuroPointCloud.KuroPointCloudWorldActor
// 0x0028 (0x02D8 - 0x02B0)
class AKuroPointCloudWorldActor final : public AActor
{
public:
	class USceneComponent*                        SceneComponent;                                    // 0x02B0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UKuroPointCloudWorldComponent*          PointCloudWorldComponent;                          // 0x02B8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   GroupName;                                         // 0x02C0(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SubGroupName;                                      // 0x02CC(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static void DeleteAllActorsInGroup(const class UObject* WorldContextObject, class FName TargetGroupName, class FName TargetSubGroupName);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroPointCloudWorldActor">();
	}
	static class AKuroPointCloudWorldActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AKuroPointCloudWorldActor>();
	}
};
static_assert(alignof(AKuroPointCloudWorldActor) == 0x000008, "Wrong alignment on AKuroPointCloudWorldActor");
static_assert(sizeof(AKuroPointCloudWorldActor) == 0x0002D8, "Wrong size on AKuroPointCloudWorldActor");
static_assert(offsetof(AKuroPointCloudWorldActor, SceneComponent) == 0x0002B0, "Member 'AKuroPointCloudWorldActor::SceneComponent' has a wrong offset!");
static_assert(offsetof(AKuroPointCloudWorldActor, PointCloudWorldComponent) == 0x0002B8, "Member 'AKuroPointCloudWorldActor::PointCloudWorldComponent' has a wrong offset!");
static_assert(offsetof(AKuroPointCloudWorldActor, GroupName) == 0x0002C0, "Member 'AKuroPointCloudWorldActor::GroupName' has a wrong offset!");
static_assert(offsetof(AKuroPointCloudWorldActor, SubGroupName) == 0x0002CC, "Member 'AKuroPointCloudWorldActor::SubGroupName' has a wrong offset!");

// Class KuroPointCloud.KuroPointCloudWorldComponent
// 0x0020 (0x00E0 - 0x00C0)
class UKuroPointCloudWorldComponent final : public UActorComponent
{
public:
	class FName                                   KuroPointCloudCollectionName;                      // 0x00C0(0x000C)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_CC[0xC];                                       // 0x00CC(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	class UKuroPointCloudInstance*                PointCloudInstance;                                // 0x00D8(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	class UKuroPointCloudInstance* GetInstance(bool bCreateIfNull);
	void MarkUpdate();
	void SetInstance(class UKuroPointCloudInstance* Instance);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroPointCloudWorldComponent">();
	}
	static class UKuroPointCloudWorldComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroPointCloudWorldComponent>();
	}
};
static_assert(alignof(UKuroPointCloudWorldComponent) == 0x000008, "Wrong alignment on UKuroPointCloudWorldComponent");
static_assert(sizeof(UKuroPointCloudWorldComponent) == 0x0000E0, "Wrong size on UKuroPointCloudWorldComponent");
static_assert(offsetof(UKuroPointCloudWorldComponent, KuroPointCloudCollectionName) == 0x0000C0, "Member 'UKuroPointCloudWorldComponent::KuroPointCloudCollectionName' has a wrong offset!");
static_assert(offsetof(UKuroPointCloudWorldComponent, PointCloudInstance) == 0x0000D8, "Member 'UKuroPointCloudWorldComponent::PointCloudInstance' has a wrong offset!");

// Class KuroPointCloud.KuroPointCloudWorldSystem
// 0x0078 (0x00B0 - 0x0038)
class UKuroPointCloudWorldSystem final : public UWorldSubsystem
{
public:
	uint8                                         Pad_38[0x8];                                       // 0x0038(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UKuroPointCloudStreamer*                Streamer;                                          // 0x0040(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_48[0x8];                                       // 0x0048(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FName, struct FKuroPointCloudWorldCollection> Collections;                                       // 0x0050(0x0050)(ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_A0[0x10];                                      // 0x00A0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetStreamingConfig(class UKuroPointCloudStreamingConfig* Config, float StreamingDistance);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroPointCloudWorldSystem">();
	}
	static class UKuroPointCloudWorldSystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroPointCloudWorldSystem>();
	}
};
static_assert(alignof(UKuroPointCloudWorldSystem) == 0x000008, "Wrong alignment on UKuroPointCloudWorldSystem");
static_assert(sizeof(UKuroPointCloudWorldSystem) == 0x0000B0, "Wrong size on UKuroPointCloudWorldSystem");
static_assert(offsetof(UKuroPointCloudWorldSystem, Streamer) == 0x000040, "Member 'UKuroPointCloudWorldSystem::Streamer' has a wrong offset!");
static_assert(offsetof(UKuroPointCloudWorldSystem, Collections) == 0x000050, "Member 'UKuroPointCloudWorldSystem::Collections' has a wrong offset!");

// Class KuroPointCloud.KuroVirtualPointCloud2DQTree
// 0x0090 (0x00C0 - 0x0030)
class UKuroVirtualPointCloud2DQTree final : public UObject
{
public:
	TArray<int32>                                 QTree;                                             // 0x0030(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_40[0x8];                                       // 0x0040(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FIntPoint                              QTreeBoundMin;                                     // 0x0048(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FIntPoint                              QTreeBoundMax;                                     // 0x0050(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_58[0x8];                                       // 0x0058(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             WorldToPointCloudLocal;                            // 0x0060(0x0030)(Edit, EditConst, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FTransform                             PointCloudLocalToWorld;                            // 0x0090(0x0030)(Edit, EditConst, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)

public:
	void BuildFromPointData(const TArray<struct FIntPoint>& InPoints, const struct FTransform& InPlaneToWorld, int32 MaxHeight);
	void Reset();

	struct FQuat GetRotation() const;
	struct FBox GetWorldBound() const;
	void SphereQuery(const struct FVector& SphereCenter, float SphereRadius, TArray<struct FIntPoint>* OutResult) const;
	struct FVector TransformPointToWorld(const struct FIntPoint& Point) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroVirtualPointCloud2DQTree">();
	}
	static class UKuroVirtualPointCloud2DQTree* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroVirtualPointCloud2DQTree>();
	}
};
static_assert(alignof(UKuroVirtualPointCloud2DQTree) == 0x000010, "Wrong alignment on UKuroVirtualPointCloud2DQTree");
static_assert(sizeof(UKuroVirtualPointCloud2DQTree) == 0x0000C0, "Wrong size on UKuroVirtualPointCloud2DQTree");
static_assert(offsetof(UKuroVirtualPointCloud2DQTree, QTree) == 0x000030, "Member 'UKuroVirtualPointCloud2DQTree::QTree' has a wrong offset!");
static_assert(offsetof(UKuroVirtualPointCloud2DQTree, QTreeBoundMin) == 0x000048, "Member 'UKuroVirtualPointCloud2DQTree::QTreeBoundMin' has a wrong offset!");
static_assert(offsetof(UKuroVirtualPointCloud2DQTree, QTreeBoundMax) == 0x000050, "Member 'UKuroVirtualPointCloud2DQTree::QTreeBoundMax' has a wrong offset!");
static_assert(offsetof(UKuroVirtualPointCloud2DQTree, WorldToPointCloudLocal) == 0x000060, "Member 'UKuroVirtualPointCloud2DQTree::WorldToPointCloudLocal' has a wrong offset!");
static_assert(offsetof(UKuroVirtualPointCloud2DQTree, PointCloudLocalToWorld) == 0x000090, "Member 'UKuroVirtualPointCloud2DQTree::PointCloudLocalToWorld' has a wrong offset!");

// Class KuroPointCloud.NiagaraDataInterfaceKuroPointCloud
// 0x0018 (0x0058 - 0x0040)
class UNiagaraDataInterfaceKuroPointCloud final : public UNiagaraDataInterface
{
public:
	class UKuroPointCloudCache*                   PointCloudCache;                                   // 0x0040(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   WorldCollectionName;                               // 0x0048(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_54[0x4];                                       // 0x0054(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NiagaraDataInterfaceKuroPointCloud">();
	}
	static class UNiagaraDataInterfaceKuroPointCloud* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNiagaraDataInterfaceKuroPointCloud>();
	}
};
static_assert(alignof(UNiagaraDataInterfaceKuroPointCloud) == 0x000008, "Wrong alignment on UNiagaraDataInterfaceKuroPointCloud");
static_assert(sizeof(UNiagaraDataInterfaceKuroPointCloud) == 0x000058, "Wrong size on UNiagaraDataInterfaceKuroPointCloud");
static_assert(offsetof(UNiagaraDataInterfaceKuroPointCloud, PointCloudCache) == 0x000040, "Member 'UNiagaraDataInterfaceKuroPointCloud::PointCloudCache' has a wrong offset!");
static_assert(offsetof(UNiagaraDataInterfaceKuroPointCloud, WorldCollectionName) == 0x000048, "Member 'UNiagaraDataInterfaceKuroPointCloud::WorldCollectionName' has a wrong offset!");

}

