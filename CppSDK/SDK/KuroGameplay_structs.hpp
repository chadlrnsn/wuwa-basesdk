#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: KuroGameplay

#include "Basic.hpp"

#include "KuroCurve_structs.hpp"
#include "Engine_structs.hpp"
#include "SlateCore_structs.hpp"
#include "CoreUObject_structs.hpp"


namespace SDK
{

// Enum KuroGameplay.EEffectModelGhostCppComponent
// NumValues: 0x0019
enum class EEffectModelGhostCppComponent : uint8
{
	Body                                     = 0,
	WeaponCase0                              = 1,
	WeaponCase1                              = 2,
	WeaponCase2                              = 3,
	WeaponCase3                              = 4,
	WeaponCase4                              = 5,
	Hulu                                     = 6,
	OtherCase0                               = 7,
	OtherCase1                               = 8,
	OtherCase2                               = 9,
	OtherCase3                               = 10,
	OtherCase4                               = 11,
	OtherCase5                               = 12,
	OtherCase6                               = 13,
	OtherCase7                               = 14,
	OtherCase8                               = 15,
	OtherCase9                               = 16,
	OtherCase10                              = 17,
	OtherCase11                              = 18,
	OtherCase12                              = 19,
	OtherCase13                              = 20,
	OtherCase14                              = 21,
	OtherCase15                              = 22,
	OtherCase16                              = 23,
	EEffectModelGhostCppComponent_MAX        = 24,
};

// Enum KuroGameplay.EMultiEffectType
// NumValues: 0x0002
enum class EMultiEffectType : uint8
{
	BuffBall                                 = 0,
	EMultiEffectType_MAX                     = 1,
};

// Enum KuroGameplay.ESignificanceGroup
// NumValues: 0x0006
enum class ESignificanceGroup : uint8
{
	Idle                                     = 0,
	Low                                      = 1,
	Middle                                   = 2,
	High                                     = 3,
	Critical                                 = 4,
	ESignificanceGroup_MAX                   = 5,
};

// Enum KuroGameplay.EActorCavernMode
// NumValues: 0x0005
enum class EActorCavernMode : uint8
{
	ActorCavernMode_None                     = 0,
	ActorCavernMode_Outside                  = 1,
	ActorCavernMode_Inside                   = 2,
	ActorCavernMode_IntermediateZone         = 3,
	ActorCavernMode_MAX                      = 4,
};

// Enum KuroGameplay.EDisableActorTickStrategy
// NumValues: 0x0006
enum class EDisableActorTickStrategy : uint8
{
	DisableActorTickStrategy_None            = 0,
	DisableActorTickStrategy_DistanceOnly    = 1,
	DisableActorTickStrategy_NotRenderedOnly = 2,
	DisableActorTickStrategy_NotRenderedAndDistance = 3,
	DisableActorTickStrategy_MaxInterval     = 4,
	DisableActorTickStrategy_MAX             = 5,
};

// Enum KuroGameplay.EGameBudgetAllocatorActorMode
// NumValues: 0x0005
enum class EGameBudgetAllocatorActorMode : uint8
{
	GBA_ActorMode_Rendered                   = 0,
	GBA_ActorMode_NotRendered                = 1,
	GBA_ActorMode_Fighting                   = 2,
	GBA_ActorMode_Num                        = 3,
	GBA_ActorMode_MAX                        = 4,
};

// Enum KuroGameplay.EGameBudgetAllocatorGlobalMode
// NumValues: 0x0005
enum class EGameBudgetAllocatorGlobalMode : uint8
{
	GBA_GlobalMode_Normal                    = 0,
	GBA_GlobalMode_Fighting                  = 1,
	GBA_GlobalMode_Cutscene                  = 2,
	GBA_GlobalMode_Num                       = 3,
	GBA_GlobalMode_MAX                       = 4,
};

// Enum KuroGameplay.EKuroEasingFuncType
// NumValues: 0x0010
enum class EKuroEasingFuncType : uint8
{
	KEF_Linear                               = 0,
	KEF_EaseIn                               = 1,
	KEF_EaseOut                              = 2,
	KEF_EaseInOut                            = 3,
	KEF_SinIn                                = 4,
	KEF_SinOut                               = 5,
	KEF_SinInOut                             = 6,
	KEF_ExpoIn                               = 7,
	KEF_ExpoOut                              = 8,
	KEF_ExpoInOut                            = 9,
	KEF_CircularIn                           = 10,
	KEF_CircularOut                          = 11,
	KEF_CircularInOut                        = 12,
	KEF_FloatCurve                           = 13,
	KEF_CustomFunc                           = 14,
	KEF_MAX                                  = 15,
};

// ScriptStruct KuroGameplay.KuroGASMessageParams
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x08) FKuroGASMessageParams final
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FKuroGASMessageParams) == 0x000008, "Wrong alignment on FKuroGASMessageParams");
static_assert(sizeof(FKuroGASMessageParams) == 0x000010, "Wrong size on FKuroGASMessageParams");

// ScriptStruct KuroGameplay.EffectModelNiagaraExtraState
// 0x00F0 (0x00F0 - 0x0000)
struct FEffectModelNiagaraExtraState final
{
public:
	TMap<class FName, struct FKuroCurveFloat>     FloatParameters;                                   // 0x0000(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TMap<class FName, struct FKuroCurveLinearColor> ColorParameters;                                   // 0x0050(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TMap<class FName, struct FKuroCurveVector>    VectorParameters;                                  // 0x00A0(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FEffectModelNiagaraExtraState) == 0x000008, "Wrong alignment on FEffectModelNiagaraExtraState");
static_assert(sizeof(FEffectModelNiagaraExtraState) == 0x0000F0, "Wrong size on FEffectModelNiagaraExtraState");
static_assert(offsetof(FEffectModelNiagaraExtraState, FloatParameters) == 0x000000, "Member 'FEffectModelNiagaraExtraState::FloatParameters' has a wrong offset!");
static_assert(offsetof(FEffectModelNiagaraExtraState, ColorParameters) == 0x000050, "Member 'FEffectModelNiagaraExtraState::ColorParameters' has a wrong offset!");
static_assert(offsetof(FEffectModelNiagaraExtraState, VectorParameters) == 0x0000A0, "Member 'FEffectModelNiagaraExtraState::VectorParameters' has a wrong offset!");

// ScriptStruct KuroGameplay.GameBudgetAllocatorGroupConfig
// 0x0078 (0x0078 - 0x0000)
struct FGameBudgetAllocatorGroupConfig final
{
public:
	class FName                                   GroupName;                                         // 0x0000(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESignificanceGroup                            SignificanceGroup;                                 // 0x000C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	uint32                                        TickPriority;                                      // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDisableActorTickStrategy                     DisableActorTickStrategy;                          // 0x0014(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	uint32                                        DisableActorTickDistance;                          // 0x0018(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x5C];                                      // 0x001C(0x005C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGameBudgetAllocatorGroupConfig) == 0x000004, "Wrong alignment on FGameBudgetAllocatorGroupConfig");
static_assert(sizeof(FGameBudgetAllocatorGroupConfig) == 0x000078, "Wrong size on FGameBudgetAllocatorGroupConfig");
static_assert(offsetof(FGameBudgetAllocatorGroupConfig, GroupName) == 0x000000, "Member 'FGameBudgetAllocatorGroupConfig::GroupName' has a wrong offset!");
static_assert(offsetof(FGameBudgetAllocatorGroupConfig, SignificanceGroup) == 0x00000C, "Member 'FGameBudgetAllocatorGroupConfig::SignificanceGroup' has a wrong offset!");
static_assert(offsetof(FGameBudgetAllocatorGroupConfig, TickPriority) == 0x000010, "Member 'FGameBudgetAllocatorGroupConfig::TickPriority' has a wrong offset!");
static_assert(offsetof(FGameBudgetAllocatorGroupConfig, DisableActorTickStrategy) == 0x000014, "Member 'FGameBudgetAllocatorGroupConfig::DisableActorTickStrategy' has a wrong offset!");
static_assert(offsetof(FGameBudgetAllocatorGroupConfig, DisableActorTickDistance) == 0x000018, "Member 'FGameBudgetAllocatorGroupConfig::DisableActorTickDistance' has a wrong offset!");

// ScriptStruct KuroGameplay.GameBudgetAllocatorTickDetailConfig
// 0x0008 (0x0008 - 0x0000)
struct FGameBudgetAllocatorTickDetailConfig final
{
public:
	uint32                                        MaxTickInterval;                                   // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint16                                        TickReductionStartSize;                            // 0x0004(0x0002)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint16                                        TickReductionIntervalSize;                         // 0x0006(0x0002)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGameBudgetAllocatorTickDetailConfig) == 0x000004, "Wrong alignment on FGameBudgetAllocatorTickDetailConfig");
static_assert(sizeof(FGameBudgetAllocatorTickDetailConfig) == 0x000008, "Wrong size on FGameBudgetAllocatorTickDetailConfig");
static_assert(offsetof(FGameBudgetAllocatorTickDetailConfig, MaxTickInterval) == 0x000000, "Member 'FGameBudgetAllocatorTickDetailConfig::MaxTickInterval' has a wrong offset!");
static_assert(offsetof(FGameBudgetAllocatorTickDetailConfig, TickReductionStartSize) == 0x000004, "Member 'FGameBudgetAllocatorTickDetailConfig::TickReductionStartSize' has a wrong offset!");
static_assert(offsetof(FGameBudgetAllocatorTickDetailConfig, TickReductionIntervalSize) == 0x000006, "Member 'FGameBudgetAllocatorTickDetailConfig::TickReductionIntervalSize' has a wrong offset!");

// ScriptStruct KuroGameplay.GameBudgetAllocatorAfterTickFunction
// 0x0008 (0x0030 - 0x0028)
struct FGameBudgetAllocatorAfterTickFunction final : public FTickFunction
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGameBudgetAllocatorAfterTickFunction) == 0x000008, "Wrong alignment on FGameBudgetAllocatorAfterTickFunction");
static_assert(sizeof(FGameBudgetAllocatorAfterTickFunction) == 0x000030, "Wrong size on FGameBudgetAllocatorAfterTickFunction");

// ScriptStruct KuroGameplay.GameBudgetAllocatorTickFunction
// 0x0008 (0x0030 - 0x0028)
struct FGameBudgetAllocatorTickFunction final : public FTickFunction
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGameBudgetAllocatorTickFunction) == 0x000008, "Wrong alignment on FGameBudgetAllocatorTickFunction");
static_assert(sizeof(FGameBudgetAllocatorTickFunction) == 0x000030, "Wrong size on FGameBudgetAllocatorTickFunction");

// ScriptStruct KuroGameplay.KuroProgressBarStyle
// 0x0240 (0x0248 - 0x0008)
struct FKuroProgressBarStyle final : public FSlateWidgetStyle
{
public:
	struct FSlateBrush                            BackgroundImage;                                   // 0x0008(0x0090)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FSlateBrush                            FillImageMiddle;                                   // 0x0098(0x0090)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FSlateBrush                            FillImage;                                         // 0x0128(0x0090)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FSlateBrush                            MarqueeImage;                                      // 0x01B8(0x0090)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FKuroProgressBarStyle) == 0x000008, "Wrong alignment on FKuroProgressBarStyle");
static_assert(sizeof(FKuroProgressBarStyle) == 0x000248, "Wrong size on FKuroProgressBarStyle");
static_assert(offsetof(FKuroProgressBarStyle, BackgroundImage) == 0x000008, "Member 'FKuroProgressBarStyle::BackgroundImage' has a wrong offset!");
static_assert(offsetof(FKuroProgressBarStyle, FillImageMiddle) == 0x000098, "Member 'FKuroProgressBarStyle::FillImageMiddle' has a wrong offset!");
static_assert(offsetof(FKuroProgressBarStyle, FillImage) == 0x000128, "Member 'FKuroProgressBarStyle::FillImage' has a wrong offset!");
static_assert(offsetof(FKuroProgressBarStyle, MarqueeImage) == 0x0001B8, "Member 'FKuroProgressBarStyle::MarqueeImage' has a wrong offset!");

// ScriptStruct KuroGameplay.SequencerBindingRuntimeProxy
// 0x0018 (0x0018 - 0x0000)
struct FSequencerBindingRuntimeProxy final
{
public:
	struct FGuid                                  BindingID;                                         // 0x0000(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMovieSceneSequence*                    Sequence;                                          // 0x0010(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSequencerBindingRuntimeProxy) == 0x000008, "Wrong alignment on FSequencerBindingRuntimeProxy");
static_assert(sizeof(FSequencerBindingRuntimeProxy) == 0x000018, "Wrong size on FSequencerBindingRuntimeProxy");
static_assert(offsetof(FSequencerBindingRuntimeProxy, BindingID) == 0x000000, "Member 'FSequencerBindingRuntimeProxy::BindingID' has a wrong offset!");
static_assert(offsetof(FSequencerBindingRuntimeProxy, Sequence) == 0x000010, "Member 'FSequencerBindingRuntimeProxy::Sequence' has a wrong offset!");

// ScriptStruct KuroGameplay.PerformanceStatisticsTagTreeNodeSerialize
// 0x0028 (0x0028 - 0x0000)
struct FPerformanceStatisticsTagTreeNodeSerialize final
{
public:
	class FName                                   Tag;                                               // 0x0000(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AverageTime;                                       // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxTime;                                           // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Mode;                                              // 0x0014(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 UserDefineMessage;                                 // 0x0018(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPerformanceStatisticsTagTreeNodeSerialize) == 0x000008, "Wrong alignment on FPerformanceStatisticsTagTreeNodeSerialize");
static_assert(sizeof(FPerformanceStatisticsTagTreeNodeSerialize) == 0x000028, "Wrong size on FPerformanceStatisticsTagTreeNodeSerialize");
static_assert(offsetof(FPerformanceStatisticsTagTreeNodeSerialize, Tag) == 0x000000, "Member 'FPerformanceStatisticsTagTreeNodeSerialize::Tag' has a wrong offset!");
static_assert(offsetof(FPerformanceStatisticsTagTreeNodeSerialize, AverageTime) == 0x00000C, "Member 'FPerformanceStatisticsTagTreeNodeSerialize::AverageTime' has a wrong offset!");
static_assert(offsetof(FPerformanceStatisticsTagTreeNodeSerialize, MaxTime) == 0x000010, "Member 'FPerformanceStatisticsTagTreeNodeSerialize::MaxTime' has a wrong offset!");
static_assert(offsetof(FPerformanceStatisticsTagTreeNodeSerialize, Mode) == 0x000014, "Member 'FPerformanceStatisticsTagTreeNodeSerialize::Mode' has a wrong offset!");
static_assert(offsetof(FPerformanceStatisticsTagTreeNodeSerialize, UserDefineMessage) == 0x000018, "Member 'FPerformanceStatisticsTagTreeNodeSerialize::UserDefineMessage' has a wrong offset!");

// ScriptStruct KuroGameplay.PerformanceStatisticsTagTreeSerialize
// 0x0038 (0x0038 - 0x0000)
struct FPerformanceStatisticsTagTreeSerialize final
{
public:
	struct FPerformanceStatisticsTagTreeNodeSerialize NodeSerialize;                                     // 0x0000(0x0028)(NativeAccessSpecifierPublic)
	TArray<struct FPerformanceStatisticsTagTreeNodeSerialize> ChildTags;                                         // 0x0028(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPerformanceStatisticsTagTreeSerialize) == 0x000008, "Wrong alignment on FPerformanceStatisticsTagTreeSerialize");
static_assert(sizeof(FPerformanceStatisticsTagTreeSerialize) == 0x000038, "Wrong size on FPerformanceStatisticsTagTreeSerialize");
static_assert(offsetof(FPerformanceStatisticsTagTreeSerialize, NodeSerialize) == 0x000000, "Member 'FPerformanceStatisticsTagTreeSerialize::NodeSerialize' has a wrong offset!");
static_assert(offsetof(FPerformanceStatisticsTagTreeSerialize, ChildTags) == 0x000028, "Member 'FPerformanceStatisticsTagTreeSerialize::ChildTags' has a wrong offset!");

// ScriptStruct KuroGameplay.PerformanceStatisticsUnitRecord
// 0x0028 (0x0028 - 0x0000)
struct FPerformanceStatisticsUnitRecord final
{
public:
	int32                                         FrameCount;                                        // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Tag;                                               // 0x0004(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Mode;                                              // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Time;                                              // 0x0014(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 UserDefineMessage;                                 // 0x0018(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPerformanceStatisticsUnitRecord) == 0x000008, "Wrong alignment on FPerformanceStatisticsUnitRecord");
static_assert(sizeof(FPerformanceStatisticsUnitRecord) == 0x000028, "Wrong size on FPerformanceStatisticsUnitRecord");
static_assert(offsetof(FPerformanceStatisticsUnitRecord, FrameCount) == 0x000000, "Member 'FPerformanceStatisticsUnitRecord::FrameCount' has a wrong offset!");
static_assert(offsetof(FPerformanceStatisticsUnitRecord, Tag) == 0x000004, "Member 'FPerformanceStatisticsUnitRecord::Tag' has a wrong offset!");
static_assert(offsetof(FPerformanceStatisticsUnitRecord, Mode) == 0x000010, "Member 'FPerformanceStatisticsUnitRecord::Mode' has a wrong offset!");
static_assert(offsetof(FPerformanceStatisticsUnitRecord, Time) == 0x000014, "Member 'FPerformanceStatisticsUnitRecord::Time' has a wrong offset!");
static_assert(offsetof(FPerformanceStatisticsUnitRecord, UserDefineMessage) == 0x000018, "Member 'FPerformanceStatisticsUnitRecord::UserDefineMessage' has a wrong offset!");

// ScriptStruct KuroGameplay.PerformanceStatisticsSectionRecordSerialize
// 0x0020 (0x0020 - 0x0000)
struct FPerformanceStatisticsSectionRecordSerialize final
{
public:
	class FName                                   SectionName;                                       // 0x0000(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FPerformanceStatisticsUnitRecord> UnitRecordValues;                                  // 0x0010(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPerformanceStatisticsSectionRecordSerialize) == 0x000008, "Wrong alignment on FPerformanceStatisticsSectionRecordSerialize");
static_assert(sizeof(FPerformanceStatisticsSectionRecordSerialize) == 0x000020, "Wrong size on FPerformanceStatisticsSectionRecordSerialize");
static_assert(offsetof(FPerformanceStatisticsSectionRecordSerialize, SectionName) == 0x000000, "Member 'FPerformanceStatisticsSectionRecordSerialize::SectionName' has a wrong offset!");
static_assert(offsetof(FPerformanceStatisticsSectionRecordSerialize, UnitRecordValues) == 0x000010, "Member 'FPerformanceStatisticsSectionRecordSerialize::UnitRecordValues' has a wrong offset!");

// ScriptStruct KuroGameplay.PerformanceStatisticsSectionsSerialize
// 0x0010 (0x0010 - 0x0000)
struct FPerformanceStatisticsSectionsSerialize final
{
public:
	TArray<struct FPerformanceStatisticsSectionRecordSerialize> SectionRecords;                                    // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPerformanceStatisticsSectionsSerialize) == 0x000008, "Wrong alignment on FPerformanceStatisticsSectionsSerialize");
static_assert(sizeof(FPerformanceStatisticsSectionsSerialize) == 0x000010, "Wrong size on FPerformanceStatisticsSectionsSerialize");
static_assert(offsetof(FPerformanceStatisticsSectionsSerialize, SectionRecords) == 0x000000, "Member 'FPerformanceStatisticsSectionsSerialize::SectionRecords' has a wrong offset!");

// ScriptStruct KuroGameplay.PerformanceStatisticsTagNode
// 0x0088 (0x0088 - 0x0000)
struct alignas(0x08) FPerformanceStatisticsTagNode final
{
public:
	class FName                                   Tag;                                               // 0x0000(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RecordFramesCount;                                 // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TotalTime;                                         // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AverageTime;                                       // 0x0014(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxTime;                                           // 0x0018(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x6C];                                      // 0x001C(0x006C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPerformanceStatisticsTagNode) == 0x000008, "Wrong alignment on FPerformanceStatisticsTagNode");
static_assert(sizeof(FPerformanceStatisticsTagNode) == 0x000088, "Wrong size on FPerformanceStatisticsTagNode");
static_assert(offsetof(FPerformanceStatisticsTagNode, Tag) == 0x000000, "Member 'FPerformanceStatisticsTagNode::Tag' has a wrong offset!");
static_assert(offsetof(FPerformanceStatisticsTagNode, RecordFramesCount) == 0x00000C, "Member 'FPerformanceStatisticsTagNode::RecordFramesCount' has a wrong offset!");
static_assert(offsetof(FPerformanceStatisticsTagNode, TotalTime) == 0x000010, "Member 'FPerformanceStatisticsTagNode::TotalTime' has a wrong offset!");
static_assert(offsetof(FPerformanceStatisticsTagNode, AverageTime) == 0x000014, "Member 'FPerformanceStatisticsTagNode::AverageTime' has a wrong offset!");
static_assert(offsetof(FPerformanceStatisticsTagNode, MaxTime) == 0x000018, "Member 'FPerformanceStatisticsTagNode::MaxTime' has a wrong offset!");

// ScriptStruct KuroGameplay.PerformanceStatisticsTagNodeForSerialize
// 0x001C (0x001C - 0x0000)
struct FPerformanceStatisticsTagNodeForSerialize final
{
public:
	class FName                                   Tag;                                               // 0x0000(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RecordFramesCount;                                 // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TotalTime;                                         // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AverageTime;                                       // 0x0014(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxTime;                                           // 0x0018(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPerformanceStatisticsTagNodeForSerialize) == 0x000004, "Wrong alignment on FPerformanceStatisticsTagNodeForSerialize");
static_assert(sizeof(FPerformanceStatisticsTagNodeForSerialize) == 0x00001C, "Wrong size on FPerformanceStatisticsTagNodeForSerialize");
static_assert(offsetof(FPerformanceStatisticsTagNodeForSerialize, Tag) == 0x000000, "Member 'FPerformanceStatisticsTagNodeForSerialize::Tag' has a wrong offset!");
static_assert(offsetof(FPerformanceStatisticsTagNodeForSerialize, RecordFramesCount) == 0x00000C, "Member 'FPerformanceStatisticsTagNodeForSerialize::RecordFramesCount' has a wrong offset!");
static_assert(offsetof(FPerformanceStatisticsTagNodeForSerialize, TotalTime) == 0x000010, "Member 'FPerformanceStatisticsTagNodeForSerialize::TotalTime' has a wrong offset!");
static_assert(offsetof(FPerformanceStatisticsTagNodeForSerialize, AverageTime) == 0x000014, "Member 'FPerformanceStatisticsTagNodeForSerialize::AverageTime' has a wrong offset!");
static_assert(offsetof(FPerformanceStatisticsTagNodeForSerialize, MaxTime) == 0x000018, "Member 'FPerformanceStatisticsTagNodeForSerialize::MaxTime' has a wrong offset!");

}

