#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: KuroUtility

#include "Basic.hpp"

#include "KuroUtility_classes.hpp"
#include "KuroUtility_parameters.hpp"


namespace SDK
{

// Function KuroUtility.AsyncLoadState.AsyncLoadClass
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           InPath                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          UserData                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAsyncLoadState::AsyncLoadClass(const class FString& InPath, class UObject* UserData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AsyncLoadState", "AsyncLoadClass");

	Params::AsyncLoadState_AsyncLoadClass Parms{};

	Parms.InPath = std::move(InPath);
	Parms.UserData = UserData;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroUtility.AsyncLoadState.AsyncLoadObject
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           InPath                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          UserData                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAsyncLoadState::AsyncLoadObject(const class FString& InPath, class UObject* UserData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AsyncLoadState", "AsyncLoadObject");

	Params::AsyncLoadState_AsyncLoadObject Parms{};

	Parms.InPath = std::move(InPath);
	Parms.UserData = UserData;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroUtility.HoldPreloadObject.AddCommonAsset
// (Final, Native, Public)
// Parameters:
// class UObject*                          InObject                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHoldPreloadObject::AddCommonAsset(class UObject* InObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HoldPreloadObject", "AddCommonAsset");

	Params::HoldPreloadObject_AddCommonAsset Parms{};

	Parms.InObject = InObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroUtility.HoldPreloadObject.AddEntityAsset
// (Final, Native, Public)
// Parameters:
// int32                                   EntityId                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          InObject                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UHoldPreloadObject::AddEntityAsset(const int32 EntityId, class UObject* InObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HoldPreloadObject", "AddEntityAsset");

	Params::HoldPreloadObject_AddEntityAsset Parms{};

	Parms.EntityId = EntityId;
	Parms.InObject = InObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroUtility.HoldPreloadObject.Clear
// (Final, Native, Public)

void UHoldPreloadObject::Clear()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HoldPreloadObject", "Clear");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function KuroUtility.HoldPreloadObject.ClearCommonAsset
// (Final, Native, Public)

void UHoldPreloadObject::ClearCommonAsset()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HoldPreloadObject", "ClearCommonAsset");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function KuroUtility.HoldPreloadObject.ClearEntityAssetMap
// (Final, Native, Public)

void UHoldPreloadObject::ClearEntityAssetMap()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HoldPreloadObject", "ClearEntityAssetMap");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function KuroUtility.HoldPreloadObject.GetCommonAssetArray
// (Final, Native, Public)
// Parameters:
// TArray<class UObject*>                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class UObject*> UHoldPreloadObject::GetCommonAssetArray()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HoldPreloadObject", "GetCommonAssetArray");

	Params::HoldPreloadObject_GetCommonAssetArray Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroUtility.HoldPreloadObject.GetEntityAssetArray
// (Final, Native, Public, HasOutParams)
// Parameters:
// int32                                   EntityId                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class UObject*>                  OutAssets                                              (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UHoldPreloadObject::GetEntityAssetArray(const int32 EntityId, TArray<class UObject*>* OutAssets)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HoldPreloadObject", "GetEntityAssetArray");

	Params::HoldPreloadObject_GetEntityAssetArray Parms{};

	Parms.EntityId = EntityId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutAssets != nullptr)
		*OutAssets = std::move(Parms.OutAssets);

	return Parms.ReturnValue;
}


// Function KuroUtility.HoldPreloadObject.RemoveEntityAssets
// (Final, Native, Public)
// Parameters:
// int32                                   EntityId                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UHoldPreloadObject::RemoveEntityAssets(const int32 EntityId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HoldPreloadObject", "RemoveEntityAssets");

	Params::HoldPreloadObject_RemoveEntityAssets Parms{};

	Parms.EntityId = EntityId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroUtility.KuroActor.ReceiveKuroActorBack
// (Event, Protected, BlueprintEvent)

void AKuroActor::ReceiveKuroActorBack()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KuroActor", "ReceiveKuroActorBack");

	UObject::ProcessEvent(Func, nullptr);
}


// Function KuroUtility.KuroActor.ReceiveKuroActorGet
// (Event, Protected, BlueprintEvent)

void AKuroActor::ReceiveKuroActorGet()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KuroActor", "ReceiveKuroActorGet");

	UObject::ProcessEvent(Func, nullptr);
}


// Function KuroUtility.KuroActorComponent.EditorTickComponent
// (Event, Public, BlueprintEvent)
// Parameters:
// float                                   DeltaTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKuroActorComponent::EditorTickComponent(float DeltaTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KuroActorComponent", "EditorTickComponent");

	Params::KuroActorComponent_EditorTickComponent Parms{};

	Parms.DeltaTime = DeltaTime;

	UObject::ProcessEvent(Func, &Parms);
}


// Function KuroUtility.KuroActorManager.Clear
// (Final, Native, Static, Public)

void UKuroActorManager::Clear()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroActorManager", "Clear");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function KuroUtility.KuroActorManager.ClearAcquiredComponents
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKuroActorManager::ClearAcquiredComponents(class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroActorManager", "ClearAcquiredComponents");

	Params::KuroActorManager_ClearAcquiredComponents Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroUtility.KuroActorManager.D_SpawnActor
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class AActor>               ActorClass                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransformDouble                 SpawnTransform                                         (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// ESpawnActorCollisionHandlingMethod      CollisionHandlingOverride                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Owner                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class APawn*                            Instigator                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bAsPoolActor                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* UKuroActorManager::D_SpawnActor(const class UObject* WorldContextObject, const TSubclassOf<class AActor> ActorClass, const struct FTransformDouble& SpawnTransform, ESpawnActorCollisionHandlingMethod CollisionHandlingOverride, class AActor* Owner, class APawn* Instigator, bool bAsPoolActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroActorManager", "D_SpawnActor");

	Params::KuroActorManager_D_SpawnActor Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.ActorClass = ActorClass;
	Parms.SpawnTransform = std::move(SpawnTransform);
	Parms.CollisionHandlingOverride = CollisionHandlingOverride;
	Parms.Owner = Owner;
	Parms.Instigator = Instigator;
	Parms.bAsPoolActor = bAsPoolActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroUtility.KuroActorManager.DestroyActor
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKuroActorManager::DestroyActor(class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroActorManager", "DestroyActor");

	Params::KuroActorManager_DestroyActor Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroUtility.KuroActorManager.GetAllAcquiredComponents
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class FString>                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class FString> UKuroActorManager::GetAllAcquiredComponents(class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroActorManager", "GetAllAcquiredComponents");

	Params::KuroActorManager_GetAllAcquiredComponents Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroUtility.KuroActorManager.GetDummySequence
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class ULevelSequence*                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ULevelSequence* UKuroActorManager::GetDummySequence()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroActorManager", "GetDummySequence");

	Params::KuroActorManager_GetDummySequence Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroUtility.KuroActorManager.GetResourceSizeBytes
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    isExclusive                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UKuroActorManager::GetResourceSizeBytes(class AActor* Actor, bool isExclusive)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroActorManager", "GetResourceSizeBytes");

	Params::KuroActorManager_GetResourceSizeBytes Parms{};

	Parms.Actor = Actor;
	Parms.isExclusive = isExclusive;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroUtility.KuroActorManager.InitActorManager
// (Final, Native, Static, Public, BlueprintCallable)

void UKuroActorManager::InitActorManager()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroActorManager", "InitActorManager");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function KuroUtility.KuroActorManager.IsActorPoolEnable
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKuroActorManager::IsActorPoolEnable()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroActorManager", "IsActorPoolEnable");

	Params::KuroActorManager_IsActorPoolEnable Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroUtility.KuroActorManager.IsPooledActor
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKuroActorManager::IsPooledActor(const class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroActorManager", "IsPooledActor");

	Params::KuroActorManager_IsPooledActor Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroUtility.KuroActorManager.RegisterActorSkipProperties
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UClass*                           Class_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FPropertyPair>            Properties                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void UKuroActorManager::RegisterActorSkipProperties(class UClass* Class_0, const TArray<struct FPropertyPair>& Properties)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroActorManager", "RegisterActorSkipProperties");

	Params::KuroActorManager_RegisterActorSkipProperties Parms{};

	Parms.Class_0 = Class_0;
	Parms.Properties = std::move(Properties);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroUtility.KuroActorManager.ResetActorToDefault
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKuroActorManager::ResetActorToDefault(class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroActorManager", "ResetActorToDefault");

	Params::KuroActorManager_ResetActorToDefault Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroUtility.KuroActorManager.ResetClassPropertyCache
// (Final, Native, Static, Public)
// Parameters:
// class UClass*                           Class_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKuroActorManager::ResetClassPropertyCache(class UClass* Class_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroActorManager", "ResetClassPropertyCache");

	Params::KuroActorManager_ResetClassPropertyCache Parms{};

	Parms.Class_0 = Class_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroUtility.KuroActorManager.ResetDelegates
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKuroActorManager::ResetDelegates(class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroActorManager", "ResetDelegates");

	Params::KuroActorManager_ResetDelegates Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroUtility.KuroActorManager.ResetUberGraph
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          Obj                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKuroActorManager::ResetUberGraph(class UObject* Obj)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroActorManager", "ResetUberGraph");

	Params::KuroActorManager_ResetUberGraph Parms{};

	Parms.Obj = Obj;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroUtility.KuroActorManager.ResetUObjectByCDO
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          Obj                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKuroActorManager::ResetUObjectByCDO(class UObject* Obj)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroActorManager", "ResetUObjectByCDO");

	Params::KuroActorManager_ResetUObjectByCDO Parms{};

	Parms.Obj = Obj;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroUtility.KuroActorManager.SpawnActor
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class AActor>               ActorClass                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransform                       SpawnTransform                                         (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// ESpawnActorCollisionHandlingMethod      CollisionHandlingOverride                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Owner                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class APawn*                            Instigator                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bAsPoolActor                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* UKuroActorManager::SpawnActor(const class UObject* WorldContextObject, const TSubclassOf<class AActor> ActorClass, const struct FTransform& SpawnTransform, ESpawnActorCollisionHandlingMethod CollisionHandlingOverride, class AActor* Owner, class APawn* Instigator, bool bAsPoolActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroActorManager", "SpawnActor");

	Params::KuroActorManager_SpawnActor Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.ActorClass = ActorClass;
	Parms.SpawnTransform = std::move(SpawnTransform);
	Parms.CollisionHandlingOverride = CollisionHandlingOverride;
	Parms.Owner = Owner;
	Parms.Instigator = Instigator;
	Parms.bAsPoolActor = bAsPoolActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroUtility.KuroActorManager.UnregisterComponent
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UActorComponent*                  Componet                                               (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKuroActorManager::UnregisterComponent(class UActorComponent* Componet)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroActorManager", "UnregisterComponent");

	Params::KuroActorManager_UnregisterComponent Parms{};

	Parms.Componet = Componet;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroUtility.KuroApplicationLibrary.AddApplicationLifetimeDelegate
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TDelegate<void(int32 Type)>             InDelegate                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKuroApplicationLibrary::AddApplicationLifetimeDelegate(const TDelegate<void(int32 Type)>& InDelegate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroApplicationLibrary", "AddApplicationLifetimeDelegate");

	Params::KuroApplicationLibrary_AddApplicationLifetimeDelegate Parms{};

	Parms.InDelegate = InDelegate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroUtility.KuroApplicationLibrary.AddEditorPreEndPIEDelegate
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TDelegate<void(bool bSimulateInEditor)> InDelegate                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKuroApplicationLibrary::AddEditorPreEndPIEDelegate(const TDelegate<void(bool bSimulateInEditor)>& InDelegate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroApplicationLibrary", "AddEditorPreEndPIEDelegate");

	Params::KuroApplicationLibrary_AddEditorPreEndPIEDelegate Parms{};

	Parms.InDelegate = InDelegate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroUtility.KuroApplicationLibrary.Test
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKuroApplicationLibrary::Test(int32 Type)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroApplicationLibrary", "Test");

	Params::KuroApplicationLibrary_Test Parms{};

	Parms.Type = Type;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroUtility.KuroApplicationLibrary.UnBind
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKuroApplicationLibrary::UnBind()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroApplicationLibrary", "UnBind");

	Params::KuroApplicationLibrary_UnBind Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroUtility.KuroCollectActorComponent.GetActorWithTag
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                             Tag                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ECollectActorType                       Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* UKuroCollectActorComponent::GetActorWithTag(class FName Tag, ECollectActorType Type)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroCollectActorComponent", "GetActorWithTag");

	Params::KuroCollectActorComponent_GetActorWithTag Parms{};

	Parms.Tag = Tag;
	Parms.Type = Type;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroUtility.KuroCompressLibrary.CompressFileOrFolder
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FString                           Path                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           DestPath                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TDelegate<void(float Rate)>             OnProgress                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// TDelegate<void(TArray<class FString>& SuccessedPaths)>OnCompressComplete                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// TDelegate<void()>                       OnFail                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// int64                                   MaxSingleFileReadSize                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKuroCompressLibrary::CompressFileOrFolder(const class FString& Path, const class FString& DestPath, const TDelegate<void(float Rate)>& OnProgress, const TDelegate<void(TArray<class FString>& SuccessedPaths)>& OnCompressComplete, const TDelegate<void()>& OnFail, int64 MaxSingleFileReadSize)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroCompressLibrary", "CompressFileOrFolder");

	Params::KuroCompressLibrary_CompressFileOrFolder Parms{};

	Parms.Path = std::move(Path);
	Parms.DestPath = std::move(DestPath);
	Parms.OnProgress = OnProgress;
	Parms.OnCompressComplete = OnCompressComplete;
	Parms.OnFail = OnFail;
	Parms.MaxSingleFileReadSize = MaxSingleFileReadSize;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroUtility.KuroCompressLibrary.CompressFilesOrFoldersAsync
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<class FString>                   Paths                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// class FString                           DestPath                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TDelegate<void(float Rate)>             OnProgress                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// TDelegate<void(TArray<class FString>& SuccessedPaths)>OnCompressComplete                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// TDelegate<void()>                       OnFail                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    bAutoIncludeFilesUnderFolder                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int64                                   MaxSingleFileReadSize                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKuroCompressLibrary::CompressFilesOrFoldersAsync(const TArray<class FString>& Paths, const class FString& DestPath, const TDelegate<void(float Rate)>& OnProgress, const TDelegate<void(TArray<class FString>& SuccessedPaths)>& OnCompressComplete, const TDelegate<void()>& OnFail, bool bAutoIncludeFilesUnderFolder, int64 MaxSingleFileReadSize)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroCompressLibrary", "CompressFilesOrFoldersAsync");

	Params::KuroCompressLibrary_CompressFilesOrFoldersAsync Parms{};

	Parms.Paths = std::move(Paths);
	Parms.DestPath = std::move(DestPath);
	Parms.OnProgress = OnProgress;
	Parms.OnCompressComplete = OnCompressComplete;
	Parms.OnFail = OnFail;
	Parms.bAutoIncludeFilesUnderFolder = bAutoIncludeFilesUnderFolder;
	Parms.MaxSingleFileReadSize = MaxSingleFileReadSize;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroUtility.KuroMathLibrary.BitwiseLeftShift
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int64                                   Source                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Bit                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int64                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int64 UKuroMathLibrary::BitwiseLeftShift(int64 Source, int32 Bit)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroMathLibrary", "BitwiseLeftShift");

	Params::KuroMathLibrary_BitwiseLeftShift Parms{};

	Parms.Source = Source;
	Parms.Bit = Bit;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroUtility.KuroMathLibrary.BitwiseRightShift
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int64                                   Source                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Bit                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int64                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int64 UKuroMathLibrary::BitwiseRightShift(int64 Source, int32 Bit)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroMathLibrary", "BitwiseRightShift");

	Params::KuroMathLibrary_BitwiseRightShift Parms{};

	Parms.Source = Source;
	Parms.Bit = Bit;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroUtility.KuroMathLibrary.IntBitwiseAnd
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   Num1                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Num2                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UKuroMathLibrary::IntBitwiseAnd(int32 Num1, int32 Num2)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroMathLibrary", "IntBitwiseAnd");

	Params::KuroMathLibrary_IntBitwiseAnd Parms{};

	Parms.Num1 = Num1;
	Parms.Num2 = Num2;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroUtility.KuroMathLibrary.IntBitwiseNot
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   Num                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UKuroMathLibrary::IntBitwiseNot(int32 Num)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroMathLibrary", "IntBitwiseNot");

	Params::KuroMathLibrary_IntBitwiseNot Parms{};

	Parms.Num = Num;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroUtility.KuroMathLibrary.IntBitwiseOr
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   Num1                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Num2                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UKuroMathLibrary::IntBitwiseOr(int32 Num1, int32 Num2)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroMathLibrary", "IntBitwiseOr");

	Params::KuroMathLibrary_IntBitwiseOr Parms{};

	Parms.Num1 = Num1;
	Parms.Num2 = Num2;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroUtility.KuroMathLibrary.IntBitwiseXOr
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   Num1                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Num2                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UKuroMathLibrary::IntBitwiseXOr(int32 Num1, int32 Num2)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroMathLibrary", "IntBitwiseXOr");

	Params::KuroMathLibrary_IntBitwiseXOr Parms{};

	Parms.Num1 = Num1;
	Parms.Num2 = Num2;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroUtility.KuroMathLibrary.KuroStringToInt64
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           StringNum                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int64                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int64 UKuroMathLibrary::KuroStringToInt64(const class FString& StringNum)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroMathLibrary", "KuroStringToInt64");

	Params::KuroMathLibrary_KuroStringToInt64 Parms{};

	Parms.StringNum = std::move(StringNum);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroUtility.KuroMathLibrary.LongBitwiseAnd
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int64                                   Num1                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int64                                   Num2                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int64                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int64 UKuroMathLibrary::LongBitwiseAnd(int64 Num1, int64 Num2)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroMathLibrary", "LongBitwiseAnd");

	Params::KuroMathLibrary_LongBitwiseAnd Parms{};

	Parms.Num1 = Num1;
	Parms.Num2 = Num2;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroUtility.KuroMathLibrary.LongBitwiseNot
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int64                                   Num                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int64                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int64 UKuroMathLibrary::LongBitwiseNot(int64 Num)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroMathLibrary", "LongBitwiseNot");

	Params::KuroMathLibrary_LongBitwiseNot Parms{};

	Parms.Num = Num;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroUtility.KuroMathLibrary.LongBitwiseOr
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int64                                   Num1                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int64                                   Num2                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int64                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int64 UKuroMathLibrary::LongBitwiseOr(int64 Num1, int64 Num2)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroMathLibrary", "LongBitwiseOr");

	Params::KuroMathLibrary_LongBitwiseOr Parms{};

	Parms.Num1 = Num1;
	Parms.Num2 = Num2;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroUtility.KuroMathLibrary.LongBitwiseXOr
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int64                                   Num1                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int64                                   Num2                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int64                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int64 UKuroMathLibrary::LongBitwiseXOr(int64 Num1, int64 Num2)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroMathLibrary", "LongBitwiseXOr");

	Params::KuroMathLibrary_LongBitwiseXOr Parms{};

	Parms.Num1 = Num1;
	Parms.Num2 = Num2;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroUtility.KuroMathLibrary.Max
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector2D                        A                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                        B                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector2D UKuroMathLibrary::Max(const struct FVector2D& A, const struct FVector2D& B)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroMathLibrary", "Max");

	Params::KuroMathLibrary_Max Parms{};

	Parms.A = std::move(A);
	Parms.B = std::move(B);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroUtility.KuroMathLibrary.Min
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector2D                        A                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                        B                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector2D UKuroMathLibrary::Min(const struct FVector2D& A, const struct FVector2D& B)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroMathLibrary", "Min");

	Params::KuroMathLibrary_Min Parms{};

	Parms.A = std::move(A);
	Parms.B = std::move(B);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroUtility.KuroMemoryLibrary.PrintUObjectMemoryInfo
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          Object                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKuroMemoryLibrary::PrintUObjectMemoryInfo(class UObject* Object)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroMemoryLibrary", "PrintUObjectMemoryInfo");

	Params::KuroMemoryLibrary_PrintUObjectMemoryInfo Parms{};

	Parms.Object = Object;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroUtility.KuroMeshTextureFunctionLibrary.AddMeshesBundleStreamedAllMipsDelegate
// (Final, Native, Static, Private, HasOutParams, BlueprintCallable)
// Parameters:
// TDelegate<void(TArray<class USkeletalMesh*>& SkeletalMeshes, TArray<class UStaticMesh*>& StaticMeshes)>InDelegate                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKuroMeshTextureFunctionLibrary::AddMeshesBundleStreamedAllMipsDelegate(const TDelegate<void(TArray<class USkeletalMesh*>& SkeletalMeshes, TArray<class UStaticMesh*>& StaticMeshes)>& InDelegate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroMeshTextureFunctionLibrary", "AddMeshesBundleStreamedAllMipsDelegate");

	Params::KuroMeshTextureFunctionLibrary_AddMeshesBundleStreamedAllMipsDelegate Parms{};

	Parms.InDelegate = InDelegate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroUtility.KuroMeshTextureFunctionLibrary.AddSkeletalStreamedAllMipsDelegate
// (Final, Native, Static, Private, HasOutParams, BlueprintCallable)
// Parameters:
// TDelegate<void(class USkeletalMesh* SkeletalMesh)>InDelegate                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKuroMeshTextureFunctionLibrary::AddSkeletalStreamedAllMipsDelegate(const TDelegate<void(class USkeletalMesh* SkeletalMesh)>& InDelegate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroMeshTextureFunctionLibrary", "AddSkeletalStreamedAllMipsDelegate");

	Params::KuroMeshTextureFunctionLibrary_AddSkeletalStreamedAllMipsDelegate Parms{};

	Parms.InDelegate = InDelegate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroUtility.KuroMeshTextureFunctionLibrary.AddStaticMeshStreamedAllMipsDelegate
// (Final, Native, Static, Private, HasOutParams, BlueprintCallable)
// Parameters:
// TDelegate<void(class UStaticMesh* StaticMesh)>InDelegate                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKuroMeshTextureFunctionLibrary::AddStaticMeshStreamedAllMipsDelegate(const TDelegate<void(class UStaticMesh* StaticMesh)>& InDelegate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroMeshTextureFunctionLibrary", "AddStaticMeshStreamedAllMipsDelegate");

	Params::KuroMeshTextureFunctionLibrary_AddStaticMeshStreamedAllMipsDelegate Parms{};

	Parms.InDelegate = InDelegate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroUtility.KuroMeshTextureFunctionLibrary.ForceMeshesBundleStreamingInAllMips
// (Final, Native, Static, Private, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<class USkeletalMesh*>            MeshBundleSkeletalMeshes                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// TArray<class UStaticMesh*>              MeshBundleStaticMeshes                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// TDelegate<void(TArray<class USkeletalMesh*>& SkeletalMeshes, TArray<class UStaticMesh*>& StaticMeshes)>InDelegate                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UKuroMeshTextureFunctionLibrary::ForceMeshesBundleStreamingInAllMips(const TArray<class USkeletalMesh*>& MeshBundleSkeletalMeshes, const TArray<class UStaticMesh*>& MeshBundleStaticMeshes, const TDelegate<void(TArray<class USkeletalMesh*>& SkeletalMeshes, TArray<class UStaticMesh*>& StaticMeshes)>& InDelegate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroMeshTextureFunctionLibrary", "ForceMeshesBundleStreamingInAllMips");

	Params::KuroMeshTextureFunctionLibrary_ForceMeshesBundleStreamingInAllMips Parms{};

	Parms.MeshBundleSkeletalMeshes = std::move(MeshBundleSkeletalMeshes);
	Parms.MeshBundleStaticMeshes = std::move(MeshBundleStaticMeshes);
	Parms.InDelegate = InDelegate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroUtility.KuroMeshTextureFunctionLibrary.HandleMeshesComponentsBundleStreaming
// (Final, Native, Static, Private, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<class USkeletalMesh*>            MeshBundleSkeletalMeshes                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// TArray<class UStaticMesh*>              MeshBundleStaticMeshes                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    bStartForceStreamIn                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKuroMeshTextureFunctionLibrary::HandleMeshesComponentsBundleStreaming(const TArray<class USkeletalMesh*>& MeshBundleSkeletalMeshes, const TArray<class UStaticMesh*>& MeshBundleStaticMeshes, const bool bStartForceStreamIn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroMeshTextureFunctionLibrary", "HandleMeshesComponentsBundleStreaming");

	Params::KuroMeshTextureFunctionLibrary_HandleMeshesComponentsBundleStreaming Parms{};

	Parms.MeshBundleSkeletalMeshes = std::move(MeshBundleSkeletalMeshes);
	Parms.MeshBundleStaticMeshes = std::move(MeshBundleStaticMeshes);
	Parms.bStartForceStreamIn = bStartForceStreamIn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroUtility.KuroMeshTextureFunctionLibrary.HandleSkeletalMeshComponentStreaming
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// class USkeletalMesh*                    skeletalMesh                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bStartForceStreamIn                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKuroMeshTextureFunctionLibrary::HandleSkeletalMeshComponentStreaming(class USkeletalMesh* skeletalMesh, const bool bStartForceStreamIn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroMeshTextureFunctionLibrary", "HandleSkeletalMeshComponentStreaming");

	Params::KuroMeshTextureFunctionLibrary_HandleSkeletalMeshComponentStreaming Parms{};

	Parms.skeletalMesh = skeletalMesh;
	Parms.bStartForceStreamIn = bStartForceStreamIn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroUtility.KuroMeshTextureFunctionLibrary.HandleStaticMeshComponentStreaming
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// class UStaticMesh*                      staticMesh                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bStartForceStreamIn                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKuroMeshTextureFunctionLibrary::HandleStaticMeshComponentStreaming(class UStaticMesh* staticMesh, const bool bStartForceStreamIn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroMeshTextureFunctionLibrary", "HandleStaticMeshComponentStreaming");

	Params::KuroMeshTextureFunctionLibrary_HandleStaticMeshComponentStreaming Parms{};

	Parms.staticMesh = staticMesh;
	Parms.bStartForceStreamIn = bStartForceStreamIn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroUtility.KuroMeshTextureFunctionLibrary.IsSkeletalMeshComponentStreamingComplete
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// class USkeletalMesh*                    skeletalMesh                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKuroMeshTextureFunctionLibrary::IsSkeletalMeshComponentStreamingComplete(class USkeletalMesh* skeletalMesh)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroMeshTextureFunctionLibrary", "IsSkeletalMeshComponentStreamingComplete");

	Params::KuroMeshTextureFunctionLibrary_IsSkeletalMeshComponentStreamingComplete Parms{};

	Parms.skeletalMesh = skeletalMesh;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroUtility.KuroMeshTextureFunctionLibrary.IsStaticMeshComponentStreamingComplete
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// class UStaticMesh*                      staticMesh                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKuroMeshTextureFunctionLibrary::IsStaticMeshComponentStreamingComplete(class UStaticMesh* staticMesh)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroMeshTextureFunctionLibrary", "IsStaticMeshComponentStreamingComplete");

	Params::KuroMeshTextureFunctionLibrary_IsStaticMeshComponentStreamingComplete Parms{};

	Parms.staticMesh = staticMesh;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroUtility.KuroMeshTextureFunctionLibrary.StopMeshesBundleStreamingInAllMips
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// int32                                   UniqueInstanceID                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKuroMeshTextureFunctionLibrary::StopMeshesBundleStreamingInAllMips(const int32 UniqueInstanceID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroMeshTextureFunctionLibrary", "StopMeshesBundleStreamingInAllMips");

	Params::KuroMeshTextureFunctionLibrary_StopMeshesBundleStreamingInAllMips Parms{};

	Parms.UniqueInstanceID = UniqueInstanceID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroUtility.KuroMeshTextureFunctionLibrary.UnbindMeshesBundleStreamedAllMipsDelegate
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKuroMeshTextureFunctionLibrary::UnbindMeshesBundleStreamedAllMipsDelegate()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroMeshTextureFunctionLibrary", "UnbindMeshesBundleStreamedAllMipsDelegate");

	Params::KuroMeshTextureFunctionLibrary_UnbindMeshesBundleStreamedAllMipsDelegate Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroUtility.KuroMeshTextureFunctionLibrary.UnbindSkeletalStreamedAllMipsDelegate
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKuroMeshTextureFunctionLibrary::UnbindSkeletalStreamedAllMipsDelegate()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroMeshTextureFunctionLibrary", "UnbindSkeletalStreamedAllMipsDelegate");

	Params::KuroMeshTextureFunctionLibrary_UnbindSkeletalStreamedAllMipsDelegate Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroUtility.KuroMeshTextureFunctionLibrary.UnbindStaticMeshStreamedAllMipsDelegate
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKuroMeshTextureFunctionLibrary::UnbindStaticMeshStreamedAllMipsDelegate()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroMeshTextureFunctionLibrary", "UnbindStaticMeshStreamedAllMipsDelegate");

	Params::KuroMeshTextureFunctionLibrary_UnbindStaticMeshStreamedAllMipsDelegate Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroUtility.KuroPhysicsLibrary.GetHitPoint
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVectorDouble                    StartLocation                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVectorDouble                    EndLocation                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              TraceComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UKuroHitResult*                   HitResult                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DrawDuration                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ForceTrace                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKuroPhysicsLibrary::GetHitPoint(const struct FVectorDouble& StartLocation, const struct FVectorDouble& EndLocation, class AActor* Actor, class UPrimitiveComponent* TraceComp, class UKuroHitResult* HitResult, float DrawDuration, bool ForceTrace)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroPhysicsLibrary", "GetHitPoint");

	Params::KuroPhysicsLibrary_GetHitPoint Parms{};

	Parms.StartLocation = std::move(StartLocation);
	Parms.EndLocation = std::move(EndLocation);
	Parms.Actor = Actor;
	Parms.TraceComp = TraceComp;
	Parms.HitResult = HitResult;
	Parms.DrawDuration = DrawDuration;
	Parms.ForceTrace = ForceTrace;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroUtility.KuroPhysicsLibrary.GetSphereHitPoint
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVectorDouble                    StartLocation                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVectorDouble                    EndLocation                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              TraceComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Radius                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UKuroHitResult*                   HitResult                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DrawDuration                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ForceTrace                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKuroPhysicsLibrary::GetSphereHitPoint(const struct FVectorDouble& StartLocation, const struct FVectorDouble& EndLocation, class AActor* Actor, class UPrimitiveComponent* TraceComp, float Radius, class UKuroHitResult* HitResult, float DrawDuration, bool ForceTrace)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroPhysicsLibrary", "GetSphereHitPoint");

	Params::KuroPhysicsLibrary_GetSphereHitPoint Parms{};

	Parms.StartLocation = std::move(StartLocation);
	Parms.EndLocation = std::move(EndLocation);
	Parms.Actor = Actor;
	Parms.TraceComp = TraceComp;
	Parms.Radius = Radius;
	Parms.HitResult = HitResult;
	Parms.DrawDuration = DrawDuration;
	Parms.ForceTrace = ForceTrace;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroUtility.KuroPolypartition.BuildTriangleByVertex2D
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TArray<struct FVector2D>                points                                                 (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// TArray<int32>                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<int32> UKuroPolypartition::BuildTriangleByVertex2D(const TArray<struct FVector2D>& points)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroPolypartition", "BuildTriangleByVertex2D");

	Params::KuroPolypartition_BuildTriangleByVertex2D Parms{};

	Parms.points = std::move(points);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroUtility.KuroSilenceGameMode.GameInitialized
// (Final, Native, Public, BlueprintCallable)

void AKuroSilenceGameMode::GameInitialized()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KuroSilenceGameMode", "GameInitialized");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function KuroUtility.KuroStaticAndroidLibrary.AddAndroidScreenChangeDelegate
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TDelegate<void()>                       Handler                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void UKuroStaticAndroidLibrary::AddAndroidScreenChangeDelegate(const TDelegate<void()>& Handler)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticAndroidLibrary", "AddAndroidScreenChangeDelegate");

	Params::KuroStaticAndroidLibrary_AddAndroidScreenChangeDelegate Parms{};

	Parms.Handler = Handler;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroUtility.KuroStaticAndroidLibrary.ClearAndroidScreenChangeDelegate
// (Final, Native, Static, Public, BlueprintCallable)

void UKuroStaticAndroidLibrary::ClearAndroidScreenChangeDelegate()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticAndroidLibrary", "ClearAndroidScreenChangeDelegate");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function KuroUtility.KuroStaticAndroidLibrary.GetCustomChannel
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UKuroStaticAndroidLibrary::GetCustomChannel()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticAndroidLibrary", "GetCustomChannel");

	Params::KuroStaticAndroidLibrary_GetCustomChannel Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroUtility.KuroStaticAndroidLibrary.GetDeviceIsEmulator
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKuroStaticAndroidLibrary::GetDeviceIsEmulator()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticAndroidLibrary", "GetDeviceIsEmulator");

	Params::KuroStaticAndroidLibrary_GetDeviceIsEmulator Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroUtility.KuroStaticAndroidLibrary.GetDeviceIsRooted
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKuroStaticAndroidLibrary::GetDeviceIsRooted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticAndroidLibrary", "GetDeviceIsRooted");

	Params::KuroStaticAndroidLibrary_GetDeviceIsRooted Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroUtility.KuroStaticAndroidLibrary.OpenAppWithUrl
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           schema                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           failSchema                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKuroStaticAndroidLibrary::OpenAppWithUrl(const class FString& schema, const class FString& failSchema)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticAndroidLibrary", "OpenAppWithUrl");

	Params::KuroStaticAndroidLibrary_OpenAppWithUrl Parms{};

	Parms.schema = std::move(schema);
	Parms.failSchema = std::move(failSchema);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroUtility.KuroStaticiOSLibrary.GetDeviceJailbroken
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKuroStaticiOSLibrary::GetDeviceJailbroken()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticiOSLibrary", "GetDeviceJailbroken");

	Params::KuroStaticiOSLibrary_GetDeviceJailbroken Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroUtility.KuroStaticiOSLibrary.OpenAppWithUrl
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           url                                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           failUrl                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKuroStaticiOSLibrary::OpenAppWithUrl(const class FString& url, const class FString& failUrl)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticiOSLibrary", "OpenAppWithUrl");

	Params::KuroStaticiOSLibrary_OpenAppWithUrl Parms{};

	Parms.url = std::move(url);
	Parms.failUrl = std::move(failUrl);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroUtility.KuroStaticLibrary.AddToRoot
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          InObject                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKuroStaticLibrary::AddToRoot(class UObject* InObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticLibrary", "AddToRoot");

	Params::KuroStaticLibrary_AddToRoot Parms{};

	Parms.InObject = InObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroUtility.KuroStaticLibrary.ApplyChangeToBlueprint
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKuroStaticLibrary::ApplyChangeToBlueprint(class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticLibrary", "ApplyChangeToBlueprint");

	Params::KuroStaticLibrary_ApplyChangeToBlueprint Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroUtility.KuroStaticLibrary.ArrayToBuffer
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<uint8>                           InArray                                                (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// struct FArrayBuffer                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FArrayBuffer UKuroStaticLibrary::ArrayToBuffer(TArray<uint8>* InArray)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticLibrary", "ArrayToBuffer");

	Params::KuroStaticLibrary_ArrayToBuffer Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (InArray != nullptr)
		*InArray = std::move(Parms.InArray);

	return Parms.ReturnValue;
}


// Function KuroUtility.KuroStaticLibrary.Base64Decode
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// class FString                           inString                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UKuroStaticLibrary::Base64Decode(const class FString& inString)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticLibrary", "Base64Decode");

	Params::KuroStaticLibrary_Base64Decode Parms{};

	Parms.inString = std::move(inString);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroUtility.KuroStaticLibrary.Base64Encode
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// class FString                           inString                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UKuroStaticLibrary::Base64Encode(const class FString& inString)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticLibrary", "Base64Encode");

	Params::KuroStaticLibrary_Base64Encode Parms{};

	Parms.inString = std::move(inString);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroUtility.KuroStaticLibrary.Base64EncodeWithConvertToUTF8
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// class FString                           inString                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UKuroStaticLibrary::Base64EncodeWithConvertToUTF8(const class FString& inString)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticLibrary", "Base64EncodeWithConvertToUTF8");

	Params::KuroStaticLibrary_Base64EncodeWithConvertToUTF8 Parms{};

	Parms.inString = std::move(inString);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroUtility.KuroStaticLibrary.Base64EncodeWithSpecifyChar
// (Final, Native, Static, Private, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<uint8>                           ByteArray                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// class FString                           SpecifyChar                                            (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UKuroStaticLibrary::Base64EncodeWithSpecifyChar(const TArray<uint8>& ByteArray, const class FString& SpecifyChar)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticLibrary", "Base64EncodeWithSpecifyChar");

	Params::KuroStaticLibrary_Base64EncodeWithSpecifyChar Parms{};

	Parms.ByteArray = std::move(ByteArray);
	Parms.SpecifyChar = std::move(SpecifyChar);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroUtility.KuroStaticLibrary.Base64EncodeWithSpecifyCharWithConvertToUTF8
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// class FString                           inString                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           SpecifyChar                                            (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UKuroStaticLibrary::Base64EncodeWithSpecifyCharWithConvertToUTF8(const class FString& inString, const class FString& SpecifyChar)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticLibrary", "Base64EncodeWithSpecifyCharWithConvertToUTF8");

	Params::KuroStaticLibrary_Base64EncodeWithSpecifyCharWithConvertToUTF8 Parms{};

	Parms.inString = std::move(inString);
	Parms.SpecifyChar = std::move(SpecifyChar);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroUtility.KuroStaticLibrary.BindCustomGetTimeBetweenGarbageCollectionPassesDelegate
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TDelegate<void(float MBFree, float ExtraDevelopmentMemorySize, int32 NumObjects)>Delegate                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void UKuroStaticLibrary::BindCustomGetTimeBetweenGarbageCollectionPassesDelegate(const TDelegate<void(float MBFree, float ExtraDevelopmentMemorySize, int32 NumObjects)>& Delegate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticLibrary", "BindCustomGetTimeBetweenGarbageCollectionPassesDelegate");

	Params::KuroStaticLibrary_BindCustomGetTimeBetweenGarbageCollectionPassesDelegate Parms{};

	Parms.Delegate = Delegate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroUtility.KuroStaticLibrary.BindDeviceLangChangeDelegate
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TDelegate<void()>                       Delegate                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void UKuroStaticLibrary::BindDeviceLangChangeDelegate(const TDelegate<void()>& Delegate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticLibrary", "BindDeviceLangChangeDelegate");

	Params::KuroStaticLibrary_BindDeviceLangChangeDelegate Parms{};

	Parms.Delegate = Delegate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroUtility.KuroStaticLibrary.ClearCustomGetTimeBetweenGarbageCollectionPassesDelegate
// (Final, Native, Static, Public, BlueprintCallable)

void UKuroStaticLibrary::ClearCustomGetTimeBetweenGarbageCollectionPassesDelegate()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticLibrary", "ClearCustomGetTimeBetweenGarbageCollectionPassesDelegate");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function KuroUtility.KuroStaticLibrary.ClearPlayerInputCache
// (Final, Native, Static, Private, HasOutParams, BlueprintCallable)
// Parameters:
// class APlayerController*                PC                                                     (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKuroStaticLibrary::ClearPlayerInputCache(class APlayerController** PC)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticLibrary", "ClearPlayerInputCache");

	Params::KuroStaticLibrary_ClearPlayerInputCache Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (PC != nullptr)
		*PC = Parms.PC;
}


// Function KuroUtility.KuroStaticLibrary.ConvertToObjectType
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// ECollisionChannel                       InCollisionChannel                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EObjectTypeQuery                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EObjectTypeQuery UKuroStaticLibrary::ConvertToObjectType(const ECollisionChannel InCollisionChannel)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticLibrary", "ConvertToObjectType");

	Params::KuroStaticLibrary_ConvertToObjectType Parms{};

	Parms.InCollisionChannel = InCollisionChannel;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroUtility.KuroStaticLibrary.ConvertToTraceType
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// ECollisionChannel                       InCollisionChannel                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ETraceTypeQuery                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ETraceTypeQuery UKuroStaticLibrary::ConvertToTraceType(const ECollisionChannel InCollisionChannel)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticLibrary", "ConvertToTraceType");

	Params::KuroStaticLibrary_ConvertToTraceType Parms{};

	Parms.InCollisionChannel = InCollisionChannel;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroUtility.KuroStaticLibrary.CopyFile
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           SourcePath                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           DstPath                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKuroStaticLibrary::CopyFile(const class FString& SourcePath, const class FString& DstPath)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticLibrary", "CopyFile");

	Params::KuroStaticLibrary_CopyFile Parms{};

	Parms.SourcePath = std::move(SourcePath);
	Parms.DstPath = std::move(DstPath);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroUtility.KuroStaticLibrary.D_GetFirstLocationFromSeqTrack
// (Final, Native, Static, Private, HasDefaults, BlueprintCallable)
// Parameters:
// class UMovieScene3DTransformTrack*      TransformTrack                                         (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVectorDouble                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVectorDouble UKuroStaticLibrary::D_GetFirstLocationFromSeqTrack(class UMovieScene3DTransformTrack* TransformTrack)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticLibrary", "D_GetFirstLocationFromSeqTrack");

	Params::KuroStaticLibrary_D_GetFirstLocationFromSeqTrack Parms{};

	Parms.TransformTrack = TransformTrack;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroUtility.KuroStaticLibrary.DeleteFile
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// class FString                           Path                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bRequireExists                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bEvenReadOnly                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bQuiet                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKuroStaticLibrary::DeleteFile(const class FString& Path, const bool bRequireExists, const bool bEvenReadOnly, const bool bQuiet)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticLibrary", "DeleteFile");

	Params::KuroStaticLibrary_DeleteFile Parms{};

	Parms.Path = std::move(Path);
	Parms.bRequireExists = bRequireExists;
	Parms.bEvenReadOnly = bEvenReadOnly;
	Parms.bQuiet = bQuiet;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroUtility.KuroStaticLibrary.DeleteFolder
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// class FString                           Path                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bRequireExists                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bTree                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKuroStaticLibrary::DeleteFolder(const class FString& Path, const bool bRequireExists, const bool bTree)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticLibrary", "DeleteFolder");

	Params::KuroStaticLibrary_DeleteFolder Parms{};

	Parms.Path = std::move(Path);
	Parms.bRequireExists = bRequireExists;
	Parms.bTree = bTree;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroUtility.KuroStaticLibrary.DestroyObject
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// class UObject*                          Object                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKuroStaticLibrary::DestroyObject(class UObject* Object)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticLibrary", "DestroyObject");

	Params::KuroStaticLibrary_DestroyObject Parms{};

	Parms.Object = Object;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroUtility.KuroStaticLibrary.DirectoryExists
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// class FString                           Path                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKuroStaticLibrary::DirectoryExists(const class FString& Path)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticLibrary", "DirectoryExists");

	Params::KuroStaticLibrary_DirectoryExists Parms{};

	Parms.Path = std::move(Path);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroUtility.KuroStaticLibrary.DoGameViewPortMouseEnter
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UGameViewportClient*              InViewport                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   x                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   y                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKuroStaticLibrary::DoGameViewPortMouseEnter(class UGameViewportClient* InViewport, int32 x, int32 y)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticLibrary", "DoGameViewPortMouseEnter");

	Params::KuroStaticLibrary_DoGameViewPortMouseEnter Parms{};

	Parms.InViewport = InViewport;
	Parms.x = x;
	Parms.y = y;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroUtility.KuroStaticLibrary.EncompassesPoint
// (Final, Native, Static, Private, HasDefaults, BlueprintCallable)
// Parameters:
// class AVolume*                          Volume                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Point                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   SphereRadius                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKuroStaticLibrary::EncompassesPoint(class AVolume* Volume, const struct FVector& Point, float SphereRadius)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticLibrary", "EncompassesPoint");

	Params::KuroStaticLibrary_EncompassesPoint Parms{};

	Parms.Volume = Volume;
	Parms.Point = std::move(Point);
	Parms.SphereRadius = SphereRadius;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroUtility.KuroStaticLibrary.ExecProcess
// (Final, Native, Static, Private, HasOutParams, BlueprintCallable)
// Parameters:
// class FString                           URL                                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           Params_0                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnCode                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           OutStd                                                 (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           OutErr                                                 (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKuroStaticLibrary::ExecProcess(const class FString& URL, const class FString& Params_0, int32* ReturnCode, class FString* OutStd, class FString* OutErr)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticLibrary", "ExecProcess");

	Params::KuroStaticLibrary_ExecProcess Parms{};

	Parms.URL = std::move(URL);
	Parms.Params_0 = std::move(Params_0);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (ReturnCode != nullptr)
		*ReturnCode = Parms.ReturnCode;

	if (OutStd != nullptr)
		*OutStd = std::move(Parms.OutStd);

	if (OutErr != nullptr)
		*OutErr = std::move(Parms.OutErr);

	return Parms.ReturnValue;
}


// Function KuroUtility.KuroStaticLibrary.ExecuteFunctionByName
// (Final, Native, Static, Private, HasOutParams, BlueprintCallable)
// Parameters:
// class UObject*                          Object                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           FunctionName                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           Result                                                 (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKuroStaticLibrary::ExecuteFunctionByName(class UObject* Object, const class FString& FunctionName, class FString* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticLibrary", "ExecuteFunctionByName");

	Params::KuroStaticLibrary_ExecuteFunctionByName Parms{};

	Parms.Object = Object;
	Parms.FunctionName = std::move(FunctionName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Result != nullptr)
		*Result = std::move(Parms.Result);

	return Parms.ReturnValue;
}


// Function KuroUtility.KuroStaticLibrary.ExitGame
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    force                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKuroStaticLibrary::ExitGame(bool force)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticLibrary", "ExitGame");

	Params::KuroStaticLibrary_ExitGame Parms{};

	Parms.force = force;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroUtility.KuroStaticLibrary.FileExists
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// class FString                           Path                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKuroStaticLibrary::FileExists(const class FString& Path)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticLibrary", "FileExists");

	Params::KuroStaticLibrary_FileExists Parms{};

	Parms.Path = std::move(Path);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroUtility.KuroStaticLibrary.FindFilesSorted
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// class FString                           Path                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           Extension                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class FString>                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class FString> UKuroStaticLibrary::FindFilesSorted(const class FString& Path, const class FString& Extension)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticLibrary", "FindFilesSorted");

	Params::KuroStaticLibrary_FindFilesSorted Parms{};

	Parms.Path = std::move(Path);
	Parms.Extension = std::move(Extension);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroUtility.KuroStaticLibrary.ForceGarbageCollection
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// bool                                    bFullPurge                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKuroStaticLibrary::ForceGarbageCollection(bool bFullPurge)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticLibrary", "ForceGarbageCollection");

	Params::KuroStaticLibrary_ForceGarbageCollection Parms{};

	Parms.bFullPurge = bFullPurge;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroUtility.KuroStaticLibrary.FromUnixTimestamp
// (Final, Native, Static, Private, HasDefaults, BlueprintCallable)
// Parameters:
// int32                                   Timestamp                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FDateTime                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FDateTime UKuroStaticLibrary::FromUnixTimestamp(const int32 Timestamp)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticLibrary", "FromUnixTimestamp");

	Params::KuroStaticLibrary_FromUnixTimestamp Parms{};

	Parms.Timestamp = Timestamp;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroUtility.KuroStaticLibrary.GetActorOfClassOnLevelInstance
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class AActor>               ActorClass                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ALevelInstance*                   LevelInstance                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* UKuroStaticLibrary::GetActorOfClassOnLevelInstance(const TSubclassOf<class AActor> ActorClass, const class ALevelInstance* LevelInstance)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticLibrary", "GetActorOfClassOnLevelInstance");

	Params::KuroStaticLibrary_GetActorOfClassOnLevelInstance Parms{};

	Parms.ActorClass = ActorClass;
	Parms.LevelInstance = LevelInstance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroUtility.KuroStaticLibrary.GetActorsOnLevelInstance
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class ALevelInstance*                   LevelInstance                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class AActor*>                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class AActor*> UKuroStaticLibrary::GetActorsOnLevelInstance(const class ALevelInstance* LevelInstance)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticLibrary", "GetActorsOnLevelInstance");

	Params::KuroStaticLibrary_GetActorsOnLevelInstance Parms{};

	Parms.LevelInstance = LevelInstance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroUtility.KuroStaticLibrary.GetAnimAssets
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UAnimBlueprint*                   InAnimBlueprint                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSet<class UAnimationAsset*>            OutAnimationAssets                                     (Parm, OutParm, NativeAccessSpecifierPublic)

void UKuroStaticLibrary::GetAnimAssets(const class UAnimBlueprint* InAnimBlueprint, TSet<class UAnimationAsset*>* OutAnimationAssets)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticLibrary", "GetAnimAssets");

	Params::KuroStaticLibrary_GetAnimAssets Parms{};

	Parms.InAnimBlueprint = InAnimBlueprint;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutAnimationAssets != nullptr)
		*OutAnimationAssets = std::move(Parms.OutAnimationAssets);
}


// Function KuroUtility.KuroStaticLibrary.GetAnimAssetsByAnimBlueprintClass
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TSubclassOf<class UAnimInstance>        InAnimClass                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSet<class UAnimationAsset*>            OutAnimationAssets                                     (Parm, OutParm, NativeAccessSpecifierPublic)

void UKuroStaticLibrary::GetAnimAssetsByAnimBlueprintClass(const TSubclassOf<class UAnimInstance>& InAnimClass, TSet<class UAnimationAsset*>* OutAnimationAssets)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticLibrary", "GetAnimAssetsByAnimBlueprintClass");

	Params::KuroStaticLibrary_GetAnimAssetsByAnimBlueprintClass Parms{};

	Parms.InAnimClass = InAnimClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutAnimationAssets != nullptr)
		*OutAnimationAssets = std::move(Parms.OutAnimationAssets);
}


// Function KuroUtility.KuroStaticLibrary.GetAnimAssetsByAnimInstance
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UAnimInstance*                    InAnimInstance                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSet<class UAnimationAsset*>            OutAnimationAssets                                     (Parm, OutParm, NativeAccessSpecifierPublic)

void UKuroStaticLibrary::GetAnimAssetsByAnimInstance(const class UAnimInstance* InAnimInstance, TSet<class UAnimationAsset*>* OutAnimationAssets)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticLibrary", "GetAnimAssetsByAnimInstance");

	Params::KuroStaticLibrary_GetAnimAssetsByAnimInstance Parms{};

	Parms.InAnimInstance = InAnimInstance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutAnimationAssets != nullptr)
		*OutAnimationAssets = std::move(Parms.OutAnimationAssets);
}


// Function KuroUtility.KuroStaticLibrary.GetAnimMontageNotifies
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class UAnimMontage*                     AnimMontage                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FAnimNotifyEvent>         OutNotifies                                            (Parm, OutParm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UKuroStaticLibrary::GetAnimMontageNotifies(const class UAnimMontage* AnimMontage, TArray<struct FAnimNotifyEvent>* OutNotifies)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticLibrary", "GetAnimMontageNotifies");

	Params::KuroStaticLibrary_GetAnimMontageNotifies Parms{};

	Parms.AnimMontage = AnimMontage;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutNotifies != nullptr)
		*OutNotifies = std::move(Parms.OutNotifies);
}


// Function KuroUtility.KuroStaticLibrary.GetAnimSequenceNotifies
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class UAnimSequenceBase*                AnimSequence                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FAnimNotifyEvent>         OutNotifies                                            (Parm, OutParm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UKuroStaticLibrary::GetAnimSequenceNotifies(const class UAnimSequenceBase* AnimSequence, TArray<struct FAnimNotifyEvent>* OutNotifies)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticLibrary", "GetAnimSequenceNotifies");

	Params::KuroStaticLibrary_GetAnimSequenceNotifies Parms{};

	Parms.AnimSequence = AnimSequence;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutNotifies != nullptr)
		*OutNotifies = std::move(Parms.OutNotifies);
}


// Function KuroUtility.KuroStaticLibrary.GetAnimSequencesByAnimMontage
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UAnimMontage*                     AnimMontage                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class UAnimSequenceBase*>        OutAnimSequences                                       (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UKuroStaticLibrary::GetAnimSequencesByAnimMontage(const class UAnimMontage* AnimMontage, TArray<class UAnimSequenceBase*>* OutAnimSequences)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticLibrary", "GetAnimSequencesByAnimMontage");

	Params::KuroStaticLibrary_GetAnimSequencesByAnimMontage Parms{};

	Parms.AnimMontage = AnimMontage;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutAnimSequences != nullptr)
		*OutAnimSequences = std::move(Parms.OutAnimSequences);
}


// Function KuroUtility.KuroStaticLibrary.GetBaseBoardInfo
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UKuroStaticLibrary::GetBaseBoardInfo()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticLibrary", "GetBaseBoardInfo");

	Params::KuroStaticLibrary_GetBaseBoardInfo Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroUtility.KuroStaticLibrary.GetBatteryLevel
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UKuroStaticLibrary::GetBatteryLevel()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticLibrary", "GetBatteryLevel");

	Params::KuroStaticLibrary_GetBatteryLevel Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroUtility.KuroStaticLibrary.GetBlueprintCallstack
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UKuroStaticLibrary::GetBlueprintCallstack()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticLibrary", "GetBlueprintCallstack");

	Params::KuroStaticLibrary_GetBlueprintCallstack Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroUtility.KuroStaticLibrary.GetCameraShakeInfo
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TSubclassOf<class UCameraShakeBase>     CameraShakeClass                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FCameraShakeInfo                 OutInfo                                                (Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKuroStaticLibrary::GetCameraShakeInfo(TSubclassOf<class UCameraShakeBase> CameraShakeClass, struct FCameraShakeInfo* OutInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticLibrary", "GetCameraShakeInfo");

	Params::KuroStaticLibrary_GetCameraShakeInfo Parms{};

	Parms.CameraShakeClass = CameraShakeClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutInfo != nullptr)
		*OutInfo = std::move(Parms.OutInfo);

	return Parms.ReturnValue;
}


// Function KuroUtility.KuroStaticLibrary.GetCharacterAnimClass
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TSubclassOf<class AActor>               InActorClass                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class UAnimInstance>        OutAnimClass                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKuroStaticLibrary::GetCharacterAnimClass(const TSubclassOf<class AActor>& InActorClass, TSubclassOf<class UAnimInstance>* OutAnimClass)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticLibrary", "GetCharacterAnimClass");

	Params::KuroStaticLibrary_GetCharacterAnimClass Parms{};

	Parms.InActorClass = InActorClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutAnimClass != nullptr)
		*OutAnimClass = Parms.OutAnimClass;
}


// Function KuroUtility.KuroStaticLibrary.GetCreatureGenDirectoryByMap
// (Final, Native, Static, Private, HasOutParams, BlueprintCallable)
// Parameters:
// class FString                           Path                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   MapID                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Exist                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           Directory                                              (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKuroStaticLibrary::GetCreatureGenDirectoryByMap(const class FString& Path, const int32 MapID, bool* Exist, class FString* Directory)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticLibrary", "GetCreatureGenDirectoryByMap");

	Params::KuroStaticLibrary_GetCreatureGenDirectoryByMap Parms{};

	Parms.Path = std::move(Path);
	Parms.MapID = MapID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Exist != nullptr)
		*Exist = Parms.Exist;

	if (Directory != nullptr)
		*Directory = std::move(Parms.Directory);
}


// Function KuroUtility.KuroStaticLibrary.GetCultureRegion
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UKuroStaticLibrary::GetCultureRegion()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticLibrary", "GetCultureRegion");

	Params::KuroStaticLibrary_GetCultureRegion Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroUtility.KuroStaticLibrary.GetCurCPUFrequency
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKuroStaticLibrary::GetCurCPUFrequency()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticLibrary", "GetCurCPUFrequency");

	Params::KuroStaticLibrary_GetCurCPUFrequency Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroUtility.KuroStaticLibrary.GetDefaultObject
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UClass*                           Class_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UObject* UKuroStaticLibrary::GetDefaultObject(class UClass* Class_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticLibrary", "GetDefaultObject");

	Params::KuroStaticLibrary_GetDefaultObject Parms{};

	Parms.Class_0 = Class_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroUtility.KuroStaticLibrary.GetDeviceCPU
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UKuroStaticLibrary::GetDeviceCPU()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticLibrary", "GetDeviceCPU");

	Params::KuroStaticLibrary_GetDeviceCPU Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroUtility.KuroStaticLibrary.GetDirectories
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// class FString                           Path                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class FString>                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class FString> UKuroStaticLibrary::GetDirectories(const class FString& Path)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticLibrary", "GetDirectories");

	Params::KuroStaticLibrary_GetDirectories Parms{};

	Parms.Path = std::move(Path);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroUtility.KuroStaticLibrary.GetDiskSerialNo
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UKuroStaticLibrary::GetDiskSerialNo()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticLibrary", "GetDiskSerialNo");

	Params::KuroStaticLibrary_GetDiskSerialNo Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroUtility.KuroStaticLibrary.GetFiles
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// class FString                           Path                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           Extension                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class FString>                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class FString> UKuroStaticLibrary::GetFiles(const class FString& Path, const class FString& Extension)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticLibrary", "GetFiles");

	Params::KuroStaticLibrary_GetFiles Parms{};

	Parms.Path = std::move(Path);
	Parms.Extension = std::move(Extension);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroUtility.KuroStaticLibrary.GetFilesRecursive
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// class FString                           Path                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           Filter                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Files                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Directories                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class FString>                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class FString> UKuroStaticLibrary::GetFilesRecursive(const class FString& Path, const class FString& Filter, bool Files, bool Directories)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticLibrary", "GetFilesRecursive");

	Params::KuroStaticLibrary_GetFilesRecursive Parms{};

	Parms.Path = std::move(Path);
	Parms.Filter = std::move(Filter);
	Parms.Files = Files;
	Parms.Directories = Directories;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroUtility.KuroStaticLibrary.GetFirstLocationFromSeqTrack
// (Final, Native, Static, Private, HasDefaults, BlueprintCallable)
// Parameters:
// class UMovieScene3DTransformTrack*      TransformTrack                                         (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UKuroStaticLibrary::GetFirstLocationFromSeqTrack(class UMovieScene3DTransformTrack* TransformTrack)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticLibrary", "GetFirstLocationFromSeqTrack");

	Params::KuroStaticLibrary_GetFirstLocationFromSeqTrack Parms{};

	Parms.TransformTrack = TransformTrack;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroUtility.KuroStaticLibrary.GetGameViewPort
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UGameViewportClient*              ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UGameViewportClient* UKuroStaticLibrary::GetGameViewPort()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticLibrary", "GetGameViewPort");

	Params::KuroStaticLibrary_GetGameViewPort Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroUtility.KuroStaticLibrary.GetGPUInfo
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UKuroStaticLibrary::GetGPUInfo()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticLibrary", "GetGPUInfo");

	Params::KuroStaticLibrary_GetGPUInfo Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroUtility.KuroStaticLibrary.GetLevelPath
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UKuroStaticLibrary::GetLevelPath(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticLibrary", "GetLevelPath");

	Params::KuroStaticLibrary_GetLevelPath Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroUtility.KuroStaticLibrary.GetLevelPrefabShowActor
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* UKuroStaticLibrary::GetLevelPrefabShowActor(class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticLibrary", "GetLevelPrefabShowActor");

	Params::KuroStaticLibrary_GetLevelPrefabShowActor Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroUtility.KuroStaticLibrary.GetLocalHostAddresses
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<class FString>                   OutAddresses                                           (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// bool                                    bAppendPort                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKuroStaticLibrary::GetLocalHostAddresses(TArray<class FString>* OutAddresses, const bool bAppendPort)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticLibrary", "GetLocalHostAddresses");

	Params::KuroStaticLibrary_GetLocalHostAddresses Parms{};

	Parms.bAppendPort = bAppendPort;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutAddresses != nullptr)
		*OutAddresses = std::move(Parms.OutAddresses);
}


// Function KuroUtility.KuroStaticLibrary.GetMacAddress
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UKuroStaticLibrary::GetMacAddress()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticLibrary", "GetMacAddress");

	Params::KuroStaticLibrary_GetMacAddress Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroUtility.KuroStaticLibrary.GetNavPointData
// (Final, Native, Static, Private, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   XNumber                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   YNumber                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Dis                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ANavigationData*                  NavData                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Point                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          QueryExtent                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class UNavigationQueryFilter>FilterClass                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FVector>                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FVector> UKuroStaticLibrary::GetNavPointData(class UObject* WorldContextObject, int32 XNumber, int32 YNumber, int32 Dis, class ANavigationData* NavData, const struct FVector& Point, const struct FVector& QueryExtent, TSubclassOf<class UNavigationQueryFilter> FilterClass)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticLibrary", "GetNavPointData");

	Params::KuroStaticLibrary_GetNavPointData Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.XNumber = XNumber;
	Parms.YNumber = YNumber;
	Parms.Dis = Dis;
	Parms.NavData = NavData;
	Parms.Point = std::move(Point);
	Parms.QueryExtent = std::move(QueryExtent);
	Parms.FilterClass = FilterClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroUtility.KuroStaticLibrary.GetPIEStartTimeInSeconds
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKuroStaticLibrary::GetPIEStartTimeInSeconds()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticLibrary", "GetPIEStartTimeInSeconds");

	Params::KuroStaticLibrary_GetPIEStartTimeInSeconds Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroUtility.KuroStaticLibrary.GetPlatformTimeInSeconds
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKuroStaticLibrary::GetPlatformTimeInSeconds()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticLibrary", "GetPlatformTimeInSeconds");

	Params::KuroStaticLibrary_GetPlatformTimeInSeconds Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroUtility.KuroStaticLibrary.GetProcessorId
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UKuroStaticLibrary::GetProcessorId()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticLibrary", "GetProcessorId");

	Params::KuroStaticLibrary_GetProcessorId Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroUtility.KuroStaticLibrary.GetSequenceTracksForObjectBindingID
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// class ALevelSequenceActor*              Actor                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             TagName                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class UMovieSceneTrack*>         ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

TArray<class UMovieSceneTrack*> UKuroStaticLibrary::GetSequenceTracksForObjectBindingID(const class ALevelSequenceActor* Actor, class FName TagName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticLibrary", "GetSequenceTracksForObjectBindingID");

	Params::KuroStaticLibrary_GetSequenceTracksForObjectBindingID Parms{};

	Parms.Actor = Actor;
	Parms.TagName = TagName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroUtility.KuroStaticLibrary.GetSlateApplicationCursorPos
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector2D                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector2D UKuroStaticLibrary::GetSlateApplicationCursorPos()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticLibrary", "GetSlateApplicationCursorPos");

	Params::KuroStaticLibrary_GetSlateApplicationCursorPos Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroUtility.KuroStaticLibrary.GetSlotNamesByAnimMontage
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UAnimMontage*                     AnimMontage                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class FName>                     OutSlotNames                                           (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UKuroStaticLibrary::GetSlotNamesByAnimMontage(const class UAnimMontage* AnimMontage, TArray<class FName>* OutSlotNames)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticLibrary", "GetSlotNamesByAnimMontage");

	Params::KuroStaticLibrary_GetSlotNamesByAnimMontage Parms{};

	Parms.AnimMontage = AnimMontage;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutSlotNames != nullptr)
		*OutSlotNames = std::move(Parms.OutSlotNames);
}


// Function KuroUtility.KuroStaticLibrary.GetSplineRotationAtSplinePoint
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class USplineComponent*                 Spline                                                 (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   PointIndex                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ESplineCoordinateSpace                  CoordinateSpace                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FRotator UKuroStaticLibrary::GetSplineRotationAtSplinePoint(class USplineComponent* Spline, int32 PointIndex, ESplineCoordinateSpace CoordinateSpace)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticLibrary", "GetSplineRotationAtSplinePoint");

	Params::KuroStaticLibrary_GetSplineRotationAtSplinePoint Parms{};

	Parms.Spline = Spline;
	Parms.PointIndex = PointIndex;
	Parms.CoordinateSpace = CoordinateSpace;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroUtility.KuroStaticLibrary.GetStatUnitInfo
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UKuroStaticLibrary::GetStatUnitInfo()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticLibrary", "GetStatUnitInfo");

	Params::KuroStaticLibrary_GetStatUnitInfo Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroUtility.KuroStaticLibrary.GetSysUUID
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UKuroStaticLibrary::GetSysUUID()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticLibrary", "GetSysUUID");

	Params::KuroStaticLibrary_GetSysUUID Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroUtility.KuroStaticLibrary.GetTotalPhysicalMemory
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int64                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int64 UKuroStaticLibrary::GetTotalPhysicalMemory()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticLibrary", "GetTotalPhysicalMemory");

	Params::KuroStaticLibrary_GetTotalPhysicalMemory Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroUtility.KuroStaticLibrary.GetTrackByClass
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// TArray<class UMovieSceneTrack*>         Tracks                                                 (Parm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// TSubclassOf<class UMovieSceneTrack>     Class_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UMovieSceneTrack*                 ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UMovieSceneTrack* UKuroStaticLibrary::GetTrackByClass(const TArray<class UMovieSceneTrack*>& Tracks, TSubclassOf<class UMovieSceneTrack> Class_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticLibrary", "GetTrackByClass");

	Params::KuroStaticLibrary_GetTrackByClass Parms{};

	Parms.Tracks = std::move(Tracks);
	Parms.Class_0 = Class_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroUtility.KuroStaticLibrary.GetVendorInfo
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UKuroStaticLibrary::GetVendorInfo()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticLibrary", "GetVendorInfo");

	Params::KuroStaticLibrary_GetVendorInfo Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroUtility.KuroStaticLibrary.GetViewPortMousePosition
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector2D                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector2D UKuroStaticLibrary::GetViewPortMousePosition()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticLibrary", "GetViewPortMousePosition");

	Params::KuroStaticLibrary_GetViewPortMousePosition Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroUtility.KuroStaticLibrary.HashStringWithSHA1
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// class FString                           inString                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UKuroStaticLibrary::HashStringWithSHA1(const class FString& inString)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticLibrary", "HashStringWithSHA1");

	Params::KuroStaticLibrary_HashStringWithSHA1 Parms{};

	Parms.inString = std::move(inString);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroUtility.KuroStaticLibrary.IcmpPing
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FString                           IpAddress                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Timeout                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TDelegate<void(const class FString& Address, float Time, int32 responseState)>InDelegate                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void UKuroStaticLibrary::IcmpPing(const class FString& IpAddress, float Timeout, const TDelegate<void(const class FString& Address, float Time, int32 responseState)>& InDelegate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticLibrary", "IcmpPing");

	Params::KuroStaticLibrary_IcmpPing Parms{};

	Parms.IpAddress = std::move(IpAddress);
	Parms.Timeout = Timeout;
	Parms.InDelegate = InDelegate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroUtility.KuroStaticLibrary.IsEditor
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKuroStaticLibrary::IsEditor(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticLibrary", "IsEditor");

	Params::KuroStaticLibrary_IsEditor Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroUtility.KuroStaticLibrary.IsForegroundWindow
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKuroStaticLibrary::IsForegroundWindow()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticLibrary", "IsForegroundWindow");

	Params::KuroStaticLibrary_IsForegroundWindow Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroUtility.KuroStaticLibrary.IsImplementInterface
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// class UClass*                           InClass                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UClass*                           InInterfaceClass                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKuroStaticLibrary::IsImplementInterface(class UClass* InClass, class UClass* InInterfaceClass)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticLibrary", "IsImplementInterface");

	Params::KuroStaticLibrary_IsImplementInterface Parms{};

	Parms.InClass = InClass;
	Parms.InInterfaceClass = InInterfaceClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroUtility.KuroStaticLibrary.IsLowMemoryDevice
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKuroStaticLibrary::IsLowMemoryDevice()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticLibrary", "IsLowMemoryDevice");

	Params::KuroStaticLibrary_IsLowMemoryDevice Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroUtility.KuroStaticLibrary.IsModuleLoaded
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           ModelName                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKuroStaticLibrary::IsModuleLoaded(const class FString& ModelName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticLibrary", "IsModuleLoaded");

	Params::KuroStaticLibrary_IsModuleLoaded Parms{};

	Parms.ModelName = std::move(ModelName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroUtility.KuroStaticLibrary.IsMontageContainGivenAnimNotify
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UAnimMontage*                     AnimMontage                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSet<class FString>                     CheckClassNames                                        (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKuroStaticLibrary::IsMontageContainGivenAnimNotify(const class UAnimMontage* AnimMontage, const TSet<class FString>& CheckClassNames)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticLibrary", "IsMontageContainGivenAnimNotify");

	Params::KuroStaticLibrary_IsMontageContainGivenAnimNotify Parms{};

	Parms.AnimMontage = AnimMontage;
	Parms.CheckClassNames = std::move(CheckClassNames);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroUtility.KuroStaticLibrary.IsObjectClassByName
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          Object                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ClassName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKuroStaticLibrary::IsObjectClassByName(class UObject* Object, class FName ClassName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticLibrary", "IsObjectClassByName");

	Params::KuroStaticLibrary_IsObjectClassByName Parms{};

	Parms.Object = Object;
	Parms.ClassName = ClassName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroUtility.KuroStaticLibrary.IsViewportFocus
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKuroStaticLibrary::IsViewportFocus()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticLibrary", "IsViewportFocus");

	Params::KuroStaticLibrary_IsViewportFocus Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroUtility.KuroStaticLibrary.IsWithEditor
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKuroStaticLibrary::IsWithEditor()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticLibrary", "IsWithEditor");

	Params::KuroStaticLibrary_IsWithEditor Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroUtility.KuroStaticLibrary.IsWorldTearingDown
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UWorld*                           World                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKuroStaticLibrary::IsWorldTearingDown(const class UWorld* World)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticLibrary", "IsWorldTearingDown");

	Params::KuroStaticLibrary_IsWorldTearingDown Parms{};

	Parms.World = World;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroUtility.KuroStaticLibrary.KuroEnableCustomAffinity
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKuroStaticLibrary::KuroEnableCustomAffinity()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticLibrary", "KuroEnableCustomAffinity");

	Params::KuroStaticLibrary_KuroEnableCustomAffinity Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroUtility.KuroStaticLibrary.KuroFormatText
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// class FString                           Format                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class FString>                   Parameters                                             (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UKuroStaticLibrary::KuroFormatText(const class FString& Format, const TArray<class FString>& Parameters)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticLibrary", "KuroFormatText");

	Params::KuroStaticLibrary_KuroFormatText Parms{};

	Parms.Format = std::move(Format);
	Parms.Parameters = std::move(Parameters);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroUtility.KuroStaticLibrary.LoadFilesRecursive
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// class FString                           Path                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           Filter                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Files                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Directories                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class FString>                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class FString> UKuroStaticLibrary::LoadFilesRecursive(const class FString& Path, const class FString& Filter, bool Files, bool Directories)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticLibrary", "LoadFilesRecursive");

	Params::KuroStaticLibrary_LoadFilesRecursive Parms{};

	Parms.Path = std::move(Path);
	Parms.Filter = std::move(Filter);
	Parms.Files = Files;
	Parms.Directories = Directories;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroUtility.KuroStaticLibrary.LoadFileToArray
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FString                           Path                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<uint8>                           OutArray                                               (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKuroStaticLibrary::LoadFileToArray(const class FString& Path, TArray<uint8>* OutArray)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticLibrary", "LoadFileToArray");

	Params::KuroStaticLibrary_LoadFileToArray Parms{};

	Parms.Path = std::move(Path);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutArray != nullptr)
		*OutArray = std::move(Parms.OutArray);

	return Parms.ReturnValue;
}


// Function KuroUtility.KuroStaticLibrary.LoadFileToString
// (Final, Native, Static, Private, HasOutParams, BlueprintCallable)
// Parameters:
// class FString                           Result                                                 (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           Filename                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKuroStaticLibrary::LoadFileToString(class FString* Result, const class FString& Filename)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticLibrary", "LoadFileToString");

	Params::KuroStaticLibrary_LoadFileToString Parms{};

	Parms.Filename = std::move(Filename);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Result != nullptr)
		*Result = std::move(Parms.Result);

	return Parms.ReturnValue;
}


// Function KuroUtility.KuroStaticLibrary.LoadFileToStringArray
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// class FString                           FileRevisionPath                                       (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class FString>                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class FString> UKuroStaticLibrary::LoadFileToStringArray(const class FString& FileRevisionPath)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticLibrary", "LoadFileToStringArray");

	Params::KuroStaticLibrary_LoadFileToStringArray Parms{};

	Parms.FileRevisionPath = std::move(FileRevisionPath);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroUtility.KuroStaticLibrary.MakeDirectory
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// class FString                           Path                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bTree                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKuroStaticLibrary::MakeDirectory(const class FString& Path, const bool bTree)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticLibrary", "MakeDirectory");

	Params::KuroStaticLibrary_MakeDirectory Parms{};

	Parms.Path = std::move(Path);
	Parms.bTree = bTree;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroUtility.KuroStaticLibrary.Md5HashAnsiString
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// class FString                           inString                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UKuroStaticLibrary::Md5HashAnsiString(const class FString& inString)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticLibrary", "Md5HashAnsiString");

	Params::KuroStaticLibrary_Md5HashAnsiString Parms{};

	Parms.inString = std::move(inString);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroUtility.KuroStaticLibrary.Md5HashUTF8String
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// class FString                           inString                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UKuroStaticLibrary::Md5HashUTF8String(const class FString& inString)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticLibrary", "Md5HashUTF8String");

	Params::KuroStaticLibrary_Md5HashUTF8String Parms{};

	Parms.inString = std::move(inString);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroUtility.KuroStaticLibrary.PerceptionConfigureSense
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UAIPerceptionComponent*           AIPerception                                           (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAISenseConfig*                   AISenseConfig                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKuroStaticLibrary::PerceptionConfigureSense(class UAIPerceptionComponent* AIPerception, class UAISenseConfig* AISenseConfig)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticLibrary", "PerceptionConfigureSense");

	Params::KuroStaticLibrary_PerceptionConfigureSense Parms{};

	Parms.AIPerception = AIPerception;
	Parms.AISenseConfig = AISenseConfig;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroUtility.KuroStaticLibrary.RegisterCustomCommandProcessor
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FString                           Category                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TDelegate<void(const class FString& Command)>Processor                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void UKuroStaticLibrary::RegisterCustomCommandProcessor(const class FString& Category, const TDelegate<void(const class FString& Command)>& Processor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticLibrary", "RegisterCustomCommandProcessor");

	Params::KuroStaticLibrary_RegisterCustomCommandProcessor Parms{};

	Parms.Category = std::move(Category);
	Parms.Processor = Processor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroUtility.KuroStaticLibrary.RemoveFromRoot
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          InObject                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKuroStaticLibrary::RemoveFromRoot(class UObject* InObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticLibrary", "RemoveFromRoot");

	Params::KuroStaticLibrary_RemoveFromRoot Parms{};

	Parms.InObject = InObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroUtility.KuroStaticLibrary.SaveBufferToFile
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FString                           Path                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FArrayBuffer                     InBuffer                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKuroStaticLibrary::SaveBufferToFile(const class FString& Path, const struct FArrayBuffer& InBuffer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticLibrary", "SaveBufferToFile");

	Params::KuroStaticLibrary_SaveBufferToFile Parms{};

	Parms.Path = std::move(Path);
	Parms.InBuffer = std::move(InBuffer);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroUtility.KuroStaticLibrary.SaveStringToFile
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// class FString                           SaveText                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           FileName                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bWithBom                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKuroStaticLibrary::SaveStringToFile(const class FString& SaveText, const class FString& FileName, const bool bWithBom)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticLibrary", "SaveStringToFile");

	Params::KuroStaticLibrary_SaveStringToFile Parms{};

	Parms.SaveText = std::move(SaveText);
	Parms.FileName = std::move(FileName);
	Parms.bWithBom = bWithBom;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroUtility.KuroStaticLibrary.SetActorModify
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKuroStaticLibrary::SetActorModify(class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticLibrary", "SetActorModify");

	Params::KuroStaticLibrary_SetActorModify Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroUtility.KuroStaticLibrary.SetActorPermanent
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIsPermanent                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bWithAllChildren                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKuroStaticLibrary::SetActorPermanent(class AActor* Actor, const bool bIsPermanent, const bool bWithAllChildren)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticLibrary", "SetActorPermanent");

	Params::KuroStaticLibrary_SetActorPermanent Parms{};

	Parms.Actor = Actor;
	Parms.bIsPermanent = bIsPermanent;
	Parms.bWithAllChildren = bWithAllChildren;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroUtility.KuroStaticLibrary.SetBaseAndSaveBaseLocation
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UCharacterMovementComponent*      CharacterMovementComp                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              NewBase                                                (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKuroStaticLibrary::SetBaseAndSaveBaseLocation(class UCharacterMovementComponent* CharacterMovementComp, class UPrimitiveComponent* NewBase)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticLibrary", "SetBaseAndSaveBaseLocation");

	Params::KuroStaticLibrary_SetBaseAndSaveBaseLocation Parms{};

	Parms.CharacterMovementComp = CharacterMovementComp;
	Parms.NewBase = NewBase;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroUtility.KuroStaticLibrary.SetCursorVisibility
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    visible                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKuroStaticLibrary::SetCursorVisibility(bool visible)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticLibrary", "SetCursorVisibility");

	Params::KuroStaticLibrary_SetCursorVisibility Parms{};

	Parms.visible = visible;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroUtility.KuroStaticLibrary.SetEditorWidgetSkipTick
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    bSkipTick                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKuroStaticLibrary::SetEditorWidgetSkipTick(bool bSkipTick)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticLibrary", "SetEditorWidgetSkipTick");

	Params::KuroStaticLibrary_SetEditorWidgetSkipTick Parms{};

	Parms.bSkipTick = bSkipTick;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroUtility.KuroStaticLibrary.SetGameThreadAffinity
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    bIsInFighting                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKuroStaticLibrary::SetGameThreadAffinity(bool bIsInFighting)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticLibrary", "SetGameThreadAffinity");

	Params::KuroStaticLibrary_SetGameThreadAffinity Parms{};

	Parms.bIsInFighting = bIsInFighting;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroUtility.KuroStaticLibrary.SetHangAssertFlag
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    bAssertFlag                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKuroStaticLibrary::SetHangAssertFlag(bool bAssertFlag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticLibrary", "SetHangAssertFlag");

	Params::KuroStaticLibrary_SetHangAssertFlag Parms{};

	Parms.bAssertFlag = bAssertFlag;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroUtility.KuroStaticLibrary.SetHangDuration
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// float                                   HangDuration                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKuroStaticLibrary::SetHangDuration(float HangDuration)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticLibrary", "SetHangDuration");

	Params::KuroStaticLibrary_SetHangDuration Parms{};

	Parms.HangDuration = HangDuration;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroUtility.KuroStaticLibrary.SetHttpThreadActiveMinimumSleepTimeInSeconds
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// float                                   InHttpThreadActiveMinimumSleepTimeInSeconds            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKuroStaticLibrary::SetHttpThreadActiveMinimumSleepTimeInSeconds(float InHttpThreadActiveMinimumSleepTimeInSeconds)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticLibrary", "SetHttpThreadActiveMinimumSleepTimeInSeconds");

	Params::KuroStaticLibrary_SetHttpThreadActiveMinimumSleepTimeInSeconds Parms{};

	Parms.InHttpThreadActiveMinimumSleepTimeInSeconds = InHttpThreadActiveMinimumSleepTimeInSeconds;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroUtility.KuroStaticLibrary.SetHttpThreadIdleMinimumSleepTimeInSeconds
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// float                                   InHttpThreadIdleMinimumSleepTimeInSeconds              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKuroStaticLibrary::SetHttpThreadIdleMinimumSleepTimeInSeconds(float InHttpThreadIdleMinimumSleepTimeInSeconds)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticLibrary", "SetHttpThreadIdleMinimumSleepTimeInSeconds");

	Params::KuroStaticLibrary_SetHttpThreadIdleMinimumSleepTimeInSeconds Parms{};

	Parms.InHttpThreadIdleMinimumSleepTimeInSeconds = InHttpThreadIdleMinimumSleepTimeInSeconds;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroUtility.KuroStaticLibrary.SetInputKeyDeadZone
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// class UObject*                          world                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   playerIndex                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FKey                             key                                                    (Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   deadZone                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKuroStaticLibrary::SetInputKeyDeadZone(class UObject* world, int32 playerIndex, const struct FKey& key, const float deadZone)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticLibrary", "SetInputKeyDeadZone");

	Params::KuroStaticLibrary_SetInputKeyDeadZone Parms{};

	Parms.world = world;
	Parms.playerIndex = playerIndex;
	Parms.key = std::move(key);
	Parms.deadZone = deadZone;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroUtility.KuroStaticLibrary.SetMontageANIndex
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UAnimMontage*                     AnimMontage                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKuroStaticLibrary::SetMontageANIndex(const class UAnimMontage* AnimMontage)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticLibrary", "SetMontageANIndex");

	Params::KuroStaticLibrary_SetMontageANIndex Parms{};

	Parms.AnimMontage = AnimMontage;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroUtility.KuroStaticLibrary.SetSplinePointsWithType
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class USplineComponent*                 Spline                                                 (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FVector>                  Points                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// ESplineCoordinateSpace                  CoordinateSpace                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ESplinePointType                        Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bUpdateSpline                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKuroStaticLibrary::SetSplinePointsWithType(class USplineComponent* Spline, const TArray<struct FVector>& Points, ESplineCoordinateSpace CoordinateSpace, ESplinePointType Type, bool bUpdateSpline)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticLibrary", "SetSplinePointsWithType");

	Params::KuroStaticLibrary_SetSplinePointsWithType Parms{};

	Parms.Spline = Spline;
	Parms.Points = std::move(Points);
	Parms.CoordinateSpace = CoordinateSpace;
	Parms.Type = Type;
	Parms.bUpdateSpline = bUpdateSpline;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroUtility.KuroStaticLibrary.SetStaticMeshVelocity
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// TArray<class AActor*>                   Actors                                                 (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// struct FVector                          NewVelocity                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKuroStaticLibrary::SetStaticMeshVelocity(const TArray<class AActor*>& Actors, const struct FVector& NewVelocity)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticLibrary", "SetStaticMeshVelocity");

	Params::KuroStaticLibrary_SetStaticMeshVelocity Parms{};

	Parms.Actors = std::move(Actors);
	Parms.NewVelocity = std::move(NewVelocity);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroUtility.KuroStaticLibrary.SetThreadAffinity
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           ThreadName                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   AffinityHigh                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   AffinityLow                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKuroStaticLibrary::SetThreadAffinity(const class FString& ThreadName, int32 AffinityHigh, int32 AffinityLow)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticLibrary", "SetThreadAffinity");

	Params::KuroStaticLibrary_SetThreadAffinity Parms{};

	Parms.ThreadName = std::move(ThreadName);
	Parms.AffinityHigh = AffinityHigh;
	Parms.AffinityLow = AffinityLow;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroUtility.KuroStaticLibrary.SetThreadPolicy
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           ThreadName                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Policy                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKuroStaticLibrary::SetThreadPolicy(const class FString& ThreadName, int32 Policy)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticLibrary", "SetThreadPolicy");

	Params::KuroStaticLibrary_SetThreadPolicy Parms{};

	Parms.ThreadName = std::move(ThreadName);
	Parms.Policy = Policy;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroUtility.KuroStaticLibrary.SetThreadPriority
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           ThreadName                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Priority                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKuroStaticLibrary::SetThreadPriority(const class FString& ThreadName, int32 Priority)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticLibrary", "SetThreadPriority");

	Params::KuroStaticLibrary_SetThreadPriority Parms{};

	Parms.ThreadName = std::move(ThreadName);
	Parms.Priority = Priority;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroUtility.KuroStaticLibrary.SetThreadPriorityAndPolicy
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           ThreadName                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Priority                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Policy                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKuroStaticLibrary::SetThreadPriorityAndPolicy(const class FString& ThreadName, int32 Priority, int32 Policy)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticLibrary", "SetThreadPriorityAndPolicy");

	Params::KuroStaticLibrary_SetThreadPriorityAndPolicy Parms{};

	Parms.ThreadName = std::move(ThreadName);
	Parms.Priority = Priority;
	Parms.Policy = Policy;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroUtility.KuroStaticLibrary.SetThreadPriorityAndPolicyAndAffinity
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           ThreadName                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Priority                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Policy                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   AffinityHigh                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   AffinityLow                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKuroStaticLibrary::SetThreadPriorityAndPolicyAndAffinity(const class FString& ThreadName, int32 Priority, int32 Policy, int32 AffinityHigh, int32 AffinityLow)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticLibrary", "SetThreadPriorityAndPolicyAndAffinity");

	Params::KuroStaticLibrary_SetThreadPriorityAndPolicyAndAffinity Parms{};

	Parms.ThreadName = std::move(ThreadName);
	Parms.Priority = Priority;
	Parms.Policy = Policy;
	Parms.AffinityHigh = AffinityHigh;
	Parms.AffinityLow = AffinityLow;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroUtility.KuroStaticLibrary.ShowSoftwareCursor
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    visible                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKuroStaticLibrary::ShowSoftwareCursor(bool visible)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticLibrary", "ShowSoftwareCursor");

	Params::KuroStaticLibrary_ShowSoftwareCursor Parms{};

	Parms.visible = visible;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroUtility.KuroStaticLibrary.SpawnActorFromAnother
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Parent                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* UKuroStaticLibrary::SpawnActorFromAnother(class AActor* Actor, class AActor* Parent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticLibrary", "SpawnActorFromAnother");

	Params::KuroStaticLibrary_SpawnActorFromAnother Parms{};

	Parms.Actor = Actor;
	Parms.Parent = Parent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroUtility.KuroStaticLibrary.StopAllMontagesBySlotName
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UAnimInstance*                    UAnimInstance                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             InSlotName                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InBlendOutTime                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKuroStaticLibrary::StopAllMontagesBySlotName(class UAnimInstance* UAnimInstance, const class FName InSlotName, const float InBlendOutTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticLibrary", "StopAllMontagesBySlotName");

	Params::KuroStaticLibrary_StopAllMontagesBySlotName Parms{};

	Parms.UAnimInstance = UAnimInstance;
	Parms.InSlotName = InSlotName;
	Parms.InBlendOutTime = InBlendOutTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroUtility.KuroStaticLibrary.SynchronizeProperties
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UWidget*                          InWidget                                               (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKuroStaticLibrary::SynchronizeProperties(class UWidget* InWidget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticLibrary", "SynchronizeProperties");

	Params::KuroStaticLibrary_SynchronizeProperties Parms{};

	Parms.InWidget = InWidget;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroUtility.KuroStaticLibrary.ToggleSequenceNodeActiveByTag
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// class ALevelSequenceActor*              Actor                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             TagName                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bActive                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKuroStaticLibrary::ToggleSequenceNodeActiveByTag(const class ALevelSequenceActor* Actor, class FName TagName, bool bActive)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticLibrary", "ToggleSequenceNodeActiveByTag");

	Params::KuroStaticLibrary_ToggleSequenceNodeActiveByTag Parms{};

	Parms.Actor = Actor;
	Parms.TagName = TagName;
	Parms.bActive = bActive;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroUtility.KuroStaticLibrary.ToUnixTimestamp
// (Final, Native, Static, Private, HasDefaults, BlueprintCallable)
// Parameters:
// struct FDateTime                        InDataTime                                             (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UKuroStaticLibrary::ToUnixTimestamp(const struct FDateTime& InDataTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticLibrary", "ToUnixTimestamp");

	Params::KuroStaticLibrary_ToUnixTimestamp Parms{};

	Parms.InDataTime = std::move(InDataTime);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroUtility.KuroStaticLibrary.UnBindDeviceLangChangeDelegate
// (Final, Native, Static, Public, BlueprintCallable)

void UKuroStaticLibrary::UnBindDeviceLangChangeDelegate()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticLibrary", "UnBindDeviceLangChangeDelegate");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function KuroUtility.KuroStaticLibrary.UnRegisterCustomCommandProcessor
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           Category                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKuroStaticLibrary::UnRegisterCustomCommandProcessor(const class FString& Category)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticLibrary", "UnRegisterCustomCommandProcessor");

	Params::KuroStaticLibrary_UnRegisterCustomCommandProcessor Parms{};

	Parms.Category = std::move(Category);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroUtility.KuroStaticLibrary.WriteStringToFile
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// class FString                           SaveText                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           FileName                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bPublic                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bWithBom                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKuroStaticLibrary::WriteStringToFile(const class FString& SaveText, const class FString& FileName, const bool bPublic, const bool bWithBom)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticLibrary", "WriteStringToFile");

	Params::KuroStaticLibrary_WriteStringToFile Parms{};

	Parms.SaveText = std::move(SaveText);
	Parms.FileName = std::move(FileName);
	Parms.bPublic = bPublic;
	Parms.bWithBom = bWithBom;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroUtility.KuroStaticPS5Library.AbortTrophyHandleAsync
// (Final, Native, Static, Public, HasOutParams)
// Parameters:
// int32                                   handle                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TDelegate<void(int32 ret)>              callback                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void UKuroStaticPS5Library::AbortTrophyHandleAsync(int32* handle, const TDelegate<void(int32 ret)>& callback)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticPS5Library", "AbortTrophyHandleAsync");

	Params::KuroStaticPS5Library_AbortTrophyHandleAsync Parms{};

	Parms.callback = callback;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (handle != nullptr)
		*handle = Parms.handle;
}


// Function KuroUtility.KuroStaticPS5Library.AbortUdsHandle
// (Final, Native, Static, Public)
// Parameters:
// int32                                   handle                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UKuroStaticPS5Library::AbortUdsHandle(int32 handle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticPS5Library", "AbortUdsHandle");

	Params::KuroStaticPS5Library_AbortUdsHandle Parms{};

	Parms.handle = handle;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroUtility.KuroStaticPS5Library.AddCacheMapElement
// (Final, Native, Static, Public)
// Parameters:
// class FString                           key                                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           value                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKuroStaticPS5Library::AddCacheMapElement(const class FString& key, const class FString& value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticPS5Library", "AddCacheMapElement");

	Params::KuroStaticPS5Library_AddCacheMapElement Parms{};

	Parms.key = std::move(key);
	Parms.value = std::move(value);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroUtility.KuroStaticPS5Library.AddJoinSessionDelegate
// (Final, Native, Static, Public, HasOutParams)
// Parameters:
// TDelegate<void(const class FString& userId, const class FString& playerSessionId)>InDelegate                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void UKuroStaticPS5Library::AddJoinSessionDelegate(const TDelegate<void(const class FString& userId, const class FString& playerSessionId)>& InDelegate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticPS5Library", "AddJoinSessionDelegate");

	Params::KuroStaticPS5Library_AddJoinSessionDelegate Parms{};

	Parms.InDelegate = InDelegate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroUtility.KuroStaticPS5Library.CheckJoinSession
// (Final, Native, Static, Public)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UKuroStaticPS5Library::CheckJoinSession()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticPS5Library", "CheckJoinSession");

	Params::KuroStaticPS5Library_CheckJoinSession Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroUtility.KuroStaticPS5Library.CheckUserPremium
// (Final, Native, Static, Public, HasOutParams)
// Parameters:
// class FString                           userId                                                 (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UKuroStaticPS5Library::CheckUserPremium(class FString* userId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticPS5Library", "CheckUserPremium");

	Params::KuroStaticPS5Library_CheckUserPremium Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (userId != nullptr)
		*userId = std::move(Parms.userId);

	return Parms.ReturnValue;
}


// Function KuroUtility.KuroStaticPS5Library.ClearJoinSessionDelegate
// (Final, Native, Static, Public)

void UKuroStaticPS5Library::ClearJoinSessionDelegate()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticPS5Library", "ClearJoinSessionDelegate");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function KuroUtility.KuroStaticPS5Library.ClearJoinSessionHandle
// (Final, Native, Static, Public)

void UKuroStaticPS5Library::ClearJoinSessionHandle()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticPS5Library", "ClearJoinSessionHandle");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function KuroUtility.KuroStaticPS5Library.CreatePlayerSession
// (Final, Native, Static, Public, HasOutParams)
// Parameters:
// int32                                   joinableUserType                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           playerId                                               (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UKuroStaticPS5Library::CreatePlayerSession(int32 joinableUserType, class FString* playerId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticPS5Library", "CreatePlayerSession");

	Params::KuroStaticPS5Library_CreatePlayerSession Parms{};

	Parms.joinableUserType = joinableUserType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (playerId != nullptr)
		*playerId = std::move(Parms.playerId);

	return Parms.ReturnValue;
}


// Function KuroUtility.KuroStaticPS5Library.CreateTrophyContextAsync
// (Final, Native, Static, Public, HasOutParams)
// Parameters:
// class FString                           userId                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   serviceLabel                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           optionsLong                                            (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TDelegate<void(int32 ret, int32 result)>callback                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void UKuroStaticPS5Library::CreateTrophyContextAsync(const class FString& userId, int32 serviceLabel, const class FString& optionsLong, const TDelegate<void(int32 ret, int32 result)>& callback)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticPS5Library", "CreateTrophyContextAsync");

	Params::KuroStaticPS5Library_CreateTrophyContextAsync Parms{};

	Parms.userId = std::move(userId);
	Parms.serviceLabel = serviceLabel;
	Parms.optionsLong = std::move(optionsLong);
	Parms.callback = callback;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroUtility.KuroStaticPS5Library.CreateTrophyHandleAsync
// (Final, Native, Static, Public, HasOutParams)
// Parameters:
// TDelegate<void(int32 ret, int32 result)>callback                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void UKuroStaticPS5Library::CreateTrophyHandleAsync(const TDelegate<void(int32 ret, int32 result)>& callback)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticPS5Library", "CreateTrophyHandleAsync");

	Params::KuroStaticPS5Library_CreateTrophyHandleAsync Parms{};

	Parms.callback = callback;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroUtility.KuroStaticPS5Library.CreateUdsContext
// (Final, Native, Static, Public, HasOutParams)
// Parameters:
// class FString                           userId                                                 (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   context                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UKuroStaticPS5Library::CreateUdsContext(class FString* userId, int32* context)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticPS5Library", "CreateUdsContext");

	Params::KuroStaticPS5Library_CreateUdsContext Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (userId != nullptr)
		*userId = std::move(Parms.userId);

	if (context != nullptr)
		*context = Parms.context;

	return Parms.ReturnValue;
}


// Function KuroUtility.KuroStaticPS5Library.CreateUdsEvent
// (Final, Native, Static, Public, HasOutParams)
// Parameters:
// class FString                           eventName                                              (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int64                                   outEventPtr                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int64                                   outProPtr                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UKuroStaticPS5Library::CreateUdsEvent(class FString* eventName, int64* outEventPtr, int64* outProPtr)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticPS5Library", "CreateUdsEvent");

	Params::KuroStaticPS5Library_CreateUdsEvent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (eventName != nullptr)
		*eventName = std::move(Parms.eventName);

	if (outEventPtr != nullptr)
		*outEventPtr = Parms.outEventPtr;

	if (outProPtr != nullptr)
		*outProPtr = Parms.outProPtr;

	return Parms.ReturnValue;
}


// Function KuroUtility.KuroStaticPS5Library.CreateUdsHandle
// (Final, Native, Static, Public, HasOutParams)
// Parameters:
// int32                                   handle                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UKuroStaticPS5Library::CreateUdsHandle(int32* handle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticPS5Library", "CreateUdsHandle");

	Params::KuroStaticPS5Library_CreateUdsHandle Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (handle != nullptr)
		*handle = Parms.handle;

	return Parms.ReturnValue;
}


// Function KuroUtility.KuroStaticPS5Library.DestroyTrophyContextAsync
// (Final, Native, Static, Public, HasOutParams)
// Parameters:
// int32                                   context                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TDelegate<void(int32 ret)>              callback                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void UKuroStaticPS5Library::DestroyTrophyContextAsync(int32* context, const TDelegate<void(int32 ret)>& callback)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticPS5Library", "DestroyTrophyContextAsync");

	Params::KuroStaticPS5Library_DestroyTrophyContextAsync Parms{};

	Parms.callback = callback;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (context != nullptr)
		*context = Parms.context;
}


// Function KuroUtility.KuroStaticPS5Library.DestroyTrophyHandleAsync
// (Final, Native, Static, Public, HasOutParams)
// Parameters:
// int32                                   handle                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TDelegate<void(int32 ret)>              callback                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void UKuroStaticPS5Library::DestroyTrophyHandleAsync(int32* handle, const TDelegate<void(int32 ret)>& callback)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticPS5Library", "DestroyTrophyHandleAsync");

	Params::KuroStaticPS5Library_DestroyTrophyHandleAsync Parms{};

	Parms.callback = callback;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (handle != nullptr)
		*handle = Parms.handle;
}


// Function KuroUtility.KuroStaticPS5Library.DestroyUdsContext
// (Final, Native, Static, Public)
// Parameters:
// int32                                   context                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UKuroStaticPS5Library::DestroyUdsContext(int32 context)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticPS5Library", "DestroyUdsContext");

	Params::KuroStaticPS5Library_DestroyUdsContext Parms{};

	Parms.context = context;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroUtility.KuroStaticPS5Library.DestroyUdsEvent
// (Final, Native, Static, Public)
// Parameters:
// int64                                   eventPtr                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UKuroStaticPS5Library::DestroyUdsEvent(int64 eventPtr)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticPS5Library", "DestroyUdsEvent");

	Params::KuroStaticPS5Library_DestroyUdsEvent Parms{};

	Parms.eventPtr = eventPtr;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroUtility.KuroStaticPS5Library.DestroyUdsHandle
// (Final, Native, Static, Public)
// Parameters:
// int32                                   handle                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UKuroStaticPS5Library::DestroyUdsHandle(int32 handle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticPS5Library", "DestroyUdsHandle");

	Params::KuroStaticPS5Library_DestroyUdsHandle Parms{};

	Parms.handle = handle;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroUtility.KuroStaticPS5Library.GetAccountIdByUserId
// (Final, Native, Static, Public, HasOutParams)
// Parameters:
// class FString                           userId                                                 (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UKuroStaticPS5Library::GetAccountIdByUserId(class FString* userId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticPS5Library", "GetAccountIdByUserId");

	Params::KuroStaticPS5Library_GetAccountIdByUserId Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (userId != nullptr)
		*userId = std::move(Parms.userId);

	return Parms.ReturnValue;
}


// Function KuroUtility.KuroStaticPS5Library.GetAuthCode
// (Final, Native, Static, Public, HasOutParams)
// Parameters:
// class FString                           ClientId                                               (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           Scope                                                  (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           AuthCode                                               (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   IssuerId                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UKuroStaticPS5Library::GetAuthCode(class FString* ClientId, class FString* Scope, class FString* AuthCode, int32* IssuerId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticPS5Library", "GetAuthCode");

	Params::KuroStaticPS5Library_GetAuthCode Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (ClientId != nullptr)
		*ClientId = std::move(Parms.ClientId);

	if (Scope != nullptr)
		*Scope = std::move(Parms.Scope);

	if (AuthCode != nullptr)
		*AuthCode = std::move(Parms.AuthCode);

	if (IssuerId != nullptr)
		*IssuerId = Parms.IssuerId;

	return Parms.ReturnValue;
}


// Function KuroUtility.KuroStaticPS5Library.GetBasicPresence
// (Final, Native, Static, Public, HasOutParams)
// Parameters:
// class FString                           accountId                                              (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FBasicPresenceData>       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FBasicPresenceData> UKuroStaticPS5Library::GetBasicPresence(class FString* accountId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticPS5Library", "GetBasicPresence");

	Params::KuroStaticPS5Library_GetBasicPresence Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (accountId != nullptr)
		*accountId = std::move(Parms.accountId);

	return Parms.ReturnValue;
}


// Function KuroUtility.KuroStaticPS5Library.GetBlockUserList
// (Final, Native, Static, Public, HasOutParams)
// Parameters:
// int32                                   offset                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   limit                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FBlockUserData                   ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FBlockUserData UKuroStaticPS5Library::GetBlockUserList(int32* offset, int32* limit)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticPS5Library", "GetBlockUserList");

	Params::KuroStaticPS5Library_GetBlockUserList Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (offset != nullptr)
		*offset = Parms.offset;

	if (limit != nullptr)
		*limit = Parms.limit;

	return Parms.ReturnValue;
}


// Function KuroUtility.KuroStaticPS5Library.GetBlockUserListAsync
// (Final, Native, Static, Public, HasOutParams)
// Parameters:
// int32                                   offset                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   limit                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TDelegate<void(const struct FBlockUserData& data)>Delegate                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void UKuroStaticPS5Library::GetBlockUserListAsync(int32* offset, int32* limit, const TDelegate<void(const struct FBlockUserData& data)>& Delegate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticPS5Library", "GetBlockUserListAsync");

	Params::KuroStaticPS5Library_GetBlockUserListAsync Parms{};

	Parms.Delegate = Delegate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (offset != nullptr)
		*offset = Parms.offset;

	if (limit != nullptr)
		*limit = Parms.limit;
}


// Function KuroUtility.KuroStaticPS5Library.GetCacheMapElement
// (Final, Native, Static, Public)
// Parameters:
// class FString                           key                                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UKuroStaticPS5Library::GetCacheMapElement(const class FString& key)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticPS5Library", "GetCacheMapElement");

	Params::KuroStaticPS5Library_GetCacheMapElement Parms{};

	Parms.key = std::move(key);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroUtility.KuroStaticPS5Library.GetCommunicationRestrictionStatusAsync
// (Final, Native, Static, Public, HasOutParams)
// Parameters:
// class FString                           accountId                                              (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TDelegate<void(int32 ret, int32 status)>callback                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void UKuroStaticPS5Library::GetCommunicationRestrictionStatusAsync(class FString* accountId, const TDelegate<void(int32 ret, int32 status)>& callback)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticPS5Library", "GetCommunicationRestrictionStatusAsync");

	Params::KuroStaticPS5Library_GetCommunicationRestrictionStatusAsync Parms{};

	Parms.callback = callback;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (accountId != nullptr)
		*accountId = std::move(Parms.accountId);
}


// Function KuroUtility.KuroStaticPS5Library.GetCountryCodeByUserId
// (Final, Native, Static, Public, HasOutParams)
// Parameters:
// class FString                           userId                                                 (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UKuroStaticPS5Library::GetCountryCodeByUserId(class FString* userId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticPS5Library", "GetCountryCodeByUserId");

	Params::KuroStaticPS5Library_GetCountryCodeByUserId Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (userId != nullptr)
		*userId = std::move(Parms.userId);

	return Parms.ReturnValue;
}


// Function KuroUtility.KuroStaticPS5Library.GetIdToken
// (Final, Native, Static, Public, HasOutParams)
// Parameters:
// class FString                           ClientId                                               (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ClientSecret                                           (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           Scope                                                  (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           IdToken                                                (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UKuroStaticPS5Library::GetIdToken(class FString* ClientId, class FString* ClientSecret, class FString* Scope, class FString* IdToken)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticPS5Library", "GetIdToken");

	Params::KuroStaticPS5Library_GetIdToken Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (ClientId != nullptr)
		*ClientId = std::move(Parms.ClientId);

	if (ClientSecret != nullptr)
		*ClientSecret = std::move(Parms.ClientSecret);

	if (Scope != nullptr)
		*Scope = std::move(Parms.Scope);

	if (IdToken != nullptr)
		*IdToken = std::move(Parms.IdToken);

	return Parms.ReturnValue;
}


// Function KuroUtility.KuroStaticPS5Library.GetMessageDialogStateAsync
// (Final, Native, Static, Public, HasOutParams)
// Parameters:
// TDelegate<void(int32 ret)>              callback                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void UKuroStaticPS5Library::GetMessageDialogStateAsync(const TDelegate<void(int32 ret)>& callback)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticPS5Library", "GetMessageDialogStateAsync");

	Params::KuroStaticPS5Library_GetMessageDialogStateAsync Parms{};

	Parms.callback = callback;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroUtility.KuroStaticPS5Library.GetOnlineIdByUserId
// (Final, Native, Static, Public, HasOutParams)
// Parameters:
// class FString                           userId                                                 (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UKuroStaticPS5Library::GetOnlineIdByUserId(class FString* userId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticPS5Library", "GetOnlineIdByUserId");

	Params::KuroStaticPS5Library_GetOnlineIdByUserId Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (userId != nullptr)
		*userId = std::move(Parms.userId);

	return Parms.ReturnValue;
}


// Function KuroUtility.KuroStaticPS5Library.GetPlayerIdByPlayerSessionId
// (Final, Native, Static, Public, HasOutParams)
// Parameters:
// class FString                           playerSessionId                                        (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UKuroStaticPS5Library::GetPlayerIdByPlayerSessionId(class FString* playerSessionId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticPS5Library", "GetPlayerIdByPlayerSessionId");

	Params::KuroStaticPS5Library_GetPlayerIdByPlayerSessionId Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (playerSessionId != nullptr)
		*playerSessionId = std::move(Parms.playerSessionId);

	return Parms.ReturnValue;
}


// Function KuroUtility.KuroStaticPS5Library.GetStoreProducts
// (Final, Native, Static, Public)
// Parameters:
// TArray<struct FProductData>             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FProductData> UKuroStaticPS5Library::GetStoreProducts()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticPS5Library", "GetStoreProducts");

	Params::KuroStaticPS5Library_GetStoreProducts Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroUtility.KuroStaticPS5Library.GetTrophyList
// (Final, Native, Static, Public, HasOutParams)
// Parameters:
// class FString                           userId                                                 (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   inputOffset                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   length                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTrophyInfoData                  ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FTrophyInfoData UKuroStaticPS5Library::GetTrophyList(class FString* userId, int32* inputOffset, int32 length)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticPS5Library", "GetTrophyList");

	Params::KuroStaticPS5Library_GetTrophyList Parms{};

	Parms.length = length;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (userId != nullptr)
		*userId = std::move(Parms.userId);

	if (inputOffset != nullptr)
		*inputOffset = Parms.inputOffset;

	return Parms.ReturnValue;
}


// Function KuroUtility.KuroStaticPS5Library.GetTrophyListWithContextIdAndHandleId
// (Final, Native, Static, Public, HasOutParams)
// Parameters:
// int32                                   context                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   handle                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   inputOffset                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   length                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTrophyInfoData                  ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FTrophyInfoData UKuroStaticPS5Library::GetTrophyListWithContextIdAndHandleId(int32 context, int32 handle, int32* inputOffset, int32 length)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticPS5Library", "GetTrophyListWithContextIdAndHandleId");

	Params::KuroStaticPS5Library_GetTrophyListWithContextIdAndHandleId Parms{};

	Parms.context = context;
	Parms.handle = handle;
	Parms.length = length;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (inputOffset != nullptr)
		*inputOffset = Parms.inputOffset;

	return Parms.ReturnValue;
}


// Function KuroUtility.KuroStaticPS5Library.GetTrophyListWithContextIdAndHandleIdAsync
// (Final, Native, Static, Public, HasOutParams)
// Parameters:
// int32                                   inputOffset                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   length                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   context                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   handle                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TDelegate<void(const struct FTrophyInfoData& data)>callback                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void UKuroStaticPS5Library::GetTrophyListWithContextIdAndHandleIdAsync(int32* inputOffset, int32 length, int32 context, int32 handle, const TDelegate<void(const struct FTrophyInfoData& data)>& callback)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticPS5Library", "GetTrophyListWithContextIdAndHandleIdAsync");

	Params::KuroStaticPS5Library_GetTrophyListWithContextIdAndHandleIdAsync Parms{};

	Parms.length = length;
	Parms.context = context;
	Parms.handle = handle;
	Parms.callback = callback;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (inputOffset != nullptr)
		*inputOffset = Parms.inputOffset;
}


// Function KuroUtility.KuroStaticPS5Library.GetUserId
// (Final, Native, Static, Public)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UKuroStaticPS5Library::GetUserId()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticPS5Library", "GetUserId");

	Params::KuroStaticPS5Library_GetUserId Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroUtility.KuroStaticPS5Library.GetUserIdByAccountId
// (Final, Native, Static, Public, HasOutParams)
// Parameters:
// class FString                           accountId                                              (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UKuroStaticPS5Library::GetUserIdByAccountId(class FString* accountId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticPS5Library", "GetUserIdByAccountId");

	Params::KuroStaticPS5Library_GetUserIdByAccountId Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (accountId != nullptr)
		*accountId = std::move(Parms.accountId);

	return Parms.ReturnValue;
}


// Function KuroUtility.KuroStaticPS5Library.HidePsStoreIcon
// (Final, Native, Static, Public)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UKuroStaticPS5Library::HidePsStoreIcon()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticPS5Library", "HidePsStoreIcon");

	Params::KuroStaticPS5Library_HidePsStoreIcon Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroUtility.KuroStaticPS5Library.InitNpUniversalDataSystem
// (Final, Native, Static, Public)
// Parameters:
// int32                                   poolSize                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UKuroStaticPS5Library::InitNpUniversalDataSystem(int32 poolSize)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticPS5Library", "InitNpUniversalDataSystem");

	Params::KuroStaticPS5Library_InitNpUniversalDataSystem Parms{};

	Parms.poolSize = poolSize;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroUtility.KuroStaticPS5Library.InitWebApi
// (Final, Native, Static, Public, HasOutParams)
// Parameters:
// class FString                           userId                                                 (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UKuroStaticPS5Library::InitWebApi(class FString* userId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticPS5Library", "InitWebApi");

	Params::KuroStaticPS5Library_InitWebApi Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (userId != nullptr)
		*userId = std::move(Parms.userId);

	return Parms.ReturnValue;
}


// Function KuroUtility.KuroStaticPS5Library.JoinPlayerSession
// (Final, Native, Static, Public, HasOutParams)
// Parameters:
// class FString                           playerSessionId                                        (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKuroStaticPS5Library::JoinPlayerSession(class FString* playerSessionId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticPS5Library", "JoinPlayerSession");

	Params::KuroStaticPS5Library_JoinPlayerSession Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (playerSessionId != nullptr)
		*playerSessionId = std::move(Parms.playerSessionId);
}


// Function KuroUtility.KuroStaticPS5Library.LeavePlayerSession
// (Final, Native, Static, Public)

void UKuroStaticPS5Library::LeavePlayerSession()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticPS5Library", "LeavePlayerSession");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function KuroUtility.KuroStaticPS5Library.NotifyPremium
// (Final, Native, Static, Public, HasOutParams)
// Parameters:
// class FString                           userId                                                 (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKuroStaticPS5Library::NotifyPremium(class FString* userId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticPS5Library", "NotifyPremium");

	Params::KuroStaticPS5Library_NotifyPremium Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (userId != nullptr)
		*userId = std::move(Parms.userId);
}


// Function KuroUtility.KuroStaticPS5Library.NotifyPremiumFeature
// (Final, Native, Static, Public, HasOutParams)
// Parameters:
// class FString                           userId                                                 (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    isPlayStationOnly                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKuroStaticPS5Library::NotifyPremiumFeature(class FString* userId, bool isPlayStationOnly)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticPS5Library", "NotifyPremiumFeature");

	Params::KuroStaticPS5Library_NotifyPremiumFeature Parms{};

	Parms.isPlayStationOnly = isPlayStationOnly;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (userId != nullptr)
		*userId = std::move(Parms.userId);
}


// Function KuroUtility.KuroStaticPS5Library.OpenCheckoutDialog
// (Final, Native, Static, Public, HasOutParams)
// Parameters:
// class FString                           ProductLabel                                           (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UKuroStaticPS5Library::OpenCheckoutDialog(class FString* ProductLabel)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticPS5Library", "OpenCheckoutDialog");

	Params::KuroStaticPS5Library_OpenCheckoutDialog Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (ProductLabel != nullptr)
		*ProductLabel = std::move(Parms.ProductLabel);

	return Parms.ReturnValue;
}


// Function KuroUtility.KuroStaticPS5Library.OpenMessageDialog
// (Final, Native, Static, Public, HasOutParams)
// Parameters:
// class FString                           userId                                                 (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   openMode                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   msgType                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TDelegate<void(int32 ret)>              callback                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void UKuroStaticPS5Library::OpenMessageDialog(class FString* userId, int32 openMode, int32 msgType, const TDelegate<void(int32 ret)>& callback)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticPS5Library", "OpenMessageDialog");

	Params::KuroStaticPS5Library_OpenMessageDialog Parms{};

	Parms.openMode = openMode;
	Parms.msgType = msgType;
	Parms.callback = callback;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (userId != nullptr)
		*userId = std::move(Parms.userId);
}


// Function KuroUtility.KuroStaticPS5Library.OpenWebBrowser
// (Final, Native, Static, Public, HasOutParams)
// Parameters:
// class FString                           Url                                                    (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKuroStaticPS5Library::OpenWebBrowser(class FString* Url)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticPS5Library", "OpenWebBrowser");

	Params::KuroStaticPS5Library_OpenWebBrowser Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Url != nullptr)
		*Url = std::move(Parms.Url);
}


// Function KuroUtility.KuroStaticPS5Library.OpenWebView
// (Final, Native, Static, Public, HasOutParams)
// Parameters:
// class FString                           Url                                                    (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UKuroStaticPS5Library::OpenWebView(class FString* Url)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticPS5Library", "OpenWebView");

	Params::KuroStaticPS5Library_OpenWebView Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Url != nullptr)
		*Url = std::move(Parms.Url);

	return Parms.ReturnValue;
}


// Function KuroUtility.KuroStaticPS5Library.PollCheckoutDialogResult
// (Final, Native, Static, Public)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UKuroStaticPS5Library::PollCheckoutDialogResult()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticPS5Library", "PollCheckoutDialogResult");

	Params::KuroStaticPS5Library_PollCheckoutDialogResult Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroUtility.KuroStaticPS5Library.PollWebBrowser
// (Final, Native, Static, Public)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKuroStaticPS5Library::PollWebBrowser()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticPS5Library", "PollWebBrowser");

	Params::KuroStaticPS5Library_PollWebBrowser Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroUtility.KuroStaticPS5Library.PostUdsEvent
// (Final, Native, Static, Public)
// Parameters:
// int32                                   context                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   handle                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int64                                   eventPtr                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UKuroStaticPS5Library::PostUdsEvent(int32 context, int32 handle, int64 eventPtr)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticPS5Library", "PostUdsEvent");

	Params::KuroStaticPS5Library_PostUdsEvent Parms{};

	Parms.context = context;
	Parms.handle = handle;
	Parms.eventPtr = eventPtr;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroUtility.KuroStaticPS5Library.RegisterTrophyContextAsync
// (Final, Native, Static, Public, HasOutParams)
// Parameters:
// int32                                   context                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   handle                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           optionsLong                                            (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TDelegate<void(int32 ret)>              callback                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void UKuroStaticPS5Library::RegisterTrophyContextAsync(int32* context, int32* handle, const class FString& optionsLong, const TDelegate<void(int32 ret)>& callback)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticPS5Library", "RegisterTrophyContextAsync");

	Params::KuroStaticPS5Library_RegisterTrophyContextAsync Parms{};

	Parms.optionsLong = std::move(optionsLong);
	Parms.callback = callback;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (context != nullptr)
		*context = Parms.context;

	if (handle != nullptr)
		*handle = Parms.handle;
}


// Function KuroUtility.KuroStaticPS5Library.RegisterUdsContext
// (Final, Native, Static, Public)
// Parameters:
// int32                                   context                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   handle                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UKuroStaticPS5Library::RegisterUdsContext(int32 context, int32 handle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticPS5Library", "RegisterUdsContext");

	Params::KuroStaticPS5Library_RegisterUdsContext Parms{};

	Parms.context = context;
	Parms.handle = handle;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroUtility.KuroStaticPS5Library.RemoveCacheElement
// (Final, Native, Static, Public)
// Parameters:
// class FString                           key                                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKuroStaticPS5Library::RemoveCacheElement(const class FString& key)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticPS5Library", "RemoveCacheElement");

	Params::KuroStaticPS5Library_RemoveCacheElement Parms{};

	Parms.key = std::move(key);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroUtility.KuroStaticPS5Library.SceNpGetNpReachabilityState
// (Final, Native, Static, Public, HasOutParams)
// Parameters:
// class FString                           userId                                                 (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   outState                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UKuroStaticPS5Library::SceNpGetNpReachabilityState(class FString* userId, int32* outState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticPS5Library", "SceNpGetNpReachabilityState");

	Params::KuroStaticPS5Library_SceNpGetNpReachabilityState Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (userId != nullptr)
		*userId = std::move(Parms.userId);

	if (outState != nullptr)
		*outState = Parms.outState;

	return Parms.ReturnValue;
}


// Function KuroUtility.KuroStaticPS5Library.SetPlayerSessionJoinableUserType
// (Final, Native, Static, Public)
// Parameters:
// int32                                   joinableUserType                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKuroStaticPS5Library::SetPlayerSessionJoinableUserType(int32 joinableUserType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticPS5Library", "SetPlayerSessionJoinableUserType");

	Params::KuroStaticPS5Library_SetPlayerSessionJoinableUserType Parms{};

	Parms.joinableUserType = joinableUserType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroUtility.KuroStaticPS5Library.ShowPsStoreIcon
// (Final, Native, Static, Public)
// Parameters:
// int32                                   position                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UKuroStaticPS5Library::ShowPsStoreIcon(int32 position)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticPS5Library", "ShowPsStoreIcon");

	Params::KuroStaticPS5Library_ShowPsStoreIcon Parms{};

	Parms.position = position;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroUtility.KuroStaticPS5Library.TerminateMessageDialog
// (Final, Native, Static, Public)

void UKuroStaticPS5Library::TerminateMessageDialog()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticPS5Library", "TerminateMessageDialog");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function KuroUtility.KuroStaticPS5Library.UdsEventPropertyArraySetString
// (Final, Native, Static, Public, HasOutParams)
// Parameters:
// int64                                   proPtr                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           key                                                    (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class FString>                   value                                                  (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UKuroStaticPS5Library::UdsEventPropertyArraySetString(int64 proPtr, class FString* key, TArray<class FString>* value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticPS5Library", "UdsEventPropertyArraySetString");

	Params::KuroStaticPS5Library_UdsEventPropertyArraySetString Parms{};

	Parms.proPtr = proPtr;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (key != nullptr)
		*key = std::move(Parms.key);

	if (value != nullptr)
		*value = std::move(Parms.value);

	return Parms.ReturnValue;
}


// Function KuroUtility.KuroStaticPS5Library.UdsEventPropertyObjectSetBool
// (Final, Native, Static, Public, HasOutParams)
// Parameters:
// int64                                   proPtr                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           key                                                    (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UKuroStaticPS5Library::UdsEventPropertyObjectSetBool(int64 proPtr, class FString* key, bool value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticPS5Library", "UdsEventPropertyObjectSetBool");

	Params::KuroStaticPS5Library_UdsEventPropertyObjectSetBool Parms{};

	Parms.proPtr = proPtr;
	Parms.value = value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (key != nullptr)
		*key = std::move(Parms.key);

	return Parms.ReturnValue;
}


// Function KuroUtility.KuroStaticPS5Library.UdsEventPropertyObjectSetFloat32
// (Final, Native, Static, Public, HasOutParams)
// Parameters:
// int64                                   proPtr                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           key                                                    (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UKuroStaticPS5Library::UdsEventPropertyObjectSetFloat32(int64 proPtr, class FString* key, float value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticPS5Library", "UdsEventPropertyObjectSetFloat32");

	Params::KuroStaticPS5Library_UdsEventPropertyObjectSetFloat32 Parms{};

	Parms.proPtr = proPtr;
	Parms.value = value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (key != nullptr)
		*key = std::move(Parms.key);

	return Parms.ReturnValue;
}


// Function KuroUtility.KuroStaticPS5Library.UdsEventPropertyObjectSetFloat64
// (Final, Native, Static, Public, HasOutParams)
// Parameters:
// int64                                   proPtr                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           key                                                    (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// double                                  value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UKuroStaticPS5Library::UdsEventPropertyObjectSetFloat64(int64 proPtr, class FString* key, double value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticPS5Library", "UdsEventPropertyObjectSetFloat64");

	Params::KuroStaticPS5Library_UdsEventPropertyObjectSetFloat64 Parms{};

	Parms.proPtr = proPtr;
	Parms.value = value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (key != nullptr)
		*key = std::move(Parms.key);

	return Parms.ReturnValue;
}


// Function KuroUtility.KuroStaticPS5Library.UdsEventPropertyObjectSetInt32
// (Final, Native, Static, Public, HasOutParams)
// Parameters:
// int64                                   proPtr                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           key                                                    (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UKuroStaticPS5Library::UdsEventPropertyObjectSetInt32(int64 proPtr, class FString* key, int32 value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticPS5Library", "UdsEventPropertyObjectSetInt32");

	Params::KuroStaticPS5Library_UdsEventPropertyObjectSetInt32 Parms{};

	Parms.proPtr = proPtr;
	Parms.value = value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (key != nullptr)
		*key = std::move(Parms.key);

	return Parms.ReturnValue;
}


// Function KuroUtility.KuroStaticPS5Library.UdsEventPropertyObjectSetInt64
// (Final, Native, Static, Public, HasOutParams)
// Parameters:
// int64                                   proPtr                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           key                                                    (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int64                                   value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UKuroStaticPS5Library::UdsEventPropertyObjectSetInt64(int64 proPtr, class FString* key, int64 value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticPS5Library", "UdsEventPropertyObjectSetInt64");

	Params::KuroStaticPS5Library_UdsEventPropertyObjectSetInt64 Parms{};

	Parms.proPtr = proPtr;
	Parms.value = value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (key != nullptr)
		*key = std::move(Parms.key);

	return Parms.ReturnValue;
}


// Function KuroUtility.KuroStaticPS5Library.UdsEventPropertyObjectSetString
// (Final, Native, Static, Public, HasOutParams)
// Parameters:
// int64                                   proPtr                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           key                                                    (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           value                                                  (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UKuroStaticPS5Library::UdsEventPropertyObjectSetString(int64 proPtr, class FString* key, class FString* value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticPS5Library", "UdsEventPropertyObjectSetString");

	Params::KuroStaticPS5Library_UdsEventPropertyObjectSetString Parms{};

	Parms.proPtr = proPtr;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (key != nullptr)
		*key = std::move(Parms.key);

	if (value != nullptr)
		*value = std::move(Parms.value);

	return Parms.ReturnValue;
}


// Function KuroUtility.KuroStaticPS5Library.UdsEventPropertyObjectSetUInt32
// (Final, Native, Static, Public, HasOutParams)
// Parameters:
// int64                                   proPtr                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           key                                                    (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UKuroStaticPS5Library::UdsEventPropertyObjectSetUInt32(int64 proPtr, class FString* key, int32 value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticPS5Library", "UdsEventPropertyObjectSetUInt32");

	Params::KuroStaticPS5Library_UdsEventPropertyObjectSetUInt32 Parms{};

	Parms.proPtr = proPtr;
	Parms.value = value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (key != nullptr)
		*key = std::move(Parms.key);

	return Parms.ReturnValue;
}


// Function KuroUtility.KuroStaticPS5Library.UdsEventPropertyObjectSetUInt64
// (Final, Native, Static, Public, HasOutParams)
// Parameters:
// int64                                   proPtr                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           key                                                    (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int64                                   value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UKuroStaticPS5Library::UdsEventPropertyObjectSetUInt64(int64 proPtr, class FString* key, int64 value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticPS5Library", "UdsEventPropertyObjectSetUInt64");

	Params::KuroStaticPS5Library_UdsEventPropertyObjectSetUInt64 Parms{};

	Parms.proPtr = proPtr;
	Parms.value = value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (key != nullptr)
		*key = std::move(Parms.key);

	return Parms.ReturnValue;
}


// Function KuroUtility.KuroStaticPS5Library.UnlockTrophy
// (Final, Native, Static, Public, HasOutParams)
// Parameters:
// class FString                           userId                                                 (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   trophyId                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UKuroStaticPS5Library::UnlockTrophy(class FString* userId, int32 trophyId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticPS5Library", "UnlockTrophy");

	Params::KuroStaticPS5Library_UnlockTrophy Parms{};

	Parms.trophyId = trophyId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (userId != nullptr)
		*userId = std::move(Parms.userId);

	return Parms.ReturnValue;
}


// Function KuroUtility.KuroStaticPS5Library.UnlockTrophyWithContextIdAndHandleId
// (Final, Native, Static, Public)
// Parameters:
// int32                                   contextId                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   handle                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   trophyId                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UKuroStaticPS5Library::UnlockTrophyWithContextIdAndHandleId(int32 contextId, int32 handle, int32 trophyId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticPS5Library", "UnlockTrophyWithContextIdAndHandleId");

	Params::KuroStaticPS5Library_UnlockTrophyWithContextIdAndHandleId Parms{};

	Parms.contextId = contextId;
	Parms.handle = handle;
	Parms.trophyId = trophyId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroUtility.KuroStaticPS5Library.UnlockTrophyWithContextIdAndHandleIdAsync
// (Final, Native, Static, Public, HasOutParams)
// Parameters:
// int32                                   contextId                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   handle                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   trophyId                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TDelegate<void(int32 ret)>              callback                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void UKuroStaticPS5Library::UnlockTrophyWithContextIdAndHandleIdAsync(int32 contextId, int32 handle, int32 trophyId, const TDelegate<void(int32 ret)>& callback)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticPS5Library", "UnlockTrophyWithContextIdAndHandleIdAsync");

	Params::KuroStaticPS5Library_UnlockTrophyWithContextIdAndHandleIdAsync Parms{};

	Parms.contextId = contextId;
	Parms.handle = handle;
	Parms.trophyId = trophyId;
	Parms.callback = callback;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroUtility.KuroStaticPS5Library.UpdateTrophyProgress
// (Final, Native, Static, Public, HasOutParams)
// Parameters:
// class FString                           userId                                                 (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   trophyId                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   progress                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UKuroStaticPS5Library::UpdateTrophyProgress(class FString* userId, int32 trophyId, int32 progress)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticPS5Library", "UpdateTrophyProgress");

	Params::KuroStaticPS5Library_UpdateTrophyProgress Parms{};

	Parms.trophyId = trophyId;
	Parms.progress = progress;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (userId != nullptr)
		*userId = std::move(Parms.userId);

	return Parms.ReturnValue;
}


// Function KuroUtility.KuroStaticPS5Library.UpdateTrophyProgressWithContextIdAndHandleId
// (Final, Native, Static, Public)
// Parameters:
// int32                                   context                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   handle                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   trophyId                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   progress                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UKuroStaticPS5Library::UpdateTrophyProgressWithContextIdAndHandleId(int32 context, int32 handle, int32 trophyId, int32 progress)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticPS5Library", "UpdateTrophyProgressWithContextIdAndHandleId");

	Params::KuroStaticPS5Library_UpdateTrophyProgressWithContextIdAndHandleId Parms{};

	Parms.context = context;
	Parms.handle = handle;
	Parms.trophyId = trophyId;
	Parms.progress = progress;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroUtility.KuroStaticPS5Library.UpdateTrophyProgressWithContextIdAndHandleIdAsync
// (Final, Native, Static, Public, HasOutParams)
// Parameters:
// int32                                   context                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   handle                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   trophyId                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   progress                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TDelegate<void(int32 ret)>              callback                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void UKuroStaticPS5Library::UpdateTrophyProgressWithContextIdAndHandleIdAsync(int32 context, int32 handle, int32 trophyId, int32 progress, const TDelegate<void(int32 ret)>& callback)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticPS5Library", "UpdateTrophyProgressWithContextIdAndHandleIdAsync");

	Params::KuroStaticPS5Library_UpdateTrophyProgressWithContextIdAndHandleIdAsync Parms{};

	Parms.context = context;
	Parms.handle = handle;
	Parms.trophyId = trophyId;
	Parms.progress = progress;
	Parms.callback = callback;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroUtility.KuroSubLevelVisibleSubsystem.GetSubSystem
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UGameInstance*                    GameInstance                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UKuroSubLevelVisibleSubsystem*    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UKuroSubLevelVisibleSubsystem* UKuroSubLevelVisibleSubsystem::GetSubSystem(const class UGameInstance* GameInstance)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroSubLevelVisibleSubsystem", "GetSubSystem");

	Params::KuroSubLevelVisibleSubsystem_GetSubSystem Parms{};

	Parms.GameInstance = GameInstance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroUtility.KuroSubLevelVisibleSubsystem.AddLevel
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   LinkId                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ULevel*                           Level                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKuroSubLevelVisibleSubsystem::AddLevel(int32 LinkId, class ULevel* Level)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KuroSubLevelVisibleSubsystem", "AddLevel");

	Params::KuroSubLevelVisibleSubsystem_AddLevel Parms{};

	Parms.LinkId = LinkId;
	Parms.Level = Level;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroUtility.KuroSubLevelVisibleSubsystem.RemoveLevel
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   LinkId                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKuroSubLevelVisibleSubsystem::RemoveLevel(int32 LinkId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KuroSubLevelVisibleSubsystem", "RemoveLevel");

	Params::KuroSubLevelVisibleSubsystem_RemoveLevel Parms{};

	Parms.LinkId = LinkId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroUtility.KuroSubLevelVisibleSubsystem.SetLevelActorsVisible
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   LinkId                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Visible                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TDelegate<void(int32 LinkId)>           FinishCallback                                         (ConstParm, Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKuroSubLevelVisibleSubsystem::SetLevelActorsVisible(const int32 LinkId, const bool Visible, const TDelegate<void(int32 LinkId)> FinishCallback)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KuroSubLevelVisibleSubsystem", "SetLevelActorsVisible");

	Params::KuroSubLevelVisibleSubsystem_SetLevelActorsVisible Parms{};

	Parms.LinkId = LinkId;
	Parms.Visible = Visible;
	Parms.FinishCallback = FinishCallback;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroUtility.KuroSubLevelVisibleSubsystem.SetOneFrameExecuteCount
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   Count                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKuroSubLevelVisibleSubsystem::SetOneFrameExecuteCount(const int32 Count)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KuroSubLevelVisibleSubsystem", "SetOneFrameExecuteCount");

	Params::KuroSubLevelVisibleSubsystem_SetOneFrameExecuteCount Parms{};

	Parms.Count = Count;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroUtility.KuroTencentCOSLibrary.ClearAllProgressCallback
// (Final, Native, Static, Public, BlueprintCallable)

void UKuroTencentCOSLibrary::ClearAllProgressCallback()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroTencentCOSLibrary", "ClearAllProgressCallback");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function KuroUtility.KuroTencentCOSLibrary.EnableAuthorization
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    Enable                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKuroTencentCOSLibrary::EnableAuthorization(bool Enable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroTencentCOSLibrary", "EnableAuthorization");

	Params::KuroTencentCOSLibrary_EnableAuthorization Parms{};

	Parms.Enable = Enable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroUtility.KuroTencentCOSLibrary.EnableAutoSendWhenExit
// (Final, Native, Static, Public, BlueprintCallable)

void UKuroTencentCOSLibrary::EnableAutoSendWhenExit()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroTencentCOSLibrary", "EnableAutoSendWhenExit");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function KuroUtility.KuroTencentCOSLibrary.GetAllFileNumNeedToSend
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UKuroTencentCOSLibrary::GetAllFileNumNeedToSend()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroTencentCOSLibrary", "GetAllFileNumNeedToSend");

	Params::KuroTencentCOSLibrary_GetAllFileNumNeedToSend Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroUtility.KuroTencentCOSLibrary.GetSendedFileNum
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UKuroTencentCOSLibrary::GetSendedFileNum()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroTencentCOSLibrary", "GetSendedFileNum");

	Params::KuroTencentCOSLibrary_GetSendedFileNum Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroUtility.KuroTencentCOSLibrary.InterruptSending
// (Final, Native, Static, Public, BlueprintCallable)

void UKuroTencentCOSLibrary::InterruptSending()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroTencentCOSLibrary", "InterruptSending");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function KuroUtility.KuroTencentCOSLibrary.IsSending
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKuroTencentCOSLibrary::IsSending()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroTencentCOSLibrary", "IsSending");

	Params::KuroTencentCOSLibrary_IsSending Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroUtility.KuroTencentCOSLibrary.SendFileToTencentCOS
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           Path                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           RemoteURI                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           SecretID                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           SecretKey                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           BucketName                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           Region                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKuroTencentCOSLibrary::SendFileToTencentCOS(const class FString& Path, const class FString& RemoteURI, const class FString& SecretID, const class FString& SecretKey, const class FString& BucketName, const class FString& Region)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroTencentCOSLibrary", "SendFileToTencentCOS");

	Params::KuroTencentCOSLibrary_SendFileToTencentCOS Parms{};

	Parms.Path = std::move(Path);
	Parms.RemoteURI = std::move(RemoteURI);
	Parms.SecretID = std::move(SecretID);
	Parms.SecretKey = std::move(SecretKey);
	Parms.BucketName = std::move(BucketName);
	Parms.Region = std::move(Region);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroUtility.KuroTencentCOSLibrary.SendLogToTencentCOS
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TDelegate<void(int32 State, float Rate)>OnProgress                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void UKuroTencentCOSLibrary::SendLogToTencentCOS(const TDelegate<void(int32 State, float Rate)>& OnProgress)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroTencentCOSLibrary", "SendLogToTencentCOS");

	Params::KuroTencentCOSLibrary_SendLogToTencentCOS Parms{};

	Parms.OnProgress = OnProgress;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroUtility.KuroTencentCOSLibrary.SetAdmissibleValue
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   SingleLogSizeInMb                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKuroTencentCOSLibrary::SetAdmissibleValue(int32 SingleLogSizeInMb)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroTencentCOSLibrary", "SetAdmissibleValue");

	Params::KuroTencentCOSLibrary_SetAdmissibleValue Parms{};

	Parms.SingleLogSizeInMb = SingleLogSizeInMb;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroUtility.KuroTencentCOSLibrary.SetFilesToSend
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<class FString>                   FilePaths                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void UKuroTencentCOSLibrary::SetFilesToSend(const TArray<class FString>& FilePaths)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroTencentCOSLibrary", "SetFilesToSend");

	Params::KuroTencentCOSLibrary_SetFilesToSend Parms{};

	Parms.FilePaths = std::move(FilePaths);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroUtility.KuroTencentCOSLibrary.SetHandleFunc
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TDelegate<void(TArray<class FString>& FileNames)>PrepareFunc                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// TDelegate<void(TArray<class FString>& SendedFiles)>PostSend                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void UKuroTencentCOSLibrary::SetHandleFunc(const TDelegate<void(TArray<class FString>& FileNames)>& PrepareFunc, const TDelegate<void(TArray<class FString>& SendedFiles)>& PostSend)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroTencentCOSLibrary", "SetHandleFunc");

	Params::KuroTencentCOSLibrary_SetHandleFunc Parms{};

	Parms.PrepareFunc = PrepareFunc;
	Parms.PostSend = PostSend;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroUtility.KuroTencentCOSLibrary.SetIsAutoSend
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    bIsAutoSend                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKuroTencentCOSLibrary::SetIsAutoSend(bool bIsAutoSend)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroTencentCOSLibrary", "SetIsAutoSend");

	Params::KuroTencentCOSLibrary_SetIsAutoSend Parms{};

	Parms.bIsAutoSend = bIsAutoSend;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroUtility.KuroTencentCOSLibrary.SetSendLogConfig
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           SecretID                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           SecretKey                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           BucketName                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           Region                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKuroTencentCOSLibrary::SetSendLogConfig(const class FString& SecretID, const class FString& SecretKey, const class FString& BucketName, const class FString& Region)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroTencentCOSLibrary", "SetSendLogConfig");

	Params::KuroTencentCOSLibrary_SetSendLogConfig Parms{};

	Parms.SecretID = std::move(SecretID);
	Parms.SecretKey = std::move(SecretKey);
	Parms.BucketName = std::move(BucketName);
	Parms.Region = std::move(Region);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroUtility.KuroTencentCOSLibrary.SetSendLogZipName
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           ZipFileName                                            (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKuroTencentCOSLibrary::SetSendLogZipName(const class FString& ZipFileName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroTencentCOSLibrary", "SetSendLogZipName");

	Params::KuroTencentCOSLibrary_SetSendLogZipName Parms{};

	Parms.ZipFileName = std::move(ZipFileName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroUtility.KuroTickableManager.CreateTickableFunc
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UObject*                          InOwner                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TDelegate<void(float DeltaSeconds)>     TickableHandler                                        (Parm, ZeroConstructor, NativeAccessSpecifierPublic)

void UKuroTickableManager::CreateTickableFunc(class UObject* InOwner, TDelegate<void(float DeltaSeconds)> TickableHandler)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KuroTickableManager", "CreateTickableFunc");

	Params::KuroTickableManager_CreateTickableFunc Parms{};

	Parms.InOwner = InOwner;
	Parms.TickableHandler = TickableHandler;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroUtility.KuroTickableManager.RemoveTickableFunc
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UObject*                          InOwner                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKuroTickableManager::RemoveTickableFunc(class UObject* InOwner)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KuroTickableManager", "RemoveTickableFunc");

	Params::KuroTickableManager_RemoveTickableFunc Parms{};

	Parms.InOwner = InOwner;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroUtility.KuroTriggerVolumeManager.GetKuroTriggerVolume
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             ActorKey                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* UKuroTriggerVolumeManager::GetKuroTriggerVolume(class FName ActorKey)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KuroTriggerVolumeManager", "GetKuroTriggerVolume");

	Params::KuroTriggerVolumeManager_GetKuroTriggerVolume Parms{};

	Parms.ActorKey = ActorKey;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroUtility.LoadMapNotify.BindBeginLoadMap
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TDelegate<void(const class FString& MapName)>BeginLoadMapHandler                                    (Parm, ZeroConstructor, NativeAccessSpecifierPublic)

void ULoadMapNotify::BindBeginLoadMap(TDelegate<void(const class FString& MapName)> BeginLoadMapHandler)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LoadMapNotify", "BindBeginLoadMap");

	Params::LoadMapNotify_BindBeginLoadMap Parms{};

	Parms.BeginLoadMapHandler = BeginLoadMapHandler;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroUtility.LoadMapNotify.BindBeginTravelLoadMap
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TDelegate<void(const class FString& MapName)>BeginTravelLoadMapHandler                              (Parm, ZeroConstructor, NativeAccessSpecifierPublic)

void ULoadMapNotify::BindBeginTravelLoadMap(TDelegate<void(const class FString& MapName)> BeginTravelLoadMapHandler)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LoadMapNotify", "BindBeginTravelLoadMap");

	Params::LoadMapNotify_BindBeginTravelLoadMap Parms{};

	Parms.BeginTravelLoadMapHandler = BeginTravelLoadMapHandler;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroUtility.LoadMapNotify.BindEndLoadMap
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TDelegate<void(const class FString& MapName)>EndLoadMapHandler                                      (Parm, ZeroConstructor, NativeAccessSpecifierPublic)

void ULoadMapNotify::BindEndLoadMap(TDelegate<void(const class FString& MapName)> EndLoadMapHandler)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LoadMapNotify", "BindEndLoadMap");

	Params::LoadMapNotify_BindEndLoadMap Parms{};

	Parms.EndLoadMapHandler = EndLoadMapHandler;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroUtility.LoadMapNotify.BindEndLoadTransitionMap
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TDelegate<void()>                       EndLoadTransitionMapHandler                            (Parm, ZeroConstructor, NativeAccessSpecifierPublic)

void ULoadMapNotify::BindEndLoadTransitionMap(TDelegate<void()> EndLoadTransitionMapHandler)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LoadMapNotify", "BindEndLoadTransitionMap");

	Params::LoadMapNotify_BindEndLoadTransitionMap Parms{};

	Parms.EndLoadTransitionMapHandler = EndLoadTransitionMapHandler;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroUtility.LoadMapNotify.BindLoadStreamLevel
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TDelegate<void(int32 LinkId, class FName& LevelName, class ULevelStreaming* StreamingLevel)>LoadStreamLevelHandler                                 (ConstParm, Parm, ZeroConstructor, NativeAccessSpecifierPublic)

void ULoadMapNotify::BindLoadStreamLevel(const TDelegate<void(int32 LinkId, class FName& LevelName, class ULevelStreaming* StreamingLevel)> LoadStreamLevelHandler)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LoadMapNotify", "BindLoadStreamLevel");

	Params::LoadMapNotify_BindLoadStreamLevel Parms{};

	Parms.LoadStreamLevelHandler = LoadStreamLevelHandler;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroUtility.LoadMapNotify.BindUnLoadStreamLevel
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TDelegate<void(int32 LinkId, class FName& LevelName)>UnLoadStreamLevelHandler                               (ConstParm, Parm, ZeroConstructor, NativeAccessSpecifierPublic)

void ULoadMapNotify::BindUnLoadStreamLevel(const TDelegate<void(int32 LinkId, class FName& LevelName)> UnLoadStreamLevelHandler)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LoadMapNotify", "BindUnLoadStreamLevel");

	Params::LoadMapNotify_BindUnLoadStreamLevel Parms{};

	Parms.UnLoadStreamLevelHandler = UnLoadStreamLevelHandler;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroUtility.LoadMapNotify.Clear
// (Final, Native, Public, BlueprintCallable)

void ULoadMapNotify::Clear()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LoadMapNotify", "Clear");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function KuroUtility.LoadMapNotify.LoadStreamLevel
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             Path                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bMakeVisibleAfterLoad                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bShouldBlockOnLoad                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ULoadMapNotify::LoadStreamLevel(const class FName& Path, bool bMakeVisibleAfterLoad, bool bShouldBlockOnLoad)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LoadMapNotify", "LoadStreamLevel");

	Params::LoadMapNotify_LoadStreamLevel Parms{};

	Parms.Path = Path;
	Parms.bMakeVisibleAfterLoad = bMakeVisibleAfterLoad;
	Parms.bShouldBlockOnLoad = bShouldBlockOnLoad;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroUtility.LoadMapNotify.OnLoadStreamLevel
// (Final, Native, Private)
// Parameters:
// int32                                   LinkID                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULoadMapNotify::OnLoadStreamLevel(const int32 LinkID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LoadMapNotify", "OnLoadStreamLevel");

	Params::LoadMapNotify_OnLoadStreamLevel Parms{};

	Parms.LinkID = LinkID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroUtility.LoadMapNotify.OnUnLoadStreamLevel
// (Final, Native, Private)
// Parameters:
// int32                                   LinkID                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULoadMapNotify::OnUnLoadStreamLevel(const int32 LinkID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LoadMapNotify", "OnUnLoadStreamLevel");

	Params::LoadMapNotify_OnUnLoadStreamLevel Parms{};

	Parms.LinkID = LinkID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroUtility.LoadMapNotify.UnloadStreamLevel
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             Path                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bShouldBlockOnLoad                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ULoadMapNotify::UnloadStreamLevel(const class FName& Path, bool bShouldBlockOnLoad)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LoadMapNotify", "UnloadStreamLevel");

	Params::LoadMapNotify_UnloadStreamLevel Parms{};

	Parms.Path = Path;
	Parms.bShouldBlockOnLoad = bShouldBlockOnLoad;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroUtility.KuroTickManager.AddPrerequisiteActor
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ETickingGroup                           TickingGroup                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Priority                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKuroTickManager::AddPrerequisiteActor(const ETickingGroup TickingGroup, class AActor* Actor, int32 Priority)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KuroTickManager", "AddPrerequisiteActor");

	Params::KuroTickManager_AddPrerequisiteActor Parms{};

	Parms.TickingGroup = TickingGroup;
	Parms.Actor = Actor;
	Parms.Priority = Priority;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroUtility.KuroTickManager.AddPrerequisiteActorComponent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ETickingGroup                           TickingGroup                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UActorComponent*                  ActorComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Priority                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKuroTickManager::AddPrerequisiteActorComponent(const ETickingGroup TickingGroup, class UActorComponent* ActorComp, int32 Priority)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KuroTickManager", "AddPrerequisiteActorComponent");

	Params::KuroTickManager_AddPrerequisiteActorComponent Parms{};

	Parms.TickingGroup = TickingGroup;
	Parms.ActorComp = ActorComp;
	Parms.Priority = Priority;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroUtility.KuroTickManager.AddTick
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ETickingGroup                           TickingGroup                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TDelegate<void(float DeltaSeconds)>     TickHandler                                            (ConstParm, Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// int32                                   Priority                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKuroTickManager::AddTick(const ETickingGroup TickingGroup, const TDelegate<void(float DeltaSeconds)> TickHandler, int32 Priority)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KuroTickManager", "AddTick");

	Params::KuroTickManager_AddTick Parms{};

	Parms.TickingGroup = TickingGroup;
	Parms.TickHandler = TickHandler;
	Parms.Priority = Priority;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroUtility.KuroTickManager.CleanCharacterMovementProxyTickFunction
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UCharacterMovementComponent*      MoveComp                                               (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKuroTickManager::CleanCharacterMovementProxyTickFunction(class UCharacterMovementComponent* MoveComp)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KuroTickManager", "CleanCharacterMovementProxyTickFunction");

	Params::KuroTickManager_CleanCharacterMovementProxyTickFunction Parms{};

	Parms.MoveComp = MoveComp;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroUtility.KuroTickManager.CleanSkeletalMeshProxyTickFunction
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class USkeletalMeshComponent*           SkeletalComp                                           (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKuroTickManager::CleanSkeletalMeshProxyTickFunction(class USkeletalMeshComponent* SkeletalComp)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KuroTickManager", "CleanSkeletalMeshProxyTickFunction");

	Params::KuroTickManager_CleanSkeletalMeshProxyTickFunction Parms{};

	Parms.SkeletalComp = SkeletalComp;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroUtility.KuroTickManager.ClearTick
// (Final, Native, Public, BlueprintCallable)

void UKuroTickManager::ClearTick()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KuroTickManager", "ClearTick");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function KuroUtility.KuroTickManager.RemovePrerequisiteActor
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ETickingGroup                           TickingGroup                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Priority                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKuroTickManager::RemovePrerequisiteActor(const ETickingGroup TickingGroup, class AActor* Actor, int32 Priority)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KuroTickManager", "RemovePrerequisiteActor");

	Params::KuroTickManager_RemovePrerequisiteActor Parms{};

	Parms.TickingGroup = TickingGroup;
	Parms.Actor = Actor;
	Parms.Priority = Priority;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroUtility.KuroTickManager.RemovePrerequisiteActorComponent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ETickingGroup                           TickingGroup                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UActorComponent*                  ActorComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Priority                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKuroTickManager::RemovePrerequisiteActorComponent(const ETickingGroup TickingGroup, class UActorComponent* ActorComp, int32 Priority)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KuroTickManager", "RemovePrerequisiteActorComponent");

	Params::KuroTickManager_RemovePrerequisiteActorComponent Parms{};

	Parms.TickingGroup = TickingGroup;
	Parms.ActorComp = ActorComp;
	Parms.Priority = Priority;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroUtility.KuroTickManager.RemoveTick
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ETickingGroup                           TickingGroup                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKuroTickManager::RemoveTick(const ETickingGroup TickingGroup)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KuroTickManager", "RemoveTick");

	Params::KuroTickManager_RemoveTick Parms{};

	Parms.TickingGroup = TickingGroup;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroUtility.KuroTickManager.SetCharacterMovementProxyTickFunction
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ETickingGroup                           TickingGroup                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UCharacterMovementComponent*      MoveComp                                               (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Priority                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKuroTickManager::SetCharacterMovementProxyTickFunction(const ETickingGroup TickingGroup, class UCharacterMovementComponent* MoveComp, int32 Priority)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KuroTickManager", "SetCharacterMovementProxyTickFunction");

	Params::KuroTickManager_SetCharacterMovementProxyTickFunction Parms{};

	Parms.TickingGroup = TickingGroup;
	Parms.MoveComp = MoveComp;
	Parms.Priority = Priority;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroUtility.KuroTickManager.SetSkeletalMeshProxyTickFunction
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ETickingGroup                           TickingGroup                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USkeletalMeshComponent*           SkeletalComp                                           (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Priority                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKuroTickManager::SetSkeletalMeshProxyTickFunction(const ETickingGroup TickingGroup, class USkeletalMeshComponent* SkeletalComp, int32 Priority)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KuroTickManager", "SetSkeletalMeshProxyTickFunction");

	Params::KuroTickManager_SetSkeletalMeshProxyTickFunction Parms{};

	Parms.TickingGroup = TickingGroup;
	Parms.SkeletalComp = SkeletalComp;
	Parms.Priority = Priority;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroUtility.KuroTickManager.SetTickFunctionCompletionCallbackInMainThread
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ETickingGroup                           TickingGroup                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Priority                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKuroTickManager::SetTickFunctionCompletionCallbackInMainThread(const ETickingGroup TickingGroup, int32 Priority)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KuroTickManager", "SetTickFunctionCompletionCallbackInMainThread");

	Params::KuroTickManager_SetTickFunctionCompletionCallbackInMainThread Parms{};

	Parms.TickingGroup = TickingGroup;
	Parms.Priority = Priority;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}

}

