#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: TASdkPlugin

#include "Basic.hpp"

#include "TASdkPlugin_classes.hpp"
#include "TASdkPlugin_parameters.hpp"


namespace SDK
{

// Function TASdkPlugin.ThinkingAnalytics.CalibrateTime
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const TDelegate<void(int32 Index)>&     OnTimeCalibrated                                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// int32                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UThinkingAnalytics::CalibrateTime(const TDelegate<void(int32 Index)>& OnTimeCalibrated, int32 Index_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ThinkingAnalytics", "CalibrateTime");

	Params::ThinkingAnalytics_CalibrateTime Parms{};

	Parms.OnTimeCalibrated = OnTimeCalibrated;
	Parms.Index_0 = Index_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TASdkPlugin.ThinkingAnalytics.CreateSimpleInstance
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FCreateInstanceParam&      Param                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UThinkingAnalytics::CreateSimpleInstance(const struct FCreateInstanceParam& Param)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ThinkingAnalytics", "CreateSimpleInstance");

	Params::ThinkingAnalytics_CreateSimpleInstance Parms{};

	Parms.Param = std::move(Param);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TASdkPlugin.ThinkingAnalytics.DestroyAllInstance
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const bool                              Flush_0                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UThinkingAnalytics::DestroyAllInstance(const bool Flush_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ThinkingAnalytics", "DestroyAllInstance");

	Params::ThinkingAnalytics_DestroyAllInstance Parms{};

	Parms.Flush_0 = Flush_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TASdkPlugin.ThinkingAnalytics.DestroyInstance
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const int32                             Index_0                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const bool                              Flush_0                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UThinkingAnalytics::DestroyInstance(const int32 Index_0, const bool Flush_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ThinkingAnalytics", "DestroyInstance");

	Params::ThinkingAnalytics_DestroyInstance Parms{};

	Parms.Index_0 = Index_0;
	Parms.Flush_0 = Flush_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TASdkPlugin.ThinkingAnalytics.EnableAutoTrack
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UThinkingAnalytics::EnableAutoTrack(int32 Index_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ThinkingAnalytics", "EnableAutoTrack");

	Params::ThinkingAnalytics_EnableAutoTrack Parms{};

	Parms.Index_0 = Index_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TASdkPlugin.ThinkingAnalytics.EnableAutoTrackWithType
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const TArray<class FString>&            EventTypeList                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// int32                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UThinkingAnalytics::EnableAutoTrackWithType(const TArray<class FString>& EventTypeList, int32 Index_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ThinkingAnalytics", "EnableAutoTrackWithType");

	Params::ThinkingAnalytics_EnableAutoTrackWithType Parms{};

	Parms.EventTypeList = std::move(EventTypeList);
	Parms.Index_0 = Index_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TASdkPlugin.ThinkingAnalytics.EnableAutoTrackWithTypeAndProperties
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const TArray<class FString>&            EventTypeList                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// const class FString&                    Properties                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UThinkingAnalytics::EnableAutoTrackWithTypeAndProperties(const TArray<class FString>& EventTypeList, const class FString& Properties, int32 Index_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ThinkingAnalytics", "EnableAutoTrackWithTypeAndProperties");

	Params::ThinkingAnalytics_EnableAutoTrackWithTypeAndProperties Parms{};

	Parms.EventTypeList = std::move(EventTypeList);
	Parms.Properties = std::move(Properties);
	Parms.Index_0 = Index_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TASdkPlugin.ThinkingAnalytics.EnableThirdPartySharing
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const TArray<class FString>&            EventTypeList                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// int32                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UThinkingAnalytics::EnableThirdPartySharing(const TArray<class FString>& EventTypeList, int32 Index_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ThinkingAnalytics", "EnableThirdPartySharing");

	Params::ThinkingAnalytics_EnableThirdPartySharing Parms{};

	Parms.EventTypeList = std::move(EventTypeList);
	Parms.Index_0 = Index_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TASdkPlugin.ThinkingAnalytics.EnableTracking
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    bIsEnable                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UThinkingAnalytics::EnableTracking(bool bIsEnable, int32 Index_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ThinkingAnalytics", "EnableTracking");

	Params::ThinkingAnalytics_EnableTracking Parms{};

	Parms.bIsEnable = bIsEnable;
	Parms.Index_0 = Index_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TASdkPlugin.ThinkingAnalytics.Flush
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UThinkingAnalytics::Flush(int32 Index_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ThinkingAnalytics", "Flush");

	Params::ThinkingAnalytics_Flush Parms{};

	Parms.Index_0 = Index_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TASdkPlugin.ThinkingAnalytics.GetAppId
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const int32                             Index_0                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UThinkingAnalytics::GetAppId(const int32 Index_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ThinkingAnalytics", "GetAppId");

	Params::ThinkingAnalytics_GetAppId Parms{};

	Parms.Index_0 = Index_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TASdkPlugin.ThinkingAnalytics.GetCurrentCPUSampledAvgFrequency
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UThinkingAnalytics::GetCurrentCPUSampledAvgFrequency()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ThinkingAnalytics", "GetCurrentCPUSampledAvgFrequency");

	Params::ThinkingAnalytics_GetCurrentCPUSampledAvgFrequency Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TASdkPlugin.ThinkingAnalytics.GetCurrentCPUSampledMaxFrequency
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UThinkingAnalytics::GetCurrentCPUSampledMaxFrequency()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ThinkingAnalytics", "GetCurrentCPUSampledMaxFrequency");

	Params::ThinkingAnalytics_GetCurrentCPUSampledMaxFrequency Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TASdkPlugin.ThinkingAnalytics.GetDeviceId
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UThinkingAnalytics::GetDeviceId(int32 Index_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ThinkingAnalytics", "GetDeviceId");

	Params::ThinkingAnalytics_GetDeviceId Parms{};

	Parms.Index_0 = Index_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TASdkPlugin.ThinkingAnalytics.GetDistinctId
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UThinkingAnalytics::GetDistinctId(int32 Index_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ThinkingAnalytics", "GetDistinctId");

	Params::ThinkingAnalytics_GetDistinctId Parms{};

	Parms.Index_0 = Index_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TASdkPlugin.ThinkingAnalytics.GetMachineID
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UThinkingAnalytics::GetMachineID()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ThinkingAnalytics", "GetMachineID");

	Params::ThinkingAnalytics_GetMachineID Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TASdkPlugin.ThinkingAnalytics.GetPresetProperties
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UThinkingAnalytics::GetPresetProperties(int32 Index_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ThinkingAnalytics", "GetPresetProperties");

	Params::ThinkingAnalytics_GetPresetProperties Parms{};

	Parms.Index_0 = Index_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TASdkPlugin.ThinkingAnalytics.GetServerUrl
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const int32                             Index_0                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UThinkingAnalytics::GetServerUrl(const int32 Index_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ThinkingAnalytics", "GetServerUrl");

	Params::ThinkingAnalytics_GetServerUrl Parms{};

	Parms.Index_0 = Index_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TASdkPlugin.ThinkingAnalytics.GetSuperProperties
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UThinkingAnalytics::GetSuperProperties(int32 Index_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ThinkingAnalytics", "GetSuperProperties");

	Params::ThinkingAnalytics_GetSuperProperties Parms{};

	Parms.Index_0 = Index_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TASdkPlugin.ThinkingAnalytics.HasDefaultInstanceInitialized
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UThinkingAnalytics::HasDefaultInstanceInitialized()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ThinkingAnalytics", "HasDefaultInstanceInitialized");

	Params::ThinkingAnalytics_HasDefaultInstanceInitialized Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TASdkPlugin.ThinkingAnalytics.HasInstanceInitialized
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UThinkingAnalytics::HasInstanceInitialized(int32 Index_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ThinkingAnalytics", "HasInstanceInitialized");

	Params::ThinkingAnalytics_HasInstanceInitialized Parms{};

	Parms.Index_0 = Index_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TASdkPlugin.ThinkingAnalytics.HasInstanceTimeCalibrated
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UThinkingAnalytics::HasInstanceTimeCalibrated(int32 Index_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ThinkingAnalytics", "HasInstanceTimeCalibrated");

	Params::ThinkingAnalytics_HasInstanceTimeCalibrated Parms{};

	Parms.Index_0 = Index_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TASdkPlugin.ThinkingAnalytics.Identify
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class FString&                    DistinctId                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UThinkingAnalytics::Identify(const class FString& DistinctId, int32 Index_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ThinkingAnalytics", "Identify");

	Params::ThinkingAnalytics_Identify Parms{};

	Parms.DistinctId = std::move(DistinctId);
	Parms.Index_0 = Index_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TASdkPlugin.ThinkingAnalytics.Initialize
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UThinkingAnalytics::Initialize()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ThinkingAnalytics", "Initialize");

	Params::ThinkingAnalytics_Initialize Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TASdkPlugin.ThinkingAnalytics.InitializeDefaultInsWithURL_Appid
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class FString&                    ServerURL                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    Appid                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const float                             ExitWaitTime                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const int32                             MaxPendingLog                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const float                             SendHttpTimeout                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const bool                              bExitFlush                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const float                             CalibrateIntervalTime                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const bool                              bCalibratedStopTimer                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UThinkingAnalytics::InitializeDefaultInsWithURL_Appid(const class FString& ServerURL, const class FString& Appid, const float ExitWaitTime, const int32 MaxPendingLog, const float SendHttpTimeout, const bool bExitFlush, const float CalibrateIntervalTime, const bool bCalibratedStopTimer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ThinkingAnalytics", "InitializeDefaultInsWithURL_Appid");

	Params::ThinkingAnalytics_InitializeDefaultInsWithURL_Appid Parms{};

	Parms.ServerURL = std::move(ServerURL);
	Parms.Appid = std::move(Appid);
	Parms.ExitWaitTime = ExitWaitTime;
	Parms.MaxPendingLog = MaxPendingLog;
	Parms.SendHttpTimeout = SendHttpTimeout;
	Parms.bExitFlush = bExitFlush;
	Parms.CalibrateIntervalTime = CalibrateIntervalTime;
	Parms.bCalibratedStopTimer = bCalibratedStopTimer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TASdkPlugin.ThinkingAnalytics.InitializeEncryptInstance
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class FString&                    appid                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    serverurl                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ETAMode                                 mode                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bEnableLog                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    timeZone                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bEnableEncrypt                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    EncryptPublicKey                                       (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   EncryptVersion                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    SymmetricEncryption                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    AsymmetricEncryption                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UThinkingAnalytics::InitializeEncryptInstance(const class FString& appid, const class FString& serverurl, ETAMode mode, bool bEnableLog, const class FString& timeZone, bool bEnableEncrypt, const class FString& EncryptPublicKey, int32 EncryptVersion, const class FString& SymmetricEncryption, const class FString& AsymmetricEncryption)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ThinkingAnalytics", "InitializeEncryptInstance");

	Params::ThinkingAnalytics_InitializeEncryptInstance Parms{};

	Parms.appid = std::move(appid);
	Parms.serverurl = std::move(serverurl);
	Parms.mode = mode;
	Parms.bEnableLog = bEnableLog;
	Parms.timeZone = std::move(timeZone);
	Parms.bEnableEncrypt = bEnableEncrypt;
	Parms.EncryptPublicKey = std::move(EncryptPublicKey);
	Parms.EncryptVersion = EncryptVersion;
	Parms.SymmetricEncryption = std::move(SymmetricEncryption);
	Parms.AsymmetricEncryption = std::move(AsymmetricEncryption);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TASdkPlugin.ThinkingAnalytics.Login
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class FString&                    AccountId                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UThinkingAnalytics::Login(const class FString& AccountId, int32 Index_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ThinkingAnalytics", "Login");

	Params::ThinkingAnalytics_Login Parms{};

	Parms.AccountId = std::move(AccountId);
	Parms.Index_0 = Index_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TASdkPlugin.ThinkingAnalytics.Logout
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UThinkingAnalytics::Logout(int32 Index_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ThinkingAnalytics", "Logout");

	Params::ThinkingAnalytics_Logout Parms{};

	Parms.Index_0 = Index_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TASdkPlugin.ThinkingAnalytics.OptInTracking
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UThinkingAnalytics::OptInTracking(int32 Index_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ThinkingAnalytics", "OptInTracking");

	Params::ThinkingAnalytics_OptInTracking Parms{};

	Parms.Index_0 = Index_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TASdkPlugin.ThinkingAnalytics.OptOutTracking
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UThinkingAnalytics::OptOutTracking(int32 Index_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ThinkingAnalytics", "OptOutTracking");

	Params::ThinkingAnalytics_OptOutTracking Parms{};

	Parms.Index_0 = Index_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TASdkPlugin.ThinkingAnalytics.SetTrackStatus
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const int32                             Status                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UThinkingAnalytics::SetTrackStatus(const int32 Status, int32 Index_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ThinkingAnalytics", "SetTrackStatus");

	Params::ThinkingAnalytics_SetTrackStatus Parms{};

	Parms.Status = Status;
	Parms.Index_0 = Index_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TASdkPlugin.ThinkingAnalytics.TimeEvent
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class FString&                    EventName                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UThinkingAnalytics::TimeEvent(const class FString& EventName, int32 Index_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ThinkingAnalytics", "TimeEvent");

	Params::ThinkingAnalytics_TimeEvent Parms{};

	Parms.EventName = std::move(EventName);
	Parms.Index_0 = Index_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TASdkPlugin.ThinkingAnalytics.ToggleSampleCPUFrequency
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    bActive                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   SampleInterval                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UThinkingAnalytics::ToggleSampleCPUFrequency(bool bActive, float SampleInterval)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ThinkingAnalytics", "ToggleSampleCPUFrequency");

	Params::ThinkingAnalytics_ToggleSampleCPUFrequency Parms{};

	Parms.bActive = bActive;
	Parms.SampleInterval = SampleInterval;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TASdkPlugin.ThinkingAnalytics.Track
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class FString&                    EventName                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    Properties                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UThinkingAnalytics::Track(const class FString& EventName, const class FString& Properties, int32 Index_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ThinkingAnalytics", "Track");

	Params::ThinkingAnalytics_Track Parms{};

	Parms.EventName = std::move(EventName);
	Parms.Properties = std::move(Properties);
	Parms.Index_0 = Index_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TASdkPlugin.ThinkingAnalytics.TrackFirst
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class FString&                    EventName                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    Properties                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UThinkingAnalytics::TrackFirst(const class FString& EventName, const class FString& Properties, int32 Index_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ThinkingAnalytics", "TrackFirst");

	Params::ThinkingAnalytics_TrackFirst Parms{};

	Parms.EventName = std::move(EventName);
	Parms.Properties = std::move(Properties);
	Parms.Index_0 = Index_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TASdkPlugin.ThinkingAnalytics.TrackFirstWithId
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class FString&                    EventName                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    Properties                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    FirstCheckId                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UThinkingAnalytics::TrackFirstWithId(const class FString& EventName, const class FString& Properties, const class FString& FirstCheckId, int32 Index_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ThinkingAnalytics", "TrackFirstWithId");

	Params::ThinkingAnalytics_TrackFirstWithId Parms{};

	Parms.EventName = std::move(EventName);
	Parms.Properties = std::move(Properties);
	Parms.FirstCheckId = std::move(FirstCheckId);
	Parms.Index_0 = Index_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TASdkPlugin.ThinkingAnalytics.TrackOverwrite
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class FString&                    EventName                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    Properties                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    EventId                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UThinkingAnalytics::TrackOverwrite(const class FString& EventName, const class FString& Properties, const class FString& EventId, int32 Index_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ThinkingAnalytics", "TrackOverwrite");

	Params::ThinkingAnalytics_TrackOverwrite Parms{};

	Parms.EventName = std::move(EventName);
	Parms.Properties = std::move(Properties);
	Parms.EventId = std::move(EventId);
	Parms.Index_0 = Index_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TASdkPlugin.ThinkingAnalytics.TrackUpdate
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class FString&                    EventName                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    Properties                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    EventId                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UThinkingAnalytics::TrackUpdate(const class FString& EventName, const class FString& Properties, const class FString& EventId, int32 Index_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ThinkingAnalytics", "TrackUpdate");

	Params::ThinkingAnalytics_TrackUpdate Parms{};

	Parms.EventName = std::move(EventName);
	Parms.Properties = std::move(Properties);
	Parms.EventId = std::move(EventId);
	Parms.Index_0 = Index_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TASdkPlugin.ThinkingAnalytics.UserAdd
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class FString&                    Property                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const float                             Value                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UThinkingAnalytics::UserAdd(const class FString& Property, const float Value, int32 Index_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ThinkingAnalytics", "UserAdd");

	Params::ThinkingAnalytics_UserAdd Parms{};

	Parms.Property = std::move(Property);
	Parms.Value = Value;
	Parms.Index_0 = Index_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TASdkPlugin.ThinkingAnalytics.UserAppend
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class FString&                    Properties                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UThinkingAnalytics::UserAppend(const class FString& Properties, int32 Index_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ThinkingAnalytics", "UserAppend");

	Params::ThinkingAnalytics_UserAppend Parms{};

	Parms.Properties = std::move(Properties);
	Parms.Index_0 = Index_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TASdkPlugin.ThinkingAnalytics.UserDelete
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UThinkingAnalytics::UserDelete(int32 Index_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ThinkingAnalytics", "UserDelete");

	Params::ThinkingAnalytics_UserDelete Parms{};

	Parms.Index_0 = Index_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TASdkPlugin.ThinkingAnalytics.UserSet
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class FString&                    Properties                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UThinkingAnalytics::UserSet(const class FString& Properties, int32 Index_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ThinkingAnalytics", "UserSet");

	Params::ThinkingAnalytics_UserSet Parms{};

	Parms.Properties = std::move(Properties);
	Parms.Index_0 = Index_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TASdkPlugin.ThinkingAnalytics.UserSetOnce
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class FString&                    Properties                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UThinkingAnalytics::UserSetOnce(const class FString& Properties, int32 Index_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ThinkingAnalytics", "UserSetOnce");

	Params::ThinkingAnalytics_UserSetOnce Parms{};

	Parms.Properties = std::move(Properties);
	Parms.Index_0 = Index_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TASdkPlugin.ThinkingAnalytics.UserUniqueAppend
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class FString&                    Properties                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UThinkingAnalytics::UserUniqueAppend(const class FString& Properties, int32 Index_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ThinkingAnalytics", "UserUniqueAppend");

	Params::ThinkingAnalytics_UserUniqueAppend Parms{};

	Parms.Properties = std::move(Properties);
	Parms.Index_0 = Index_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TASdkPlugin.ThinkingAnalytics.UserUnset
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class FString&                    Property                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UThinkingAnalytics::UserUnset(const class FString& Property, int32 Index_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ThinkingAnalytics", "UserUnset");

	Params::ThinkingAnalytics_UserUnset Parms{};

	Parms.Property = std::move(Property);
	Parms.Index_0 = Index_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}

}

