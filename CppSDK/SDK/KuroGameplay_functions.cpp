#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: KuroGameplay

#include "Basic.hpp"

#include "KuroGameplay_classes.hpp"
#include "KuroGameplay_parameters.hpp"


namespace SDK
{

// Function KuroGameplay.KuroInputEvent.DoActionCallback
// (Final, Native, Public)
// Parameters:
// const struct FKey&                      Key                                                    (Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKuroInputEvent::DoActionCallback(const struct FKey& Key)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KuroInputEvent", "DoActionCallback");

	Params::KuroInputEvent_DoActionCallback Parms{};

	Parms.Key = std::move(Key);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroGameplay.KuroInputEvent.DoAxisCallback
// (Final, Native, Public)
// Parameters:
// float                                   value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKuroInputEvent::DoAxisCallback(float value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KuroInputEvent", "DoAxisCallback");

	Params::KuroInputEvent_DoAxisCallback Parms{};

	Parms.value = value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroGameplay.KuroInputEvent.DoKeyCallback
// (Final, Native, Public)
// Parameters:
// const struct FKey&                      Key                                                    (Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKuroInputEvent::DoKeyCallback(const struct FKey& Key)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KuroInputEvent", "DoKeyCallback");

	Params::KuroInputEvent_DoKeyCallback Parms{};

	Parms.Key = std::move(Key);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroGameplay.KuroInputEvent.DoTouchCallback
// (Final, Native, Public, HasDefaults)
// Parameters:
// const ETouchIndex                       touchIndex                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   position                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKuroInputEvent::DoTouchCallback(const ETouchIndex touchIndex, const struct FVector& position)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KuroInputEvent", "DoTouchCallback");

	Params::KuroInputEvent_DoTouchCallback Parms{};

	Parms.touchIndex = touchIndex;
	Parms.position = std::move(position);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroGameplay.KuroLevelPlayLibrary.FakeAddAlwaysLoadedActorsToWorld
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class UWorld*                     World                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKuroLevelPlayLibrary::FakeAddAlwaysLoadedActorsToWorld(const class UWorld* World)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroLevelPlayLibrary", "FakeAddAlwaysLoadedActorsToWorld");

	Params::KuroLevelPlayLibrary_FakeAddAlwaysLoadedActorsToWorld Parms{};

	Parms.World = World;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroGameplay.KuroLevelPlayLibrary.FakeRemoveAlwaysLoadedActorsFromWorld
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class UWorld*                     World                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKuroLevelPlayLibrary::FakeRemoveAlwaysLoadedActorsFromWorld(const class UWorld* World)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroLevelPlayLibrary", "FakeRemoveAlwaysLoadedActorsFromWorld");

	Params::KuroLevelPlayLibrary_FakeRemoveAlwaysLoadedActorsFromWorld Parms{};

	Parms.World = World;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroGameplay.KuroLevelPlayLibrary.GetActorComponentsBoundingBox
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bNonColliding                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIncludeFromChildActors                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FBox                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FBox UKuroLevelPlayLibrary::GetActorComponentsBoundingBox(class AActor* Actor, bool bNonColliding, bool bIncludeFromChildActors)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroLevelPlayLibrary", "GetActorComponentsBoundingBox");

	Params::KuroLevelPlayLibrary_GetActorComponentsBoundingBox Parms{};

	Parms.Actor = Actor;
	Parms.bNonColliding = bNonColliding;
	Parms.bIncludeFromChildActors = bIncludeFromChildActors;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroGameplay.KuroLevelPlayLibrary.GetActorScreenBoundingBox
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class APlayerController*                PlayerController                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D*                       ScreenMin                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D*                       ScreenMax                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKuroLevelPlayLibrary::GetActorScreenBoundingBox(class APlayerController* PlayerController, class AActor* Actor, struct FVector2D* ScreenMin, struct FVector2D* ScreenMax)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroLevelPlayLibrary", "GetActorScreenBoundingBox");

	Params::KuroLevelPlayLibrary_GetActorScreenBoundingBox Parms{};

	Parms.PlayerController = PlayerController;
	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (ScreenMin != nullptr)
		*ScreenMin = std::move(Parms.ScreenMin);

	if (ScreenMax != nullptr)
		*ScreenMax = std::move(Parms.ScreenMax);

	return Parms.ReturnValue;
}


// Function KuroGameplay.KuroLevelPlayLibrary.GetAllActorsInPersistentLevel
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class AActor*>*                  OutLevelActors                                         (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UKuroLevelPlayLibrary::GetAllActorsInPersistentLevel(const class UObject* WorldContextObject, TArray<class AActor*>* OutLevelActors)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroLevelPlayLibrary", "GetAllActorsInPersistentLevel");

	Params::KuroLevelPlayLibrary_GetAllActorsInPersistentLevel Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutLevelActors != nullptr)
		*OutLevelActors = std::move(Parms.OutLevelActors);
}


// Function KuroGameplay.KuroLevelPlayLibrary.GetCurrentLevelRefPath
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UKuroLevelPlayLibrary::GetCurrentLevelRefPath(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroLevelPlayLibrary", "GetCurrentLevelRefPath");

	Params::KuroLevelPlayLibrary_GetCurrentLevelRefPath Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroGameplay.KuroLevelPlayLibrary.GetEntityIdByBaseItem
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UKuroLevelPlayLibrary::GetEntityIdByBaseItem(class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroLevelPlayLibrary", "GetEntityIdByBaseItem");

	Params::KuroLevelPlayLibrary_GetEntityIdByBaseItem Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroGameplay.KuroLevelPlayLibrary.GetPersistentLevelActorsInPackage
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const class FString&                    PackageName                                            (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class AActor*>*                  OutLevelActors                                         (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UKuroLevelPlayLibrary::GetPersistentLevelActorsInPackage(const class FString& PackageName, TArray<class AActor*>* OutLevelActors)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroLevelPlayLibrary", "GetPersistentLevelActorsInPackage");

	Params::KuroLevelPlayLibrary_GetPersistentLevelActorsInPackage Parms{};

	Parms.PackageName = std::move(PackageName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutLevelActors != nullptr)
		*OutLevelActors = std::move(Parms.OutLevelActors);
}


// Function KuroGameplay.KuroLevelPlayLibrary.GetWorldInPackage
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class FString&                    PackageName                                            (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UWorld*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UWorld* UKuroLevelPlayLibrary::GetWorldInPackage(const class FString& PackageName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroLevelPlayLibrary", "GetWorldInPackage");

	Params::KuroLevelPlayLibrary_GetWorldInPackage Parms{};

	Parms.PackageName = std::move(PackageName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroGameplay.KuroLevelPlayLibrary.RegisterBaseItemInfo
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UClass*                           BaseItemClass                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    EntityIdName                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKuroLevelPlayLibrary::RegisterBaseItemInfo(class UClass* BaseItemClass, const class FString& EntityIdName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroLevelPlayLibrary", "RegisterBaseItemInfo");

	Params::KuroLevelPlayLibrary_RegisterBaseItemInfo Parms{};

	Parms.BaseItemClass = BaseItemClass;
	Parms.EntityIdName = std::move(EntityIdName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroGameplay.KuroInputManager.OnActorDestroy
// (Final, Native, Private)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKuroInputManager::OnActorDestroy(class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KuroInputManager", "OnActorDestroy");

	Params::KuroInputManager_OnActorDestroy Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroGameplay.KuroLockAxisCollisionComponent.SetAxisValue
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   InAxisValue                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKuroLockAxisCollisionComponent::SetAxisValue(float InAxisValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KuroLockAxisCollisionComponent", "SetAxisValue");

	Params::KuroLockAxisCollisionComponent_SetAxisValue Parms{};

	Parms.InAxisValue = InAxisValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroGameplay.KuroLockAxisCollisionComponent.SetLockAxis
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ELockAxis                               InLockAxis                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKuroLockAxisCollisionComponent::SetLockAxis(ELockAxis InLockAxis)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KuroLockAxisCollisionComponent", "SetLockAxis");

	Params::KuroLockAxisCollisionComponent_SetLockAxis Parms{};

	Parms.InLockAxis = InLockAxis;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroGameplay.KuroLockAxisCollisionComponent.UpdateCollisionTransform
// (Final, Native, Public)

void UKuroLockAxisCollisionComponent::UpdateCollisionTransform()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KuroLockAxisCollisionComponent", "UpdateCollisionTransform");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function KuroGameplay.EffectSystemActor.SetOwnerEntityId
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   EntityId                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AEffectSystemActor::SetOwnerEntityId(int32 EntityId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EffectSystemActor", "SetOwnerEntityId");

	Params::EffectSystemActor_SetOwnerEntityId Parms{};

	Parms.EntityId = EntityId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroGameplay.EffectSystemActor.GetEffectType
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 AEffectSystemActor::GetEffectType() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EffectSystemActor", "GetEffectType");

	Params::EffectSystemActor_GetEffectType Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroGameplay.EffectSystemActor.GetHandle
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 AEffectSystemActor::GetHandle() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EffectSystemActor", "GetHandle");

	Params::EffectSystemActor_GetHandle Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroGameplay.EffectSystemActor.GetOwnerEntityId
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 AEffectSystemActor::GetOwnerEntityId() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EffectSystemActor", "GetOwnerEntityId");

	Params::EffectSystemActor_GetOwnerEntityId Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroGameplay.EffectSystemActor.GetTimeScale
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AEffectSystemActor::GetTimeScale() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EffectSystemActor", "GetTimeScale");

	Params::EffectSystemActor_GetTimeScale Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroGameplay.EffectSystemActor.StopEffect
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class FName&                      Reason                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Immediately                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    DestroyActor                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AEffectSystemActor::StopEffect(const class FName& Reason, bool Immediately, bool DestroyActor) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EffectSystemActor", "StopEffect");

	Params::EffectSystemActor_StopEffect Parms{};

	Parms.Reason = Reason;
	Parms.Immediately = Immediately;
	Parms.DestroyActor = DestroyActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroGameplay.GameBudgetAllocator.AfterTickOutside
// (Final, Native, Public)
// Parameters:
// float                                   DeltaSeconds                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameBudgetAllocator::AfterTickOutside(float DeltaSeconds)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameBudgetAllocator", "AfterTickOutside");

	Params::GameBudgetAllocator_AfterTickOutside Parms{};

	Parms.DeltaSeconds = DeltaSeconds;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroGameplay.GameBudgetAllocator.SetCenterActor
// (Final, Native, Public)
// Parameters:
// class AActor*                           CenterActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameBudgetAllocator::SetCenterActor(class AActor* CenterActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameBudgetAllocator", "SetCenterActor");

	Params::GameBudgetAllocator_SetCenterActor Parms{};

	Parms.CenterActor = CenterActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroGameplay.GameBudgetAllocator.SetDefaultTickIntervalDetailConfig
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FGameBudgetAllocatorGroupConfig* Config                                                 (Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)
// uint32                                  MaxTickInterval                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint16                                  TickReductionStartSize                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint16                                  TickReductionIntervalSize                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameBudgetAllocator::SetDefaultTickIntervalDetailConfig(struct FGameBudgetAllocatorGroupConfig* Config, uint32 MaxTickInterval, uint16 TickReductionStartSize, uint16 TickReductionIntervalSize)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameBudgetAllocator", "SetDefaultTickIntervalDetailConfig");

	Params::GameBudgetAllocator_SetDefaultTickIntervalDetailConfig Parms{};

	Parms.MaxTickInterval = MaxTickInterval;
	Parms.TickReductionStartSize = TickReductionStartSize;
	Parms.TickReductionIntervalSize = TickReductionIntervalSize;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Config != nullptr)
		*Config = std::move(Parms.Config);
}


// Function KuroGameplay.GameBudgetAllocator.SetGlobalMode
// (Final, Native, Public)
// Parameters:
// EGameBudgetAllocatorGlobalMode          Mode                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameBudgetAllocator::SetGlobalMode(EGameBudgetAllocatorGlobalMode Mode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameBudgetAllocator", "SetGlobalMode");

	Params::GameBudgetAllocator_SetGlobalMode Parms{};

	Parms.Mode = Mode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroGameplay.GameBudgetAllocator.SetGroupConfig
// (Final, Native, Public, HasOutParams)
// Parameters:
// class FName                             GroupName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameBudgetAllocatorGroupConfig&Config                                                 (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UGameBudgetAllocator::SetGroupConfig(class FName GroupName, const struct FGameBudgetAllocatorGroupConfig& Config)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameBudgetAllocator", "SetGroupConfig");

	Params::GameBudgetAllocator_SetGroupConfig Parms{};

	Parms.GroupName = GroupName;
	Parms.Config = std::move(Config);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroGameplay.GameBudgetAllocator.SetMaximumFrameRate
// (Final, Native, Public)
// Parameters:
// uint32                                  MaxFPS                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameBudgetAllocator::SetMaximumFrameRate(uint32 MaxFPS)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameBudgetAllocator", "SetMaximumFrameRate");

	Params::GameBudgetAllocator_SetMaximumFrameRate Parms{};

	Parms.MaxFPS = MaxFPS;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroGameplay.GameBudgetAllocator.SetTickIntervalDetailConfig
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FGameBudgetAllocatorGroupConfig* Config                                                 (Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)
// EGameBudgetAllocatorGlobalMode          GlobalMode                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EGameBudgetAllocatorActorMode           ActorMode                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint32                                  MaxTickInterval                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint16                                  TickReductionStartSize                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint16                                  TickReductionIntervalSize                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameBudgetAllocator::SetTickIntervalDetailConfig(struct FGameBudgetAllocatorGroupConfig* Config, EGameBudgetAllocatorGlobalMode GlobalMode, EGameBudgetAllocatorActorMode ActorMode, uint32 MaxTickInterval, uint16 TickReductionStartSize, uint16 TickReductionIntervalSize)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameBudgetAllocator", "SetTickIntervalDetailConfig");

	Params::GameBudgetAllocator_SetTickIntervalDetailConfig Parms{};

	Parms.GlobalMode = GlobalMode;
	Parms.ActorMode = ActorMode;
	Parms.MaxTickInterval = MaxTickInterval;
	Parms.TickReductionStartSize = TickReductionStartSize;
	Parms.TickReductionIntervalSize = TickReductionIntervalSize;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Config != nullptr)
		*Config = std::move(Parms.Config);
}


// Function KuroGameplay.GameBudgetAllocator.TickOutside
// (Final, Native, Public)
// Parameters:
// float                                   DeltaSeconds                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameBudgetAllocator::TickOutside(float DeltaSeconds)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameBudgetAllocator", "TickOutside");

	Params::GameBudgetAllocator_TickOutside Parms{};

	Parms.DeltaSeconds = DeltaSeconds;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroGameplay.GameBudgetAllocator.UpdateMinUpdateFIFOBudgetTime
// (Final, Native, Public)
// Parameters:
// float                                   Time                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameBudgetAllocator::UpdateMinUpdateFIFOBudgetTime(float Time)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameBudgetAllocator", "UpdateMinUpdateFIFOBudgetTime");

	Params::GameBudgetAllocator_UpdateMinUpdateFIFOBudgetTime Parms{};

	Parms.Time = Time;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroGameplay.KuroEffectLibrary.AddSceneComponent
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UClass*                           Class_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USceneComponent*                  Parent                                                 (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bDeferredFinish                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USceneComponent*                  ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USceneComponent* UKuroEffectLibrary::AddSceneComponent(class AActor* Actor, class UClass* Class_0, class USceneComponent* Parent, bool bDeferredFinish)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroEffectLibrary", "AddSceneComponent");

	Params::KuroEffectLibrary_AddSceneComponent Parms{};

	Parms.Actor = Actor;
	Parms.Class_0 = Class_0;
	Parms.Parent = Parent;
	Parms.bDeferredFinish = bDeferredFinish;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroGameplay.KuroEffectLibrary.AddSceneComponentWithTransform
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UClass*                           Class_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USceneComponent*                  Parent                                                 (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bDeferredFinish                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FTransform&                Transform                                              (Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// class USceneComponent*                  ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USceneComponent* UKuroEffectLibrary::AddSceneComponentWithTransform(class AActor* Actor, class UClass* Class_0, class USceneComponent* Parent, bool bDeferredFinish, const struct FTransform& Transform)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroEffectLibrary", "AddSceneComponentWithTransform");

	Params::KuroEffectLibrary_AddSceneComponentWithTransform Parms{};

	Parms.Actor = Actor;
	Parms.Class_0 = Class_0;
	Parms.Parent = Parent;
	Parms.bDeferredFinish = bDeferredFinish;
	Parms.Transform = std::move(Transform);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroGameplay.KuroEffectLibrary.DeactivateImmediateNiagaraComponent
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UNiagaraComponent*                NiagaraComponent                                       (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKuroEffectLibrary::DeactivateImmediateNiagaraComponent(class UNiagaraComponent* NiagaraComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroEffectLibrary", "DeactivateImmediateNiagaraComponent");

	Params::KuroEffectLibrary_DeactivateImmediateNiagaraComponent Parms{};

	Parms.NiagaraComponent = NiagaraComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroGameplay.KuroEffectLibrary.EqualWorld
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UWorld*                           World                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UWorld*                           Other                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKuroEffectLibrary::EqualWorld(class UWorld* World, class UWorld* Other)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroEffectLibrary", "EqualWorld");

	Params::KuroEffectLibrary_EqualWorld Parms{};

	Parms.World = World;
	Parms.Other = Other;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroGameplay.KuroEffectLibrary.GetActorDefaultAttachComponent
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USceneComponent*                  ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USceneComponent* UKuroEffectLibrary::GetActorDefaultAttachComponent(class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroEffectLibrary", "GetActorDefaultAttachComponent");

	Params::KuroEffectLibrary_GetActorDefaultAttachComponent Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroGameplay.KuroEffectLibrary.GetNiagaraEffectRegularTypeScalabilitySettingsMaxDistance
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// EKuroNiagaraEffectRegularType           EffectRegularType                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKuroEffectLibrary::GetNiagaraEffectRegularTypeScalabilitySettingsMaxDistance(EKuroNiagaraEffectRegularType EffectRegularType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroEffectLibrary", "GetNiagaraEffectRegularTypeScalabilitySettingsMaxDistance");

	Params::KuroEffectLibrary_GetNiagaraEffectRegularTypeScalabilitySettingsMaxDistance Parms{};

	Parms.EffectRegularType = EffectRegularType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroGameplay.KuroEffectLibrary.GetNiagaraQualityLevel
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UKuroEffectLibrary::GetNiagaraQualityLevel()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroEffectLibrary", "GetNiagaraQualityLevel");

	Params::KuroEffectLibrary_GetNiagaraQualityLevel Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroGameplay.KuroEffectLibrary.GetNiagaraSystemEffectRegularType
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UNiagaraSystem*                   NiagaraSystem                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EKuroNiagaraEffectRegularType           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EKuroNiagaraEffectRegularType UKuroEffectLibrary::GetNiagaraSystemEffectRegularType(class UNiagaraSystem* NiagaraSystem)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroEffectLibrary", "GetNiagaraSystemEffectRegularType");

	Params::KuroEffectLibrary_GetNiagaraSystemEffectRegularType Parms{};

	Parms.NiagaraSystem = NiagaraSystem;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroGameplay.KuroEffectLibrary.GetNpcDisappearDistance
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKuroEffectLibrary::GetNpcDisappearDistance()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroEffectLibrary", "GetNpcDisappearDistance");

	Params::KuroEffectLibrary_GetNpcDisappearDistance Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroGameplay.KuroEffectLibrary.InitModelNiagaraSpec
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UNiagaraComponent*                NiagaraComponent                                       (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bUIScene                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bReceivesDecals                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   TranslucencySortPriority                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKuroEffectLibrary::InitModelNiagaraSpec(class UNiagaraComponent* NiagaraComponent, bool bUIScene, bool bReceivesDecals, int32 TranslucencySortPriority)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroEffectLibrary", "InitModelNiagaraSpec");

	Params::KuroEffectLibrary_InitModelNiagaraSpec Parms{};

	Parms.NiagaraComponent = NiagaraComponent;
	Parms.bUIScene = bUIScene;
	Parms.bReceivesDecals = bReceivesDecals;
	Parms.TranslucencySortPriority = TranslucencySortPriority;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroGameplay.KuroEffectLibrary.IsEffectSystemInEditorNoPIE
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKuroEffectLibrary::IsEffectSystemInEditorNoPIE()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroEffectLibrary", "IsEffectSystemInEditorNoPIE");

	Params::KuroEffectLibrary_IsEffectSystemInEditorNoPIE Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroGameplay.KuroEffectLibrary.IsNiagaraComponentHasBound
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UNiagaraComponent*                NiagaraComponent                                       (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Threshold                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKuroEffectLibrary::IsNiagaraComponentHasBound(class UNiagaraComponent* NiagaraComponent, float Threshold)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroEffectLibrary", "IsNiagaraComponentHasBound");

	Params::KuroEffectLibrary_IsNiagaraComponentHasBound Parms{};

	Parms.NiagaraComponent = NiagaraComponent;
	Parms.Threshold = Threshold;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroGameplay.KuroEffectLibrary.RegisterOnSystemFinished
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UNiagaraComponent*                NiagaraComponent                                       (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKuroEffectLibrary::RegisterOnSystemFinished(class UNiagaraComponent* NiagaraComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroEffectLibrary", "RegisterOnSystemFinished");

	Params::KuroEffectLibrary_RegisterOnSystemFinished Parms{};

	Parms.NiagaraComponent = NiagaraComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroGameplay.KuroEffectLibrary.RegisterOnSystemPaused
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UNiagaraComponent*                NiagaraComponent                                       (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKuroEffectLibrary::RegisterOnSystemPaused(class UNiagaraComponent* NiagaraComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroEffectLibrary", "RegisterOnSystemPaused");

	Params::KuroEffectLibrary_RegisterOnSystemPaused Parms{};

	Parms.NiagaraComponent = NiagaraComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroGameplay.KuroEffectLibrary.SetEffectActorSpawnInUIScene
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Immediately                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKuroEffectLibrary::SetEffectActorSpawnInUIScene(class AActor* Actor, bool Value, bool Immediately)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroEffectLibrary", "SetEffectActorSpawnInUIScene");

	Params::KuroEffectLibrary_SetEffectActorSpawnInUIScene Parms{};

	Parms.Actor = Actor;
	Parms.Value = Value;
	Parms.Immediately = Immediately;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroGameplay.KuroEffectLibrary.SetNiagaraFrameDeltaTime
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UNiagaraComponent*                NiagaraComponent                                       (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DeltaTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKuroEffectLibrary::SetNiagaraFrameDeltaTime(class UNiagaraComponent* NiagaraComponent, float DeltaTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroEffectLibrary", "SetNiagaraFrameDeltaTime");

	Params::KuroEffectLibrary_SetNiagaraFrameDeltaTime Parms{};

	Parms.NiagaraComponent = NiagaraComponent;
	Parms.DeltaTime = DeltaTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroGameplay.KuroEffectLibrary.SetNiagaraSimulationMinDeltaTime
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UNiagaraComponent*                NiagaraComponent                                       (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MinDeltaTime                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKuroEffectLibrary::SetNiagaraSimulationMinDeltaTime(class UNiagaraComponent* NiagaraComponent, float MinDeltaTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroEffectLibrary", "SetNiagaraSimulationMinDeltaTime");

	Params::KuroEffectLibrary_SetNiagaraSimulationMinDeltaTime Parms{};

	Parms.NiagaraComponent = NiagaraComponent;
	Parms.MinDeltaTime = MinDeltaTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroGameplay.KuroEffectLibrary.SetOnSystemFinishedDelegate
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const TDelegate<void(class UNiagaraComponent* NiagaraComponent)>&Delegate                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void UKuroEffectLibrary::SetOnSystemFinishedDelegate(const TDelegate<void(class UNiagaraComponent* NiagaraComponent)>& Delegate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroEffectLibrary", "SetOnSystemFinishedDelegate");

	Params::KuroEffectLibrary_SetOnSystemFinishedDelegate Parms{};

	Parms.Delegate = Delegate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroGameplay.KuroEffectLibrary.SetOnSystemPausedDelegate
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const TDelegate<void(class UNiagaraComponent* NiagaraComponent, bool IsPaused)>&Delegate                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void UKuroEffectLibrary::SetOnSystemPausedDelegate(const TDelegate<void(class UNiagaraComponent* NiagaraComponent, bool IsPaused)>& Delegate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroEffectLibrary", "SetOnSystemPausedDelegate");

	Params::KuroEffectLibrary_SetOnSystemPausedDelegate Parms{};

	Parms.Delegate = Delegate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroGameplay.KuroEffectLibrary.UpdateEffectModelLightSpec
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UEffectModelLight*                EffectModelLight                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPointLightComponent*             LightComponent                                         (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bForceUpdate                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Time                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DefaultMaxLightRadius                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKuroEffectLibrary::UpdateEffectModelLightSpec(class UEffectModelLight* EffectModelLight, class UPointLightComponent* LightComponent, bool bForceUpdate, float Time, float DefaultMaxLightRadius)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroEffectLibrary", "UpdateEffectModelLightSpec");

	Params::KuroEffectLibrary_UpdateEffectModelLightSpec Parms{};

	Parms.EffectModelLight = EffectModelLight;
	Parms.LightComponent = LightComponent;
	Parms.bForceUpdate = bForceUpdate;
	Parms.Time = Time;
	Parms.DefaultMaxLightRadius = DefaultMaxLightRadius;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroGameplay.KuroEffectLibrary.UpdateEffectModelNiagaraSpec
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UEffectModelNiagara*              EffectModelNiagara                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UNiagaraComponent*                NiagaraComponent                                       (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bForceUpdate                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Time                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ExtraState                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKuroEffectLibrary::UpdateEffectModelNiagaraSpec(class UEffectModelNiagara* EffectModelNiagara, class UNiagaraComponent* NiagaraComponent, bool bForceUpdate, float Time, int32 ExtraState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroEffectLibrary", "UpdateEffectModelNiagaraSpec");

	Params::KuroEffectLibrary_UpdateEffectModelNiagaraSpec Parms{};

	Parms.EffectModelNiagara = EffectModelNiagara;
	Parms.NiagaraComponent = NiagaraComponent;
	Parms.bForceUpdate = bForceUpdate;
	Parms.Time = Time;
	Parms.ExtraState = ExtraState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroGameplay.KuroEffectLibrary.UpdateEffectModelPostProcessMaterial
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UEffectModelPostProcess*          EffectModelPostProcess                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UMaterialInstanceDynamic*         DynMaterial                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bForceUpdate                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Time                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKuroEffectLibrary::UpdateEffectModelPostProcessMaterial(class UEffectModelPostProcess* EffectModelPostProcess, class UMaterialInstanceDynamic* DynMaterial, bool bForceUpdate, float Time)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroEffectLibrary", "UpdateEffectModelPostProcessMaterial");

	Params::KuroEffectLibrary_UpdateEffectModelPostProcessMaterial Parms{};

	Parms.EffectModelPostProcess = EffectModelPostProcess;
	Parms.DynMaterial = DynMaterial;
	Parms.bForceUpdate = bForceUpdate;
	Parms.Time = Time;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroGameplay.KuroEffectLibrary.UpdateEffectModelPostProcessSpec
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UEffectModelPostProcess*          EffectModelPostProcess                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UKuroPostProcessComponent*        PostProcessComponent                                   (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bForceUpdate                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Time                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class APlayerController*                Controller                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ACharacter*                       Character                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           EffectActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector2D&                 LastScreenUV                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector2D UKuroEffectLibrary::UpdateEffectModelPostProcessSpec(class UEffectModelPostProcess* EffectModelPostProcess, class UKuroPostProcessComponent* PostProcessComponent, bool bForceUpdate, float Time, class APlayerController* Controller, class ACharacter* Character, class AActor* EffectActor, const struct FVector2D& LastScreenUV)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroEffectLibrary", "UpdateEffectModelPostProcessSpec");

	Params::KuroEffectLibrary_UpdateEffectModelPostProcessSpec Parms{};

	Parms.EffectModelPostProcess = EffectModelPostProcess;
	Parms.PostProcessComponent = PostProcessComponent;
	Parms.bForceUpdate = bForceUpdate;
	Parms.Time = Time;
	Parms.Controller = Controller;
	Parms.Character = Character;
	Parms.EffectActor = EffectActor;
	Parms.LastScreenUV = std::move(LastScreenUV);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroGameplay.KuroLevelPlayCustomCollisionComponent.CanEnableCollision
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKuroLevelPlayCustomCollisionComponent::CanEnableCollision() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KuroLevelPlayCustomCollisionComponent", "CanEnableCollision");

	Params::KuroLevelPlayCustomCollisionComponent_CanEnableCollision Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroGameplay.KuroLevelPlayInterface.ProcessPhysics
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool IKuroLevelPlayInterface::ProcessPhysics()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("KuroLevelPlayInterface", "ProcessPhysics");

	Params::KuroLevelPlayInterface_ProcessPhysics Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroGameplay.KuroLevelPlaySubsystem.ProcessAllItems
// (Final, Native, Public, BlueprintCallable)

void UKuroLevelPlaySubsystem::ProcessAllItems()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KuroLevelPlaySubsystem", "ProcessAllItems");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function KuroGameplay.KuroLevelPlaySubsystem.RegisterObject
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UObject*                          InKuroLevelPlayObject                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKuroLevelPlaySubsystem::RegisterObject(class UObject* InKuroLevelPlayObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KuroLevelPlaySubsystem", "RegisterObject");

	Params::KuroLevelPlaySubsystem_RegisterObject Parms{};

	Parms.InKuroLevelPlayObject = InKuroLevelPlayObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroGameplay.KuroLevelPlaySubsystem.UnregisterObject
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UObject*                          InKuroLevelPlayObject                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKuroLevelPlaySubsystem::UnregisterObject(class UObject* InKuroLevelPlayObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KuroLevelPlaySubsystem", "UnregisterObject");

	Params::KuroLevelPlaySubsystem_UnregisterObject Parms{};

	Parms.InKuroLevelPlayObject = InKuroLevelPlayObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroGameplay.KuroMultilBgProgressBar.SetFillColorAndOpacity
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FLinearColor&              InColor                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKuroMultilBgProgressBar::SetFillColorAndOpacity(const struct FLinearColor& InColor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KuroMultilBgProgressBar", "SetFillColorAndOpacity");

	Params::KuroMultilBgProgressBar_SetFillColorAndOpacity Parms{};

	Parms.InColor = std::move(InColor);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroGameplay.KuroMultilBgProgressBar.SetIsMarquee
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    InbIsMarquee                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKuroMultilBgProgressBar::SetIsMarquee(bool InbIsMarquee)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KuroMultilBgProgressBar", "SetIsMarquee");

	Params::KuroMultilBgProgressBar_SetIsMarquee Parms{};

	Parms.InbIsMarquee = InbIsMarquee;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroGameplay.KuroMultilBgProgressBar.SetMiddlePercent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   InPercent                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKuroMultilBgProgressBar::SetMiddlePercent(float InPercent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KuroMultilBgProgressBar", "SetMiddlePercent");

	Params::KuroMultilBgProgressBar_SetMiddlePercent Parms{};

	Parms.InPercent = InPercent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroGameplay.KuroMultilBgProgressBar.SetPercent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   InPercent                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKuroMultilBgProgressBar::SetPercent(float InPercent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KuroMultilBgProgressBar", "SetPercent");

	Params::KuroMultilBgProgressBar_SetPercent Parms{};

	Parms.InPercent = InPercent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroGameplay.KuroResourceManager.GetAsset
// (Final, Native, Public)
// Parameters:
// const int32                             HandleId                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UObject* UKuroResourceManager::GetAsset(const int32 HandleId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KuroResourceManager", "GetAsset");

	Params::KuroResourceManager_GetAsset Parms{};

	Parms.HandleId = HandleId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroGameplay.KuroResourceManager.LoadAsyncWithId
// (Final, Native, Public)
// Parameters:
// const class FString&                    Path                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const int32                             HandleId                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const int32                             Priority                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UKuroResourceManager::LoadAsyncWithId(const class FString& Path, const int32 HandleId, const int32 Priority)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KuroResourceManager", "LoadAsyncWithId");

	Params::KuroResourceManager_LoadAsyncWithId Parms{};

	Parms.Path = std::move(Path);
	Parms.HandleId = HandleId;
	Parms.Priority = Priority;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroGameplay.KuroResourceManager.LoadWithId
// (Final, Native, Public)
// Parameters:
// const class FString&                    Path                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const int32                             HandleId                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UKuroResourceManager::LoadWithId(const class FString& Path, const int32 HandleId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KuroResourceManager", "LoadWithId");

	Params::KuroResourceManager_LoadWithId Parms{};

	Parms.Path = std::move(Path);
	Parms.HandleId = HandleId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroGameplay.KuroResourceManager.Release
// (Final, Native, Public)
// Parameters:
// const int32                             HandleId                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKuroResourceManager::Release(const int32 HandleId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KuroResourceManager", "Release");

	Params::KuroResourceManager_Release Parms{};

	Parms.HandleId = HandleId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroGameplay.KuroResourceManager.WaitComplete
// (Final, Native, Public)
// Parameters:
// const int32                             HandleId                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const float                             Timeout                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKuroResourceManager::WaitComplete(const int32 HandleId, const float Timeout)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KuroResourceManager", "WaitComplete");

	Params::KuroResourceManager_WaitComplete Parms{};

	Parms.HandleId = HandleId;
	Parms.Timeout = Timeout;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroGameplay.KuroResourceManager.DebugDumpLoadingAssets
// (Final, Native, Public, Const)

void UKuroResourceManager::DebugDumpLoadingAssets() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KuroResourceManager", "DebugDumpLoadingAssets");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function KuroGameplay.KuroResourceManager.GetLoadedAsset
// (Final, Native, Public, Const)
// Parameters:
// const class FString&                    Path                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UObject* UKuroResourceManager::GetLoadedAsset(const class FString& Path) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KuroResourceManager", "GetLoadedAsset");

	Params::KuroResourceManager_GetLoadedAsset Parms{};

	Parms.Path = std::move(Path);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroGameplay.KuroSequenceEaseExecutor.StopEase
// (Native, Public, BlueprintCallable)

void UKuroSequenceEaseExecutor::StopEase()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KuroSequenceEaseExecutor", "StopEase");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function KuroGameplay.KuroSequenceEaseExecutor.UpdateEase
// (Native, Public, BlueprintCallable)
// Parameters:
// float                                   DeltaTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKuroSequenceEaseExecutor::UpdateEase(float DeltaTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KuroSequenceEaseExecutor", "UpdateEase");

	Params::KuroSequenceEaseExecutor_UpdateEase Parms{};

	Parms.DeltaTime = DeltaTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroGameplay.KuroSequenceEaseFloatExecutor.GetDuration
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKuroSequenceEaseFloatExecutor::GetDuration() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KuroSequenceEaseFloatExecutor", "GetDuration");

	Params::KuroSequenceEaseFloatExecutor_GetDuration Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroGameplay.KuroSequenceEaseFloatExecutor.GetStartValue
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKuroSequenceEaseFloatExecutor::GetStartValue() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KuroSequenceEaseFloatExecutor", "GetStartValue");

	Params::KuroSequenceEaseFloatExecutor_GetStartValue Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroGameplay.KuroSequenceEaseFloatExecutor.GetTargetValue
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKuroSequenceEaseFloatExecutor::GetTargetValue() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KuroSequenceEaseFloatExecutor", "GetTargetValue");

	Params::KuroSequenceEaseFloatExecutor_GetTargetValue Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroGameplay.KuroSequenceRuntimeFunctionLibrary.EasePlayRateTo
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// class ALevelSequenceActor*              SequenceActor                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   TargetPlayRate                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EKuroEasingFuncType                     EaseType                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Duration                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Exp                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UKuroSequenceRuntimeFunctionLibrary::EasePlayRateTo(class ALevelSequenceActor* SequenceActor, float TargetPlayRate, EKuroEasingFuncType EaseType, float Duration, float Exp)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroSequenceRuntimeFunctionLibrary", "EasePlayRateTo");

	Params::KuroSequenceRuntimeFunctionLibrary_EasePlayRateTo Parms{};

	Parms.SequenceActor = SequenceActor;
	Parms.TargetPlayRate = TargetPlayRate;
	Parms.EaseType = EaseType;
	Parms.Duration = Duration;
	Parms.Exp = Exp;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroGameplay.KuroSequenceRuntimeFunctionLibrary.FindBindingById
// (Final, Native, Static, Private, HasDefaults, BlueprintCallable)
// Parameters:
// class UMovieSceneSequence*              Sequence                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGuid&                     BindingId                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FSequencerBindingRuntimeProxy    ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FSequencerBindingRuntimeProxy UKuroSequenceRuntimeFunctionLibrary::FindBindingById(class UMovieSceneSequence* Sequence, const struct FGuid& BindingId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroSequenceRuntimeFunctionLibrary", "FindBindingById");

	Params::KuroSequenceRuntimeFunctionLibrary_FindBindingById Parms{};

	Parms.Sequence = Sequence;
	Parms.BindingId = std::move(BindingId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroGameplay.KuroSequenceRuntimeFunctionLibrary.FindMasterTracksByType
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// class UMovieSceneSequence*              Sequence                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class UMovieSceneTrack>     TrackType                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class UMovieSceneTrack*>         ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

TArray<class UMovieSceneTrack*> UKuroSequenceRuntimeFunctionLibrary::FindMasterTracksByType(class UMovieSceneSequence* Sequence, TSubclassOf<class UMovieSceneTrack> TrackType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroSequenceRuntimeFunctionLibrary", "FindMasterTracksByType");

	Params::KuroSequenceRuntimeFunctionLibrary_FindMasterTracksByType Parms{};

	Parms.Sequence = Sequence;
	Parms.TrackType = TrackType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroGameplay.KuroSequenceRuntimeFunctionLibrary.FindTracksByType
// (Final, Native, Static, Private, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FSequencerBindingRuntimeProxy&InBinding                                              (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// TSubclassOf<class UMovieSceneTrack>     TrackType                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class UMovieSceneTrack*>         ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

TArray<class UMovieSceneTrack*> UKuroSequenceRuntimeFunctionLibrary::FindTracksByType(const struct FSequencerBindingRuntimeProxy& InBinding, TSubclassOf<class UMovieSceneTrack> TrackType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroSequenceRuntimeFunctionLibrary", "FindTracksByType");

	Params::KuroSequenceRuntimeFunctionLibrary_FindTracksByType Parms{};

	Parms.InBinding = std::move(InBinding);
	Parms.TrackType = TrackType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroGameplay.KuroSequenceRuntimeFunctionLibrary.GetEndFrame
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// class UMovieSceneSection*               Section                                                (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UKuroSequenceRuntimeFunctionLibrary::GetEndFrame(class UMovieSceneSection* Section)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroSequenceRuntimeFunctionLibrary", "GetEndFrame");

	Params::KuroSequenceRuntimeFunctionLibrary_GetEndFrame Parms{};

	Parms.Section = Section;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroGameplay.KuroSequenceRuntimeFunctionLibrary.GetFadeAmountAt
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// class UMovieSceneFadeSection*           Section                                                (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FFrameTime&                Frame                                                  (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKuroSequenceRuntimeFunctionLibrary::GetFadeAmountAt(class UMovieSceneFadeSection* Section, const struct FFrameTime& Frame)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroSequenceRuntimeFunctionLibrary", "GetFadeAmountAt");

	Params::KuroSequenceRuntimeFunctionLibrary_GetFadeAmountAt Parms{};

	Parms.Section = Section;
	Parms.Frame = std::move(Frame);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroGameplay.KuroSequenceRuntimeFunctionLibrary.GetFrameTransform
// (Final, Native, Static, Private, HasDefaults, BlueprintCallable)
// Parameters:
// class UMovieSceneTrack*                 Track                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FFrameTime&                Frame                                                  (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransform                       ReturnValue                                            (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FTransform UKuroSequenceRuntimeFunctionLibrary::GetFrameTransform(class UMovieSceneTrack* Track, const struct FFrameTime& Frame)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroSequenceRuntimeFunctionLibrary", "GetFrameTransform");

	Params::KuroSequenceRuntimeFunctionLibrary_GetFrameTransform Parms{};

	Parms.Track = Track;
	Parms.Frame = std::move(Frame);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroGameplay.KuroSequenceRuntimeFunctionLibrary.GetFrameTransformByTag
// (Final, Native, Static, Private, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UMovieSceneSequence*              Sequence                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             Tag                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OutsideFrame                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransform*                      OutTransfom                                            (Parm, OutParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKuroSequenceRuntimeFunctionLibrary::GetFrameTransformByTag(class UMovieSceneSequence* Sequence, class FName Tag, int32 OutsideFrame, struct FTransform* OutTransfom)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroSequenceRuntimeFunctionLibrary", "GetFrameTransformByTag");

	Params::KuroSequenceRuntimeFunctionLibrary_GetFrameTransformByTag Parms{};

	Parms.Sequence = Sequence;
	Parms.Tag = Tag;
	Parms.OutsideFrame = OutsideFrame;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutTransfom != nullptr)
		*OutTransfom = std::move(Parms.OutTransfom);

	return Parms.ReturnValue;
}


// Function KuroGameplay.KuroSequenceRuntimeFunctionLibrary.GetMasterTracks
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// class UMovieSceneSequence*              Sequence                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class UMovieSceneTrack*>         ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

TArray<class UMovieSceneTrack*> UKuroSequenceRuntimeFunctionLibrary::GetMasterTracks(class UMovieSceneSequence* Sequence)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroSequenceRuntimeFunctionLibrary", "GetMasterTracks");

	Params::KuroSequenceRuntimeFunctionLibrary_GetMasterTracks Parms{};

	Parms.Sequence = Sequence;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroGameplay.KuroSequenceRuntimeFunctionLibrary.GetObjectTemplate
// (Final, Native, Static, Private, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FSequencerBindingRuntimeProxy&InBinding                                              (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// class UObject*                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UObject* UKuroSequenceRuntimeFunctionLibrary::GetObjectTemplate(const struct FSequencerBindingRuntimeProxy& InBinding)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroSequenceRuntimeFunctionLibrary", "GetObjectTemplate");

	Params::KuroSequenceRuntimeFunctionLibrary_GetObjectTemplate Parms{};

	Parms.InBinding = std::move(InBinding);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroGameplay.KuroSequenceRuntimeFunctionLibrary.GetPlaybackEnd
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// class UMovieSceneSequence*              Sequence                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UKuroSequenceRuntimeFunctionLibrary::GetPlaybackEnd(class UMovieSceneSequence* Sequence)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroSequenceRuntimeFunctionLibrary", "GetPlaybackEnd");

	Params::KuroSequenceRuntimeFunctionLibrary_GetPlaybackEnd Parms{};

	Parms.Sequence = Sequence;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroGameplay.KuroSequenceRuntimeFunctionLibrary.GetPlaybackStart
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// class UMovieSceneSequence*              Sequence                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UKuroSequenceRuntimeFunctionLibrary::GetPlaybackStart(class UMovieSceneSequence* Sequence)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroSequenceRuntimeFunctionLibrary", "GetPlaybackStart");

	Params::KuroSequenceRuntimeFunctionLibrary_GetPlaybackStart Parms{};

	Parms.Sequence = Sequence;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroGameplay.KuroSequenceRuntimeFunctionLibrary.GetSections
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// class UMovieSceneTrack*                 Track                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class UMovieSceneSection*>       ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

TArray<class UMovieSceneSection*> UKuroSequenceRuntimeFunctionLibrary::GetSections(class UMovieSceneTrack* Track)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroSequenceRuntimeFunctionLibrary", "GetSections");

	Params::KuroSequenceRuntimeFunctionLibrary_GetSections Parms{};

	Parms.Track = Track;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroGameplay.KuroSequenceRuntimeFunctionLibrary.GetSpawnables
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// class UMovieSceneSequence*              Sequence                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FSequencerBindingRuntimeProxy>ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FSequencerBindingRuntimeProxy> UKuroSequenceRuntimeFunctionLibrary::GetSpawnables(class UMovieSceneSequence* Sequence)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroSequenceRuntimeFunctionLibrary", "GetSpawnables");

	Params::KuroSequenceRuntimeFunctionLibrary_GetSpawnables Parms{};

	Parms.Sequence = Sequence;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroGameplay.KuroSequenceRuntimeFunctionLibrary.GetStartFrame
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// class UMovieSceneSection*               Section                                                (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UKuroSequenceRuntimeFunctionLibrary::GetStartFrame(class UMovieSceneSection* Section)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroSequenceRuntimeFunctionLibrary", "GetStartFrame");

	Params::KuroSequenceRuntimeFunctionLibrary_GetStartFrame Parms{};

	Parms.Section = Section;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroGameplay.KuroSequenceRuntimeFunctionLibrary.GetTracks
// (Final, Native, Static, Private, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FSequencerBindingRuntimeProxy&InBinding                                              (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// TArray<class UMovieSceneTrack*>         ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

TArray<class UMovieSceneTrack*> UKuroSequenceRuntimeFunctionLibrary::GetTracks(const struct FSequencerBindingRuntimeProxy& InBinding)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroSequenceRuntimeFunctionLibrary", "GetTracks");

	Params::KuroSequenceRuntimeFunctionLibrary_GetTracks Parms{};

	Parms.InBinding = std::move(InBinding);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroGameplay.KuroSequenceRuntimeFunctionLibrary.HandleSeqTexStreaming
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// const class ULevelSequence*             LevelSequences                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const bool                              bStartForceStreamIn                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKuroSequenceRuntimeFunctionLibrary::HandleSeqTexStreaming(const class ULevelSequence* LevelSequences, const bool bStartForceStreamIn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroSequenceRuntimeFunctionLibrary", "HandleSeqTexStreaming");

	Params::KuroSequenceRuntimeFunctionLibrary_HandleSeqTexStreaming Parms{};

	Parms.LevelSequences = LevelSequences;
	Parms.bStartForceStreamIn = bStartForceStreamIn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroGameplay.KuroSequenceRuntimeFunctionLibrary.MuteTrackByName
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// class UMovieSceneSequence*              Sequence                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             Name_0                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIsMuted                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKuroSequenceRuntimeFunctionLibrary::MuteTrackByName(class UMovieSceneSequence* Sequence, class FName Name_0, bool bIsMuted)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroSequenceRuntimeFunctionLibrary", "MuteTrackByName");

	Params::KuroSequenceRuntimeFunctionLibrary_MuteTrackByName Parms{};

	Parms.Sequence = Sequence;
	Parms.Name_0 = Name_0;
	Parms.bIsMuted = bIsMuted;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroGameplay.KuroSequenceRuntimeFunctionLibrary.MuteTrackByTag
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// class UMovieSceneSequence*              Sequence                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             Tag                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIsMuted                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKuroSequenceRuntimeFunctionLibrary::MuteTrackByTag(class UMovieSceneSequence* Sequence, class FName Tag, bool bIsMuted)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroSequenceRuntimeFunctionLibrary", "MuteTrackByTag");

	Params::KuroSequenceRuntimeFunctionLibrary_MuteTrackByTag Parms{};

	Parms.Sequence = Sequence;
	Parms.Tag = Tag;
	Parms.bIsMuted = bIsMuted;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroGameplay.KuroSequenceRuntimeFunctionLibrary.ResetMovieSceneCompiledData
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// class UMovieSceneSequence*              Sequence                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKuroSequenceRuntimeFunctionLibrary::ResetMovieSceneCompiledData(class UMovieSceneSequence* Sequence)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroSequenceRuntimeFunctionLibrary", "ResetMovieSceneCompiledData");

	Params::KuroSequenceRuntimeFunctionLibrary_ResetMovieSceneCompiledData Parms{};

	Parms.Sequence = Sequence;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroGameplay.KuroSequenceRuntimeFunctionLibrary.SearchAttachAndReattach
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// class UMovieSceneSequence*              Sequence                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<class FName>&              InBindingNames                                         (ConstParm, Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// const class FName                       Tag                                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKuroSequenceRuntimeFunctionLibrary::SearchAttachAndReattach(class UMovieSceneSequence* Sequence, const TArray<class FName>& InBindingNames, const class FName Tag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroSequenceRuntimeFunctionLibrary", "SearchAttachAndReattach");

	Params::KuroSequenceRuntimeFunctionLibrary_SearchAttachAndReattach Parms{};

	Parms.Sequence = Sequence;
	Parms.InBindingNames = std::move(InBindingNames);
	Parms.Tag = Tag;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroGameplay.KuroSequenceRuntimeFunctionLibrary.SectionContains
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// class UMovieSceneSection*               Section                                                (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FFrameTime&                Frame                                                  (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKuroSequenceRuntimeFunctionLibrary::SectionContains(class UMovieSceneSection* Section, const struct FFrameTime& Frame)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroSequenceRuntimeFunctionLibrary", "SectionContains");

	Params::KuroSequenceRuntimeFunctionLibrary_SectionContains Parms{};

	Parms.Section = Section;
	Parms.Frame = std::move(Frame);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroGameplay.KuroSequenceRuntimeFunctionLibrary.SetSequenceInUiScene
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// class UMovieSceneSequence*              Sequence                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    IsEnable                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKuroSequenceRuntimeFunctionLibrary::SetSequenceInUiScene(class UMovieSceneSequence* Sequence, bool IsEnable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroSequenceRuntimeFunctionLibrary", "SetSequenceInUiScene");

	Params::KuroSequenceRuntimeFunctionLibrary_SetSequenceInUiScene Parms{};

	Parms.Sequence = Sequence;
	Parms.IsEnable = IsEnable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroGameplay.KuroSequenceRuntimeFunctionLibrary.StopEasingPlayRate
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// class ALevelSequenceActor*              SequenceActor                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   HandleId                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    JumpToTarget                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKuroSequenceRuntimeFunctionLibrary::StopEasingPlayRate(class ALevelSequenceActor* SequenceActor, int32 HandleId, bool JumpToTarget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroSequenceRuntimeFunctionLibrary", "StopEasingPlayRate");

	Params::KuroSequenceRuntimeFunctionLibrary_StopEasingPlayRate Parms{};

	Parms.SequenceActor = SequenceActor;
	Parms.HandleId = HandleId;
	Parms.JumpToTarget = JumpToTarget;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroGameplay.KuroSplineCylinderTriggerActor.GenerateMesh
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class USplineComponent*                 Spline                                                 (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   CircleRadius                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AKuroSplineCylinderTriggerActor::GenerateMesh(class USplineComponent* Spline, float CircleRadius)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KuroSplineCylinderTriggerActor", "GenerateMesh");

	Params::KuroSplineCylinderTriggerActor_GenerateMesh Parms{};

	Parms.Spline = Spline;
	Parms.CircleRadius = CircleRadius;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroGameplay.KuroSplineVolumeGenerator.Generate
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class USplineComponent*                 InSplineComponent                                      (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TSubclassOf<class ABrush>         InVolumeClass                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UKuroSplineVolumeBuilder*         InSplineVolumeBuilder                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AKuroSplineVolumeGenerator::Generate(class USplineComponent* InSplineComponent, const TSubclassOf<class ABrush> InVolumeClass, class UKuroSplineVolumeBuilder* InSplineVolumeBuilder)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KuroSplineVolumeGenerator", "Generate");

	Params::KuroSplineVolumeGenerator_Generate Parms{};

	Parms.InSplineComponent = InSplineComponent;
	Parms.InVolumeClass = InVolumeClass;
	Parms.InSplineVolumeBuilder = InSplineVolumeBuilder;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroGameplay.KuroSplineVolumeGenerator.GeneratePolyhedron
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class USplineComponent*                 InSplineComponent                                      (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TSubclassOf<class ABrush>         InVolumeClass                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const float                             LowerBoundsHeight                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const float                             UpperBoundsHeight                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AKuroSplineVolumeGenerator::GeneratePolyhedron(class USplineComponent* InSplineComponent, const TSubclassOf<class ABrush> InVolumeClass, const float LowerBoundsHeight, const float UpperBoundsHeight)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KuroSplineVolumeGenerator", "GeneratePolyhedron");

	Params::KuroSplineVolumeGenerator_GeneratePolyhedron Parms{};

	Parms.InSplineComponent = InSplineComponent;
	Parms.InVolumeClass = InVolumeClass;
	Parms.LowerBoundsHeight = LowerBoundsHeight;
	Parms.UpperBoundsHeight = UpperBoundsHeight;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroGameplay.KuroStaticMeshLibrary.MergeSimpleCollisions
// (Final, Native, Static, Private, HasOutParams, BlueprintCallable)
// Parameters:
// class UStaticMeshComponent*             TemplateComponent                                      (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<struct FTransform>&        LocalTransforms                                        (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void UKuroStaticMeshLibrary::MergeSimpleCollisions(class UStaticMeshComponent* TemplateComponent, const TArray<struct FTransform>& LocalTransforms)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticMeshLibrary", "MergeSimpleCollisions");

	Params::KuroStaticMeshLibrary_MergeSimpleCollisions Parms{};

	Parms.TemplateComponent = TemplateComponent;
	Parms.LocalTransforms = std::move(LocalTransforms);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroGameplay.PerformanceStatisticsLibrary.AddStatistics
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                             SectionName                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   FrameCount                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    Tag                                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   MeasureMode                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Time                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    UserDefineMessage                                      (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPerformanceStatisticsLibrary::AddStatistics(class FName SectionName, int32 FrameCount, const class FString& Tag, int32 MeasureMode, float Time, const class FString& UserDefineMessage)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("PerformanceStatisticsLibrary", "AddStatistics");

	Params::PerformanceStatisticsLibrary_AddStatistics Parms{};

	Parms.SectionName = SectionName;
	Parms.FrameCount = FrameCount;
	Parms.Tag = std::move(Tag);
	Parms.MeasureMode = MeasureMode;
	Parms.Time = Time;
	Parms.UserDefineMessage = std::move(UserDefineMessage);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroGameplay.PerformanceStatisticsLibrary.Clear
// (Final, Native, Static, Public, BlueprintCallable)

void UPerformanceStatisticsLibrary::Clear()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("PerformanceStatisticsLibrary", "Clear");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function KuroGameplay.PerformanceStatisticsLibrary.Export
// (Final, Native, Static, Public, BlueprintCallable)

void UPerformanceStatisticsLibrary::Export()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("PerformanceStatisticsLibrary", "Export");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function KuroGameplay.PerformanceStatisticsLibrary.ReadAllSectionsFromDirectory
// (Final, Native, Static, Public, BlueprintCallable)

void UPerformanceStatisticsLibrary::ReadAllSectionsFromDirectory()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("PerformanceStatisticsLibrary", "ReadAllSectionsFromDirectory");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function KuroGameplay.PerformanceStatisticsLibrary.ReadSectionFromFile
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FString*                          FilePath                                               (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPerformanceStatisticsLibrary::ReadSectionFromFile(class FString* FilePath)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("PerformanceStatisticsLibrary", "ReadSectionFromFile");

	Params::PerformanceStatisticsLibrary_ReadSectionFromFile Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (FilePath != nullptr)
		*FilePath = std::move(Parms.FilePath);
}


// Function KuroGameplay.PerformanceStatisticsLibrary.StatisticsFromRawDataFiles
// (Final, Native, Static, Public, BlueprintCallable)

void UPerformanceStatisticsLibrary::StatisticsFromRawDataFiles()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("PerformanceStatisticsLibrary", "StatisticsFromRawDataFiles");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}

}

