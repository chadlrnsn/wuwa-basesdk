#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: KuroAnim

#include "Basic.hpp"

#include "Engine_structs.hpp"
#include "Engine_classes.hpp"
#include "KuroAnim_structs.hpp"
#include "CoreUObject_structs.hpp"
#include "CoreUObject_classes.hpp"


namespace SDK
{

// Class KuroAnim.KuroAnimInstance
// 0x00F0 (0x0750 - 0x0660)
#pragma pack(push, 0x1)
class alignas(0x10) UKuroAnimInstance : public UAnimInstance
{
public:
	uint8                                         Pad_660[0x68];                                     // 0x0660(0x0068)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              TurnLimitForBoneRotateAnimNode;                    // 0x06C8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              LookUpLimitForBoneRotateAnimNode;                  // 0x06D0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRollBackToOriginForBoneRotateAnimNode;            // 0x06D8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStopForBoneRotateAnimNode;                        // 0x06D9(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6DA[0x2];                                      // 0x06DA(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TurnAngleForBoneRotateAnimNode;                    // 0x06DC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LookUpAngleForBoneRotateAnimNode;                  // 0x06E0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TurnOffsetForBoneRotateAnimNode;                   // 0x06E4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LookUpOffsetForBoneRotateAnimNode;                 // 0x06E8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6EC[0x4];                                      // 0x06EC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FName, class UAnimSequence*>       ExtraRibbonAnims;                                  // 0x06F0(0x0050)(Edit, NativeAccessSpecifierPublic)
	uint8                                         Pad_740[0x8];                                      // 0x0740(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	float AngleConversion(const float& Angle);
	void BindBooleanVarToActorTag(bool& BooleanVarRef, class FName Tag);
	void BindBooleanVarToTag(bool& BooleanVarRef, const struct FGameplayTag& Tag);
	void BindComponentVarToAnimInstance(class UObject* Component, const class FString& ComponentVarName, const class FString& InstanceVarName);
	void BindEnumToRoleAnimInstance(class UObject* Component);
	void BindVarToCharacter(struct FVector& VelocityRef, struct FVector& ActorForwardVectorRef, struct FRotator& ActorRotationRef, struct FRotator& ControlRotationRef, struct FVector& CurrentAccelerationRef, bool& bMoveBlockRef);
	struct FVector2D CalculateAimMixed(const struct FVector& Speed, const struct FRotator& RoleRotator, class ACharacter* Character);
	struct FVector CalculateRelativeAcceleration(const struct FVector& Speed, const struct FVector& Acceleration, const struct FRotator& RoleRotator, class ACharacter* Character);
	void CalculateSpeedMixed(const struct FRotator& RoleRotator, const struct FRotator& AdditiveRotator, const struct FVector& Speed, class ACharacter* Character, class UCurveFloat*& Curve, const float& DeltaTime, float& CachedPercentFB, float& CachedPercentLR, struct FVeloctiyBlend& VelocityBlend);
	float CalculateStandRate(class UCurveFloat*& AngleToStepFrequency, const float& Slop, const float& Speed, const float& AnimWalkSpeed, const float& AnimRunSpeed, const float& SprintSpeed, const float& StepLengthMix);
	float CalculateStepLengthMixed(class UCurveFloat*& AngleToStepLength, class UCurveFloat*& WalkCurve, class UCurveFloat*& RunCurve, const float& Speed, const float& Slop);
	float CalculateWalkRunMixed(const int32& MoveState);
	void CalucateClimbOffset(class ACharacter*& Character, const struct FVector& IKDirection, const struct FVector& OffsetRelativeLocation, const struct FVector& BoneLocation, float OffsetCorrection, float TraceRadius, const struct FVector& MeshWorldLocation, const struct FRotator& QuatInverse, struct FVector& CachedLocation, struct FVector& CachedNormal, const float& IKCurveValue, const float& ClimbRadius, float& PrevFrameAlpha, struct FVector* OutOffset, struct FVector* OutNormal, bool* bSuccess);
	void ClimbIKProcess(class UAnimInstance* AnimInstance, const struct FVector& MeshWorldLocation, const struct FRotator& QuatInverse, const bool& IsClimbExitState, struct FVector& OverallOffsetLocation, float& ClimbIK, class ACharacter*& Character, class USkeletalMeshComponent*& Mesh, const float& ClimbRadius, const struct FVector& LFootOffsetRelativeLocation, struct FVector& LFootCachedLocation, struct FVector& LFootCachedNormal, struct FVector& LFootOffsetLocation, struct FVector& LFootNormalDirection, float& LFootPrevFrameAlpha, const struct FVector& RFootOffsetRelativeLocation, struct FVector& RFootCachedLocation, struct FVector& RFootCachedNormal, struct FVector& RFootOffsetLocation, struct FVector& RFootNormalDirection, float& RFootPrevFrameAlpha, const struct FVector& LHandOffsetRelativeLocation, struct FVector& LHandCachedLocation, struct FVector& LHandCachedNormal, struct FVector& LHandOffsetLocation, struct FVector& LHandNormalDirection, float& LHandPrevFrameAlpha, const struct FVector& RHandOffsetRelativeLocation, struct FVector& RHandCachedLocation, struct FVector& RHandCachedNormal, struct FVector& RHandOffsetLocation, struct FVector& RHandNormalDirection, float& RHandPrevFrameAlpha);
	class FString GetDebugAnimNodeString();
	void GroundIKProcess(const struct FVector& MeshWorldLocation, const float& DegMovementSlop, class ACharacter*& Character, class USkeletalMeshComponent*& Mesh, const bool& bUpHill, const bool& bDownHill, const float& Speed, const bool& HasMoveInput, bool& bLFootNeedIK, struct FVector& LFootOffsetLocation, struct FVector& LFootNormalDirection, struct FHitResult& LFootHitResult, bool& bRFootNeedIK, struct FVector& RFootOffsetLocation, struct FVector& RFootNormalDirection, struct FHitResult& RFootHitResult, bool UseCurveFootLocation);
	void IKInfoLerpProcess(const float& DeltaTime, const float& HipLerpSpeed, const struct FRotator& QuatInverse, const struct FVector& OverallOffsetLocation, struct FVector& OverallOffsetLocationBeUsed, struct FVector& LFootOffsetRelativeLocation, struct FVector& LFootNormalRelativeDirection, const struct FVector& LFootOffsetLocation, const struct FVector& LFootNormalDirection, struct FVector& RFootOffsetRelativeLocation, struct FVector& RFootNormalRelativeDirection, const struct FVector& RFootOffsetLocation, const struct FVector& RFootNormalDirection, struct FVector& LHandOffsetRelativeLocation, struct FVector& LHandNormalRelativeDirection, const struct FVector& LHandOffsetLocation, const struct FVector& LHandNormalDirection, struct FVector& RHandOffsetRelativeLocation, struct FVector& RHandNormalRelativeDirection, const struct FVector& RHandOffsetLocation, const struct FVector& RHandNormalDirection);
	struct FLeanAmount InterpLeanAmountTo(const struct FLeanAmount& Current, const struct FLeanAmount& Target, float DeltaTime, float InterpSpeed);
	float IsContainExtraRibbonAnims();
	void OnComponentStart();
	void RegisterActor(class ACharacter* Character);
	void ResigterExtraRibbenOwnerAnimInstance(class UAnimInstance* AnimInstance);
	void SetBoneRotateToLocationInfoRunBegin(float TurnAngle, float LookUpAngle, const struct FVector2D& TurnLimit, const struct FVector2D& LookUpLimit, float TurnOffset, float LookUpOffset);
	void SetBoneRotateToLocationInfoRunEnd();
	void SetBoneRotateToLocationInfoRunTick(float TurnAngle, float LookUpAngle);
	void SetBoneRotateToLocationInfoStopBegin();
	void SetBoneRotateToLocationInfoStopEnd();
	void SetDebugTraceType(EDrawDebugTrace GroundTrace, EDrawDebugTrace ClimbTrace);
	void SetFootOffset(const struct FVector& SkeletionAbsoluteLocation, const struct FVector& IKDirection, const float& BenchMarkDepth, const float& RotationCorrectedDistance, class ACharacter*& Character, class USkeletalMeshComponent*& Mesh, const bool& HasMoveInput, bool& bNeedIK, struct FVector& OffsetLocation, struct FVector& NormalDirection, struct FHitResult& OutHitResult);
	void StartABP();
	void UnRegisterActorAndResetInstance();
	void UpdateABP(float DeltaSeconds);
	void UpdateAdditiveBlendInfo(class UAnimInstance* AnimInstance, const bool& bUsingAdditiveBlend, const bool& bUsingWholeBodyBlend, float& AdditiveBlendAlpha, struct FAdditiveBlendAlpha& Plevis, struct FAdditiveBlendAlpha& Spine, struct FAdditiveBlendAlpha& Head, struct FAdditiveBlendAlpha& ArmL, struct FAdditiveBlendAlpha& ArmR, struct FAdditiveBlendAlpha& Leg);
	void UpdateBattleIdle(const float& BattleIdleTime, bool& bBattleIdle);
	void UpdateBindRoleInfo();
	void UpdateBooleanVar();
	void UpdateCameraStateMoveInfo(const struct FVector& Speed, class ACharacter*& Character, const struct FRotator& RoleRotator, const struct FVector& Acceleration, float& RotatorMixed, const float& DeltaTime, struct FVector& RelativeAcceleration, struct FLeanAmount& LeanAmount, const float& GroundLeanAmountLerpSpeed, const struct FRotator& AimRotator, float& AimAngle);
	void UpdateCharacterVar();
	void UpdateIKinfoInClimbState(class UAnimInstance* AnimInstance, const struct FVector& MeshWorldLocation, const struct FRotator& QuatInverse, struct FVector& OverallOffsetLocation, float& ClimbIK, const float& FastClimbDirection, const bool& IsFastClimbState, class ACharacter*& Character, class USkeletalMeshComponent*& Mesh, float& HipLerpSpeed, const float& Speed, const bool& HasMoveInput, const bool& IsClimbExitState, const float& ClimbRadius, const struct FVector& LFootOffsetRelativeLocation, struct FVector& LFootCachedLocation, struct FVector& LFootCachedNormal, struct FVector& LFootOffsetLocation, struct FVector& LFootNormalDirection, float& LFootPrevFrameAlpha, const struct FVector& RFootOffsetRelativeLocation, struct FVector& RFootCachedLocation, struct FVector& RFootCachedNormal, struct FVector& RFootOffsetLocation, struct FVector& RFootNormalDirection, float& RFootPrevFrameAlpha, const struct FVector& LHandOffsetRelativeLocation, struct FVector& LHandCachedLocation, struct FVector& LHandCachedNormal, struct FVector& LHandOffsetLocation, struct FVector& LHandNormalDirection, float& LHandPrevFrameAlpha, const struct FVector& RHandOffsetRelativeLocation, struct FVector& RHandCachedLocation, struct FVector& RHandCachedNormal, struct FVector& RHandOffsetLocation, struct FVector& RHandNormalDirection, float& RHandPrevFrameAlpha);
	void UpdateIKInfoInGroundState(const bool& HasWallForward, const struct FVector& MeshWorldLocation, const bool& IsMoving, const float& DegMovementSlop, bool& bUpHill, bool& bDownHill, class ACharacter*& Character, class USkeletalMeshComponent*& Mesh, const float& Speed, const bool& HasMoveInput, const float& RunWalkMix, struct FVector& OverallOffsetLocation, float& HipLerpSpeed, bool& bLFootNeedIK, struct FVector& LFootOffsetLocation, struct FVector& LFootNormalDirection, struct FHitResult& LFootHitResult, bool& bRFootNeedIK, struct FVector& RFootOffsetLocation, struct FVector& RFootNormalDirection, struct FHitResult& RFootHitResult, bool UseCurveFootLocation);
	void UpdateIKinfoInOtherState(class ACharacter*& Character, struct FVector& OverallOffsetLocation, struct FVector& LFootOffsetLocation, struct FVector& LFootNormalDirection, struct FVector& RFootOffsetLocation, struct FVector& RFootNormalDirection, struct FVector& LHandNormalDirection, struct FVector& RHandNormalDirection, float& HipLerpSpeed);
	void UpdateIKInfoLocalValue(class ACharacter* Character, struct FRotator& MeshQuatInverse, struct FVector& MeshWorldLocation);
	void UpdateMoveInfoMixed(float& WalkRunMixed, const float& DeltaTime, const float& Slop, class UCurveFloat*& AngleToStepFrequency, class UCurveFloat*& AngleToStepLength, class UCurveFloat*& WalkCurve, class UCurveFloat*& RunCurve, const float& SpeedSize, float& StepLengthMixed, const float& AnimWalkSpeed, const float& AnimRunSpeed, const float& SprintSpeed, float& StandRate);
	void UpdateRoleInfo(bool& StateGround, bool& StateGroundSprint, bool& StateGroundWalk, bool& StateGroundRun, bool& StateRunStop, bool& StateSprintStop, bool& StateWalkStop, bool& RunStop, bool& StateClimb, bool& StateAir, bool& StateAirGlide, bool& StateWater, bool& StateView, bool& StateAim, bool& StateFace);
	void UpdateSkillMoveInfo(const float& DeltaTime, const struct FRotator& RoleRotator, const struct FVector& Speed, class ACharacter*& Character, float& RotatorMixed, const struct FVector& Acceleration, struct FVector& RelativeAcceleration, struct FLeanAmount& LeanAmount, const float& GroundLeanAmountLerpSpeed, const struct FRotator& AimRotator, float& AimAngle, struct FVector2D& AimMoveMixed, const float& RotatorSpeed, class AActor* SkillTarget, const struct FVectorDouble& CachedActorLocation);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroAnimInstance">();
	}
	static class UKuroAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroAnimInstance>();
	}
};
#pragma pack(pop)
static_assert(alignof(UKuroAnimInstance) == 0x000010, "Wrong alignment on UKuroAnimInstance");
static_assert(sizeof(UKuroAnimInstance) == 0x000750, "Wrong size on UKuroAnimInstance");
static_assert(offsetof(UKuroAnimInstance, TurnLimitForBoneRotateAnimNode) == 0x0006C8, "Member 'UKuroAnimInstance::TurnLimitForBoneRotateAnimNode' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstance, LookUpLimitForBoneRotateAnimNode) == 0x0006D0, "Member 'UKuroAnimInstance::LookUpLimitForBoneRotateAnimNode' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstance, bRollBackToOriginForBoneRotateAnimNode) == 0x0006D8, "Member 'UKuroAnimInstance::bRollBackToOriginForBoneRotateAnimNode' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstance, bStopForBoneRotateAnimNode) == 0x0006D9, "Member 'UKuroAnimInstance::bStopForBoneRotateAnimNode' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstance, TurnAngleForBoneRotateAnimNode) == 0x0006DC, "Member 'UKuroAnimInstance::TurnAngleForBoneRotateAnimNode' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstance, LookUpAngleForBoneRotateAnimNode) == 0x0006E0, "Member 'UKuroAnimInstance::LookUpAngleForBoneRotateAnimNode' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstance, TurnOffsetForBoneRotateAnimNode) == 0x0006E4, "Member 'UKuroAnimInstance::TurnOffsetForBoneRotateAnimNode' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstance, LookUpOffsetForBoneRotateAnimNode) == 0x0006E8, "Member 'UKuroAnimInstance::LookUpOffsetForBoneRotateAnimNode' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstance, ExtraRibbonAnims) == 0x0006F0, "Member 'UKuroAnimInstance::ExtraRibbonAnims' has a wrong offset!");

// Class KuroAnim.KuroAnimInstanceChar
// 0x00D0 (0x0820 - 0x0750)
class UKuroAnimInstanceChar : public UKuroAnimInstance
{
public:
	class UAbpLogicParams*                        LogicParams;                                       // 0x0748(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ABaseCharacter*                         BaseCharacter;                                     // 0x0750(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_758[0x8];                                      // 0x0758(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DeltaTime;                                         // 0x0760(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EntityId;                                          // 0x0764(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsAutonomousProxy;                                // 0x0768(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_769[0x3];                                      // 0x0769(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                Velocity;                                          // 0x076C(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_778[0xC];                                      // 0x0778(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bIsMovedLocation;                                  // 0x0784(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_785[0x1B];                                     // 0x0785(0x001B)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                Acceleration;                                      // 0x07A0(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ActorForward;                                      // 0x07AC(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7B8[0x4];                                      // 0x07B8(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         OnJumpSpeed;                                       // 0x07BC(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStunned;                                          // 0x07C0(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7C1[0x2F];                                     // 0x07C1(0x002F)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               LowerBodyRotator;                                  // 0x07F0(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_7FC[0x4];                                      // 0x07FC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVectorDouble                          LocationProxy;                                     // 0x0800(0x0018)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESightLockMode                                SightLockMode;                                     // 0x0818(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_819[0x7];                                      // 0x0819(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroAnimInstanceChar">();
	}
	static class UKuroAnimInstanceChar* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroAnimInstanceChar>();
	}
};
static_assert(alignof(UKuroAnimInstanceChar) == 0x000010, "Wrong alignment on UKuroAnimInstanceChar");
static_assert(sizeof(UKuroAnimInstanceChar) == 0x000820, "Wrong size on UKuroAnimInstanceChar");
static_assert(offsetof(UKuroAnimInstanceChar, LogicParams) == 0x000748, "Member 'UKuroAnimInstanceChar::LogicParams' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceChar, BaseCharacter) == 0x000750, "Member 'UKuroAnimInstanceChar::BaseCharacter' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceChar, DeltaTime) == 0x000760, "Member 'UKuroAnimInstanceChar::DeltaTime' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceChar, EntityId) == 0x000764, "Member 'UKuroAnimInstanceChar::EntityId' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceChar, bIsAutonomousProxy) == 0x000768, "Member 'UKuroAnimInstanceChar::bIsAutonomousProxy' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceChar, Velocity) == 0x00076C, "Member 'UKuroAnimInstanceChar::Velocity' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceChar, bIsMovedLocation) == 0x000784, "Member 'UKuroAnimInstanceChar::bIsMovedLocation' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceChar, Acceleration) == 0x0007A0, "Member 'UKuroAnimInstanceChar::Acceleration' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceChar, ActorForward) == 0x0007AC, "Member 'UKuroAnimInstanceChar::ActorForward' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceChar, OnJumpSpeed) == 0x0007BC, "Member 'UKuroAnimInstanceChar::OnJumpSpeed' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceChar, bStunned) == 0x0007C0, "Member 'UKuroAnimInstanceChar::bStunned' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceChar, LowerBodyRotator) == 0x0007F0, "Member 'UKuroAnimInstanceChar::LowerBodyRotator' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceChar, LocationProxy) == 0x000800, "Member 'UKuroAnimInstanceChar::LocationProxy' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceChar, SightLockMode) == 0x000818, "Member 'UKuroAnimInstanceChar::SightLockMode' has a wrong offset!");

// Class KuroAnim.KuroAdjustableBoxComponent
// 0x0030 (0x0560 - 0x0530)
class UKuroAdjustableBoxComponent final : public UBoxComponent
{
public:
	TArray<class FName>                           BindSocketNames;                                   // 0x0528(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         AddExtent;                                         // 0x0538(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinExtent;                                         // 0x053C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxExtent;                                         // 0x0540(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAdjustBoxType                                AdjustBoxType;                                     // 0x0544(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_545[0x1B];                                     // 0x0545(0x001B)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroAdjustableBoxComponent">();
	}
	static class UKuroAdjustableBoxComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroAdjustableBoxComponent>();
	}
};
static_assert(alignof(UKuroAdjustableBoxComponent) == 0x000010, "Wrong alignment on UKuroAdjustableBoxComponent");
static_assert(sizeof(UKuroAdjustableBoxComponent) == 0x000560, "Wrong size on UKuroAdjustableBoxComponent");
static_assert(offsetof(UKuroAdjustableBoxComponent, BindSocketNames) == 0x000528, "Member 'UKuroAdjustableBoxComponent::BindSocketNames' has a wrong offset!");
static_assert(offsetof(UKuroAdjustableBoxComponent, AddExtent) == 0x000538, "Member 'UKuroAdjustableBoxComponent::AddExtent' has a wrong offset!");
static_assert(offsetof(UKuroAdjustableBoxComponent, MinExtent) == 0x00053C, "Member 'UKuroAdjustableBoxComponent::MinExtent' has a wrong offset!");
static_assert(offsetof(UKuroAdjustableBoxComponent, MaxExtent) == 0x000540, "Member 'UKuroAdjustableBoxComponent::MaxExtent' has a wrong offset!");
static_assert(offsetof(UKuroAdjustableBoxComponent, AdjustBoxType) == 0x000544, "Member 'UKuroAdjustableBoxComponent::AdjustBoxType' has a wrong offset!");

// Class KuroAnim.KuroAnimInstanceNpc
// 0x0030 (0x0850 - 0x0820)
class UKuroAnimInstanceNpc final : public UKuroAnimInstanceChar
{
public:
	struct FVector                                SightDirection;                                    // 0x0820(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SightAlpha;                                        // 0x082C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CameraModeType;                                    // 0x0830(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsBeingCaptured;                                  // 0x0834(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPlayKnockUpAnim;                                  // 0x0835(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHeadIKReturnToOrigin;                             // 0x0836(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECharMoveStateType                            CharacterMoveStateType;                            // 0x0837(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECharPositionStateType                        CharacterPositionStateType;                        // 0x0838(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMoveDirection                                MovementDirection;                                 // 0x0839(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EWalkPosture                                  WalkingPosture;                                    // 0x083A(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_83B[0x1];                                      // 0x083B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         UpdateDeltaSeconds;                                // 0x083C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WorldDeltaSeconds;                                 // 0x0840(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIdleThreeState;                                   // 0x0844(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCommonDebugState;                                 // 0x0845(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInAirState;                                       // 0x0846(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLowerHalfUniversalFusionState;                    // 0x0847(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInBattleState;                                    // 0x0848(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPlayEnterBattleState;                             // 0x0849(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_84A[0x6];                                      // 0x084A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroAnimInstanceNpc">();
	}
	static class UKuroAnimInstanceNpc* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroAnimInstanceNpc>();
	}
};
static_assert(alignof(UKuroAnimInstanceNpc) == 0x000010, "Wrong alignment on UKuroAnimInstanceNpc");
static_assert(sizeof(UKuroAnimInstanceNpc) == 0x000850, "Wrong size on UKuroAnimInstanceNpc");
static_assert(offsetof(UKuroAnimInstanceNpc, SightDirection) == 0x000820, "Member 'UKuroAnimInstanceNpc::SightDirection' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceNpc, SightAlpha) == 0x00082C, "Member 'UKuroAnimInstanceNpc::SightAlpha' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceNpc, CameraModeType) == 0x000830, "Member 'UKuroAnimInstanceNpc::CameraModeType' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceNpc, bIsBeingCaptured) == 0x000834, "Member 'UKuroAnimInstanceNpc::bIsBeingCaptured' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceNpc, bPlayKnockUpAnim) == 0x000835, "Member 'UKuroAnimInstanceNpc::bPlayKnockUpAnim' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceNpc, bHeadIKReturnToOrigin) == 0x000836, "Member 'UKuroAnimInstanceNpc::bHeadIKReturnToOrigin' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceNpc, CharacterMoveStateType) == 0x000837, "Member 'UKuroAnimInstanceNpc::CharacterMoveStateType' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceNpc, CharacterPositionStateType) == 0x000838, "Member 'UKuroAnimInstanceNpc::CharacterPositionStateType' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceNpc, MovementDirection) == 0x000839, "Member 'UKuroAnimInstanceNpc::MovementDirection' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceNpc, WalkingPosture) == 0x00083A, "Member 'UKuroAnimInstanceNpc::WalkingPosture' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceNpc, UpdateDeltaSeconds) == 0x00083C, "Member 'UKuroAnimInstanceNpc::UpdateDeltaSeconds' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceNpc, WorldDeltaSeconds) == 0x000840, "Member 'UKuroAnimInstanceNpc::WorldDeltaSeconds' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceNpc, bIdleThreeState) == 0x000844, "Member 'UKuroAnimInstanceNpc::bIdleThreeState' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceNpc, bCommonDebugState) == 0x000845, "Member 'UKuroAnimInstanceNpc::bCommonDebugState' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceNpc, bInAirState) == 0x000846, "Member 'UKuroAnimInstanceNpc::bInAirState' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceNpc, bLowerHalfUniversalFusionState) == 0x000847, "Member 'UKuroAnimInstanceNpc::bLowerHalfUniversalFusionState' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceNpc, bInBattleState) == 0x000848, "Member 'UKuroAnimInstanceNpc::bInBattleState' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceNpc, bPlayEnterBattleState) == 0x000849, "Member 'UKuroAnimInstanceNpc::bPlayEnterBattleState' has a wrong offset!");

// Class KuroAnim.KuroAdjustableCapsuleComponent
// 0x0040 (0x0560 - 0x0520)
class UKuroAdjustableCapsuleComponent final : public UCapsuleComponent
{
public:
	TArray<class FName>                           BindSocketNames;                                   // 0x0520(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         AddRadius;                                         // 0x0530(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinRadius;                                         // 0x0534(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxRadius;                                         // 0x0538(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAdjustCapsuleType                            AdjustCapsuleType;                                 // 0x053C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_53D[0x23];                                     // 0x053D(0x0023)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroAdjustableCapsuleComponent">();
	}
	static class UKuroAdjustableCapsuleComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroAdjustableCapsuleComponent>();
	}
};
static_assert(alignof(UKuroAdjustableCapsuleComponent) == 0x000010, "Wrong alignment on UKuroAdjustableCapsuleComponent");
static_assert(sizeof(UKuroAdjustableCapsuleComponent) == 0x000560, "Wrong size on UKuroAdjustableCapsuleComponent");
static_assert(offsetof(UKuroAdjustableCapsuleComponent, BindSocketNames) == 0x000520, "Member 'UKuroAdjustableCapsuleComponent::BindSocketNames' has a wrong offset!");
static_assert(offsetof(UKuroAdjustableCapsuleComponent, AddRadius) == 0x000530, "Member 'UKuroAdjustableCapsuleComponent::AddRadius' has a wrong offset!");
static_assert(offsetof(UKuroAdjustableCapsuleComponent, MinRadius) == 0x000534, "Member 'UKuroAdjustableCapsuleComponent::MinRadius' has a wrong offset!");
static_assert(offsetof(UKuroAdjustableCapsuleComponent, MaxRadius) == 0x000538, "Member 'UKuroAdjustableCapsuleComponent::MaxRadius' has a wrong offset!");
static_assert(offsetof(UKuroAdjustableCapsuleComponent, AdjustCapsuleType) == 0x00053C, "Member 'UKuroAdjustableCapsuleComponent::AdjustCapsuleType' has a wrong offset!");

// Class KuroAnim.KuroAnimInstancePhyCloth
// 0x0040 (0x06A0 - 0x0660)
class UKuroAnimInstancePhyCloth final : public UAnimInstance
{
public:
	bool                                          bEnableFormSwitch;                                 // 0x0660(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_661[0x7];                                      // 0x0661(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSoftObjectPtr<class USkeletalMesh>>   FormSkelMeshRefs;                                  // 0x0668(0x0010)(Edit, BlueprintVisible, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	uint8                                         Pad_678[0x28];                                     // 0x0678(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroAnimInstancePhyCloth">();
	}
	static class UKuroAnimInstancePhyCloth* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroAnimInstancePhyCloth>();
	}
};
static_assert(alignof(UKuroAnimInstancePhyCloth) == 0x000010, "Wrong alignment on UKuroAnimInstancePhyCloth");
static_assert(sizeof(UKuroAnimInstancePhyCloth) == 0x0006A0, "Wrong size on UKuroAnimInstancePhyCloth");
static_assert(offsetof(UKuroAnimInstancePhyCloth, bEnableFormSwitch) == 0x000660, "Member 'UKuroAnimInstancePhyCloth::bEnableFormSwitch' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstancePhyCloth, FormSkelMeshRefs) == 0x000668, "Member 'UKuroAnimInstancePhyCloth::FormSkelMeshRefs' has a wrong offset!");

// Class KuroAnim.KuroAnimConfig
// 0x0008 (0x0038 - 0x0030)
class UKuroAnimConfig final : public UObject
{
public:
	float                                         DefaultFootOffset;                                 // 0x0030(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DefaultHighHeelsOffset;                            // 0x0034(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroAnimConfig">();
	}
	static class UKuroAnimConfig* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroAnimConfig>();
	}
};
static_assert(alignof(UKuroAnimConfig) == 0x000008, "Wrong alignment on UKuroAnimConfig");
static_assert(sizeof(UKuroAnimConfig) == 0x000038, "Wrong size on UKuroAnimConfig");
static_assert(offsetof(UKuroAnimConfig, DefaultFootOffset) == 0x000030, "Member 'UKuroAnimConfig::DefaultFootOffset' has a wrong offset!");
static_assert(offsetof(UKuroAnimConfig, DefaultHighHeelsOffset) == 0x000034, "Member 'UKuroAnimConfig::DefaultHighHeelsOffset' has a wrong offset!");

// Class KuroAnim.KuroAnimInstanceMonster
// 0x0050 (0x0870 - 0x0820)
class UKuroAnimInstanceMonster : public UKuroAnimInstanceChar
{
public:
	TArray<class FName>                           HitBonesList;                                      // 0x0820(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FVector                                SightDirection;                                    // 0x0830(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SightAlpha;                                        // 0x083C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CameraModeType;                                    // 0x0840(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                HateLocation;                                      // 0x0844(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsBeingCaptured;                                  // 0x0850(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPlayKnockUpAnim;                                  // 0x0851(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHeadIKReturnToOrigin;                             // 0x0852(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECharMoveStateType                            CharacterMoveStateType;                            // 0x0853(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECharPositionStateType                        CharacterPositionStateType;                        // 0x0854(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAcceptNewHit;                                     // 0x0855(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnterFk;                                          // 0x0856(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHitInAir;                                         // 0x0857(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         HitAnimType;                                       // 0x0858(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMoveDirection                                MovementDirection;                                 // 0x085C(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EWalkPosture                                  WalkingPosture;                                    // 0x085D(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_85E[0x2];                                      // 0x085E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         UpdateDeltaSeconds;                                // 0x0860(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WorldDeltaSeconds;                                 // 0x0864(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIdleThreeState;                                   // 0x0868(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCommonDebugState;                                 // 0x0869(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInAirState;                                       // 0x086A(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLowerHalfUniversalFusionState;                    // 0x086B(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInBattleState;                                    // 0x086C(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPlayEnterBattleState;                             // 0x086D(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_86E[0x2];                                      // 0x086E(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroAnimInstanceMonster">();
	}
	static class UKuroAnimInstanceMonster* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroAnimInstanceMonster>();
	}
};
static_assert(alignof(UKuroAnimInstanceMonster) == 0x000010, "Wrong alignment on UKuroAnimInstanceMonster");
static_assert(sizeof(UKuroAnimInstanceMonster) == 0x000870, "Wrong size on UKuroAnimInstanceMonster");
static_assert(offsetof(UKuroAnimInstanceMonster, HitBonesList) == 0x000820, "Member 'UKuroAnimInstanceMonster::HitBonesList' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceMonster, SightDirection) == 0x000830, "Member 'UKuroAnimInstanceMonster::SightDirection' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceMonster, SightAlpha) == 0x00083C, "Member 'UKuroAnimInstanceMonster::SightAlpha' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceMonster, CameraModeType) == 0x000840, "Member 'UKuroAnimInstanceMonster::CameraModeType' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceMonster, HateLocation) == 0x000844, "Member 'UKuroAnimInstanceMonster::HateLocation' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceMonster, bIsBeingCaptured) == 0x000850, "Member 'UKuroAnimInstanceMonster::bIsBeingCaptured' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceMonster, bPlayKnockUpAnim) == 0x000851, "Member 'UKuroAnimInstanceMonster::bPlayKnockUpAnim' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceMonster, bHeadIKReturnToOrigin) == 0x000852, "Member 'UKuroAnimInstanceMonster::bHeadIKReturnToOrigin' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceMonster, CharacterMoveStateType) == 0x000853, "Member 'UKuroAnimInstanceMonster::CharacterMoveStateType' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceMonster, CharacterPositionStateType) == 0x000854, "Member 'UKuroAnimInstanceMonster::CharacterPositionStateType' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceMonster, bAcceptNewHit) == 0x000855, "Member 'UKuroAnimInstanceMonster::bAcceptNewHit' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceMonster, bEnterFk) == 0x000856, "Member 'UKuroAnimInstanceMonster::bEnterFk' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceMonster, bHitInAir) == 0x000857, "Member 'UKuroAnimInstanceMonster::bHitInAir' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceMonster, HitAnimType) == 0x000858, "Member 'UKuroAnimInstanceMonster::HitAnimType' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceMonster, MovementDirection) == 0x00085C, "Member 'UKuroAnimInstanceMonster::MovementDirection' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceMonster, WalkingPosture) == 0x00085D, "Member 'UKuroAnimInstanceMonster::WalkingPosture' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceMonster, UpdateDeltaSeconds) == 0x000860, "Member 'UKuroAnimInstanceMonster::UpdateDeltaSeconds' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceMonster, WorldDeltaSeconds) == 0x000864, "Member 'UKuroAnimInstanceMonster::WorldDeltaSeconds' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceMonster, bIdleThreeState) == 0x000868, "Member 'UKuroAnimInstanceMonster::bIdleThreeState' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceMonster, bCommonDebugState) == 0x000869, "Member 'UKuroAnimInstanceMonster::bCommonDebugState' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceMonster, bInAirState) == 0x00086A, "Member 'UKuroAnimInstanceMonster::bInAirState' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceMonster, bLowerHalfUniversalFusionState) == 0x00086B, "Member 'UKuroAnimInstanceMonster::bLowerHalfUniversalFusionState' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceMonster, bInBattleState) == 0x00086C, "Member 'UKuroAnimInstanceMonster::bInBattleState' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceMonster, bPlayEnterBattleState) == 0x00086D, "Member 'UKuroAnimInstanceMonster::bPlayEnterBattleState' has a wrong offset!");

// Class KuroAnim.KuroAnimInstanceRole
// 0x0320 (0x0B40 - 0x0820)
class UKuroAnimInstanceRole : public UKuroAnimInstanceChar
{
public:
	TArray<int32>                                 ValidPerformanceIndexes;                           // 0x0820(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bIsFloorMoving;                                    // 0x0830(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_831[0x1F];                                     // 0x0831(0x001F)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bCanbeInterrupt;                                   // 0x0850(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMoveBlock;                                        // 0x0851(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_852[0x2];                                      // 0x0852(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TimeSeconds;                                       // 0x0854(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_858[0x4];                                      // 0x0858(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bIsNotNPC;                                         // 0x085C(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_85D[0x3];                                      // 0x085D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ChangeRoleCount;                                   // 0x0860(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_864[0x1];                                      // 0x0864(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bHasNPCTag;                                        // 0x0865(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsGoingToMove;                                    // 0x0866(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_867[0x5];                                      // 0x0867(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TurnMix;                                           // 0x086C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVeloctiyBlend                         SpeedMix;                                          // 0x0870(0x0010)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector2D                              AimMoveMix;                                        // 0x0880(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LocalAccel;                                        // 0x0888(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLeanAmount                            LeanAmount;                                        // 0x0894(0x0008)(BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	EMoveDirection                                MoveDirection;                                     // 0x089C(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_89D[0x3];                                      // 0x089D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         GroundMovePlayRate;                                // 0x08A0(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WalkRunMix;                                        // 0x08A4(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StepSizeMix;                                       // 0x08A8(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVeloctiyBlend                         AccelLerpMix;                                      // 0x08AC(0x0010)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         AimYaw;                                            // 0x08BC(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AimPitch;                                          // 0x08C0(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsFightStand;                                     // 0x08C4(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8C5[0x3];                                      // 0x08C5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              MoveMix;                                           // 0x08C8(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CachePercentLR;                                    // 0x08D0(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CachePercentFB;                                    // 0x08D4(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EStandTurnType                                StandTurnType;                                     // 0x08D8(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8D9[0x3];                                      // 0x08D9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         LandSpeedIndex;                                    // 0x08DC(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FallingSpeed;                                      // 0x08E0(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ForecastLandWeight;                                // 0x08E4(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                AirVelocity;                                       // 0x08E8(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AirTargetYaw;                                      // 0x08F4(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                GlideMix;                                          // 0x08F8(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SlideMix;                                          // 0x0904(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_908[0x18];                                     // 0x0908(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                AirSlideMix;                                       // 0x0920(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                HookRopeMix;                                       // 0x092C(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          HookRopeSucceedSpeed;                              // 0x0938(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_939[0x3];                                      // 0x0939(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         JumpMix;                                           // 0x093C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                SwimRootOffset;                                    // 0x0940(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SwimAccelOffset;                                   // 0x094C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SwimAccelOffsetReal;                               // 0x0950(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SwimMix;                                           // 0x0954(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FastClimbMix;                                      // 0x0958(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ClimbBrakeMix;                                     // 0x095C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsClimbMoving;                                    // 0x0960(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_961[0x3];                                      // 0x0961(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ClimbRadius;                                       // 0x0964(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ClimbDirection;                                    // 0x0968(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ValidClimbDirection;                               // 0x096C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EKuroHumanIKMode                              IKMode;                                            // 0x0970(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIKNoLerp;                                         // 0x0971(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_972[0x2];                                      // 0x0972(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               ComprehensiveRotator;                              // 0x0974(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                BeHitStandardizedDirect;                           // 0x0980(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                BeHitSocketLocation;                               // 0x098C(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SightLockAlpha;                                    // 0x0998(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                SightLockDirect;                                   // 0x099C(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInAimShotEnd;                                     // 0x09A8(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9A9[0x3];                                      // 0x09A9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AimYawMix;                                         // 0x09AC(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         FreezeCountDown;                                   // 0x09B0(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStateStop;                                        // 0x09B4(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStateSprintStop;                                  // 0x09B5(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStateRunStop;                                     // 0x09B6(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStateWalkStop;                                    // 0x09B7(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStateGround;                                      // 0x09B8(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStateStand;                                       // 0x09B9(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStateGroundSprint;                                // 0x09BA(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStateGroundRun;                                   // 0x09BB(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStateGroundWalk;                                  // 0x09BC(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStateClimb;                                       // 0x09BD(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStateAir;                                         // 0x09BE(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStateSki;                                         // 0x09BF(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStateNormalSki;                                   // 0x09C0(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStateAirSlide;                                    // 0x09C1(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStateAirGlide;                                    // 0x09C2(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStateWater;                                       // 0x09C3(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStateSkill;                                       // 0x09C4(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStateLockDirection;                               // 0x09C5(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStateAimDirection;                                // 0x09C6(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStateFaceDirection;                               // 0x09C7(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStateBeHit;                                       // 0x09C8(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStateHitPush;                                     // 0x09C9(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStateBeHitFly;                                    // 0x09CA(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStateDying;                                       // 0x09CB(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStateDrown;                                       // 0x09CC(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStateInBattle;                                    // 0x09CD(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStateEnterBattle;                                 // 0x09CE(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStateKeepSprint;                                  // 0x09CF(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStateFastSwim;                                    // 0x09D0(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStateSit;                                         // 0x09D1(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStateOverlapBaseAnim;                             // 0x09D2(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseAdditive;                                      // 0x09D3(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseOverlapLayerAdditive;                          // 0x09D4(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStateLowerRightTurnBlending;                      // 0x09D5(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStateLowerBlending;                               // 0x09D6(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStateWholeBodyBlend;                              // 0x09D7(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStateUseSpecialStateMachine;                      // 0x09D8(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStateFastBlend;                                   // 0x09D9(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9DA[0x2];                                      // 0x09DA(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LowerBlendAlpha;                                   // 0x09DC(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FAdditiveBlendAlpha                    BlendAlphaPelvis;                                  // 0x09E0(0x000C)(BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FAdditiveBlendAlpha                    BlendAlphaSpine;                                   // 0x09EC(0x000C)(BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FAdditiveBlendAlpha                    BlendAlphaHead;                                    // 0x09F8(0x000C)(BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FAdditiveBlendAlpha                    BlendAlphaArmL;                                    // 0x0A04(0x000C)(BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FAdditiveBlendAlpha                    BlendAlphaArmR;                                    // 0x0A10(0x000C)(BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FAdditiveBlendAlpha                    BlendAlphaLeg;                                     // 0x0A1C(0x000C)(BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bStateCast;                                        // 0x0A28(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStateCastThrowing;                                // 0x0A29(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStateCastSelecting;                               // 0x0A2A(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStateCastCasting;                                 // 0x0A2B(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStateMoveShot;                                    // 0x0A2C(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStateHoldShot;                                    // 0x0A2D(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStateAiming;                                      // 0x0A2E(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStateGeneralAiming;                               // 0x0A2F(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStateShotNotify;                                  // 0x0A30(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStateFixHook;                                     // 0x0A31(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStateAirNormalShot;                               // 0x0A32(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStateAirNormalShotLeft;                           // 0x0A33(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStateAirNormalShotRight;                          // 0x0A34(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStateAirNormalShotFall;                           // 0x0A35(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStateBurst;                                       // 0x0A36(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStateInBurst;                                     // 0x0A37(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStateLimitForward;                                // 0x0A38(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStateLimitBackward;                               // 0x0A39(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLandRollWhenDying;                                // 0x0A3A(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCaught;                                           // 0x0A3B(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRagDollQuit;                                      // 0x0A3C(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A3D[0x3];                                      // 0x0A3D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ExpresionAlpha;                                    // 0x0A40(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A44[0x8];                                      // 0x0A44(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bEpresion;                                         // 0x0A4C(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A4D[0x3];                                      // 0x0A4D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PerformanceCountDown;                              // 0x0A50(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPerformance;                                      // 0x0A54(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A55[0x3];                                      // 0x0A55(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         PerformanceIndex;                                  // 0x0A58(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllowPerformance;                                 // 0x0A5C(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAcceptNewSkill;                                   // 0x0A5D(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A5E[0x6];                                      // 0x0A5E(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bStageMotionSki;                                   // 0x0A64(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHugeItemPull;                                     // 0x0A65(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHugeItemPullAngle;                                // 0x0A66(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A67[0x1];                                      // 0x0A67(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FString, float>                    SizeToCharHeightMap;                               // 0x0A68(0x0050)(Edit, NativeAccessSpecifierPublic)
	struct FVector2D                              LandSpeedThresholds;                               // 0x0AB8(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpeedMixLerp;                                      // 0x0AC0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GroundLeanLerp;                                    // 0x0AC4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AnimWalkSpeed;                                     // 0x0AC8(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AnimRunSpeed;                                      // 0x0ACC(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AnimSprintSpeed;                                   // 0x0AD0(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AirLeanLerp;                                       // 0x0AD4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         JumpMixLerp;                                       // 0x0AD8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SlideRotateLerp;                                   // 0x0ADC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SlideRotateLerp2;                                  // 0x0AE0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_AE4[0x4];                                      // 0x0AE4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            StandWalkStepCurve;                                // 0x0AE8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            StandRunStepCurve;                                 // 0x0AF0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            ForecastLandCurve;                                 // 0x0AF8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            RelativeSpeedBlendCurve;                           // 0x0B00(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            AirLeanCurve;                                      // 0x0B08(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            AngelToStepLengthCurve;                            // 0x0B10(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            AngleToStepFrequencyCurve;                         // 0x0B18(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataAsset*                             FkMaterialControllerData;                          // 0x0B20(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B28[0x18];                                     // 0x0B28(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroAnimInstanceRole">();
	}
	static class UKuroAnimInstanceRole* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroAnimInstanceRole>();
	}
};
static_assert(alignof(UKuroAnimInstanceRole) == 0x000010, "Wrong alignment on UKuroAnimInstanceRole");
static_assert(sizeof(UKuroAnimInstanceRole) == 0x000B40, "Wrong size on UKuroAnimInstanceRole");
static_assert(offsetof(UKuroAnimInstanceRole, ValidPerformanceIndexes) == 0x000820, "Member 'UKuroAnimInstanceRole::ValidPerformanceIndexes' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceRole, bIsFloorMoving) == 0x000830, "Member 'UKuroAnimInstanceRole::bIsFloorMoving' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceRole, bCanbeInterrupt) == 0x000850, "Member 'UKuroAnimInstanceRole::bCanbeInterrupt' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceRole, bMoveBlock) == 0x000851, "Member 'UKuroAnimInstanceRole::bMoveBlock' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceRole, TimeSeconds) == 0x000854, "Member 'UKuroAnimInstanceRole::TimeSeconds' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceRole, bIsNotNPC) == 0x00085C, "Member 'UKuroAnimInstanceRole::bIsNotNPC' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceRole, ChangeRoleCount) == 0x000860, "Member 'UKuroAnimInstanceRole::ChangeRoleCount' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceRole, bHasNPCTag) == 0x000865, "Member 'UKuroAnimInstanceRole::bHasNPCTag' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceRole, bIsGoingToMove) == 0x000866, "Member 'UKuroAnimInstanceRole::bIsGoingToMove' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceRole, TurnMix) == 0x00086C, "Member 'UKuroAnimInstanceRole::TurnMix' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceRole, SpeedMix) == 0x000870, "Member 'UKuroAnimInstanceRole::SpeedMix' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceRole, AimMoveMix) == 0x000880, "Member 'UKuroAnimInstanceRole::AimMoveMix' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceRole, LocalAccel) == 0x000888, "Member 'UKuroAnimInstanceRole::LocalAccel' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceRole, LeanAmount) == 0x000894, "Member 'UKuroAnimInstanceRole::LeanAmount' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceRole, MoveDirection) == 0x00089C, "Member 'UKuroAnimInstanceRole::MoveDirection' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceRole, GroundMovePlayRate) == 0x0008A0, "Member 'UKuroAnimInstanceRole::GroundMovePlayRate' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceRole, WalkRunMix) == 0x0008A4, "Member 'UKuroAnimInstanceRole::WalkRunMix' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceRole, StepSizeMix) == 0x0008A8, "Member 'UKuroAnimInstanceRole::StepSizeMix' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceRole, AccelLerpMix) == 0x0008AC, "Member 'UKuroAnimInstanceRole::AccelLerpMix' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceRole, AimYaw) == 0x0008BC, "Member 'UKuroAnimInstanceRole::AimYaw' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceRole, AimPitch) == 0x0008C0, "Member 'UKuroAnimInstanceRole::AimPitch' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceRole, bIsFightStand) == 0x0008C4, "Member 'UKuroAnimInstanceRole::bIsFightStand' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceRole, MoveMix) == 0x0008C8, "Member 'UKuroAnimInstanceRole::MoveMix' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceRole, CachePercentLR) == 0x0008D0, "Member 'UKuroAnimInstanceRole::CachePercentLR' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceRole, CachePercentFB) == 0x0008D4, "Member 'UKuroAnimInstanceRole::CachePercentFB' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceRole, StandTurnType) == 0x0008D8, "Member 'UKuroAnimInstanceRole::StandTurnType' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceRole, LandSpeedIndex) == 0x0008DC, "Member 'UKuroAnimInstanceRole::LandSpeedIndex' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceRole, FallingSpeed) == 0x0008E0, "Member 'UKuroAnimInstanceRole::FallingSpeed' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceRole, ForecastLandWeight) == 0x0008E4, "Member 'UKuroAnimInstanceRole::ForecastLandWeight' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceRole, AirVelocity) == 0x0008E8, "Member 'UKuroAnimInstanceRole::AirVelocity' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceRole, AirTargetYaw) == 0x0008F4, "Member 'UKuroAnimInstanceRole::AirTargetYaw' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceRole, GlideMix) == 0x0008F8, "Member 'UKuroAnimInstanceRole::GlideMix' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceRole, SlideMix) == 0x000904, "Member 'UKuroAnimInstanceRole::SlideMix' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceRole, AirSlideMix) == 0x000920, "Member 'UKuroAnimInstanceRole::AirSlideMix' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceRole, HookRopeMix) == 0x00092C, "Member 'UKuroAnimInstanceRole::HookRopeMix' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceRole, HookRopeSucceedSpeed) == 0x000938, "Member 'UKuroAnimInstanceRole::HookRopeSucceedSpeed' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceRole, JumpMix) == 0x00093C, "Member 'UKuroAnimInstanceRole::JumpMix' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceRole, SwimRootOffset) == 0x000940, "Member 'UKuroAnimInstanceRole::SwimRootOffset' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceRole, SwimAccelOffset) == 0x00094C, "Member 'UKuroAnimInstanceRole::SwimAccelOffset' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceRole, SwimAccelOffsetReal) == 0x000950, "Member 'UKuroAnimInstanceRole::SwimAccelOffsetReal' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceRole, SwimMix) == 0x000954, "Member 'UKuroAnimInstanceRole::SwimMix' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceRole, FastClimbMix) == 0x000958, "Member 'UKuroAnimInstanceRole::FastClimbMix' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceRole, ClimbBrakeMix) == 0x00095C, "Member 'UKuroAnimInstanceRole::ClimbBrakeMix' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceRole, bIsClimbMoving) == 0x000960, "Member 'UKuroAnimInstanceRole::bIsClimbMoving' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceRole, ClimbRadius) == 0x000964, "Member 'UKuroAnimInstanceRole::ClimbRadius' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceRole, ClimbDirection) == 0x000968, "Member 'UKuroAnimInstanceRole::ClimbDirection' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceRole, ValidClimbDirection) == 0x00096C, "Member 'UKuroAnimInstanceRole::ValidClimbDirection' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceRole, IKMode) == 0x000970, "Member 'UKuroAnimInstanceRole::IKMode' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceRole, bIKNoLerp) == 0x000971, "Member 'UKuroAnimInstanceRole::bIKNoLerp' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceRole, ComprehensiveRotator) == 0x000974, "Member 'UKuroAnimInstanceRole::ComprehensiveRotator' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceRole, BeHitStandardizedDirect) == 0x000980, "Member 'UKuroAnimInstanceRole::BeHitStandardizedDirect' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceRole, BeHitSocketLocation) == 0x00098C, "Member 'UKuroAnimInstanceRole::BeHitSocketLocation' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceRole, SightLockAlpha) == 0x000998, "Member 'UKuroAnimInstanceRole::SightLockAlpha' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceRole, SightLockDirect) == 0x00099C, "Member 'UKuroAnimInstanceRole::SightLockDirect' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceRole, bInAimShotEnd) == 0x0009A8, "Member 'UKuroAnimInstanceRole::bInAimShotEnd' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceRole, AimYawMix) == 0x0009AC, "Member 'UKuroAnimInstanceRole::AimYawMix' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceRole, FreezeCountDown) == 0x0009B0, "Member 'UKuroAnimInstanceRole::FreezeCountDown' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceRole, bStateStop) == 0x0009B4, "Member 'UKuroAnimInstanceRole::bStateStop' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceRole, bStateSprintStop) == 0x0009B5, "Member 'UKuroAnimInstanceRole::bStateSprintStop' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceRole, bStateRunStop) == 0x0009B6, "Member 'UKuroAnimInstanceRole::bStateRunStop' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceRole, bStateWalkStop) == 0x0009B7, "Member 'UKuroAnimInstanceRole::bStateWalkStop' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceRole, bStateGround) == 0x0009B8, "Member 'UKuroAnimInstanceRole::bStateGround' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceRole, bStateStand) == 0x0009B9, "Member 'UKuroAnimInstanceRole::bStateStand' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceRole, bStateGroundSprint) == 0x0009BA, "Member 'UKuroAnimInstanceRole::bStateGroundSprint' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceRole, bStateGroundRun) == 0x0009BB, "Member 'UKuroAnimInstanceRole::bStateGroundRun' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceRole, bStateGroundWalk) == 0x0009BC, "Member 'UKuroAnimInstanceRole::bStateGroundWalk' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceRole, bStateClimb) == 0x0009BD, "Member 'UKuroAnimInstanceRole::bStateClimb' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceRole, bStateAir) == 0x0009BE, "Member 'UKuroAnimInstanceRole::bStateAir' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceRole, bStateSki) == 0x0009BF, "Member 'UKuroAnimInstanceRole::bStateSki' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceRole, bStateNormalSki) == 0x0009C0, "Member 'UKuroAnimInstanceRole::bStateNormalSki' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceRole, bStateAirSlide) == 0x0009C1, "Member 'UKuroAnimInstanceRole::bStateAirSlide' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceRole, bStateAirGlide) == 0x0009C2, "Member 'UKuroAnimInstanceRole::bStateAirGlide' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceRole, bStateWater) == 0x0009C3, "Member 'UKuroAnimInstanceRole::bStateWater' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceRole, bStateSkill) == 0x0009C4, "Member 'UKuroAnimInstanceRole::bStateSkill' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceRole, bStateLockDirection) == 0x0009C5, "Member 'UKuroAnimInstanceRole::bStateLockDirection' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceRole, bStateAimDirection) == 0x0009C6, "Member 'UKuroAnimInstanceRole::bStateAimDirection' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceRole, bStateFaceDirection) == 0x0009C7, "Member 'UKuroAnimInstanceRole::bStateFaceDirection' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceRole, bStateBeHit) == 0x0009C8, "Member 'UKuroAnimInstanceRole::bStateBeHit' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceRole, bStateHitPush) == 0x0009C9, "Member 'UKuroAnimInstanceRole::bStateHitPush' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceRole, bStateBeHitFly) == 0x0009CA, "Member 'UKuroAnimInstanceRole::bStateBeHitFly' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceRole, bStateDying) == 0x0009CB, "Member 'UKuroAnimInstanceRole::bStateDying' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceRole, bStateDrown) == 0x0009CC, "Member 'UKuroAnimInstanceRole::bStateDrown' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceRole, bStateInBattle) == 0x0009CD, "Member 'UKuroAnimInstanceRole::bStateInBattle' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceRole, bStateEnterBattle) == 0x0009CE, "Member 'UKuroAnimInstanceRole::bStateEnterBattle' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceRole, bStateKeepSprint) == 0x0009CF, "Member 'UKuroAnimInstanceRole::bStateKeepSprint' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceRole, bStateFastSwim) == 0x0009D0, "Member 'UKuroAnimInstanceRole::bStateFastSwim' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceRole, bStateSit) == 0x0009D1, "Member 'UKuroAnimInstanceRole::bStateSit' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceRole, bStateOverlapBaseAnim) == 0x0009D2, "Member 'UKuroAnimInstanceRole::bStateOverlapBaseAnim' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceRole, bUseAdditive) == 0x0009D3, "Member 'UKuroAnimInstanceRole::bUseAdditive' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceRole, bUseOverlapLayerAdditive) == 0x0009D4, "Member 'UKuroAnimInstanceRole::bUseOverlapLayerAdditive' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceRole, bStateLowerRightTurnBlending) == 0x0009D5, "Member 'UKuroAnimInstanceRole::bStateLowerRightTurnBlending' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceRole, bStateLowerBlending) == 0x0009D6, "Member 'UKuroAnimInstanceRole::bStateLowerBlending' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceRole, bStateWholeBodyBlend) == 0x0009D7, "Member 'UKuroAnimInstanceRole::bStateWholeBodyBlend' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceRole, bStateUseSpecialStateMachine) == 0x0009D8, "Member 'UKuroAnimInstanceRole::bStateUseSpecialStateMachine' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceRole, bStateFastBlend) == 0x0009D9, "Member 'UKuroAnimInstanceRole::bStateFastBlend' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceRole, LowerBlendAlpha) == 0x0009DC, "Member 'UKuroAnimInstanceRole::LowerBlendAlpha' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceRole, BlendAlphaPelvis) == 0x0009E0, "Member 'UKuroAnimInstanceRole::BlendAlphaPelvis' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceRole, BlendAlphaSpine) == 0x0009EC, "Member 'UKuroAnimInstanceRole::BlendAlphaSpine' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceRole, BlendAlphaHead) == 0x0009F8, "Member 'UKuroAnimInstanceRole::BlendAlphaHead' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceRole, BlendAlphaArmL) == 0x000A04, "Member 'UKuroAnimInstanceRole::BlendAlphaArmL' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceRole, BlendAlphaArmR) == 0x000A10, "Member 'UKuroAnimInstanceRole::BlendAlphaArmR' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceRole, BlendAlphaLeg) == 0x000A1C, "Member 'UKuroAnimInstanceRole::BlendAlphaLeg' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceRole, bStateCast) == 0x000A28, "Member 'UKuroAnimInstanceRole::bStateCast' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceRole, bStateCastThrowing) == 0x000A29, "Member 'UKuroAnimInstanceRole::bStateCastThrowing' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceRole, bStateCastSelecting) == 0x000A2A, "Member 'UKuroAnimInstanceRole::bStateCastSelecting' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceRole, bStateCastCasting) == 0x000A2B, "Member 'UKuroAnimInstanceRole::bStateCastCasting' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceRole, bStateMoveShot) == 0x000A2C, "Member 'UKuroAnimInstanceRole::bStateMoveShot' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceRole, bStateHoldShot) == 0x000A2D, "Member 'UKuroAnimInstanceRole::bStateHoldShot' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceRole, bStateAiming) == 0x000A2E, "Member 'UKuroAnimInstanceRole::bStateAiming' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceRole, bStateGeneralAiming) == 0x000A2F, "Member 'UKuroAnimInstanceRole::bStateGeneralAiming' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceRole, bStateShotNotify) == 0x000A30, "Member 'UKuroAnimInstanceRole::bStateShotNotify' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceRole, bStateFixHook) == 0x000A31, "Member 'UKuroAnimInstanceRole::bStateFixHook' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceRole, bStateAirNormalShot) == 0x000A32, "Member 'UKuroAnimInstanceRole::bStateAirNormalShot' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceRole, bStateAirNormalShotLeft) == 0x000A33, "Member 'UKuroAnimInstanceRole::bStateAirNormalShotLeft' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceRole, bStateAirNormalShotRight) == 0x000A34, "Member 'UKuroAnimInstanceRole::bStateAirNormalShotRight' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceRole, bStateAirNormalShotFall) == 0x000A35, "Member 'UKuroAnimInstanceRole::bStateAirNormalShotFall' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceRole, bStateBurst) == 0x000A36, "Member 'UKuroAnimInstanceRole::bStateBurst' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceRole, bStateInBurst) == 0x000A37, "Member 'UKuroAnimInstanceRole::bStateInBurst' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceRole, bStateLimitForward) == 0x000A38, "Member 'UKuroAnimInstanceRole::bStateLimitForward' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceRole, bStateLimitBackward) == 0x000A39, "Member 'UKuroAnimInstanceRole::bStateLimitBackward' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceRole, bLandRollWhenDying) == 0x000A3A, "Member 'UKuroAnimInstanceRole::bLandRollWhenDying' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceRole, bCaught) == 0x000A3B, "Member 'UKuroAnimInstanceRole::bCaught' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceRole, bRagDollQuit) == 0x000A3C, "Member 'UKuroAnimInstanceRole::bRagDollQuit' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceRole, ExpresionAlpha) == 0x000A40, "Member 'UKuroAnimInstanceRole::ExpresionAlpha' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceRole, bEpresion) == 0x000A4C, "Member 'UKuroAnimInstanceRole::bEpresion' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceRole, PerformanceCountDown) == 0x000A50, "Member 'UKuroAnimInstanceRole::PerformanceCountDown' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceRole, bPerformance) == 0x000A54, "Member 'UKuroAnimInstanceRole::bPerformance' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceRole, PerformanceIndex) == 0x000A58, "Member 'UKuroAnimInstanceRole::PerformanceIndex' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceRole, bAllowPerformance) == 0x000A5C, "Member 'UKuroAnimInstanceRole::bAllowPerformance' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceRole, bAcceptNewSkill) == 0x000A5D, "Member 'UKuroAnimInstanceRole::bAcceptNewSkill' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceRole, bStageMotionSki) == 0x000A64, "Member 'UKuroAnimInstanceRole::bStageMotionSki' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceRole, bHugeItemPull) == 0x000A65, "Member 'UKuroAnimInstanceRole::bHugeItemPull' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceRole, bHugeItemPullAngle) == 0x000A66, "Member 'UKuroAnimInstanceRole::bHugeItemPullAngle' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceRole, SizeToCharHeightMap) == 0x000A68, "Member 'UKuroAnimInstanceRole::SizeToCharHeightMap' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceRole, LandSpeedThresholds) == 0x000AB8, "Member 'UKuroAnimInstanceRole::LandSpeedThresholds' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceRole, SpeedMixLerp) == 0x000AC0, "Member 'UKuroAnimInstanceRole::SpeedMixLerp' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceRole, GroundLeanLerp) == 0x000AC4, "Member 'UKuroAnimInstanceRole::GroundLeanLerp' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceRole, AnimWalkSpeed) == 0x000AC8, "Member 'UKuroAnimInstanceRole::AnimWalkSpeed' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceRole, AnimRunSpeed) == 0x000ACC, "Member 'UKuroAnimInstanceRole::AnimRunSpeed' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceRole, AnimSprintSpeed) == 0x000AD0, "Member 'UKuroAnimInstanceRole::AnimSprintSpeed' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceRole, AirLeanLerp) == 0x000AD4, "Member 'UKuroAnimInstanceRole::AirLeanLerp' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceRole, JumpMixLerp) == 0x000AD8, "Member 'UKuroAnimInstanceRole::JumpMixLerp' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceRole, SlideRotateLerp) == 0x000ADC, "Member 'UKuroAnimInstanceRole::SlideRotateLerp' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceRole, SlideRotateLerp2) == 0x000AE0, "Member 'UKuroAnimInstanceRole::SlideRotateLerp2' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceRole, StandWalkStepCurve) == 0x000AE8, "Member 'UKuroAnimInstanceRole::StandWalkStepCurve' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceRole, StandRunStepCurve) == 0x000AF0, "Member 'UKuroAnimInstanceRole::StandRunStepCurve' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceRole, ForecastLandCurve) == 0x000AF8, "Member 'UKuroAnimInstanceRole::ForecastLandCurve' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceRole, RelativeSpeedBlendCurve) == 0x000B00, "Member 'UKuroAnimInstanceRole::RelativeSpeedBlendCurve' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceRole, AirLeanCurve) == 0x000B08, "Member 'UKuroAnimInstanceRole::AirLeanCurve' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceRole, AngelToStepLengthCurve) == 0x000B10, "Member 'UKuroAnimInstanceRole::AngelToStepLengthCurve' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceRole, AngleToStepFrequencyCurve) == 0x000B18, "Member 'UKuroAnimInstanceRole::AngleToStepFrequencyCurve' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceRole, FkMaterialControllerData) == 0x000B20, "Member 'UKuroAnimInstanceRole::FkMaterialControllerData' has a wrong offset!");

// Class KuroAnim.AbpLogicParams
// 0x00F0 (0x0120 - 0x0030)
class UAbpLogicParams final : public UObject
{
public:
	bool                                          AcceptedNewBeHitRef;                               // 0x0030(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x3];                                       // 0x0031(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         BeHitAnimRef;                                      // 0x0034(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          EnterFkRef;                                        // 0x0038(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          DoubleHitInAirRef;                                 // 0x0039(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3A[0x2];                                       // 0x003A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                BeHitDirectRef;                                    // 0x003C(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                BeHitLocationRef;                                  // 0x0048(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BeHitSocketNameRef;                                // 0x0054(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BeHitBoneRef;                                      // 0x0060(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECharMoveStateType                            CharMoveStateRef;                                  // 0x006C(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECharPositionStateType                        CharPositionStateRef;                              // 0x006D(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECharViewDirectionStateType                   CharCameraStateRef;                                // 0x006E(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6F[0x1];                                       // 0x006F(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BattleIdleTimeRef;                                 // 0x0070(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DegMovementSlopeRef;                               // 0x0074(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                SightDirectRef;                                    // 0x0078(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          RagQuitStateRef;                                   // 0x0084(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsJumpRef;                                         // 0x0085(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_86[0x2];                                       // 0x0086(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                AccelerationRef;                                   // 0x0088(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsMovingRef;                                       // 0x0094(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_95[0x3];                                       // 0x0095(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SpeedRef;                                          // 0x0098(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                InputDirectRef;                                    // 0x009C(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               InputRotatorRef;                                   // 0x00A8(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          IsFallingIntoWaterRef;                             // 0x00B4(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B5[0x3];                                       // 0x00B5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         GroundedTimeRef;                                   // 0x00B8(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          HasMoveInputRef;                                   // 0x00BC(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_BD[0x3];                                       // 0x00BD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FClimbInfoStruct                       ClimbInfoRef;                                      // 0x00C0(0x0010)(BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FClimbStateStruct                      ClimbStateRef;                                     // 0x00D0(0x0003)(BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_D3[0x1];                                       // 0x00D3(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ClimbOnWallAngleRef;                               // 0x00D4(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SprintSwimOffsetRef;                               // 0x00D8(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SprintSwimOffsetLerpSpeedRef;                      // 0x00DC(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                SlideForwardRef;                                   // 0x00E0(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          SlideSwitchThisFrameRef;                           // 0x00EC(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          SlideStandModeRef;                                 // 0x00ED(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_EE[0x2];                                       // 0x00EE(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         JumpUpRateRef;                                     // 0x00F0(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ForceExitStateStopRef;                             // 0x00F4(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F5[0x3];                                       // 0x00F5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 SkillTarget;                                       // 0x00F8(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 HateTarget;                                        // 0x0100(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LastActiveSkillTime;                               // 0x0108(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SitDownDirect;                                     // 0x010C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         StandUpDirect;                                     // 0x0110(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSitDown;                                          // 0x0114(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_115[0x3];                                      // 0x0115(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         SitDownType;                                       // 0x0118(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsInPerformingPlot;                               // 0x011C(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsInSequence;                                     // 0x011D(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsInSplineMove;                                   // 0x011E(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsInUiCamera;                                     // 0x011F(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AbpLogicParams">();
	}
	static class UAbpLogicParams* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbpLogicParams>();
	}
};
static_assert(alignof(UAbpLogicParams) == 0x000008, "Wrong alignment on UAbpLogicParams");
static_assert(sizeof(UAbpLogicParams) == 0x000120, "Wrong size on UAbpLogicParams");
static_assert(offsetof(UAbpLogicParams, AcceptedNewBeHitRef) == 0x000030, "Member 'UAbpLogicParams::AcceptedNewBeHitRef' has a wrong offset!");
static_assert(offsetof(UAbpLogicParams, BeHitAnimRef) == 0x000034, "Member 'UAbpLogicParams::BeHitAnimRef' has a wrong offset!");
static_assert(offsetof(UAbpLogicParams, EnterFkRef) == 0x000038, "Member 'UAbpLogicParams::EnterFkRef' has a wrong offset!");
static_assert(offsetof(UAbpLogicParams, DoubleHitInAirRef) == 0x000039, "Member 'UAbpLogicParams::DoubleHitInAirRef' has a wrong offset!");
static_assert(offsetof(UAbpLogicParams, BeHitDirectRef) == 0x00003C, "Member 'UAbpLogicParams::BeHitDirectRef' has a wrong offset!");
static_assert(offsetof(UAbpLogicParams, BeHitLocationRef) == 0x000048, "Member 'UAbpLogicParams::BeHitLocationRef' has a wrong offset!");
static_assert(offsetof(UAbpLogicParams, BeHitSocketNameRef) == 0x000054, "Member 'UAbpLogicParams::BeHitSocketNameRef' has a wrong offset!");
static_assert(offsetof(UAbpLogicParams, BeHitBoneRef) == 0x000060, "Member 'UAbpLogicParams::BeHitBoneRef' has a wrong offset!");
static_assert(offsetof(UAbpLogicParams, CharMoveStateRef) == 0x00006C, "Member 'UAbpLogicParams::CharMoveStateRef' has a wrong offset!");
static_assert(offsetof(UAbpLogicParams, CharPositionStateRef) == 0x00006D, "Member 'UAbpLogicParams::CharPositionStateRef' has a wrong offset!");
static_assert(offsetof(UAbpLogicParams, CharCameraStateRef) == 0x00006E, "Member 'UAbpLogicParams::CharCameraStateRef' has a wrong offset!");
static_assert(offsetof(UAbpLogicParams, BattleIdleTimeRef) == 0x000070, "Member 'UAbpLogicParams::BattleIdleTimeRef' has a wrong offset!");
static_assert(offsetof(UAbpLogicParams, DegMovementSlopeRef) == 0x000074, "Member 'UAbpLogicParams::DegMovementSlopeRef' has a wrong offset!");
static_assert(offsetof(UAbpLogicParams, SightDirectRef) == 0x000078, "Member 'UAbpLogicParams::SightDirectRef' has a wrong offset!");
static_assert(offsetof(UAbpLogicParams, RagQuitStateRef) == 0x000084, "Member 'UAbpLogicParams::RagQuitStateRef' has a wrong offset!");
static_assert(offsetof(UAbpLogicParams, IsJumpRef) == 0x000085, "Member 'UAbpLogicParams::IsJumpRef' has a wrong offset!");
static_assert(offsetof(UAbpLogicParams, AccelerationRef) == 0x000088, "Member 'UAbpLogicParams::AccelerationRef' has a wrong offset!");
static_assert(offsetof(UAbpLogicParams, IsMovingRef) == 0x000094, "Member 'UAbpLogicParams::IsMovingRef' has a wrong offset!");
static_assert(offsetof(UAbpLogicParams, SpeedRef) == 0x000098, "Member 'UAbpLogicParams::SpeedRef' has a wrong offset!");
static_assert(offsetof(UAbpLogicParams, InputDirectRef) == 0x00009C, "Member 'UAbpLogicParams::InputDirectRef' has a wrong offset!");
static_assert(offsetof(UAbpLogicParams, InputRotatorRef) == 0x0000A8, "Member 'UAbpLogicParams::InputRotatorRef' has a wrong offset!");
static_assert(offsetof(UAbpLogicParams, IsFallingIntoWaterRef) == 0x0000B4, "Member 'UAbpLogicParams::IsFallingIntoWaterRef' has a wrong offset!");
static_assert(offsetof(UAbpLogicParams, GroundedTimeRef) == 0x0000B8, "Member 'UAbpLogicParams::GroundedTimeRef' has a wrong offset!");
static_assert(offsetof(UAbpLogicParams, HasMoveInputRef) == 0x0000BC, "Member 'UAbpLogicParams::HasMoveInputRef' has a wrong offset!");
static_assert(offsetof(UAbpLogicParams, ClimbInfoRef) == 0x0000C0, "Member 'UAbpLogicParams::ClimbInfoRef' has a wrong offset!");
static_assert(offsetof(UAbpLogicParams, ClimbStateRef) == 0x0000D0, "Member 'UAbpLogicParams::ClimbStateRef' has a wrong offset!");
static_assert(offsetof(UAbpLogicParams, ClimbOnWallAngleRef) == 0x0000D4, "Member 'UAbpLogicParams::ClimbOnWallAngleRef' has a wrong offset!");
static_assert(offsetof(UAbpLogicParams, SprintSwimOffsetRef) == 0x0000D8, "Member 'UAbpLogicParams::SprintSwimOffsetRef' has a wrong offset!");
static_assert(offsetof(UAbpLogicParams, SprintSwimOffsetLerpSpeedRef) == 0x0000DC, "Member 'UAbpLogicParams::SprintSwimOffsetLerpSpeedRef' has a wrong offset!");
static_assert(offsetof(UAbpLogicParams, SlideForwardRef) == 0x0000E0, "Member 'UAbpLogicParams::SlideForwardRef' has a wrong offset!");
static_assert(offsetof(UAbpLogicParams, SlideSwitchThisFrameRef) == 0x0000EC, "Member 'UAbpLogicParams::SlideSwitchThisFrameRef' has a wrong offset!");
static_assert(offsetof(UAbpLogicParams, SlideStandModeRef) == 0x0000ED, "Member 'UAbpLogicParams::SlideStandModeRef' has a wrong offset!");
static_assert(offsetof(UAbpLogicParams, JumpUpRateRef) == 0x0000F0, "Member 'UAbpLogicParams::JumpUpRateRef' has a wrong offset!");
static_assert(offsetof(UAbpLogicParams, ForceExitStateStopRef) == 0x0000F4, "Member 'UAbpLogicParams::ForceExitStateStopRef' has a wrong offset!");
static_assert(offsetof(UAbpLogicParams, SkillTarget) == 0x0000F8, "Member 'UAbpLogicParams::SkillTarget' has a wrong offset!");
static_assert(offsetof(UAbpLogicParams, HateTarget) == 0x000100, "Member 'UAbpLogicParams::HateTarget' has a wrong offset!");
static_assert(offsetof(UAbpLogicParams, LastActiveSkillTime) == 0x000108, "Member 'UAbpLogicParams::LastActiveSkillTime' has a wrong offset!");
static_assert(offsetof(UAbpLogicParams, SitDownDirect) == 0x00010C, "Member 'UAbpLogicParams::SitDownDirect' has a wrong offset!");
static_assert(offsetof(UAbpLogicParams, StandUpDirect) == 0x000110, "Member 'UAbpLogicParams::StandUpDirect' has a wrong offset!");
static_assert(offsetof(UAbpLogicParams, bSitDown) == 0x000114, "Member 'UAbpLogicParams::bSitDown' has a wrong offset!");
static_assert(offsetof(UAbpLogicParams, SitDownType) == 0x000118, "Member 'UAbpLogicParams::SitDownType' has a wrong offset!");
static_assert(offsetof(UAbpLogicParams, bIsInPerformingPlot) == 0x00011C, "Member 'UAbpLogicParams::bIsInPerformingPlot' has a wrong offset!");
static_assert(offsetof(UAbpLogicParams, bIsInSequence) == 0x00011D, "Member 'UAbpLogicParams::bIsInSequence' has a wrong offset!");
static_assert(offsetof(UAbpLogicParams, bIsInSplineMove) == 0x00011E, "Member 'UAbpLogicParams::bIsInSplineMove' has a wrong offset!");
static_assert(offsetof(UAbpLogicParams, bIsInUiCamera) == 0x00011F, "Member 'UAbpLogicParams::bIsInUiCamera' has a wrong offset!");

// Class KuroAnim.KuroAnimJsSubsystem
// 0x00B0 (0x00E8 - 0x0038)
class UKuroAnimJsSubsystem final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_38[0xB0];                                      // 0x0038(0x00B0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroAnimJsSubsystem">();
	}
	static class UKuroAnimJsSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroAnimJsSubsystem>();
	}
};
static_assert(alignof(UKuroAnimJsSubsystem) == 0x000008, "Wrong alignment on UKuroAnimJsSubsystem");
static_assert(sizeof(UKuroAnimJsSubsystem) == 0x0000E8, "Wrong size on UKuroAnimJsSubsystem");

// Class KuroAnim.KuroAnimLibrary
// 0x0000 (0x0030 - 0x0030)
class UKuroAnimLibrary final : public UBlueprintFunctionLibrary
{
public:
	static void EndAnimNotifyStates(class UAnimInstance* AnimInstance);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroAnimLibrary">();
	}
	static class UKuroAnimLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroAnimLibrary>();
	}
};
static_assert(alignof(UKuroAnimLibrary) == 0x000008, "Wrong alignment on UKuroAnimLibrary");
static_assert(sizeof(UKuroAnimLibrary) == 0x000030, "Wrong size on UKuroAnimLibrary");

// Class KuroAnim.KuroAnimMathLibrary
// 0x0000 (0x0030 - 0x0030)
class UKuroAnimMathLibrary final : public UBlueprintFunctionLibrary
{
public:
	static struct FRotator LookRotation_ForwardFirst(const struct FVector& Forward, const struct FVector& Up);
	static struct FRotator LookRotation_UpFirst(const struct FVector& Forward, const struct FVector& Up);
	static struct FRotator Quat_FindBetween(const struct FVector& V1, const struct FVector& V2);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroAnimMathLibrary">();
	}
	static class UKuroAnimMathLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroAnimMathLibrary>();
	}
};
static_assert(alignof(UKuroAnimMathLibrary) == 0x000008, "Wrong alignment on UKuroAnimMathLibrary");
static_assert(sizeof(UKuroAnimMathLibrary) == 0x000030, "Wrong size on UKuroAnimMathLibrary");

// Class KuroAnim.KuroTrackRecorder
// 0x00F0 (0x0120 - 0x0030)
class UKuroTrackRecorder : public UObject
{
public:
	uint8                                         Pad_30[0xF0];                                      // 0x0030(0x00F0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	struct FGuid GetMainGuid();
	class AActor* GetShadow();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroTrackRecorder">();
	}
	static class UKuroTrackRecorder* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroTrackRecorder>();
	}
};
static_assert(alignof(UKuroTrackRecorder) == 0x000008, "Wrong alignment on UKuroTrackRecorder");
static_assert(sizeof(UKuroTrackRecorder) == 0x000120, "Wrong size on UKuroTrackRecorder");

// Class KuroAnim.KuroCameraRecorder
// 0x0008 (0x0128 - 0x0120)
class UKuroCameraRecorder final : public UKuroTrackRecorder
{
public:
	uint8                                         Pad_120[0x8];                                      // 0x0120(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroCameraRecorder">();
	}
	static class UKuroCameraRecorder* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroCameraRecorder>();
	}
};
static_assert(alignof(UKuroCameraRecorder) == 0x000008, "Wrong alignment on UKuroCameraRecorder");
static_assert(sizeof(UKuroCameraRecorder) == 0x000128, "Wrong size on UKuroCameraRecorder");

// Class KuroAnim.KuroCameraShake
// 0x0030 (0x01D0 - 0x01A0)
class UKuroCameraShake : public UMatineeCameraShake
{
public:
	EAlphaBlendOption                             BlendInMode;                                       // 0x0198(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_199[0x7];                                      // 0x0199(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            BlendInCustomCurve;                                // 0x01A0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAlphaBlendOption                             BlendOutMode;                                      // 0x01A8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A9[0x7];                                      // 0x01A9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            BlendOutCustomCurve;                               // 0x01B0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bIsUseCurveVector : 1;                             // 0x01B8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1B9[0x7];                                      // 0x01B9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveVector*                           BlendCurveVector;                                  // 0x01C0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C8[0x8];                                      // 0x01C8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroCameraShake">();
	}
	static class UKuroCameraShake* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroCameraShake>();
	}
};
static_assert(alignof(UKuroCameraShake) == 0x000010, "Wrong alignment on UKuroCameraShake");
static_assert(sizeof(UKuroCameraShake) == 0x0001D0, "Wrong size on UKuroCameraShake");
static_assert(offsetof(UKuroCameraShake, BlendInMode) == 0x000198, "Member 'UKuroCameraShake::BlendInMode' has a wrong offset!");
static_assert(offsetof(UKuroCameraShake, BlendInCustomCurve) == 0x0001A0, "Member 'UKuroCameraShake::BlendInCustomCurve' has a wrong offset!");
static_assert(offsetof(UKuroCameraShake, BlendOutMode) == 0x0001A8, "Member 'UKuroCameraShake::BlendOutMode' has a wrong offset!");
static_assert(offsetof(UKuroCameraShake, BlendOutCustomCurve) == 0x0001B0, "Member 'UKuroCameraShake::BlendOutCustomCurve' has a wrong offset!");
static_assert(offsetof(UKuroCameraShake, BlendCurveVector) == 0x0001C0, "Member 'UKuroCameraShake::BlendCurveVector' has a wrong offset!");

// Class KuroAnim.KuroCharacterRecorder
// 0x0010 (0x0130 - 0x0120)
class UKuroCharacterRecorder final : public UKuroTrackRecorder
{
public:
	bool                                          bUseClone;                                         // 0x0120(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_121[0x7];                                      // 0x0121(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UObject*                                BaseBlueprint;                                     // 0x0128(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroCharacterRecorder">();
	}
	static class UKuroCharacterRecorder* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroCharacterRecorder>();
	}
};
static_assert(alignof(UKuroCharacterRecorder) == 0x000008, "Wrong alignment on UKuroCharacterRecorder");
static_assert(sizeof(UKuroCharacterRecorder) == 0x000130, "Wrong size on UKuroCharacterRecorder");
static_assert(offsetof(UKuroCharacterRecorder, bUseClone) == 0x000120, "Member 'UKuroCharacterRecorder::bUseClone' has a wrong offset!");
static_assert(offsetof(UKuroCharacterRecorder, BaseBlueprint) == 0x000128, "Member 'UKuroCharacterRecorder::BaseBlueprint' has a wrong offset!");

// Class KuroAnim.KuroEffectRecorder
// 0x0000 (0x0120 - 0x0120)
class UKuroEffectRecorder final : public UKuroTrackRecorder
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroEffectRecorder">();
	}
	static class UKuroEffectRecorder* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroEffectRecorder>();
	}
};
static_assert(alignof(UKuroEffectRecorder) == 0x000008, "Wrong alignment on UKuroEffectRecorder");
static_assert(sizeof(UKuroEffectRecorder) == 0x000120, "Wrong size on UKuroEffectRecorder");

// Class KuroAnim.KuroMeshRecorder
// 0x0000 (0x0120 - 0x0120)
class UKuroMeshRecorder final : public UKuroTrackRecorder
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroMeshRecorder">();
	}
	static class UKuroMeshRecorder* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroMeshRecorder>();
	}
};
static_assert(alignof(UKuroMeshRecorder) == 0x000008, "Wrong alignment on UKuroMeshRecorder");
static_assert(sizeof(UKuroMeshRecorder) == 0x000120, "Wrong size on UKuroMeshRecorder");

// Class KuroAnim.KuroRecordCharacter
// 0x0068 (0x0318 - 0x02B0)
class AKuroRecordCharacter final : public AActor
{
public:
	class USceneComponent*                        MainScene;                                         // 0x02B0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USkeletalMeshComponent*                 SubMesh0;                                          // 0x02B8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USkeletalMeshComponent*                 SubMesh1;                                          // 0x02C0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USkeletalMeshComponent*                 SubMesh2;                                          // 0x02C8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USkeletalMeshComponent*                 SubMesh3;                                          // 0x02D0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USkeletalMeshComponent*                 SubMesh4;                                          // 0x02D8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USkeletalMeshComponent*                 SubMesh5;                                          // 0x02E0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USkeletalMeshComponent*                 SubMesh6;                                          // 0x02E8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USkeletalMeshComponent*                 SubMesh7;                                          // 0x02F0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USkeletalMeshComponent*                 SubMesh8;                                          // 0x02F8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USkeletalMeshComponent*                 SubMesh9;                                          // 0x0300(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USkeletalMeshComponent*                 SubMesh10;                                         // 0x0308(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USkeletalMeshComponent*                 SubMesh11;                                         // 0x0310(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroRecordCharacter">();
	}
	static class AKuroRecordCharacter* GetDefaultObj()
	{
		return GetDefaultObjImpl<AKuroRecordCharacter>();
	}
};
static_assert(alignof(AKuroRecordCharacter) == 0x000008, "Wrong alignment on AKuroRecordCharacter");
static_assert(sizeof(AKuroRecordCharacter) == 0x000318, "Wrong size on AKuroRecordCharacter");
static_assert(offsetof(AKuroRecordCharacter, MainScene) == 0x0002B0, "Member 'AKuroRecordCharacter::MainScene' has a wrong offset!");
static_assert(offsetof(AKuroRecordCharacter, SubMesh0) == 0x0002B8, "Member 'AKuroRecordCharacter::SubMesh0' has a wrong offset!");
static_assert(offsetof(AKuroRecordCharacter, SubMesh1) == 0x0002C0, "Member 'AKuroRecordCharacter::SubMesh1' has a wrong offset!");
static_assert(offsetof(AKuroRecordCharacter, SubMesh2) == 0x0002C8, "Member 'AKuroRecordCharacter::SubMesh2' has a wrong offset!");
static_assert(offsetof(AKuroRecordCharacter, SubMesh3) == 0x0002D0, "Member 'AKuroRecordCharacter::SubMesh3' has a wrong offset!");
static_assert(offsetof(AKuroRecordCharacter, SubMesh4) == 0x0002D8, "Member 'AKuroRecordCharacter::SubMesh4' has a wrong offset!");
static_assert(offsetof(AKuroRecordCharacter, SubMesh5) == 0x0002E0, "Member 'AKuroRecordCharacter::SubMesh5' has a wrong offset!");
static_assert(offsetof(AKuroRecordCharacter, SubMesh6) == 0x0002E8, "Member 'AKuroRecordCharacter::SubMesh6' has a wrong offset!");
static_assert(offsetof(AKuroRecordCharacter, SubMesh7) == 0x0002F0, "Member 'AKuroRecordCharacter::SubMesh7' has a wrong offset!");
static_assert(offsetof(AKuroRecordCharacter, SubMesh8) == 0x0002F8, "Member 'AKuroRecordCharacter::SubMesh8' has a wrong offset!");
static_assert(offsetof(AKuroRecordCharacter, SubMesh9) == 0x000300, "Member 'AKuroRecordCharacter::SubMesh9' has a wrong offset!");
static_assert(offsetof(AKuroRecordCharacter, SubMesh10) == 0x000308, "Member 'AKuroRecordCharacter::SubMesh10' has a wrong offset!");
static_assert(offsetof(AKuroRecordCharacter, SubMesh11) == 0x000310, "Member 'AKuroRecordCharacter::SubMesh11' has a wrong offset!");

// Class KuroAnim.KuroRecordEffect
// 0x0000 (0x02B0 - 0x02B0)
class AKuroRecordEffect : public AActor
{
public:
	void OnPlay();
	void OnStop();
	void Play();
	void Stop();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroRecordEffect">();
	}
	static class AKuroRecordEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<AKuroRecordEffect>();
	}
};
static_assert(alignof(AKuroRecordEffect) == 0x000008, "Wrong alignment on AKuroRecordEffect");
static_assert(sizeof(AKuroRecordEffect) == 0x0002B0, "Wrong size on AKuroRecordEffect");

// Class KuroAnim.KuroRecorderLibrary
// 0x0000 (0x0030 - 0x0030)
class UKuroRecorderLibrary final : public UBlueprintFunctionLibrary
{
public:
	static struct FGuid CopyLevelSequence(class ULevelSequence* SourceSequence, class ULevelSequence* TargetSequence, float TimeOffset, const TMap<class FName, struct FGuid>& RetargetAttached, const TSet<class UClass*>& IgnoreClasses, const struct FTransform& StartTransform);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroRecorderLibrary">();
	}
	static class UKuroRecorderLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroRecorderLibrary>();
	}
};
static_assert(alignof(UKuroRecorderLibrary) == 0x000008, "Wrong alignment on UKuroRecorderLibrary");
static_assert(sizeof(UKuroRecorderLibrary) == 0x000030, "Wrong size on UKuroRecorderLibrary");

}

