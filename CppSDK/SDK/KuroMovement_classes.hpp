#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: KuroMovement

#include "Basic.hpp"

#include "CoreUObject_classes.hpp"
#include "KuroMovement_structs.hpp"
#include "Engine_structs.hpp"
#include "Engine_classes.hpp"


namespace SDK
{

// Class KuroMovement.KuroClimbObject
// 0x01F0 (0x0220 - 0x0030)
class UKuroClimbObject final : public UObject
{
public:
	uint8                                         Pad_30[0x1F0];                                     // 0x0030(0x01F0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool ClimbBlock();
	void ConfirmMove();
	struct FVectorDouble D_GetSafetyLocation();
	bool D_ProcessClimbing(const struct FVectorDouble& MoveSpeed, float DeltaTime, bool IsTryMove, float DebugDrawDuration, struct FTransformDouble* OutTrans);
	EClimbingArriveType D_TryClimbingArrives(const struct FVectorDouble& InputDirect, float DebugDrawDuration, struct FTransformDouble* OutTrans, bool NeedTryBlockUp);
	ESprintVaultType D_TrySprintVault(float DebugDrawDuration, struct FTransformDouble* OutTrans, float* OutLongOffset);
	bool D_TryStartClimb(const struct FTransformDouble& Trans, float DebugDrawDuration, struct FTransformDouble* OutTrans);
	EClimbingArriveType D_TryUpArrives(const struct FVectorDouble& InputDirect, float DebugDrawDuration, struct FTransformDouble* OutTrans);
	void ExitClimb();
	struct FVector GetSafetyLocation();
	struct FVector GetSecondMoveOffset();
	void InitBase(class UShapeComponent* InShapeComp, ECollisionChannel InClimbChannel, const TArray<struct FVector>& BaseLocations, float InSphereRadius, float InActorToWallDist, float InDetectLength, float InSafetyHalfHeight, float InSafetyRadius);
	void InitBlockUps(const struct FVector& InBlockUpOffset, float InBlockUpDetectRadius, float InBlockUpDetectDistance, float InBlockUpBackDistance, float InBlockUpBackMin, const struct FVector& InBlockUpFinalMove, float BlockUpVerticalRangeMin, float BlockUpVerticalRangeMax);
	void InitClimbSafety(float InRadius, float InHalfHeight, float InMaxOffset);
	void InitSprintVault(float InForwardBlockHeight, float InForwardBlockRadius, float InForwardBlockDistanceMin, float InForwardBlockDistanceMax, const struct FVector& InSprintVaultMoveOffset, float InHeightMin, float InHeightMax, float InSprintVaultLongNeedDistance, float InSprintVaultLongHeight, ETraceTypeQuery InBlockChannel, float SprintVaultLongMin, float SprintVaultLongMax, float SprintVaultBlockMaxAngle);
	void InitUpArrives(const TArray<struct FVector>& InUpArriveMoveOffsets, const TArray<float>& InHeightMins, const TArray<float>& InHeightMaxs);
	bool NeedFollowHangOnStartingClimb();
	bool ProcessClimbing(const struct FVector& MoveSpeed, float DeltaTime, bool IsTryMove, float DebugDrawDuration, struct FTransform* OutTrans);
	void SyncFromOther(class UKuroClimbObject* Other);
	EClimbingArriveType TryClimbingArrives(const struct FVector& InputDirect, float DebugDrawDuration, struct FTransform* OutTrans, bool NeedTryBlockUp);
	ESprintVaultType TrySprintVault(float DebugDrawDuration, struct FTransform* OutTrans, float* OutLongOffset);
	bool TryStartClimb(const struct FTransform& Trans, float DebugDrawDuration, struct FTransform* OutTrans);
	EClimbingArriveType TryUpArrives(const struct FVector& InputDirect, float DebugDrawDuration, struct FTransform* OutTrans);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroClimbObject">();
	}
	static class UKuroClimbObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroClimbObject>();
	}
};
static_assert(alignof(UKuroClimbObject) == 0x000008, "Wrong alignment on UKuroClimbObject");
static_assert(sizeof(UKuroClimbObject) == 0x000220, "Wrong size on UKuroClimbObject");

// Class KuroMovement.KuroDebugMovementComponent
// 0x01A0 (0x06A0 - 0x0500)
class UKuroDebugMovementComponent final : public UPrimitiveComponent
{
public:
	int32                                         DrawDebugCount;                                    // 0x0500(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bShowLog : 1;                                      // 0x0504(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	EKDMDrawDebugType                             bDrawDebug;                                        // 0x0505(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_506[0x19A];                                    // 0x0506(0x019A)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class FString KuroDebugMovementBaseRecordToString(const struct FBaseRecord& Record);

	int32 GetCurrentFrameIndex();
	class FString GetFrameCountInfo();
	int32 GetMaxRecordFrameCount();
	const struct FSingleFrameDebugInfo GetPreviousRecord(int32 preNum);
	const TArray<struct FSingleFrameDebugInfo> GetRecentRecords();
	int32 GetRecordFrames();
	void RecordModifyInfo(const class FString& Context, const struct FVector& CustomVector, EKDMRecordType Type);
	void Resigter();
	void SetDebug(bool bDebug, bool bDetial);
	void UnResigter();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroDebugMovementComponent">();
	}
	static class UKuroDebugMovementComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroDebugMovementComponent>();
	}
};
static_assert(alignof(UKuroDebugMovementComponent) == 0x000010, "Wrong alignment on UKuroDebugMovementComponent");
static_assert(sizeof(UKuroDebugMovementComponent) == 0x0006A0, "Wrong size on UKuroDebugMovementComponent");
static_assert(offsetof(UKuroDebugMovementComponent, DrawDebugCount) == 0x000500, "Member 'UKuroDebugMovementComponent::DrawDebugCount' has a wrong offset!");
static_assert(offsetof(UKuroDebugMovementComponent, bDrawDebug) == 0x000505, "Member 'UKuroDebugMovementComponent::bDrawDebug' has a wrong offset!");

// Class KuroMovement.KuroMoveTrigger
// 0x0008 (0x02B8 - 0x02B0)
class AKuroMoveTrigger : public AActor
{
public:
	ETriggerAreaType                              AreaType;                                          // 0x02B0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B1[0x7];                                      // 0x02B1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnEndOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);
	void OnEnterOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroMoveTrigger">();
	}
	static class AKuroMoveTrigger* GetDefaultObj()
	{
		return GetDefaultObjImpl<AKuroMoveTrigger>();
	}
};
static_assert(alignof(AKuroMoveTrigger) == 0x000008, "Wrong alignment on AKuroMoveTrigger");
static_assert(sizeof(AKuroMoveTrigger) == 0x0002B8, "Wrong size on AKuroMoveTrigger");
static_assert(offsetof(AKuroMoveTrigger, AreaType) == 0x0002B0, "Member 'AKuroMoveTrigger::AreaType' has a wrong offset!");

// Class KuroMovement.KuroMoveBoxTrigger
// 0x0008 (0x02C0 - 0x02B8)
class AKuroMoveBoxTrigger final : public AKuroMoveTrigger
{
public:
	class UBoxComponent*                          BoxCollision;                                      // 0x02B8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroMoveBoxTrigger">();
	}
	static class AKuroMoveBoxTrigger* GetDefaultObj()
	{
		return GetDefaultObjImpl<AKuroMoveBoxTrigger>();
	}
};
static_assert(alignof(AKuroMoveBoxTrigger) == 0x000008, "Wrong alignment on AKuroMoveBoxTrigger");
static_assert(sizeof(AKuroMoveBoxTrigger) == 0x0002C0, "Wrong size on AKuroMoveBoxTrigger");
static_assert(offsetof(AKuroMoveBoxTrigger, BoxCollision) == 0x0002B8, "Member 'AKuroMoveBoxTrigger::BoxCollision' has a wrong offset!");

// Class KuroMovement.KuroMoveBrushTrigger
// 0x0010 (0x02C8 - 0x02B8)
class AKuroMoveBrushTrigger final : public AKuroMoveTrigger
{
public:
	class ABrush*                                 Volume;                                            // 0x02B8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USceneComponent*                        Root;                                              // 0x02C0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroMoveBrushTrigger">();
	}
	static class AKuroMoveBrushTrigger* GetDefaultObj()
	{
		return GetDefaultObjImpl<AKuroMoveBrushTrigger>();
	}
};
static_assert(alignof(AKuroMoveBrushTrigger) == 0x000008, "Wrong alignment on AKuroMoveBrushTrigger");
static_assert(sizeof(AKuroMoveBrushTrigger) == 0x0002C8, "Wrong size on AKuroMoveBrushTrigger");
static_assert(offsetof(AKuroMoveBrushTrigger, Volume) == 0x0002B8, "Member 'AKuroMoveBrushTrigger::Volume' has a wrong offset!");
static_assert(offsetof(AKuroMoveBrushTrigger, Root) == 0x0002C0, "Member 'AKuroMoveBrushTrigger::Root' has a wrong offset!");

// Class KuroMovement.KuroMovementBPLibrary
// 0x0000 (0x0030 - 0x0030)
class UKuroMovementBPLibrary final : public UBlueprintFunctionLibrary
{
public:
	static bool KuroKite(float DeltaSeconds, class UCharacterMovementComponent* CharMoveComp, const struct FVector& TargetPrevPos, const struct FVector& TargetNextPos, float MinDist, float MaxDist, float MinAccel, float MaxAccel, float Friction, struct FVector* InOutTargetForward, float FacingLerpSpeed, float FacingLerpRate);
	static bool KuroRoll(float DeltaSeconds, class UCharacterMovementComponent* CharMoveComp, float TargetSpeed, float Friction, float AccelOnGround, struct FVector* FloorNormal, float Gravity, float StepUpHeight, float MaxSpeed);
	static int32 KuroSki(float DeltaTime, class UCharacterMovementComponent* CharMoveComp, const struct FVector& PrevBlockNormal, const struct FVector& Direction, const struct FVector& SpeedParams, float IgnoreStepHeight, class UCurveFloat* SpeedReduceCurve);
	static EMoveHitType KuroSoar(float DeltaSeconds, class UCharacterMovementComponent* CharMoveComp, float AirFriction, float Aerodynamics, const struct FVector& Gravity, const struct FVector& SoarPlaneNormal, float MaxSpeed);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroMovementBPLibrary">();
	}
	static class UKuroMovementBPLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroMovementBPLibrary>();
	}
};
static_assert(alignof(UKuroMovementBPLibrary) == 0x000008, "Wrong alignment on UKuroMovementBPLibrary");
static_assert(sizeof(UKuroMovementBPLibrary) == 0x000030, "Wrong size on UKuroMovementBPLibrary");

// Class KuroMovement.KuroMoveTriggerController
// 0x0020 (0x02D0 - 0x02B0)
class AKuroMoveTriggerController final : public AInfo
{
public:
	TMulticastInlineDelegate<void(const TArray<struct FOverlapActorRecord>& Records)> Callback;      // 0x02B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TArray<struct FOverlapActorRecord>            Records;                                           // 0x02C0(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	static void RegisterController(class AKuroMoveTriggerController* ControllerPtr);
	static void UnRegisterController();

	void InitAllTriggers();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroMoveTriggerController">();
	}
	static class AKuroMoveTriggerController* GetDefaultObj()
	{
		return GetDefaultObjImpl<AKuroMoveTriggerController>();
	}
};
static_assert(alignof(AKuroMoveTriggerController) == 0x000008, "Wrong alignment on AKuroMoveTriggerController");
static_assert(sizeof(AKuroMoveTriggerController) == 0x0002D0, "Wrong size on AKuroMoveTriggerController");
static_assert(offsetof(AKuroMoveTriggerController, Callback) == 0x0002B0, "Member 'AKuroMoveTriggerController::Callback' has a wrong offset!");
static_assert(offsetof(AKuroMoveTriggerController, Records) == 0x0002C0, "Member 'AKuroMoveTriggerController::Records' has a wrong offset!");

}

