#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: MagicLeapPlanes

#include "Basic.hpp"

#include "MagicLeapPlanes_classes.hpp"
#include "MagicLeapPlanes_parameters.hpp"


namespace SDK
{

// Function MagicLeapPlanes.MagicLeapPlanesComponent.RequestPlanesAsync
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMagicLeapPlanesComponent::RequestPlanesAsync()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MagicLeapPlanesComponent", "RequestPlanesAsync");

	Params::MagicLeapPlanesComponent_RequestPlanesAsync Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function MagicLeapPlanes.MagicLeapPlanesFunctionLibrary.AddPersistentQuery
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// EMagicLeapPlaneQueryType                PersistentQueryType                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGuid                            ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FGuid UMagicLeapPlanesFunctionLibrary::AddPersistentQuery(EMagicLeapPlaneQueryType PersistentQueryType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MagicLeapPlanesFunctionLibrary", "AddPersistentQuery");

	Params::MagicLeapPlanesFunctionLibrary_AddPersistentQuery Parms{};

	Parms.PersistentQueryType = PersistentQueryType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function MagicLeapPlanes.MagicLeapPlanesFunctionLibrary.CreateTracker
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMagicLeapPlanesFunctionLibrary::CreateTracker()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MagicLeapPlanesFunctionLibrary", "CreateTracker");

	Params::MagicLeapPlanesFunctionLibrary_CreateTracker Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function MagicLeapPlanes.MagicLeapPlanesFunctionLibrary.DestroyTracker
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMagicLeapPlanesFunctionLibrary::DestroyTracker()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MagicLeapPlanesFunctionLibrary", "DestroyTracker");

	Params::MagicLeapPlanesFunctionLibrary_DestroyTracker Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function MagicLeapPlanes.MagicLeapPlanesFunctionLibrary.GetContentScale
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const class AActor*                     ContentActor                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FMagicLeapPlaneResult&     PlaneResult                                            (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FTransform                       ReturnValue                                            (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FTransform UMagicLeapPlanesFunctionLibrary::GetContentScale(const class AActor* ContentActor, const struct FMagicLeapPlaneResult& PlaneResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MagicLeapPlanesFunctionLibrary", "GetContentScale");

	Params::MagicLeapPlanesFunctionLibrary_GetContentScale Parms{};

	Parms.ContentActor = ContentActor;
	Parms.PlaneResult = std::move(PlaneResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function MagicLeapPlanes.MagicLeapPlanesFunctionLibrary.IsTrackerValid
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMagicLeapPlanesFunctionLibrary::IsTrackerValid()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MagicLeapPlanesFunctionLibrary", "IsTrackerValid");

	Params::MagicLeapPlanesFunctionLibrary_IsTrackerValid Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function MagicLeapPlanes.MagicLeapPlanesFunctionLibrary.PlanesPersistentQueryBeginAsync
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FMagicLeapPlanesQuery&     Query                                                  (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// const struct FGuid&                     Handle                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TDelegate<void(const bool bSuccess, const struct FGuid& QueryHandle, const EMagicLeapPlaneQueryType QueryType, const TArray<struct FMagicLeapPlaneResult>& NewPlanes, const TArray<struct FGuid>& RemovedPlaneIDs, const TArray<struct FMagicLeapPlaneBoundaries>& NewPolygons, const TArray<struct FGuid>& RemovedPolygonIDs)>&ResultDelegate                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMagicLeapPlanesFunctionLibrary::PlanesPersistentQueryBeginAsync(const struct FMagicLeapPlanesQuery& Query, const struct FGuid& Handle, const TDelegate<void(const bool bSuccess, const struct FGuid& QueryHandle, const EMagicLeapPlaneQueryType QueryType, const TArray<struct FMagicLeapPlaneResult>& NewPlanes, const TArray<struct FGuid>& RemovedPlaneIDs, const TArray<struct FMagicLeapPlaneBoundaries>& NewPolygons, const TArray<struct FGuid>& RemovedPolygonIDs)>& ResultDelegate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MagicLeapPlanesFunctionLibrary", "PlanesPersistentQueryBeginAsync");

	Params::MagicLeapPlanesFunctionLibrary_PlanesPersistentQueryBeginAsync Parms{};

	Parms.Query = std::move(Query);
	Parms.Handle = std::move(Handle);
	Parms.ResultDelegate = ResultDelegate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function MagicLeapPlanes.MagicLeapPlanesFunctionLibrary.PlanesQueryBeginAsync
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FMagicLeapPlanesQuery&     Query                                                  (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// const TDelegate<void(const bool bSuccess, const TArray<struct FMagicLeapPlaneResult>& Planes, const TArray<struct FMagicLeapPlaneBoundaries>& Polygons)>&ResultDelegate                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMagicLeapPlanesFunctionLibrary::PlanesQueryBeginAsync(const struct FMagicLeapPlanesQuery& Query, const TDelegate<void(const bool bSuccess, const TArray<struct FMagicLeapPlaneResult>& Planes, const TArray<struct FMagicLeapPlaneBoundaries>& Polygons)>& ResultDelegate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MagicLeapPlanesFunctionLibrary", "PlanesQueryBeginAsync");

	Params::MagicLeapPlanesFunctionLibrary_PlanesQueryBeginAsync Parms{};

	Parms.Query = std::move(Query);
	Parms.ResultDelegate = ResultDelegate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function MagicLeapPlanes.MagicLeapPlanesFunctionLibrary.RemoveFlagsNotInQuery
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const TArray<EMagicLeapPlaneQueryFlags>&InQueryFlags                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// const TArray<EMagicLeapPlaneQueryFlags>&InResultFlags                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// TArray<EMagicLeapPlaneQueryFlags>*      OutFlags                                               (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UMagicLeapPlanesFunctionLibrary::RemoveFlagsNotInQuery(const TArray<EMagicLeapPlaneQueryFlags>& InQueryFlags, const TArray<EMagicLeapPlaneQueryFlags>& InResultFlags, TArray<EMagicLeapPlaneQueryFlags>* OutFlags)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MagicLeapPlanesFunctionLibrary", "RemoveFlagsNotInQuery");

	Params::MagicLeapPlanesFunctionLibrary_RemoveFlagsNotInQuery Parms{};

	Parms.InQueryFlags = std::move(InQueryFlags);
	Parms.InResultFlags = std::move(InResultFlags);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutFlags != nullptr)
		*OutFlags = std::move(Parms.OutFlags);
}


// Function MagicLeapPlanes.MagicLeapPlanesFunctionLibrary.RemovePersistentQuery
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FGuid&                     Handle                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMagicLeapPlanesFunctionLibrary::RemovePersistentQuery(const struct FGuid& Handle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MagicLeapPlanesFunctionLibrary", "RemovePersistentQuery");

	Params::MagicLeapPlanesFunctionLibrary_RemovePersistentQuery Parms{};

	Parms.Handle = std::move(Handle);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function MagicLeapPlanes.MagicLeapPlanesFunctionLibrary.ReorderPlaneFlags
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const TArray<EMagicLeapPlaneQueryFlags>&InPriority                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// const TArray<EMagicLeapPlaneQueryFlags>&InFlagsToReorder                                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// TArray<EMagicLeapPlaneQueryFlags>*      OutReorderedFlags                                      (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UMagicLeapPlanesFunctionLibrary::ReorderPlaneFlags(const TArray<EMagicLeapPlaneQueryFlags>& InPriority, const TArray<EMagicLeapPlaneQueryFlags>& InFlagsToReorder, TArray<EMagicLeapPlaneQueryFlags>* OutReorderedFlags)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MagicLeapPlanesFunctionLibrary", "ReorderPlaneFlags");

	Params::MagicLeapPlanesFunctionLibrary_ReorderPlaneFlags Parms{};

	Parms.InPriority = std::move(InPriority);
	Parms.InFlagsToReorder = std::move(InFlagsToReorder);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutReorderedFlags != nullptr)
		*OutReorderedFlags = std::move(Parms.OutReorderedFlags);
}

}

