#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: KuroMovement

#include "Basic.hpp"

#include "KuroMovement_classes.hpp"
#include "KuroMovement_parameters.hpp"


namespace SDK
{

// Function KuroMovement.KuroClimbObject.ClimbBlock
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKuroClimbObject::ClimbBlock()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KuroClimbObject", "ClimbBlock");

	Params::KuroClimbObject_ClimbBlock Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroMovement.KuroClimbObject.ConfirmMove
// (Final, Native, Public, BlueprintCallable)

void UKuroClimbObject::ConfirmMove()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KuroClimbObject", "ConfirmMove");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function KuroMovement.KuroClimbObject.D_GetSafetyLocation
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVectorDouble                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVectorDouble UKuroClimbObject::D_GetSafetyLocation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KuroClimbObject", "D_GetSafetyLocation");

	Params::KuroClimbObject_D_GetSafetyLocation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroMovement.KuroClimbObject.D_ProcessClimbing
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FVectorDouble&             MoveSpeed                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DeltaTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    IsTryMove                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DebugDrawDuration                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransformDouble*                OutTrans                                               (Parm, OutParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKuroClimbObject::D_ProcessClimbing(const struct FVectorDouble& MoveSpeed, float DeltaTime, bool IsTryMove, float DebugDrawDuration, struct FTransformDouble* OutTrans)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KuroClimbObject", "D_ProcessClimbing");

	Params::KuroClimbObject_D_ProcessClimbing Parms{};

	Parms.MoveSpeed = std::move(MoveSpeed);
	Parms.DeltaTime = DeltaTime;
	Parms.IsTryMove = IsTryMove;
	Parms.DebugDrawDuration = DebugDrawDuration;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutTrans != nullptr)
		*OutTrans = std::move(Parms.OutTrans);

	return Parms.ReturnValue;
}


// Function KuroMovement.KuroClimbObject.D_TryClimbingArrives
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FVectorDouble&             InputDirect                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DebugDrawDuration                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransformDouble*                OutTrans                                               (Parm, OutParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    NeedTryBlockUp                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EClimbingArriveType                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EClimbingArriveType UKuroClimbObject::D_TryClimbingArrives(const struct FVectorDouble& InputDirect, float DebugDrawDuration, struct FTransformDouble* OutTrans, bool NeedTryBlockUp)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KuroClimbObject", "D_TryClimbingArrives");

	Params::KuroClimbObject_D_TryClimbingArrives Parms{};

	Parms.InputDirect = std::move(InputDirect);
	Parms.DebugDrawDuration = DebugDrawDuration;
	Parms.NeedTryBlockUp = NeedTryBlockUp;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutTrans != nullptr)
		*OutTrans = std::move(Parms.OutTrans);

	return Parms.ReturnValue;
}


// Function KuroMovement.KuroClimbObject.D_TrySprintVault
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// float                                   DebugDrawDuration                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransformDouble*                OutTrans                                               (Parm, OutParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// float*                                  OutLongOffset                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ESprintVaultType                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ESprintVaultType UKuroClimbObject::D_TrySprintVault(float DebugDrawDuration, struct FTransformDouble* OutTrans, float* OutLongOffset)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KuroClimbObject", "D_TrySprintVault");

	Params::KuroClimbObject_D_TrySprintVault Parms{};

	Parms.DebugDrawDuration = DebugDrawDuration;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutTrans != nullptr)
		*OutTrans = std::move(Parms.OutTrans);

	if (OutLongOffset != nullptr)
		*OutLongOffset = Parms.OutLongOffset;

	return Parms.ReturnValue;
}


// Function KuroMovement.KuroClimbObject.D_TryStartClimb
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FTransformDouble&          Trans                                                  (Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// float                                   DebugDrawDuration                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransformDouble*                OutTrans                                               (Parm, OutParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKuroClimbObject::D_TryStartClimb(const struct FTransformDouble& Trans, float DebugDrawDuration, struct FTransformDouble* OutTrans)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KuroClimbObject", "D_TryStartClimb");

	Params::KuroClimbObject_D_TryStartClimb Parms{};

	Parms.Trans = std::move(Trans);
	Parms.DebugDrawDuration = DebugDrawDuration;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutTrans != nullptr)
		*OutTrans = std::move(Parms.OutTrans);

	return Parms.ReturnValue;
}


// Function KuroMovement.KuroClimbObject.D_TryUpArrives
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FVectorDouble&             InputDirect                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DebugDrawDuration                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransformDouble*                OutTrans                                               (Parm, OutParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// EClimbingArriveType                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EClimbingArriveType UKuroClimbObject::D_TryUpArrives(const struct FVectorDouble& InputDirect, float DebugDrawDuration, struct FTransformDouble* OutTrans)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KuroClimbObject", "D_TryUpArrives");

	Params::KuroClimbObject_D_TryUpArrives Parms{};

	Parms.InputDirect = std::move(InputDirect);
	Parms.DebugDrawDuration = DebugDrawDuration;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutTrans != nullptr)
		*OutTrans = std::move(Parms.OutTrans);

	return Parms.ReturnValue;
}


// Function KuroMovement.KuroClimbObject.ExitClimb
// (Final, Native, Public, BlueprintCallable)

void UKuroClimbObject::ExitClimb()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KuroClimbObject", "ExitClimb");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function KuroMovement.KuroClimbObject.GetSafetyLocation
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UKuroClimbObject::GetSafetyLocation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KuroClimbObject", "GetSafetyLocation");

	Params::KuroClimbObject_GetSafetyLocation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroMovement.KuroClimbObject.GetSecondMoveOffset
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UKuroClimbObject::GetSecondMoveOffset()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KuroClimbObject", "GetSecondMoveOffset");

	Params::KuroClimbObject_GetSecondMoveOffset Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroMovement.KuroClimbObject.InitBase
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UShapeComponent*                  InShapeComp                                            (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ECollisionChannel                       InClimbChannel                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<struct FVector>&           BaseLocations                                          (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// float                                   InSphereRadius                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InActorToWallDist                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InDetectLength                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InSafetyHalfHeight                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InSafetyRadius                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKuroClimbObject::InitBase(class UShapeComponent* InShapeComp, ECollisionChannel InClimbChannel, const TArray<struct FVector>& BaseLocations, float InSphereRadius, float InActorToWallDist, float InDetectLength, float InSafetyHalfHeight, float InSafetyRadius)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KuroClimbObject", "InitBase");

	Params::KuroClimbObject_InitBase Parms{};

	Parms.InShapeComp = InShapeComp;
	Parms.InClimbChannel = InClimbChannel;
	Parms.BaseLocations = std::move(BaseLocations);
	Parms.InSphereRadius = InSphereRadius;
	Parms.InActorToWallDist = InActorToWallDist;
	Parms.InDetectLength = InDetectLength;
	Parms.InSafetyHalfHeight = InSafetyHalfHeight;
	Parms.InSafetyRadius = InSafetyRadius;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroMovement.KuroClimbObject.InitBlockUps
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FVector&                   InBlockUpOffset                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InBlockUpDetectRadius                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InBlockUpDetectDistance                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InBlockUpBackDistance                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InBlockUpBackMin                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   InBlockUpFinalMove                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   BlockUpVerticalRangeMin                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   BlockUpVerticalRangeMax                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKuroClimbObject::InitBlockUps(const struct FVector& InBlockUpOffset, float InBlockUpDetectRadius, float InBlockUpDetectDistance, float InBlockUpBackDistance, float InBlockUpBackMin, const struct FVector& InBlockUpFinalMove, float BlockUpVerticalRangeMin, float BlockUpVerticalRangeMax)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KuroClimbObject", "InitBlockUps");

	Params::KuroClimbObject_InitBlockUps Parms{};

	Parms.InBlockUpOffset = std::move(InBlockUpOffset);
	Parms.InBlockUpDetectRadius = InBlockUpDetectRadius;
	Parms.InBlockUpDetectDistance = InBlockUpDetectDistance;
	Parms.InBlockUpBackDistance = InBlockUpBackDistance;
	Parms.InBlockUpBackMin = InBlockUpBackMin;
	Parms.InBlockUpFinalMove = std::move(InBlockUpFinalMove);
	Parms.BlockUpVerticalRangeMin = BlockUpVerticalRangeMin;
	Parms.BlockUpVerticalRangeMax = BlockUpVerticalRangeMax;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroMovement.KuroClimbObject.InitClimbSafety
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   InRadius                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InHalfHeight                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InMaxOffset                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKuroClimbObject::InitClimbSafety(float InRadius, float InHalfHeight, float InMaxOffset)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KuroClimbObject", "InitClimbSafety");

	Params::KuroClimbObject_InitClimbSafety Parms{};

	Parms.InRadius = InRadius;
	Parms.InHalfHeight = InHalfHeight;
	Parms.InMaxOffset = InMaxOffset;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroMovement.KuroClimbObject.InitSprintVault
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// float                                   InForwardBlockHeight                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InForwardBlockRadius                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InForwardBlockDistanceMin                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InForwardBlockDistanceMax                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   InSprintVaultMoveOffset                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InHeightMin                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InHeightMax                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InSprintVaultLongNeedDistance                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InSprintVaultLongHeight                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ETraceTypeQuery                         InBlockChannel                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   SprintVaultLongMin                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   SprintVaultLongMax                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   SprintVaultBlockMaxAngle                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKuroClimbObject::InitSprintVault(float InForwardBlockHeight, float InForwardBlockRadius, float InForwardBlockDistanceMin, float InForwardBlockDistanceMax, const struct FVector& InSprintVaultMoveOffset, float InHeightMin, float InHeightMax, float InSprintVaultLongNeedDistance, float InSprintVaultLongHeight, ETraceTypeQuery InBlockChannel, float SprintVaultLongMin, float SprintVaultLongMax, float SprintVaultBlockMaxAngle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KuroClimbObject", "InitSprintVault");

	Params::KuroClimbObject_InitSprintVault Parms{};

	Parms.InForwardBlockHeight = InForwardBlockHeight;
	Parms.InForwardBlockRadius = InForwardBlockRadius;
	Parms.InForwardBlockDistanceMin = InForwardBlockDistanceMin;
	Parms.InForwardBlockDistanceMax = InForwardBlockDistanceMax;
	Parms.InSprintVaultMoveOffset = std::move(InSprintVaultMoveOffset);
	Parms.InHeightMin = InHeightMin;
	Parms.InHeightMax = InHeightMax;
	Parms.InSprintVaultLongNeedDistance = InSprintVaultLongNeedDistance;
	Parms.InSprintVaultLongHeight = InSprintVaultLongHeight;
	Parms.InBlockChannel = InBlockChannel;
	Parms.SprintVaultLongMin = SprintVaultLongMin;
	Parms.SprintVaultLongMax = SprintVaultLongMax;
	Parms.SprintVaultBlockMaxAngle = SprintVaultBlockMaxAngle;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroMovement.KuroClimbObject.InitUpArrives
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const TArray<struct FVector>&           InUpArriveMoveOffsets                                  (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// const TArray<float>&                    InHeightMins                                           (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// const TArray<float>&                    InHeightMaxs                                           (Parm, ZeroConstructor, NativeAccessSpecifierPublic)

void UKuroClimbObject::InitUpArrives(const TArray<struct FVector>& InUpArriveMoveOffsets, const TArray<float>& InHeightMins, const TArray<float>& InHeightMaxs)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KuroClimbObject", "InitUpArrives");

	Params::KuroClimbObject_InitUpArrives Parms{};

	Parms.InUpArriveMoveOffsets = std::move(InUpArriveMoveOffsets);
	Parms.InHeightMins = std::move(InHeightMins);
	Parms.InHeightMaxs = std::move(InHeightMaxs);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroMovement.KuroClimbObject.NeedFollowHangOnStartingClimb
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKuroClimbObject::NeedFollowHangOnStartingClimb()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KuroClimbObject", "NeedFollowHangOnStartingClimb");

	Params::KuroClimbObject_NeedFollowHangOnStartingClimb Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroMovement.KuroClimbObject.ProcessClimbing
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FVector&                   MoveSpeed                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DeltaTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    IsTryMove                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DebugDrawDuration                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransform*                      OutTrans                                               (Parm, OutParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKuroClimbObject::ProcessClimbing(const struct FVector& MoveSpeed, float DeltaTime, bool IsTryMove, float DebugDrawDuration, struct FTransform* OutTrans)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KuroClimbObject", "ProcessClimbing");

	Params::KuroClimbObject_ProcessClimbing Parms{};

	Parms.MoveSpeed = std::move(MoveSpeed);
	Parms.DeltaTime = DeltaTime;
	Parms.IsTryMove = IsTryMove;
	Parms.DebugDrawDuration = DebugDrawDuration;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutTrans != nullptr)
		*OutTrans = std::move(Parms.OutTrans);

	return Parms.ReturnValue;
}


// Function KuroMovement.KuroClimbObject.SyncFromOther
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UKuroClimbObject*                 Other                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKuroClimbObject::SyncFromOther(class UKuroClimbObject* Other)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KuroClimbObject", "SyncFromOther");

	Params::KuroClimbObject_SyncFromOther Parms{};

	Parms.Other = Other;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroMovement.KuroClimbObject.TryClimbingArrives
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FVector&                   InputDirect                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DebugDrawDuration                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransform*                      OutTrans                                               (Parm, OutParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    NeedTryBlockUp                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EClimbingArriveType                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EClimbingArriveType UKuroClimbObject::TryClimbingArrives(const struct FVector& InputDirect, float DebugDrawDuration, struct FTransform* OutTrans, bool NeedTryBlockUp)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KuroClimbObject", "TryClimbingArrives");

	Params::KuroClimbObject_TryClimbingArrives Parms{};

	Parms.InputDirect = std::move(InputDirect);
	Parms.DebugDrawDuration = DebugDrawDuration;
	Parms.NeedTryBlockUp = NeedTryBlockUp;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutTrans != nullptr)
		*OutTrans = std::move(Parms.OutTrans);

	return Parms.ReturnValue;
}


// Function KuroMovement.KuroClimbObject.TrySprintVault
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// float                                   DebugDrawDuration                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransform*                      OutTrans                                               (Parm, OutParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// float*                                  OutLongOffset                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ESprintVaultType                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ESprintVaultType UKuroClimbObject::TrySprintVault(float DebugDrawDuration, struct FTransform* OutTrans, float* OutLongOffset)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KuroClimbObject", "TrySprintVault");

	Params::KuroClimbObject_TrySprintVault Parms{};

	Parms.DebugDrawDuration = DebugDrawDuration;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutTrans != nullptr)
		*OutTrans = std::move(Parms.OutTrans);

	if (OutLongOffset != nullptr)
		*OutLongOffset = Parms.OutLongOffset;

	return Parms.ReturnValue;
}


// Function KuroMovement.KuroClimbObject.TryStartClimb
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FTransform&                Trans                                                  (Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// float                                   DebugDrawDuration                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransform*                      OutTrans                                               (Parm, OutParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKuroClimbObject::TryStartClimb(const struct FTransform& Trans, float DebugDrawDuration, struct FTransform* OutTrans)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KuroClimbObject", "TryStartClimb");

	Params::KuroClimbObject_TryStartClimb Parms{};

	Parms.Trans = std::move(Trans);
	Parms.DebugDrawDuration = DebugDrawDuration;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutTrans != nullptr)
		*OutTrans = std::move(Parms.OutTrans);

	return Parms.ReturnValue;
}


// Function KuroMovement.KuroClimbObject.TryUpArrives
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FVector&                   InputDirect                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DebugDrawDuration                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransform*                      OutTrans                                               (Parm, OutParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// EClimbingArriveType                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EClimbingArriveType UKuroClimbObject::TryUpArrives(const struct FVector& InputDirect, float DebugDrawDuration, struct FTransform* OutTrans)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KuroClimbObject", "TryUpArrives");

	Params::KuroClimbObject_TryUpArrives Parms{};

	Parms.InputDirect = std::move(InputDirect);
	Parms.DebugDrawDuration = DebugDrawDuration;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutTrans != nullptr)
		*OutTrans = std::move(Parms.OutTrans);

	return Parms.ReturnValue;
}


// Function KuroMovement.KuroDebugMovementComponent.KuroDebugMovementBaseRecordToString
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const struct FBaseRecord&               Record                                                 (Parm, NoDestructor, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UKuroDebugMovementComponent::KuroDebugMovementBaseRecordToString(const struct FBaseRecord& Record)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroDebugMovementComponent", "KuroDebugMovementBaseRecordToString");

	Params::KuroDebugMovementComponent_KuroDebugMovementBaseRecordToString Parms{};

	Parms.Record = std::move(Record);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroMovement.KuroDebugMovementComponent.GetCurrentFrameIndex
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UKuroDebugMovementComponent::GetCurrentFrameIndex()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KuroDebugMovementComponent", "GetCurrentFrameIndex");

	Params::KuroDebugMovementComponent_GetCurrentFrameIndex Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroMovement.KuroDebugMovementComponent.GetFrameCountInfo
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UKuroDebugMovementComponent::GetFrameCountInfo()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KuroDebugMovementComponent", "GetFrameCountInfo");

	Params::KuroDebugMovementComponent_GetFrameCountInfo Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroMovement.KuroDebugMovementComponent.GetMaxRecordFrameCount
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UKuroDebugMovementComponent::GetMaxRecordFrameCount()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KuroDebugMovementComponent", "GetMaxRecordFrameCount");

	Params::KuroDebugMovementComponent_GetMaxRecordFrameCount Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroMovement.KuroDebugMovementComponent.GetPreviousRecord
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   preNum                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FSingleFrameDebugInfo      ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const struct FSingleFrameDebugInfo UKuroDebugMovementComponent::GetPreviousRecord(int32 preNum)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KuroDebugMovementComponent", "GetPreviousRecord");

	Params::KuroDebugMovementComponent_GetPreviousRecord Parms{};

	Parms.preNum = preNum;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroMovement.KuroDebugMovementComponent.GetRecentRecords
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const TArray<struct FSingleFrameDebugInfo>ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const TArray<struct FSingleFrameDebugInfo> UKuroDebugMovementComponent::GetRecentRecords()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KuroDebugMovementComponent", "GetRecentRecords");

	Params::KuroDebugMovementComponent_GetRecentRecords Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroMovement.KuroDebugMovementComponent.GetRecordFrames
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UKuroDebugMovementComponent::GetRecordFrames()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KuroDebugMovementComponent", "GetRecordFrames");

	Params::KuroDebugMovementComponent_GetRecordFrames Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroMovement.KuroDebugMovementComponent.RecordModifyInfo
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// const class FString&                    Context                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   CustomVector                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EKDMRecordType                          Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKuroDebugMovementComponent::RecordModifyInfo(const class FString& Context, const struct FVector& CustomVector, EKDMRecordType Type)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KuroDebugMovementComponent", "RecordModifyInfo");

	Params::KuroDebugMovementComponent_RecordModifyInfo Parms{};

	Parms.Context = std::move(Context);
	Parms.CustomVector = std::move(CustomVector);
	Parms.Type = Type;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroMovement.KuroDebugMovementComponent.Resigter
// (Final, Native, Public, BlueprintCallable)

void UKuroDebugMovementComponent::Resigter()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KuroDebugMovementComponent", "Resigter");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function KuroMovement.KuroDebugMovementComponent.SetDebug
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bDebug                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bDetial                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKuroDebugMovementComponent::SetDebug(bool bDebug, bool bDetial)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KuroDebugMovementComponent", "SetDebug");

	Params::KuroDebugMovementComponent_SetDebug Parms{};

	Parms.bDebug = bDebug;
	Parms.bDetial = bDetial;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroMovement.KuroDebugMovementComponent.UnResigter
// (Final, Native, Public, BlueprintCallable)

void UKuroDebugMovementComponent::UnResigter()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KuroDebugMovementComponent", "UnResigter");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function KuroMovement.KuroMoveTrigger.OnEndOverlap
// (Final, Native, Protected)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AKuroMoveTrigger::OnEndOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KuroMoveTrigger", "OnEndOverlap");

	Params::KuroMoveTrigger_OnEndOverlap Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroMovement.KuroMoveTrigger.OnEnterOverlap
// (Final, Native, Protected, HasOutParams)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromSweep                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FHitResult&                SweepResult                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void AKuroMoveTrigger::OnEnterOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KuroMoveTrigger", "OnEnterOverlap");

	Params::KuroMoveTrigger_OnEnterOverlap Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = std::move(SweepResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroMovement.KuroMovementBPLibrary.KuroKite
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// float                                   DeltaSeconds                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UCharacterMovementComponent*      CharMoveComp                                           (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   TargetPrevPos                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   TargetNextPos                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MinDist                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MaxDist                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MinAccel                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MaxAccel                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Friction                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector*                         InOutTargetForward                                     (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   FacingLerpSpeed                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   FacingLerpRate                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKuroMovementBPLibrary::KuroKite(float DeltaSeconds, class UCharacterMovementComponent* CharMoveComp, const struct FVector& TargetPrevPos, const struct FVector& TargetNextPos, float MinDist, float MaxDist, float MinAccel, float MaxAccel, float Friction, struct FVector* InOutTargetForward, float FacingLerpSpeed, float FacingLerpRate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroMovementBPLibrary", "KuroKite");

	Params::KuroMovementBPLibrary_KuroKite Parms{};

	Parms.DeltaSeconds = DeltaSeconds;
	Parms.CharMoveComp = CharMoveComp;
	Parms.TargetPrevPos = std::move(TargetPrevPos);
	Parms.TargetNextPos = std::move(TargetNextPos);
	Parms.MinDist = MinDist;
	Parms.MaxDist = MaxDist;
	Parms.MinAccel = MinAccel;
	Parms.MaxAccel = MaxAccel;
	Parms.Friction = Friction;
	Parms.FacingLerpSpeed = FacingLerpSpeed;
	Parms.FacingLerpRate = FacingLerpRate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (InOutTargetForward != nullptr)
		*InOutTargetForward = std::move(Parms.InOutTargetForward);

	return Parms.ReturnValue;
}


// Function KuroMovement.KuroMovementBPLibrary.KuroRoll
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// float                                   DeltaSeconds                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UCharacterMovementComponent*      CharMoveComp                                           (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   TargetSpeed                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Friction                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   AccelOnGround                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector*                         FloorNormal                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Gravity                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   StepUpHeight                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MaxSpeed                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKuroMovementBPLibrary::KuroRoll(float DeltaSeconds, class UCharacterMovementComponent* CharMoveComp, float TargetSpeed, float Friction, float AccelOnGround, struct FVector* FloorNormal, float Gravity, float StepUpHeight, float MaxSpeed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroMovementBPLibrary", "KuroRoll");

	Params::KuroMovementBPLibrary_KuroRoll Parms{};

	Parms.DeltaSeconds = DeltaSeconds;
	Parms.CharMoveComp = CharMoveComp;
	Parms.TargetSpeed = TargetSpeed;
	Parms.Friction = Friction;
	Parms.AccelOnGround = AccelOnGround;
	Parms.Gravity = Gravity;
	Parms.StepUpHeight = StepUpHeight;
	Parms.MaxSpeed = MaxSpeed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (FloorNormal != nullptr)
		*FloorNormal = std::move(Parms.FloorNormal);

	return Parms.ReturnValue;
}


// Function KuroMovement.KuroMovementBPLibrary.KuroSki
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// float                                   DeltaTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UCharacterMovementComponent*      CharMoveComp                                           (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   PrevBlockNormal                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   Direction                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   SpeedParams                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   IgnoreStepHeight                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UCurveFloat*                      SpeedReduceCurve                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UKuroMovementBPLibrary::KuroSki(float DeltaTime, class UCharacterMovementComponent* CharMoveComp, const struct FVector& PrevBlockNormal, const struct FVector& Direction, const struct FVector& SpeedParams, float IgnoreStepHeight, class UCurveFloat* SpeedReduceCurve)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroMovementBPLibrary", "KuroSki");

	Params::KuroMovementBPLibrary_KuroSki Parms{};

	Parms.DeltaTime = DeltaTime;
	Parms.CharMoveComp = CharMoveComp;
	Parms.PrevBlockNormal = std::move(PrevBlockNormal);
	Parms.Direction = std::move(Direction);
	Parms.SpeedParams = std::move(SpeedParams);
	Parms.IgnoreStepHeight = IgnoreStepHeight;
	Parms.SpeedReduceCurve = SpeedReduceCurve;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroMovement.KuroMovementBPLibrary.KuroSoar
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// float                                   DeltaSeconds                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UCharacterMovementComponent*      CharMoveComp                                           (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   AirFriction                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Aerodynamics                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   Gravity                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   SoarPlaneNormal                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MaxSpeed                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EMoveHitType                            ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EMoveHitType UKuroMovementBPLibrary::KuroSoar(float DeltaSeconds, class UCharacterMovementComponent* CharMoveComp, float AirFriction, float Aerodynamics, const struct FVector& Gravity, const struct FVector& SoarPlaneNormal, float MaxSpeed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroMovementBPLibrary", "KuroSoar");

	Params::KuroMovementBPLibrary_KuroSoar Parms{};

	Parms.DeltaSeconds = DeltaSeconds;
	Parms.CharMoveComp = CharMoveComp;
	Parms.AirFriction = AirFriction;
	Parms.Aerodynamics = Aerodynamics;
	Parms.Gravity = std::move(Gravity);
	Parms.SoarPlaneNormal = std::move(SoarPlaneNormal);
	Parms.MaxSpeed = MaxSpeed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroMovement.KuroMoveTriggerController.RegisterController
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AKuroMoveTriggerController*       ControllerPtr                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AKuroMoveTriggerController::RegisterController(class AKuroMoveTriggerController* ControllerPtr)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroMoveTriggerController", "RegisterController");

	Params::KuroMoveTriggerController_RegisterController Parms{};

	Parms.ControllerPtr = ControllerPtr;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroMovement.KuroMoveTriggerController.UnRegisterController
// (Final, Native, Static, Public, BlueprintCallable)

void AKuroMoveTriggerController::UnRegisterController()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroMoveTriggerController", "UnRegisterController");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function KuroMovement.KuroMoveTriggerController.InitAllTriggers
// (Final, Native, Public, BlueprintCallable)

void AKuroMoveTriggerController::InitAllTriggers()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KuroMoveTriggerController", "InitAllTriggers");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}

}

