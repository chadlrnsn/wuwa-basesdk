#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: KuroEditorRuntime

#include "Basic.hpp"

#include "KuroEditorRuntime_classes.hpp"
#include "KuroEditorRuntime_parameters.hpp"


namespace SDK
{

// Function KuroEditorRuntime.CommandService.EnableRecvLog
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    isEnable                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCommandService::EnableRecvLog(bool isEnable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CommandService", "EnableRecvLog");

	Params::CommandService_EnableRecvLog Parms{};

	Parms.isEnable = isEnable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroEditorRuntime.CommandService.Start
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   Port                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCommandService::Start(int32 Port)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CommandService", "Start");

	Params::CommandService_Start Parms{};

	Parms.Port = Port;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroEditorRuntime.CommandService.Stop
// (Final, Native, Public, BlueprintCallable)

void UCommandService::Stop()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CommandService", "Stop");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function KuroEditorRuntime.EditorRuntimeOperations.IsPortInUse
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   Port                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UEditorRuntimeOperations::IsPortInUse(int32 Port)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EditorRuntimeOperations", "IsPortInUse");

	Params::EditorRuntimeOperations_IsPortInUse Parms{};

	Parms.Port = Port;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroEditorRuntime.EditorRuntimeOperations.IsTcpPortInUse
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   Port                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UEditorRuntimeOperations::IsTcpPortInUse(int32 Port)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EditorRuntimeOperations", "IsTcpPortInUse");

	Params::EditorRuntimeOperations_IsTcpPortInUse Parms{};

	Parms.Port = Port;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroEditorRuntime.EditorRuntimeOperations.IsUdpPortInUse
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   Port                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UEditorRuntimeOperations::IsUdpPortInUse(int32 Port)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EditorRuntimeOperations", "IsUdpPortInUse");

	Params::EditorRuntimeOperations_IsUdpPortInUse Parms{};

	Parms.Port = Port;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroEditorRuntime.EditorRuntimeOperations.ReadBatchFilesAsync
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const TArray<class FString>&            FilePaths                                              (ConstParm, Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// TDelegate<void(const TArray<struct FReadFileData>& LoadedFiles, const TArray<class FString>& ReadFailedFiles)>OnAllFilesRead                                         (Parm, ZeroConstructor, NativeAccessSpecifierPublic)

void UEditorRuntimeOperations::ReadBatchFilesAsync(const TArray<class FString>& FilePaths, TDelegate<void(const TArray<struct FReadFileData>& LoadedFiles, const TArray<class FString>& ReadFailedFiles)> OnAllFilesRead)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EditorRuntimeOperations", "ReadBatchFilesAsync");

	Params::EditorRuntimeOperations_ReadBatchFilesAsync Parms{};

	Parms.FilePaths = std::move(FilePaths);
	Parms.OnAllFilesRead = OnAllFilesRead;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroEditorRuntime.EditorRuntimeOperations.ReadFileAsync
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class FString&                    FilePath                                               (ConstParm, Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TDelegate<void(bool IsSuccess, const class FString& FileContent)>OnFileRead                                             (Parm, ZeroConstructor, NativeAccessSpecifierPublic)

void UEditorRuntimeOperations::ReadFileAsync(const class FString& FilePath, TDelegate<void(bool IsSuccess, const class FString& FileContent)> OnFileRead)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EditorRuntimeOperations", "ReadFileAsync");

	Params::EditorRuntimeOperations_ReadFileAsync Parms{};

	Parms.FilePath = std::move(FilePath);
	Parms.OnFileRead = OnFileRead;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroEditorRuntime.EditorRuntimeOperations.SendHttpRequest
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const class FString&                    Method                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    Url                                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TMap<class FString, class FString>&HeaderParam                                            (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// const class FString&                    Content                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TDelegate<void(bool Success, int32 Code, const class FString& Data)>Handler                                                (Parm, ZeroConstructor, NativeAccessSpecifierPublic)

void UEditorRuntimeOperations::SendHttpRequest(const class FString& Method, const class FString& Url, const TMap<class FString, class FString>& HeaderParam, const class FString& Content, TDelegate<void(bool Success, int32 Code, const class FString& Data)> Handler)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EditorRuntimeOperations", "SendHttpRequest");

	Params::EditorRuntimeOperations_SendHttpRequest Parms{};

	Parms.Method = std::move(Method);
	Parms.Url = std::move(Url);
	Parms.HeaderParam = std::move(HeaderParam);
	Parms.Content = std::move(Content);
	Parms.Handler = Handler;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroEditorRuntime.EditorRuntimeOperations.SendMessage
// (Final, BlueprintCosmetic, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class FString&                    Msg                                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    Ip                                                     (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Port                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UEditorRuntimeOperations::SendMessage(const class FString& Msg, const class FString& Ip, int32 Port)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EditorRuntimeOperations", "SendMessage");

	Params::EditorRuntimeOperations_SendMessage Parms{};

	Parms.Msg = std::move(Msg);
	Parms.Ip = std::move(Ip);
	Parms.Port = Port;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}

}

