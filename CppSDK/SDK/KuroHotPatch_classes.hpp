#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: KuroHotPatch

#include "Basic.hpp"

#include "CoreUObject_classes.hpp"
#include "KuroHotPatch_structs.hpp"
#include "Engine_classes.hpp"


namespace SDK
{

// Class KuroHotPatch.DownloaderProxy
// 0x00A0 (0x00D0 - 0x0030)
class UDownloaderProxy final : public UObject
{
public:
	uint8                                         Pad_30[0xA0];                                      // 0x0030(0x00A0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Cancel();
	int64 GetContentLength();
	int64 GetReceivedSize();
	int64 GetSavedSize();
	float GetTotalDownloadTime();
	bool HasComplete();
	void SetCompleteCallback(TDelegate<void(uint8 DownloadState, int32 HttpState)> InCb);
	void SetProgressCallback(TDelegate<void(int64 ThisTimeReceiveSize, int64 ReceivedSize, int64 SavedSize)> InCb);
	void Start(const class FString& Url, const class FString& SavePath, const class FString& Suffix, const int64 InFileSize, const float InLimitTime, const bool bForceNew, const bool InCache, const class FString& Sha1, const float InTimeout, const bool bNewTick);
	void UnbindCallback();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DownloaderProxy">();
	}
	static class UDownloaderProxy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDownloaderProxy>();
	}
};
static_assert(alignof(UDownloaderProxy) == 0x000008, "Wrong alignment on UDownloaderProxy");
static_assert(sizeof(UDownloaderProxy) == 0x0000D0, "Wrong size on UDownloaderProxy");

// Class KuroHotPatch.KuroAppSetting
// 0x0058 (0x0088 - 0x0030)
class UKuroAppSetting final : public UObject
{
public:
	class FString                                 AppVersion;                                        // 0x0030(0x0010)(Edit, ZeroConstructor, Config, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 AppBuildNum;                                       // 0x0040(0x0010)(Edit, ZeroConstructor, Config, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 AppReleaseType;                                    // 0x0050(0x0010)(Edit, ZeroConstructor, Config, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 InternalUse;                                       // 0x0060(0x0010)(Edit, ZeroConstructor, Config, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ParallelApp;                                       // 0x0070(0x0010)(Edit, ZeroConstructor, Config, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLocalPackaging;                                   // 0x0080(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNeedHotPatch;                                     // 0x0081(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_82[0x6];                                       // 0x0082(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroAppSetting">();
	}
	static class UKuroAppSetting* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroAppSetting>();
	}
};
static_assert(alignof(UKuroAppSetting) == 0x000008, "Wrong alignment on UKuroAppSetting");
static_assert(sizeof(UKuroAppSetting) == 0x000088, "Wrong size on UKuroAppSetting");
static_assert(offsetof(UKuroAppSetting, AppVersion) == 0x000030, "Member 'UKuroAppSetting::AppVersion' has a wrong offset!");
static_assert(offsetof(UKuroAppSetting, AppBuildNum) == 0x000040, "Member 'UKuroAppSetting::AppBuildNum' has a wrong offset!");
static_assert(offsetof(UKuroAppSetting, AppReleaseType) == 0x000050, "Member 'UKuroAppSetting::AppReleaseType' has a wrong offset!");
static_assert(offsetof(UKuroAppSetting, InternalUse) == 0x000060, "Member 'UKuroAppSetting::InternalUse' has a wrong offset!");
static_assert(offsetof(UKuroAppSetting, ParallelApp) == 0x000070, "Member 'UKuroAppSetting::ParallelApp' has a wrong offset!");
static_assert(offsetof(UKuroAppSetting, bLocalPackaging) == 0x000080, "Member 'UKuroAppSetting::bLocalPackaging' has a wrong offset!");
static_assert(offsetof(UKuroAppSetting, bNeedHotPatch) == 0x000081, "Member 'UKuroAppSetting::bNeedHotPatch' has a wrong offset!");

// Class KuroHotPatch.KuroCheckFiles
// 0x0048 (0x0078 - 0x0030)
class UKuroCheckFiles final : public UObject
{
public:
	TArray<struct FKuroCheckInfoEntry>            CheckList;                                         // 0x0030(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	class FString                                 TmpSuffix;                                         // 0x0040(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(int32 Current, int32 Total)> ProgressDelegate;                     // 0x0050(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              CompleteDelegate;                                  // 0x0060(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_70[0x8];                                       // 0x0070(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Check();
	void Clear();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroCheckFiles">();
	}
	static class UKuroCheckFiles* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroCheckFiles>();
	}
};
static_assert(alignof(UKuroCheckFiles) == 0x000008, "Wrong alignment on UKuroCheckFiles");
static_assert(sizeof(UKuroCheckFiles) == 0x000078, "Wrong size on UKuroCheckFiles");
static_assert(offsetof(UKuroCheckFiles, CheckList) == 0x000030, "Member 'UKuroCheckFiles::CheckList' has a wrong offset!");
static_assert(offsetof(UKuroCheckFiles, TmpSuffix) == 0x000040, "Member 'UKuroCheckFiles::TmpSuffix' has a wrong offset!");
static_assert(offsetof(UKuroCheckFiles, ProgressDelegate) == 0x000050, "Member 'UKuroCheckFiles::ProgressDelegate' has a wrong offset!");
static_assert(offsetof(UKuroCheckFiles, CompleteDelegate) == 0x000060, "Member 'UKuroCheckFiles::CompleteDelegate' has a wrong offset!");

// Class KuroHotPatch.KuroConfigPatcher
// 0x0000 (0x0030 - 0x0030)
class UKuroConfigPatcher final : public UBlueprintFunctionLibrary
{
public:
	static void UpdateConfigs(const class FString& ConfigListPath);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroConfigPatcher">();
	}
	static class UKuroConfigPatcher* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroConfigPatcher>();
	}
};
static_assert(alignof(UKuroConfigPatcher) == 0x000008, "Wrong alignment on UKuroConfigPatcher");
static_assert(sizeof(UKuroConfigPatcher) == 0x000030, "Wrong size on UKuroConfigPatcher");

// Class KuroHotPatch.KuroBinPatch
// 0x0030 (0x0060 - 0x0030)
class UKuroBinPatch final : public UObject
{
public:
	TMulticastInlineDelegate<void(int64 CurrentSize)> ProgressDelegate;                              // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(int32 ResultCode, const TArray<class FString>& SucFiles)> CompleteDelegate; // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_50[0x10];                                      // 0x0050(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BeginPatch(const class FString& Diff, const class FString& OldDir, const class FString& NewDir);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroBinPatch">();
	}
	static class UKuroBinPatch* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroBinPatch>();
	}
};
static_assert(alignof(UKuroBinPatch) == 0x000008, "Wrong alignment on UKuroBinPatch");
static_assert(sizeof(UKuroBinPatch) == 0x000060, "Wrong size on UKuroBinPatch");
static_assert(offsetof(UKuroBinPatch, ProgressDelegate) == 0x000030, "Member 'UKuroBinPatch::ProgressDelegate' has a wrong offset!");
static_assert(offsetof(UKuroBinPatch, CompleteDelegate) == 0x000040, "Member 'UKuroBinPatch::CompleteDelegate' has a wrong offset!");

// Class KuroHotPatch.KuroLauncherLibrary
// 0x0050 (0x0080 - 0x0030)
class UKuroLauncherLibrary final : public UBlueprintFunctionLibrary
{
public:
	TSet<class UObject*>                          PreloadBp;                                         // 0x0030(0x0050)(Edit, Transient, EditConst, NativeAccessSpecifierPrivate)

public:
	static bool CheckFileSha1(const class FString& FilePath, const class FString& CheckSha1Hash);
	static void ClearPatchPaks();
	static void CloseShaderLibrary();
	static bool CopyFile(const class FString& DstPath, const class FString& SrcPath);
	static bool Decrypt(const class FString& InCipher, class FString* OutPlain);
	static bool DeleteDirectory(const class FString& DirPath);
	static bool DeleteFile(const class FString& FilePath);
	static bool DoesDiskHaveEnoughSpace(const class FString& CheckPath, const int64 CheckSize);
	static bool Encrypt(const class FString& InPlain, class FString* OutCipher);
	static class FString GameSavedDir();
	static class FString GetAppChangeList();
	static class FString GetAppInternalUseType();
	static class FString GetAppParallel();
	static class FString GetAppReleaseType();
	static class FString GetAppVersion();
	static bool GetConfig(const class FString& Key, const class FString& DefaultValue, class FString* OutStr);
	static int64 GetFileSize(const class FString& FilePath);
	static bool GetGConfigString(const class FString& Section, const class FString& Key, class FString* OutStr);
	static uint8 GetNetworkConnectionType();
	static int32 GetRemainPrecompileShaders();
	static int64 GetTotalAndFreeSpace(const class FString& CheckPath, int64* FreeSize);
	static int32 GetTotalPrecompileShaders();
	static bool IsFirstIntoLauncher();
	static bool IsLocalPackaging();
	static bool IsStartupMountSuccess();
	static void LogoutToLauncher();
	static bool MakeDirectory(const class FString& DirPath);
	static bool MoveFile(const class FString& DstPath, const class FString& SrcPath);
	static bool NeedClearPatchPaks();
	static bool NeedHotPatch();
	static uint8 NeedRestartApp();
	static void PreloadRequiredBp();
	static void ReloadShaderLibrary();
	static void ResetLauncher();
	static void RestartApplication(const class FString& ScriptContent);
	static void ResumeCompileShader();
	static void SetPrecompileShaderBatchMode(int32 Mode);
	static void SetRestartApp(uint8 RestartType);
	static void WillClearPatchPaks();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroLauncherLibrary">();
	}
	static class UKuroLauncherLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroLauncherLibrary>();
	}
};
static_assert(alignof(UKuroLauncherLibrary) == 0x000008, "Wrong alignment on UKuroLauncherLibrary");
static_assert(sizeof(UKuroLauncherLibrary) == 0x000080, "Wrong size on UKuroLauncherLibrary");
static_assert(offsetof(UKuroLauncherLibrary, PreloadBp) == 0x000030, "Member 'UKuroLauncherLibrary::PreloadBp' has a wrong offset!");

// Class KuroHotPatch.KuroPakMountStatic
// 0x0000 (0x0030 - 0x0030)
class UKuroPakMountStatic final : public UBlueprintFunctionLibrary
{
public:
	static void AddSha1Check(const class FString& FilePath, const class FString& CheckSha1Hash);
	static void DeleteSha1CheckFailedFiles();
	static int32 GetSha1CheckFailedCount();
	static bool IsSha1CheckWorking();
	static bool MakePakDirPatch(const class FString& OldPakPath, const class FString& DiffPath, const class FString& NewPatchPath);
	static bool MakePakPatch(const class FString& OldPakPath, const class FString& DiffPath, const class FString& NewPatchPath);
	static void MountFromManifest(const class FString& Path);
	static void MountGamePaks();
	static void MountMultiLangPaks();
	static void MountPak(const class FString& Path, int32 Order);
	static void MountStartupPaks();
	static void RemoveSha1Check(const class FString& FilePath);
	static void ResetSha1CheckResult();
	static void Save(const class FString& Path);
	static void StartSha1Check();
	static void StopSha1Check();
	static void UnmountAllPaks();
	static void UnmountFromManifest(const class FString& Path);
	static void UnmountPak(const class FString& Path);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroPakMountStatic">();
	}
	static class UKuroPakMountStatic* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroPakMountStatic>();
	}
};
static_assert(alignof(UKuroPakMountStatic) == 0x000008, "Wrong alignment on UKuroPakMountStatic");
static_assert(sizeof(UKuroPakMountStatic) == 0x000030, "Wrong size on UKuroPakMountStatic");

}

