#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: KuroUtility

#include "Basic.hpp"

#include "CoreUObject_classes.hpp"
#include "KuroUtility_structs.hpp"
#include "Engine_structs.hpp"
#include "Engine_classes.hpp"


namespace SDK
{

// Class KuroUtility.AsyncLoadState
// 0x0020 (0x0050 - 0x0030)
class UAsyncLoadState final : public UObject
{
public:
	TMulticastInlineDelegate<void(class UClass* ClassLoaded, class UObject* UserData)> ClassLoadedDelegate;                               // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class UObject* ObjectLoaded, class UObject* UserData)> ObjectLoadedDelegate;                              // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	void AsyncLoadClass(const class FString& InPath, class UObject* UserData);
	void AsyncLoadObject(const class FString& InPath, class UObject* UserData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AsyncLoadState">();
	}
	static class UAsyncLoadState* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAsyncLoadState>();
	}
};
static_assert(alignof(UAsyncLoadState) == 0x000008, "Wrong alignment on UAsyncLoadState");
static_assert(sizeof(UAsyncLoadState) == 0x000050, "Wrong size on UAsyncLoadState");
static_assert(offsetof(UAsyncLoadState, ClassLoadedDelegate) == 0x000030, "Member 'UAsyncLoadState::ClassLoadedDelegate' has a wrong offset!");
static_assert(offsetof(UAsyncLoadState, ObjectLoadedDelegate) == 0x000040, "Member 'UAsyncLoadState::ObjectLoadedDelegate' has a wrong offset!");

// Class KuroUtility.HoldPreloadObject
// 0x0060 (0x0090 - 0x0030)
class UHoldPreloadObject final : public UObject
{
public:
	TArray<class UObject*>                        CommonAssets;                                      // 0x0030(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TMap<int32, struct FPreloadObjectCollection>  EntityAssetMap;                                    // 0x0040(0x0050)(NativeAccessSpecifierPrivate)

public:
	void AddCommonAsset(class UObject* InObject);
	bool AddEntityAsset(const int32 EntityId, class UObject* InObject);
	void Clear();
	void ClearCommonAsset();
	void ClearEntityAssetMap();
	TArray<class UObject*> GetCommonAssetArray();
	bool GetEntityAssetArray(const int32 EntityId, TArray<class UObject*>* OutAssets);
	bool RemoveEntityAssets(const int32 EntityId);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HoldPreloadObject">();
	}
	static class UHoldPreloadObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHoldPreloadObject>();
	}
};
static_assert(alignof(UHoldPreloadObject) == 0x000008, "Wrong alignment on UHoldPreloadObject");
static_assert(sizeof(UHoldPreloadObject) == 0x000090, "Wrong size on UHoldPreloadObject");
static_assert(offsetof(UHoldPreloadObject, CommonAssets) == 0x000030, "Member 'UHoldPreloadObject::CommonAssets' has a wrong offset!");
static_assert(offsetof(UHoldPreloadObject, EntityAssetMap) == 0x000040, "Member 'UHoldPreloadObject::EntityAssetMap' has a wrong offset!");

// Class KuroUtility.KuroActor
// 0x0000 (0x02B0 - 0x02B0)
class AKuroActor : public AActor
{
public:
	void ReceiveKuroActorBack();
	void ReceiveKuroActorGet();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroActor">();
	}
	static class AKuroActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AKuroActor>();
	}
};
static_assert(alignof(AKuroActor) == 0x000008, "Wrong alignment on AKuroActor");
static_assert(sizeof(AKuroActor) == 0x0002B0, "Wrong size on AKuroActor");

// Class KuroUtility.KuroActorComponent
// 0x0000 (0x00C0 - 0x00C0)
class UKuroActorComponent final : public UActorComponent
{
public:
	void EditorTickComponent(float DeltaTime);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroActorComponent">();
	}
	static class UKuroActorComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroActorComponent>();
	}
};
static_assert(alignof(UKuroActorComponent) == 0x000008, "Wrong alignment on UKuroActorComponent");
static_assert(sizeof(UKuroActorComponent) == 0x0000C0, "Wrong size on UKuroActorComponent");

// Class KuroUtility.KuroActorEventBinder
// 0x0010 (0x0040 - 0x0030)
class UKuroActorEventBinder final : public UObject
{
public:
	TMulticastInlineDelegate<void(class AActor* Actor, bool bContent)> Callback;                                          // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroActorEventBinder">();
	}
	static class UKuroActorEventBinder* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroActorEventBinder>();
	}
};
static_assert(alignof(UKuroActorEventBinder) == 0x000008, "Wrong alignment on UKuroActorEventBinder");
static_assert(sizeof(UKuroActorEventBinder) == 0x000040, "Wrong size on UKuroActorEventBinder");
static_assert(offsetof(UKuroActorEventBinder, Callback) == 0x000030, "Member 'UKuroActorEventBinder::Callback' has a wrong offset!");

// Class KuroUtility.KuroActorManager
// 0x0000 (0x0030 - 0x0030)
class UKuroActorManager final : public UBlueprintFunctionLibrary
{
public:
	static void Clear();
	static bool ClearAcquiredComponents(class AActor* Actor);
	static class AActor* D_SpawnActor(const class UObject* WorldContextObject, const TSubclassOf<class AActor> ActorClass, const struct FTransformDouble& SpawnTransform, ESpawnActorCollisionHandlingMethod CollisionHandlingOverride, class AActor* Owner, class APawn* Instigator, bool bAsPoolActor);
	static void DestroyActor(class AActor* Actor);
	static TArray<class FString> GetAllAcquiredComponents(class AActor* Actor);
	static class ULevelSequence* GetDummySequence();
	static int32 GetResourceSizeBytes(class AActor* Actor, bool isExclusive);
	static void InitActorManager();
	static bool IsActorPoolEnable();
	static bool IsPooledActor(const class AActor* Actor);
	static void RegisterActorSkipProperties(class UClass* Class_0, const TArray<struct FPropertyPair>& Properties);
	static bool ResetActorToDefault(class AActor* Actor);
	static void ResetClassPropertyCache(class UClass* Class_0);
	static void ResetDelegates(class AActor* Actor);
	static void ResetUberGraph(class UObject* Obj);
	static void ResetUObjectByCDO(class UObject* Obj);
	static class AActor* SpawnActor(const class UObject* WorldContextObject, const TSubclassOf<class AActor> ActorClass, const struct FTransform& SpawnTransform, ESpawnActorCollisionHandlingMethod CollisionHandlingOverride, class AActor* Owner, class APawn* Instigator, bool bAsPoolActor);
	static void UnregisterComponent(class UActorComponent* Componet);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroActorManager">();
	}
	static class UKuroActorManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroActorManager>();
	}
};
static_assert(alignof(UKuroActorManager) == 0x000008, "Wrong alignment on UKuroActorManager");
static_assert(sizeof(UKuroActorManager) == 0x000030, "Wrong size on UKuroActorManager");

// Class KuroUtility.KuroApplicationLibrary
// 0x0000 (0x0030 - 0x0030)
class UKuroApplicationLibrary final : public UBlueprintFunctionLibrary
{
public:
	static bool AddApplicationLifetimeDelegate(const TDelegate<void(int32 Type)>& InDelegate);
	static bool AddEditorPreEndPIEDelegate(const TDelegate<void(bool bSimulateInEditor)>& InDelegate);
	static bool Test(int32 Type);
	static bool UnBind();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroApplicationLibrary">();
	}
	static class UKuroApplicationLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroApplicationLibrary>();
	}
};
static_assert(alignof(UKuroApplicationLibrary) == 0x000008, "Wrong alignment on UKuroApplicationLibrary");
static_assert(sizeof(UKuroApplicationLibrary) == 0x000030, "Wrong size on UKuroApplicationLibrary");

// Class KuroUtility.KuroBlockingVolume
// 0x0010 (0x02F8 - 0x02E8)
class AKuroBlockingVolume final : public AVolume
{
public:
	class FName                                   VolumeId;                                          // 0x02E8(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2F4[0x4];                                      // 0x02F4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroBlockingVolume">();
	}
	static class AKuroBlockingVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<AKuroBlockingVolume>();
	}
};
static_assert(alignof(AKuroBlockingVolume) == 0x000008, "Wrong alignment on AKuroBlockingVolume");
static_assert(sizeof(AKuroBlockingVolume) == 0x0002F8, "Wrong size on AKuroBlockingVolume");
static_assert(offsetof(AKuroBlockingVolume, VolumeId) == 0x0002E8, "Member 'AKuroBlockingVolume::VolumeId' has a wrong offset!");

// Class KuroUtility.KuroBooleanEventBinder
// 0x0010 (0x0040 - 0x0030)
class UKuroBooleanEventBinder final : public UObject
{
public:
	TMulticastInlineDelegate<void(bool bContent)> Callback;                                          // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroBooleanEventBinder">();
	}
	static class UKuroBooleanEventBinder* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroBooleanEventBinder>();
	}
};
static_assert(alignof(UKuroBooleanEventBinder) == 0x000008, "Wrong alignment on UKuroBooleanEventBinder");
static_assert(sizeof(UKuroBooleanEventBinder) == 0x000040, "Wrong size on UKuroBooleanEventBinder");
static_assert(offsetof(UKuroBooleanEventBinder, Callback) == 0x000030, "Member 'UKuroBooleanEventBinder::Callback' has a wrong offset!");

// Class KuroUtility.KuroBpDataAsset
// 0x0000 (0x0038 - 0x0038)
class UKuroBpDataAsset : public UPrimaryDataAsset
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroBpDataAsset">();
	}
	static class UKuroBpDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroBpDataAsset>();
	}
};
static_assert(alignof(UKuroBpDataAsset) == 0x000008, "Wrong alignment on UKuroBpDataAsset");
static_assert(sizeof(UKuroBpDataAsset) == 0x000038, "Wrong size on UKuroBpDataAsset");

// Class KuroUtility.KuroBpDataAssetGroup
// 0x0010 (0x0048 - 0x0038)
class UKuroBpDataAssetGroup final : public UDataAsset
{
public:
	TArray<class UKuroBpDataAsset*>               Data;                                              // 0x0038(0x0010)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroBpDataAssetGroup">();
	}
	static class UKuroBpDataAssetGroup* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroBpDataAssetGroup>();
	}
};
static_assert(alignof(UKuroBpDataAssetGroup) == 0x000008, "Wrong alignment on UKuroBpDataAssetGroup");
static_assert(sizeof(UKuroBpDataAssetGroup) == 0x000048, "Wrong size on UKuroBpDataAssetGroup");
static_assert(offsetof(UKuroBpDataAssetGroup, Data) == 0x000038, "Member 'UKuroBpDataAssetGroup::Data' has a wrong offset!");

// Class KuroUtility.KuroStateMachineBase
// 0x0070 (0x00A8 - 0x0038)
class UKuroStateMachineBase final : public UPrimaryDataAsset
{
public:
	class FString                                 Name_0;                                            // 0x0038(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class FString, class UKuroStateMachineConditionBase*> Transitions;                                       // 0x0048(0x0050)(Edit, BlueprintVisible, ExportObject, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<class UKuroStateMachineBase*>          Children;                                          // 0x0098(0x0010)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroStateMachineBase">();
	}
	static class UKuroStateMachineBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroStateMachineBase>();
	}
};
static_assert(alignof(UKuroStateMachineBase) == 0x000008, "Wrong alignment on UKuroStateMachineBase");
static_assert(sizeof(UKuroStateMachineBase) == 0x0000A8, "Wrong size on UKuroStateMachineBase");
static_assert(offsetof(UKuroStateMachineBase, Name_0) == 0x000038, "Member 'UKuroStateMachineBase::Name_0' has a wrong offset!");
static_assert(offsetof(UKuroStateMachineBase, Transitions) == 0x000048, "Member 'UKuroStateMachineBase::Transitions' has a wrong offset!");
static_assert(offsetof(UKuroStateMachineBase, Children) == 0x000098, "Member 'UKuroStateMachineBase::Children' has a wrong offset!");

// Class KuroUtility.KuroStateMachineGroup
// 0x0010 (0x0048 - 0x0038)
class UKuroStateMachineGroup final : public UDataAsset
{
public:
	TArray<class UKuroStateMachineBase*>          StateMachineList;                                  // 0x0038(0x0010)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroStateMachineGroup">();
	}
	static class UKuroStateMachineGroup* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroStateMachineGroup>();
	}
};
static_assert(alignof(UKuroStateMachineGroup) == 0x000008, "Wrong alignment on UKuroStateMachineGroup");
static_assert(sizeof(UKuroStateMachineGroup) == 0x000048, "Wrong size on UKuroStateMachineGroup");
static_assert(offsetof(UKuroStateMachineGroup, StateMachineList) == 0x000038, "Member 'UKuroStateMachineGroup::StateMachineList' has a wrong offset!");

// Class KuroUtility.KuroStateMachineConditionBase
// 0x0000 (0x0038 - 0x0038)
class UKuroStateMachineConditionBase : public UPrimaryDataAsset
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroStateMachineConditionBase">();
	}
	static class UKuroStateMachineConditionBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroStateMachineConditionBase>();
	}
};
static_assert(alignof(UKuroStateMachineConditionBase) == 0x000008, "Wrong alignment on UKuroStateMachineConditionBase");
static_assert(sizeof(UKuroStateMachineConditionBase) == 0x000038, "Wrong size on UKuroStateMachineConditionBase");

// Class KuroUtility.KuroStateMachineConditionAnd
// 0x0010 (0x0048 - 0x0038)
class UKuroStateMachineConditionAnd final : public UKuroStateMachineConditionBase
{
public:
	TArray<class UKuroStateMachineConditionBase*> Conditions;                                        // 0x0038(0x0010)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroStateMachineConditionAnd">();
	}
	static class UKuroStateMachineConditionAnd* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroStateMachineConditionAnd>();
	}
};
static_assert(alignof(UKuroStateMachineConditionAnd) == 0x000008, "Wrong alignment on UKuroStateMachineConditionAnd");
static_assert(sizeof(UKuroStateMachineConditionAnd) == 0x000048, "Wrong size on UKuroStateMachineConditionAnd");
static_assert(offsetof(UKuroStateMachineConditionAnd, Conditions) == 0x000038, "Member 'UKuroStateMachineConditionAnd::Conditions' has a wrong offset!");

// Class KuroUtility.KuroStateMachineConditionOr
// 0x0010 (0x0048 - 0x0038)
class UKuroStateMachineConditionOr final : public UKuroStateMachineConditionBase
{
public:
	TArray<class UKuroStateMachineConditionBase*> Conditions;                                        // 0x0038(0x0010)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroStateMachineConditionOr">();
	}
	static class UKuroStateMachineConditionOr* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroStateMachineConditionOr>();
	}
};
static_assert(alignof(UKuroStateMachineConditionOr) == 0x000008, "Wrong alignment on UKuroStateMachineConditionOr");
static_assert(sizeof(UKuroStateMachineConditionOr) == 0x000048, "Wrong size on UKuroStateMachineConditionOr");
static_assert(offsetof(UKuroStateMachineConditionOr, Conditions) == 0x000038, "Member 'UKuroStateMachineConditionOr::Conditions' has a wrong offset!");

// Class KuroUtility.KuroCollectActorComponent
// 0x0008 (0x00C8 - 0x00C0)
class UKuroCollectActorComponent final : public UActorComponent
{
public:
	ECollectActorType                             CollectActorType;                                  // 0x00C0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C1[0x7];                                       // 0x00C1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class AActor* GetActorWithTag(class FName Tag, ECollectActorType Type);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroCollectActorComponent">();
	}
	static class UKuroCollectActorComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroCollectActorComponent>();
	}
};
static_assert(alignof(UKuroCollectActorComponent) == 0x000008, "Wrong alignment on UKuroCollectActorComponent");
static_assert(sizeof(UKuroCollectActorComponent) == 0x0000C8, "Wrong size on UKuroCollectActorComponent");
static_assert(offsetof(UKuroCollectActorComponent, CollectActorType) == 0x0000C0, "Member 'UKuroCollectActorComponent::CollectActorType' has a wrong offset!");

// Class KuroUtility.KuroCompressLibrary
// 0x0000 (0x0030 - 0x0030)
class UKuroCompressLibrary final : public UBlueprintFunctionLibrary
{
public:
	static void CompressFileOrFolder(const class FString& Path, const class FString& DestPath, const TDelegate<void(float Rate)>& OnProgress, const TDelegate<void(TArray<class FString>& SuccessedPaths)>& OnCompressComplete, const TDelegate<void()>& OnFail, int64 MaxSingleFileReadSize);
	static void CompressFilesOrFoldersAsync(const TArray<class FString>& Paths, const class FString& DestPath, const TDelegate<void(float Rate)>& OnProgress, const TDelegate<void(TArray<class FString>& SuccessedPaths)>& OnCompressComplete, const TDelegate<void()>& OnFail, bool bAutoIncludeFilesUnderFolder, int64 MaxSingleFileReadSize);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroCompressLibrary">();
	}
	static class UKuroCompressLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroCompressLibrary>();
	}
};
static_assert(alignof(UKuroCompressLibrary) == 0x000008, "Wrong alignment on UKuroCompressLibrary");
static_assert(sizeof(UKuroCompressLibrary) == 0x000030, "Wrong size on UKuroCompressLibrary");

// Class KuroUtility.KuroEntityActor
// 0x0008 (0x02B8 - 0x02B0)
class AKuroEntityActor final : public AKuroActor
{
public:
	int32                                         EntityId;                                          // 0x02B0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B4[0x4];                                      // 0x02B4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroEntityActor">();
	}
	static class AKuroEntityActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AKuroEntityActor>();
	}
};
static_assert(alignof(AKuroEntityActor) == 0x000008, "Wrong alignment on AKuroEntityActor");
static_assert(sizeof(AKuroEntityActor) == 0x0002B8, "Wrong size on AKuroEntityActor");
static_assert(offsetof(AKuroEntityActor, EntityId) == 0x0002B0, "Member 'AKuroEntityActor::EntityId' has a wrong offset!");

// Class KuroUtility.KuroIntEventBinder
// 0x0010 (0x0040 - 0x0030)
class UKuroIntEventBinder final : public UObject
{
public:
	TMulticastInlineDelegate<void(int32 Number)>  Callback;                                          // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroIntEventBinder">();
	}
	static class UKuroIntEventBinder* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroIntEventBinder>();
	}
};
static_assert(alignof(UKuroIntEventBinder) == 0x000008, "Wrong alignment on UKuroIntEventBinder");
static_assert(sizeof(UKuroIntEventBinder) == 0x000040, "Wrong size on UKuroIntEventBinder");
static_assert(offsetof(UKuroIntEventBinder, Callback) == 0x000030, "Member 'UKuroIntEventBinder::Callback' has a wrong offset!");

// Class KuroUtility.KuroJsStatsLibrary
// 0x0000 (0x0030 - 0x0030)
class UKuroJsStatsLibrary final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroJsStatsLibrary">();
	}
	static class UKuroJsStatsLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroJsStatsLibrary>();
	}
};
static_assert(alignof(UKuroJsStatsLibrary) == 0x000008, "Wrong alignment on UKuroJsStatsLibrary");
static_assert(sizeof(UKuroJsStatsLibrary) == 0x000030, "Wrong size on UKuroJsStatsLibrary");

// Class KuroUtility.KuroMathLibrary
// 0x0000 (0x0030 - 0x0030)
class UKuroMathLibrary final : public UBlueprintFunctionLibrary
{
public:
	static int64 BitwiseLeftShift(int64 Source, int32 Bit);
	static int64 BitwiseRightShift(int64 Source, int32 Bit);
	static int32 IntBitwiseAnd(int32 Num1, int32 Num2);
	static int32 IntBitwiseNot(int32 Num);
	static int32 IntBitwiseOr(int32 Num1, int32 Num2);
	static int32 IntBitwiseXOr(int32 Num1, int32 Num2);
	static int64 KuroStringToInt64(const class FString& StringNum);
	static int64 LongBitwiseAnd(int64 Num1, int64 Num2);
	static int64 LongBitwiseNot(int64 Num);
	static int64 LongBitwiseOr(int64 Num1, int64 Num2);
	static int64 LongBitwiseXOr(int64 Num1, int64 Num2);
	static struct FVector2D Max(const struct FVector2D& A, const struct FVector2D& B);
	static struct FVector2D Min(const struct FVector2D& A, const struct FVector2D& B);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroMathLibrary">();
	}
	static class UKuroMathLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroMathLibrary>();
	}
};
static_assert(alignof(UKuroMathLibrary) == 0x000008, "Wrong alignment on UKuroMathLibrary");
static_assert(sizeof(UKuroMathLibrary) == 0x000030, "Wrong size on UKuroMathLibrary");

// Class KuroUtility.KuroMemoryLibrary
// 0x0000 (0x0030 - 0x0030)
class UKuroMemoryLibrary final : public UBlueprintFunctionLibrary
{
public:
	static void PrintUObjectMemoryInfo(class UObject* Object);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroMemoryLibrary">();
	}
	static class UKuroMemoryLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroMemoryLibrary>();
	}
};
static_assert(alignof(UKuroMemoryLibrary) == 0x000008, "Wrong alignment on UKuroMemoryLibrary");
static_assert(sizeof(UKuroMemoryLibrary) == 0x000030, "Wrong size on UKuroMemoryLibrary");

// Class KuroUtility.KuroMeshTextureFunctionLibrary
// 0x0000 (0x0030 - 0x0030)
class UKuroMeshTextureFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static bool AddMeshesBundleStreamedAllMipsDelegate(const TDelegate<void(TArray<class USkeletalMesh*>& SkeletalMeshes, TArray<class UStaticMesh*>& StaticMeshes)>& InDelegate);
	static bool AddSkeletalStreamedAllMipsDelegate(const TDelegate<void(class USkeletalMesh* SkeletalMesh)>& InDelegate);
	static bool AddStaticMeshStreamedAllMipsDelegate(const TDelegate<void(class UStaticMesh* StaticMesh)>& InDelegate);
	static int32 ForceMeshesBundleStreamingInAllMips(const TArray<class USkeletalMesh*>& MeshBundleSkeletalMeshes, const TArray<class UStaticMesh*>& MeshBundleStaticMeshes, const TDelegate<void(TArray<class USkeletalMesh*>& SkeletalMeshes, TArray<class UStaticMesh*>& StaticMeshes)>& InDelegate);
	static void HandleMeshesComponentsBundleStreaming(const TArray<class USkeletalMesh*>& MeshBundleSkeletalMeshes, const TArray<class UStaticMesh*>& MeshBundleStaticMeshes, const bool bStartForceStreamIn);
	static void HandleSkeletalMeshComponentStreaming(class USkeletalMesh* skeletalMesh, const bool bStartForceStreamIn);
	static void HandleStaticMeshComponentStreaming(class UStaticMesh* staticMesh, const bool bStartForceStreamIn);
	static bool IsSkeletalMeshComponentStreamingComplete(class USkeletalMesh* skeletalMesh);
	static bool IsStaticMeshComponentStreamingComplete(class UStaticMesh* staticMesh);
	static bool StopMeshesBundleStreamingInAllMips(const int32 UniqueInstanceID);
	static bool UnbindMeshesBundleStreamedAllMipsDelegate();
	static bool UnbindSkeletalStreamedAllMipsDelegate();
	static bool UnbindStaticMeshStreamedAllMipsDelegate();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroMeshTextureFunctionLibrary">();
	}
	static class UKuroMeshTextureFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroMeshTextureFunctionLibrary>();
	}
};
static_assert(alignof(UKuroMeshTextureFunctionLibrary) == 0x000008, "Wrong alignment on UKuroMeshTextureFunctionLibrary");
static_assert(sizeof(UKuroMeshTextureFunctionLibrary) == 0x000030, "Wrong size on UKuroMeshTextureFunctionLibrary");

// Class KuroUtility.KuroPerceptionEventBinder
// 0x0010 (0x0040 - 0x0030)
class UKuroPerceptionEventBinder final : public UObject
{
public:
	TMulticastInlineDelegate<void(TArray<class AActor*>& AddActor, TArray<class AActor*>& RemoveActor, TArray<int32>& RemoveActorIds, int32 Num)> Callback;                                          // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroPerceptionEventBinder">();
	}
	static class UKuroPerceptionEventBinder* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroPerceptionEventBinder>();
	}
};
static_assert(alignof(UKuroPerceptionEventBinder) == 0x000008, "Wrong alignment on UKuroPerceptionEventBinder");
static_assert(sizeof(UKuroPerceptionEventBinder) == 0x000040, "Wrong size on UKuroPerceptionEventBinder");
static_assert(offsetof(UKuroPerceptionEventBinder, Callback) == 0x000030, "Member 'UKuroPerceptionEventBinder::Callback' has a wrong offset!");

// Class KuroUtility.KuroPhysicsLibrary
// 0x0000 (0x0030 - 0x0030)
class UKuroPhysicsLibrary final : public UBlueprintFunctionLibrary
{
public:
	static bool GetHitPoint(const struct FVectorDouble& StartLocation, const struct FVectorDouble& EndLocation, class AActor* Actor, class UPrimitiveComponent* TraceComp, class UKuroHitResult* HitResult, float DrawDuration, bool ForceTrace);
	static bool GetSphereHitPoint(const struct FVectorDouble& StartLocation, const struct FVectorDouble& EndLocation, class AActor* Actor, class UPrimitiveComponent* TraceComp, float Radius, class UKuroHitResult* HitResult, float DrawDuration, bool ForceTrace);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroPhysicsLibrary">();
	}
	static class UKuroPhysicsLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroPhysicsLibrary>();
	}
};
static_assert(alignof(UKuroPhysicsLibrary) == 0x000008, "Wrong alignment on UKuroPhysicsLibrary");
static_assert(sizeof(UKuroPhysicsLibrary) == 0x000030, "Wrong size on UKuroPhysicsLibrary");

// Class KuroUtility.KuroPolypartition
// 0x0000 (0x0030 - 0x0030)
class UKuroPolypartition final : public UBlueprintFunctionLibrary
{
public:
	static TArray<int32> BuildTriangleByVertex2D(const TArray<struct FVector2D>& points);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroPolypartition">();
	}
	static class UKuroPolypartition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroPolypartition>();
	}
};
static_assert(alignof(UKuroPolypartition) == 0x000008, "Wrong alignment on UKuroPolypartition");
static_assert(sizeof(UKuroPolypartition) == 0x000030, "Wrong size on UKuroPolypartition");

// Class KuroUtility.KuroSilenceGameMode
// 0x0008 (0x03A8 - 0x03A0)
class AKuroSilenceGameMode : public AGameMode
{
public:
	uint8                                         Pad_3A0[0x8];                                      // 0x03A0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void GameInitialized();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroSilenceGameMode">();
	}
	static class AKuroSilenceGameMode* GetDefaultObj()
	{
		return GetDefaultObjImpl<AKuroSilenceGameMode>();
	}
};
static_assert(alignof(AKuroSilenceGameMode) == 0x000008, "Wrong alignment on AKuroSilenceGameMode");
static_assert(sizeof(AKuroSilenceGameMode) == 0x0003A8, "Wrong size on AKuroSilenceGameMode");

// Class KuroUtility.KuroStaticAndroidLibrary
// 0x0000 (0x0030 - 0x0030)
class UKuroStaticAndroidLibrary final : public UBlueprintFunctionLibrary
{
public:
	static void AddAndroidScreenChangeDelegate(const TDelegate<void()>& Handler);
	static void ClearAndroidScreenChangeDelegate();
	static class FString GetCustomChannel();
	static bool GetDeviceIsEmulator();
	static bool GetDeviceIsRooted();
	static void OpenAppWithUrl(const class FString& schema, const class FString& failSchema);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroStaticAndroidLibrary">();
	}
	static class UKuroStaticAndroidLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroStaticAndroidLibrary>();
	}
};
static_assert(alignof(UKuroStaticAndroidLibrary) == 0x000008, "Wrong alignment on UKuroStaticAndroidLibrary");
static_assert(sizeof(UKuroStaticAndroidLibrary) == 0x000030, "Wrong size on UKuroStaticAndroidLibrary");

// Class KuroUtility.KuroStaticiOSLibrary
// 0x0000 (0x0030 - 0x0030)
class UKuroStaticiOSLibrary final : public UBlueprintFunctionLibrary
{
public:
	static bool GetDeviceJailbroken();
	static void OpenAppWithUrl(const class FString& url, const class FString& failUrl);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroStaticiOSLibrary">();
	}
	static class UKuroStaticiOSLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroStaticiOSLibrary>();
	}
};
static_assert(alignof(UKuroStaticiOSLibrary) == 0x000008, "Wrong alignment on UKuroStaticiOSLibrary");
static_assert(sizeof(UKuroStaticiOSLibrary) == 0x000030, "Wrong size on UKuroStaticiOSLibrary");

// Class KuroUtility.KuroStaticLibrary
// 0x0000 (0x0030 - 0x0030)
class UKuroStaticLibrary final : public UBlueprintFunctionLibrary
{
public:
	static void AddToRoot(class UObject* InObject);
	static void ApplyChangeToBlueprint(class AActor* Actor);
	static struct FArrayBuffer ArrayToBuffer(TArray<uint8>* InArray);
	static class FString Base64Decode(const class FString& inString);
	static class FString Base64Encode(const class FString& inString);
	static class FString Base64EncodeWithConvertToUTF8(const class FString& inString);
	static class FString Base64EncodeWithSpecifyChar(const TArray<uint8>& ByteArray, const class FString& SpecifyChar);
	static class FString Base64EncodeWithSpecifyCharWithConvertToUTF8(const class FString& inString, const class FString& SpecifyChar);
	static void BindCustomGetTimeBetweenGarbageCollectionPassesDelegate(const TDelegate<void(float MBFree, float ExtraDevelopmentMemorySize, int32 NumObjects)>& Delegate);
	static void BindDeviceLangChangeDelegate(const TDelegate<void()>& Delegate);
	static void ClearCustomGetTimeBetweenGarbageCollectionPassesDelegate();
	static void ClearPlayerInputCache(class APlayerController** PC);
	static EObjectTypeQuery ConvertToObjectType(const ECollisionChannel InCollisionChannel);
	static ETraceTypeQuery ConvertToTraceType(const ECollisionChannel InCollisionChannel);
	static bool CopyFile(const class FString& SourcePath, const class FString& DstPath);
	static struct FVectorDouble D_GetFirstLocationFromSeqTrack(class UMovieScene3DTransformTrack* TransformTrack);
	static bool DeleteFile(const class FString& Path, const bool bRequireExists, const bool bEvenReadOnly, const bool bQuiet);
	static bool DeleteFolder(const class FString& Path, const bool bRequireExists, const bool bTree);
	static void DestroyObject(class UObject* Object);
	static bool DirectoryExists(const class FString& Path);
	static void DoGameViewPortMouseEnter(class UGameViewportClient* InViewport, int32 x, int32 y);
	static bool EncompassesPoint(class AVolume* Volume, const struct FVector& Point, float SphereRadius);
	static bool ExecProcess(const class FString& URL, const class FString& Params_0, int32* ReturnCode, class FString* OutStd, class FString* OutErr);
	static bool ExecuteFunctionByName(class UObject* Object, const class FString& FunctionName, class FString* Result);
	static void ExitGame(bool force);
	static bool FileExists(const class FString& Path);
	static TArray<class FString> FindFilesSorted(const class FString& Path, const class FString& Extension);
	static void ForceGarbageCollection(bool bFullPurge);
	static struct FDateTime FromUnixTimestamp(const int32 Timestamp);
	static class AActor* GetActorOfClassOnLevelInstance(const TSubclassOf<class AActor> ActorClass, const class ALevelInstance* LevelInstance);
	static TArray<class AActor*> GetActorsOnLevelInstance(const class ALevelInstance* LevelInstance);
	static void GetAnimAssets(const class UAnimBlueprint* InAnimBlueprint, TSet<class UAnimationAsset*>* OutAnimationAssets);
	static void GetAnimAssetsByAnimBlueprintClass(const TSubclassOf<class UAnimInstance>& InAnimClass, TSet<class UAnimationAsset*>* OutAnimationAssets);
	static void GetAnimAssetsByAnimInstance(const class UAnimInstance* InAnimInstance, TSet<class UAnimationAsset*>* OutAnimationAssets);
	static void GetAnimMontageNotifies(const class UAnimMontage* AnimMontage, TArray<struct FAnimNotifyEvent>* OutNotifies);
	static void GetAnimSequenceNotifies(const class UAnimSequenceBase* AnimSequence, TArray<struct FAnimNotifyEvent>* OutNotifies);
	static void GetAnimSequencesByAnimMontage(const class UAnimMontage* AnimMontage, TArray<class UAnimSequenceBase*>* OutAnimSequences);
	static class FString GetBaseBoardInfo();
	static int32 GetBatteryLevel();
	static class FString GetBlueprintCallstack();
	static bool GetCameraShakeInfo(TSubclassOf<class UCameraShakeBase> CameraShakeClass, struct FCameraShakeInfo* OutInfo);
	static void GetCharacterAnimClass(const TSubclassOf<class AActor>& InActorClass, TSubclassOf<class UAnimInstance>* OutAnimClass);
	static void GetCreatureGenDirectoryByMap(const class FString& Path, const int32 MapID, bool* Exist, class FString* Directory);
	static class FString GetCultureRegion();
	static float GetCurCPUFrequency();
	static class UObject* GetDefaultObject(class UClass* Class_0);
	static class FString GetDeviceCPU();
	static TArray<class FString> GetDirectories(const class FString& Path);
	static class FString GetDiskSerialNo();
	static TArray<class FString> GetFiles(const class FString& Path, const class FString& Extension);
	static TArray<class FString> GetFilesRecursive(const class FString& Path, const class FString& Filter, bool Files, bool Directories);
	static struct FVector GetFirstLocationFromSeqTrack(class UMovieScene3DTransformTrack* TransformTrack);
	static class UGameViewportClient* GetGameViewPort();
	static class FString GetGPUInfo();
	static class FString GetLevelPath(const class UObject* WorldContextObject);
	static class AActor* GetLevelPrefabShowActor(class AActor* Actor);
	static void GetLocalHostAddresses(TArray<class FString>* OutAddresses, const bool bAppendPort);
	static class FString GetMacAddress();
	static TArray<struct FVector> GetNavPointData(class UObject* WorldContextObject, int32 XNumber, int32 YNumber, int32 Dis, class ANavigationData* NavData, const struct FVector& Point, const struct FVector& QueryExtent, TSubclassOf<class UNavigationQueryFilter> FilterClass);
	static float GetPIEStartTimeInSeconds();
	static float GetPlatformTimeInSeconds();
	static class FString GetProcessorId();
	static TArray<class UMovieSceneTrack*> GetSequenceTracksForObjectBindingID(const class ALevelSequenceActor* Actor, class FName TagName);
	static struct FVector2D GetSlateApplicationCursorPos();
	static void GetSlotNamesByAnimMontage(const class UAnimMontage* AnimMontage, TArray<class FName>* OutSlotNames);
	static struct FRotator GetSplineRotationAtSplinePoint(class USplineComponent* Spline, int32 PointIndex, ESplineCoordinateSpace CoordinateSpace);
	static class FString GetStatUnitInfo();
	static class FString GetSysUUID();
	static int64 GetTotalPhysicalMemory();
	static class UMovieSceneTrack* GetTrackByClass(const TArray<class UMovieSceneTrack*>& Tracks, TSubclassOf<class UMovieSceneTrack> Class_0);
	static class FString GetVendorInfo();
	static struct FVector2D GetViewPortMousePosition();
	static class FString HashStringWithSHA1(const class FString& inString);
	static void IcmpPing(const class FString& IpAddress, float Timeout, const TDelegate<void(const class FString& Address, float Time, int32 responseState)>& InDelegate);
	static bool IsEditor(const class UObject* WorldContextObject);
	static bool IsForegroundWindow();
	static bool IsImplementInterface(class UClass* InClass, class UClass* InInterfaceClass);
	static bool IsLowMemoryDevice();
	static bool IsModuleLoaded(const class FString& ModelName);
	static bool IsMontageContainGivenAnimNotify(const class UAnimMontage* AnimMontage, const TSet<class FString>& CheckClassNames);
	static bool IsObjectClassByName(class UObject* Object, class FName ClassName);
	static bool IsViewportFocus();
	static bool IsWithEditor();
	static bool IsWorldTearingDown(const class UWorld* World);
	static bool KuroEnableCustomAffinity();
	static class FString KuroFormatText(const class FString& Format, const TArray<class FString>& Parameters);
	static TArray<class FString> LoadFilesRecursive(const class FString& Path, const class FString& Filter, bool Files, bool Directories);
	static bool LoadFileToArray(const class FString& Path, TArray<uint8>* OutArray);
	static bool LoadFileToString(class FString* Result, const class FString& Filename);
	static TArray<class FString> LoadFileToStringArray(const class FString& FileRevisionPath);
	static bool MakeDirectory(const class FString& Path, const bool bTree);
	static class FString Md5HashAnsiString(const class FString& inString);
	static class FString Md5HashUTF8String(const class FString& inString);
	static void PerceptionConfigureSense(class UAIPerceptionComponent* AIPerception, class UAISenseConfig* AISenseConfig);
	static void RegisterCustomCommandProcessor(const class FString& Category, const TDelegate<void(const class FString& Command)>& Processor);
	static void RemoveFromRoot(class UObject* InObject);
	static bool SaveBufferToFile(const class FString& Path, const struct FArrayBuffer& InBuffer);
	static bool SaveStringToFile(const class FString& SaveText, const class FString& FileName, const bool bWithBom);
	static void SetActorModify(class AActor* Actor);
	static void SetActorPermanent(class AActor* Actor, const bool bIsPermanent, const bool bWithAllChildren);
	static void SetBaseAndSaveBaseLocation(class UCharacterMovementComponent* CharacterMovementComp, class UPrimitiveComponent* NewBase);
	static void SetCursorVisibility(bool visible);
	static void SetEditorWidgetSkipTick(bool bSkipTick);
	static void SetGameThreadAffinity(bool bIsInFighting);
	static void SetHangAssertFlag(bool bAssertFlag);
	static void SetHangDuration(float HangDuration);
	static void SetHttpThreadActiveMinimumSleepTimeInSeconds(float InHttpThreadActiveMinimumSleepTimeInSeconds);
	static void SetHttpThreadIdleMinimumSleepTimeInSeconds(float InHttpThreadIdleMinimumSleepTimeInSeconds);
	static void SetInputKeyDeadZone(class UObject* world, int32 playerIndex, const struct FKey& key, const float deadZone);
	static void SetMontageANIndex(const class UAnimMontage* AnimMontage);
	static void SetSplinePointsWithType(class USplineComponent* Spline, const TArray<struct FVector>& Points, ESplineCoordinateSpace CoordinateSpace, ESplinePointType Type, bool bUpdateSpline);
	static void SetStaticMeshVelocity(const TArray<class AActor*>& Actors, const struct FVector& NewVelocity);
	static void SetThreadAffinity(const class FString& ThreadName, int32 AffinityHigh, int32 AffinityLow);
	static void SetThreadPolicy(const class FString& ThreadName, int32 Policy);
	static void SetThreadPriority(const class FString& ThreadName, int32 Priority);
	static void SetThreadPriorityAndPolicy(const class FString& ThreadName, int32 Priority, int32 Policy);
	static void SetThreadPriorityAndPolicyAndAffinity(const class FString& ThreadName, int32 Priority, int32 Policy, int32 AffinityHigh, int32 AffinityLow);
	static void ShowSoftwareCursor(bool visible);
	static class AActor* SpawnActorFromAnother(class AActor* Actor, class AActor* Parent);
	static void StopAllMontagesBySlotName(class UAnimInstance* UAnimInstance, const class FName InSlotName, const float InBlendOutTime);
	static void SynchronizeProperties(class UWidget* InWidget);
	static bool ToggleSequenceNodeActiveByTag(const class ALevelSequenceActor* Actor, class FName TagName, bool bActive);
	static int32 ToUnixTimestamp(const struct FDateTime& InDataTime);
	static void UnBindDeviceLangChangeDelegate();
	static void UnRegisterCustomCommandProcessor(const class FString& Category);
	static bool WriteStringToFile(const class FString& SaveText, const class FString& FileName, const bool bPublic, const bool bWithBom);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroStaticLibrary">();
	}
	static class UKuroStaticLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroStaticLibrary>();
	}
};
static_assert(alignof(UKuroStaticLibrary) == 0x000008, "Wrong alignment on UKuroStaticLibrary");
static_assert(sizeof(UKuroStaticLibrary) == 0x000030, "Wrong size on UKuroStaticLibrary");

// Class KuroUtility.KuroStaticPS5Library
// 0x0000 (0x0030 - 0x0030)
class UKuroStaticPS5Library final : public UBlueprintFunctionLibrary
{
public:
	static void AbortTrophyHandleAsync(int32* handle, const TDelegate<void(int32 ret)>& callback);
	static int32 AbortUdsHandle(int32 handle);
	static void AddCacheMapElement(const class FString& key, const class FString& value);
	static void AddJoinSessionDelegate(const TDelegate<void(const class FString& userId, const class FString& playerSessionId)>& InDelegate);
	static class FString CheckJoinSession();
	static int32 CheckUserPremium(class FString* userId);
	static void ClearJoinSessionDelegate();
	static void ClearJoinSessionHandle();
	static class FString CreatePlayerSession(int32 joinableUserType, class FString* playerId);
	static void CreateTrophyContextAsync(const class FString& userId, int32 serviceLabel, const class FString& optionsLong, const TDelegate<void(int32 ret, int32 result)>& callback);
	static void CreateTrophyHandleAsync(const TDelegate<void(int32 ret, int32 result)>& callback);
	static int32 CreateUdsContext(class FString* userId, int32* context);
	static int32 CreateUdsEvent(class FString* eventName, int64* outEventPtr, int64* outProPtr);
	static int32 CreateUdsHandle(int32* handle);
	static void DestroyTrophyContextAsync(int32* context, const TDelegate<void(int32 ret)>& callback);
	static void DestroyTrophyHandleAsync(int32* handle, const TDelegate<void(int32 ret)>& callback);
	static int32 DestroyUdsContext(int32 context);
	static int32 DestroyUdsEvent(int64 eventPtr);
	static int32 DestroyUdsHandle(int32 handle);
	static class FString GetAccountIdByUserId(class FString* userId);
	static int32 GetAuthCode(class FString* ClientId, class FString* Scope, class FString* AuthCode, int32* IssuerId);
	static TArray<struct FBasicPresenceData> GetBasicPresence(class FString* accountId);
	static struct FBlockUserData GetBlockUserList(int32* offset, int32* limit);
	static void GetBlockUserListAsync(int32* offset, int32* limit, const TDelegate<void(const struct FBlockUserData& data)>& Delegate);
	static class FString GetCacheMapElement(const class FString& key);
	static void GetCommunicationRestrictionStatusAsync(class FString* accountId, const TDelegate<void(int32 ret, int32 status)>& callback);
	static class FString GetCountryCodeByUserId(class FString* userId);
	static int32 GetIdToken(class FString* ClientId, class FString* ClientSecret, class FString* Scope, class FString* IdToken);
	static void GetMessageDialogStateAsync(const TDelegate<void(int32 ret)>& callback);
	static class FString GetOnlineIdByUserId(class FString* userId);
	static class FString GetPlayerIdByPlayerSessionId(class FString* playerSessionId);
	static TArray<struct FProductData> GetStoreProducts();
	static struct FTrophyInfoData GetTrophyList(class FString* userId, int32* inputOffset, int32 length);
	static struct FTrophyInfoData GetTrophyListWithContextIdAndHandleId(int32 context, int32 handle, int32* inputOffset, int32 length);
	static void GetTrophyListWithContextIdAndHandleIdAsync(int32* inputOffset, int32 length, int32 context, int32 handle, const TDelegate<void(const struct FTrophyInfoData& data)>& callback);
	static class FString GetUserId();
	static class FString GetUserIdByAccountId(class FString* accountId);
	static int32 HidePsStoreIcon();
	static int32 InitNpUniversalDataSystem(int32 poolSize);
	static int32 InitWebApi(class FString* userId);
	static void JoinPlayerSession(class FString* playerSessionId);
	static void LeavePlayerSession();
	static void NotifyPremium(class FString* userId);
	static void NotifyPremiumFeature(class FString* userId, bool isPlayStationOnly);
	static int32 OpenCheckoutDialog(class FString* ProductLabel);
	static void OpenMessageDialog(class FString* userId, int32 openMode, int32 msgType, const TDelegate<void(int32 ret)>& callback);
	static void OpenWebBrowser(class FString* Url);
	static int32 OpenWebView(class FString* Url);
	static int32 PollCheckoutDialogResult();
	static bool PollWebBrowser();
	static int32 PostUdsEvent(int32 context, int32 handle, int64 eventPtr);
	static void RegisterTrophyContextAsync(int32* context, int32* handle, const class FString& optionsLong, const TDelegate<void(int32 ret)>& callback);
	static int32 RegisterUdsContext(int32 context, int32 handle);
	static void RemoveCacheElement(const class FString& key);
	static int32 SceNpGetNpReachabilityState(class FString* userId, int32* outState);
	static void SetPlayerSessionJoinableUserType(int32 joinableUserType);
	static int32 ShowPsStoreIcon(int32 position);
	static void TerminateMessageDialog();
	static int32 UdsEventPropertyArraySetString(int64 proPtr, class FString* key, TArray<class FString>* value);
	static int32 UdsEventPropertyObjectSetBool(int64 proPtr, class FString* key, bool value);
	static int32 UdsEventPropertyObjectSetFloat32(int64 proPtr, class FString* key, float value);
	static int32 UdsEventPropertyObjectSetFloat64(int64 proPtr, class FString* key, double value);
	static int32 UdsEventPropertyObjectSetInt32(int64 proPtr, class FString* key, int32 value);
	static int32 UdsEventPropertyObjectSetInt64(int64 proPtr, class FString* key, int64 value);
	static int32 UdsEventPropertyObjectSetString(int64 proPtr, class FString* key, class FString* value);
	static int32 UdsEventPropertyObjectSetUInt32(int64 proPtr, class FString* key, int32 value);
	static int32 UdsEventPropertyObjectSetUInt64(int64 proPtr, class FString* key, int64 value);
	static int32 UnlockTrophy(class FString* userId, int32 trophyId);
	static int32 UnlockTrophyWithContextIdAndHandleId(int32 contextId, int32 handle, int32 trophyId);
	static void UnlockTrophyWithContextIdAndHandleIdAsync(int32 contextId, int32 handle, int32 trophyId, const TDelegate<void(int32 ret)>& callback);
	static int32 UpdateTrophyProgress(class FString* userId, int32 trophyId, int32 progress);
	static int32 UpdateTrophyProgressWithContextIdAndHandleId(int32 context, int32 handle, int32 trophyId, int32 progress);
	static void UpdateTrophyProgressWithContextIdAndHandleIdAsync(int32 context, int32 handle, int32 trophyId, int32 progress, const TDelegate<void(int32 ret)>& callback);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroStaticPS5Library">();
	}
	static class UKuroStaticPS5Library* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroStaticPS5Library>();
	}
};
static_assert(alignof(UKuroStaticPS5Library) == 0x000008, "Wrong alignment on UKuroStaticPS5Library");
static_assert(sizeof(UKuroStaticPS5Library) == 0x000030, "Wrong size on UKuroStaticPS5Library");

// Class KuroUtility.KuroSubLevelVisibleSubsystem
// 0x0088 (0x00C0 - 0x0038)
class UKuroSubLevelVisibleSubsystem final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_38[0x88];                                      // 0x0038(0x0088)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UKuroSubLevelVisibleSubsystem* GetSubSystem(const class UGameInstance* GameInstance);

	void AddLevel(int32 LinkId, class ULevel* Level);
	void RemoveLevel(int32 LinkId);
	bool SetLevelActorsVisible(const int32 LinkId, const bool Visible, const TDelegate<void(int32 LinkId)> FinishCallback);
	void SetOneFrameExecuteCount(const int32 Count);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroSubLevelVisibleSubsystem">();
	}
	static class UKuroSubLevelVisibleSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroSubLevelVisibleSubsystem>();
	}
};
static_assert(alignof(UKuroSubLevelVisibleSubsystem) == 0x000008, "Wrong alignment on UKuroSubLevelVisibleSubsystem");
static_assert(sizeof(UKuroSubLevelVisibleSubsystem) == 0x0000C0, "Wrong size on UKuroSubLevelVisibleSubsystem");

// Class KuroUtility.KuroTencentCOSLibrary
// 0x0000 (0x0030 - 0x0030)
class UKuroTencentCOSLibrary final : public UBlueprintFunctionLibrary
{
public:
	static void ClearAllProgressCallback();
	static void EnableAuthorization(bool Enable);
	static void EnableAutoSendWhenExit();
	static int32 GetAllFileNumNeedToSend();
	static int32 GetSendedFileNum();
	static void InterruptSending();
	static bool IsSending();
	static void SendFileToTencentCOS(const class FString& Path, const class FString& RemoteURI, const class FString& SecretID, const class FString& SecretKey, const class FString& BucketName, const class FString& Region);
	static void SendLogToTencentCOS(const TDelegate<void(int32 State, float Rate)>& OnProgress);
	static void SetAdmissibleValue(int32 SingleLogSizeInMb);
	static void SetFilesToSend(const TArray<class FString>& FilePaths);
	static void SetHandleFunc(const TDelegate<void(TArray<class FString>& FileNames)>& PrepareFunc, const TDelegate<void(TArray<class FString>& SendedFiles)>& PostSend);
	static void SetIsAutoSend(bool bIsAutoSend);
	static void SetSendLogConfig(const class FString& SecretID, const class FString& SecretKey, const class FString& BucketName, const class FString& Region);
	static void SetSendLogZipName(const class FString& ZipFileName);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroTencentCOSLibrary">();
	}
	static class UKuroTencentCOSLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroTencentCOSLibrary>();
	}
};
static_assert(alignof(UKuroTencentCOSLibrary) == 0x000008, "Wrong alignment on UKuroTencentCOSLibrary");
static_assert(sizeof(UKuroTencentCOSLibrary) == 0x000030, "Wrong size on UKuroTencentCOSLibrary");

// Class KuroUtility.KuroTickableManager
// 0x0018 (0x0048 - 0x0030)
class UKuroTickableManager final : public UObject
{
public:
	uint8                                         Pad_30[0x18];                                      // 0x0030(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CreateTickableFunc(class UObject* InOwner, TDelegate<void(float DeltaSeconds)> TickableHandler);
	void RemoveTickableFunc(class UObject* InOwner);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroTickableManager">();
	}
	static class UKuroTickableManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroTickableManager>();
	}
};
static_assert(alignof(UKuroTickableManager) == 0x000008, "Wrong alignment on UKuroTickableManager");
static_assert(sizeof(UKuroTickableManager) == 0x000048, "Wrong size on UKuroTickableManager");

// Class KuroUtility.KuroTriggerVolume
// 0x0010 (0x02F8 - 0x02E8)
class AKuroTriggerVolume final : public AVolume
{
public:
	class FName                                   VolumeId;                                          // 0x02E8(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2F4[0x4];                                      // 0x02F4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroTriggerVolume">();
	}
	static class AKuroTriggerVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<AKuroTriggerVolume>();
	}
};
static_assert(alignof(AKuroTriggerVolume) == 0x000008, "Wrong alignment on AKuroTriggerVolume");
static_assert(sizeof(AKuroTriggerVolume) == 0x0002F8, "Wrong size on AKuroTriggerVolume");
static_assert(offsetof(AKuroTriggerVolume, VolumeId) == 0x0002E8, "Member 'AKuroTriggerVolume::VolumeId' has a wrong offset!");

// Class KuroUtility.KuroTriggerVolumeManager
// 0x0070 (0x00A8 - 0x0038)
class UKuroTriggerVolumeManager final : public UWorldSubsystem
{
public:
	TMulticastInlineDelegate<void(class FName ActorKey)> OnTriggerVolumeAddToSubsystem;                     // 0x0038(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class FName ActorKey)> OnTriggerVolumeRemoveFromSubsystem;                // 0x0048(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMap<class FName, class AActor*>              KuroTriggerVolumeMap;                              // 0x0058(0x0050)(NativeAccessSpecifierPrivate)

public:
	class AActor* GetKuroTriggerVolume(class FName ActorKey);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroTriggerVolumeManager">();
	}
	static class UKuroTriggerVolumeManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroTriggerVolumeManager>();
	}
};
static_assert(alignof(UKuroTriggerVolumeManager) == 0x000008, "Wrong alignment on UKuroTriggerVolumeManager");
static_assert(sizeof(UKuroTriggerVolumeManager) == 0x0000A8, "Wrong size on UKuroTriggerVolumeManager");
static_assert(offsetof(UKuroTriggerVolumeManager, OnTriggerVolumeAddToSubsystem) == 0x000038, "Member 'UKuroTriggerVolumeManager::OnTriggerVolumeAddToSubsystem' has a wrong offset!");
static_assert(offsetof(UKuroTriggerVolumeManager, OnTriggerVolumeRemoveFromSubsystem) == 0x000048, "Member 'UKuroTriggerVolumeManager::OnTriggerVolumeRemoveFromSubsystem' has a wrong offset!");
static_assert(offsetof(UKuroTriggerVolumeManager, KuroTriggerVolumeMap) == 0x000058, "Member 'UKuroTriggerVolumeManager::KuroTriggerVolumeMap' has a wrong offset!");

// Class KuroUtility.KuroWaterVolume
// 0x0000 (0x02E8 - 0x02E8)
class AKuroWaterVolume final : public AVolume
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroWaterVolume">();
	}
	static class AKuroWaterVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<AKuroWaterVolume>();
	}
};
static_assert(alignof(AKuroWaterVolume) == 0x000008, "Wrong alignment on AKuroWaterVolume");
static_assert(sizeof(AKuroWaterVolume) == 0x0002E8, "Wrong size on AKuroWaterVolume");

// Class KuroUtility.LoadMapNotify
// 0x0158 (0x0188 - 0x0030)
class ULoadMapNotify final : public UObject
{
public:
	uint8                                         Pad_30[0x158];                                     // 0x0030(0x0158)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BindBeginLoadMap(TDelegate<void(const class FString& MapName)> BeginLoadMapHandler);
	void BindBeginTravelLoadMap(TDelegate<void(const class FString& MapName)> BeginTravelLoadMapHandler);
	void BindEndLoadMap(TDelegate<void(const class FString& MapName)> EndLoadMapHandler);
	void BindEndLoadTransitionMap(TDelegate<void()> EndLoadTransitionMapHandler);
	void BindLoadStreamLevel(const TDelegate<void(int32 LinkId, class FName& LevelName, class ULevelStreaming* StreamingLevel)> LoadStreamLevelHandler);
	void BindUnLoadStreamLevel(const TDelegate<void(int32 LinkId, class FName& LevelName)> UnLoadStreamLevelHandler);
	void Clear();
	int32 LoadStreamLevel(const class FName& Path, bool bMakeVisibleAfterLoad, bool bShouldBlockOnLoad);
	void OnLoadStreamLevel(const int32 LinkID);
	void OnUnLoadStreamLevel(const int32 LinkID);
	int32 UnloadStreamLevel(const class FName& Path, bool bShouldBlockOnLoad);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LoadMapNotify">();
	}
	static class ULoadMapNotify* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULoadMapNotify>();
	}
};
static_assert(alignof(ULoadMapNotify) == 0x000008, "Wrong alignment on ULoadMapNotify");
static_assert(sizeof(ULoadMapNotify) == 0x000188, "Wrong size on ULoadMapNotify");

// Class KuroUtility.KuroTickManager
// 0x0080 (0x00B0 - 0x0030)
class UKuroTickManager final : public UObject
{
public:
	uint8                                         Pad_30[0x80];                                      // 0x0030(0x0080)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddPrerequisiteActor(const ETickingGroup TickingGroup, class AActor* Actor, int32 Priority);
	void AddPrerequisiteActorComponent(const ETickingGroup TickingGroup, class UActorComponent* ActorComp, int32 Priority);
	bool AddTick(const ETickingGroup TickingGroup, const TDelegate<void(float DeltaSeconds)> TickHandler, int32 Priority);
	void CleanCharacterMovementProxyTickFunction(class UCharacterMovementComponent* MoveComp);
	void CleanSkeletalMeshProxyTickFunction(class USkeletalMeshComponent* SkeletalComp);
	void ClearTick();
	void RemovePrerequisiteActor(const ETickingGroup TickingGroup, class AActor* Actor, int32 Priority);
	void RemovePrerequisiteActorComponent(const ETickingGroup TickingGroup, class UActorComponent* ActorComp, int32 Priority);
	bool RemoveTick(const ETickingGroup TickingGroup);
	void SetCharacterMovementProxyTickFunction(const ETickingGroup TickingGroup, class UCharacterMovementComponent* MoveComp, int32 Priority);
	void SetSkeletalMeshProxyTickFunction(const ETickingGroup TickingGroup, class USkeletalMeshComponent* SkeletalComp, int32 Priority);
	void SetTickFunctionCompletionCallbackInMainThread(const ETickingGroup TickingGroup, int32 Priority);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroTickManager">();
	}
	static class UKuroTickManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroTickManager>();
	}
};
static_assert(alignof(UKuroTickManager) == 0x000008, "Wrong alignment on UKuroTickManager");
static_assert(sizeof(UKuroTickManager) == 0x0000B0, "Wrong size on UKuroTickManager");

}

