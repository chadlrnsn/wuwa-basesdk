#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: KuroRenderingRuntimeBPPlugin

#include "Basic.hpp"

#include "CoreUObject_structs.hpp"
#include "Engine_structs.hpp"
#include "KuroCurve_structs.hpp"
#include "KuroRenderingRuntimeBPPlugin_structs.hpp"
#include "Renderer_structs.hpp"
#include "MovieScene_structs.hpp"


namespace SDK::Params
{

// Function KuroRenderingRuntimeBPPlugin.KuroLevelSequenceSubsystem.GetAllLevelSequences
// 0x0010 (0x0010 - 0x0000)
struct KuroLevelSequenceSubsystem_GetAllLevelSequences final
{
public:
	TArray<class AKuroLevelSequenceActor*>        InAllLevelSequences;                               // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroLevelSequenceSubsystem_GetAllLevelSequences) == 0x000008, "Wrong alignment on KuroLevelSequenceSubsystem_GetAllLevelSequences");
static_assert(sizeof(KuroLevelSequenceSubsystem_GetAllLevelSequences) == 0x000010, "Wrong size on KuroLevelSequenceSubsystem_GetAllLevelSequences");
static_assert(offsetof(KuroLevelSequenceSubsystem_GetAllLevelSequences, InAllLevelSequences) == 0x000000, "Member 'KuroLevelSequenceSubsystem_GetAllLevelSequences::InAllLevelSequences' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroLevelSequenceSubsystem.GetLevelSequence
// 0x0018 (0x0018 - 0x0000)
struct KuroLevelSequenceSubsystem_GetLevelSequence final
{
public:
	class FName                                   Key;                                               // 0x0000(0x000C)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AKuroLevelSequenceActor*                ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroLevelSequenceSubsystem_GetLevelSequence) == 0x000008, "Wrong alignment on KuroLevelSequenceSubsystem_GetLevelSequence");
static_assert(sizeof(KuroLevelSequenceSubsystem_GetLevelSequence) == 0x000018, "Wrong size on KuroLevelSequenceSubsystem_GetLevelSequence");
static_assert(offsetof(KuroLevelSequenceSubsystem_GetLevelSequence, Key) == 0x000000, "Member 'KuroLevelSequenceSubsystem_GetLevelSequence::Key' has a wrong offset!");
static_assert(offsetof(KuroLevelSequenceSubsystem_GetLevelSequence, ReturnValue) == 0x000010, "Member 'KuroLevelSequenceSubsystem_GetLevelSequence::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroLightActorBase.SetLightIntensityScale
// 0x0004 (0x0004 - 0x0000)
struct KuroLightActorBase_SetLightIntensityScale final
{
public:
	float                                         ScaleFactor;                                       // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroLightActorBase_SetLightIntensityScale) == 0x000004, "Wrong alignment on KuroLightActorBase_SetLightIntensityScale");
static_assert(sizeof(KuroLightActorBase_SetLightIntensityScale) == 0x000004, "Wrong size on KuroLightActorBase_SetLightIntensityScale");
static_assert(offsetof(KuroLightActorBase_SetLightIntensityScale, ScaleFactor) == 0x000000, "Member 'KuroLightActorBase_SetLightIntensityScale::ScaleFactor' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroLightActorBase.Update
// 0x0004 (0x0004 - 0x0000)
struct KuroLightActorBase_Update final
{
public:
	float                                         DeltaSeconds;                                      // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroLightActorBase_Update) == 0x000004, "Wrong alignment on KuroLightActorBase_Update");
static_assert(sizeof(KuroLightActorBase_Update) == 0x000004, "Wrong size on KuroLightActorBase_Update");
static_assert(offsetof(KuroLightActorBase_Update, DeltaSeconds) == 0x000000, "Member 'KuroLightActorBase_Update::DeltaSeconds' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroMaterialControllerComponent.AddOrGetMaterialControllerComponentFromActor
// 0x0010 (0x0010 - 0x0000)
struct KuroMaterialControllerComponent_AddOrGetMaterialControllerComponentFromActor final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UKuroMaterialControllerComponent*       ReturnValue;                                       // 0x0008(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroMaterialControllerComponent_AddOrGetMaterialControllerComponentFromActor) == 0x000008, "Wrong alignment on KuroMaterialControllerComponent_AddOrGetMaterialControllerComponentFromActor");
static_assert(sizeof(KuroMaterialControllerComponent_AddOrGetMaterialControllerComponentFromActor) == 0x000010, "Wrong size on KuroMaterialControllerComponent_AddOrGetMaterialControllerComponentFromActor");
static_assert(offsetof(KuroMaterialControllerComponent_AddOrGetMaterialControllerComponentFromActor, Actor) == 0x000000, "Member 'KuroMaterialControllerComponent_AddOrGetMaterialControllerComponentFromActor::Actor' has a wrong offset!");
static_assert(offsetof(KuroMaterialControllerComponent_AddOrGetMaterialControllerComponentFromActor, ReturnValue) == 0x000008, "Member 'KuroMaterialControllerComponent_AddOrGetMaterialControllerComponentFromActor::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroMaterialControllerComponent.AddOrGetMaterialControllerComponentFromActorWithoutInit
// 0x0010 (0x0010 - 0x0000)
struct KuroMaterialControllerComponent_AddOrGetMaterialControllerComponentFromActorWithoutInit final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UKuroMaterialControllerComponent*       ReturnValue;                                       // 0x0008(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroMaterialControllerComponent_AddOrGetMaterialControllerComponentFromActorWithoutInit) == 0x000008, "Wrong alignment on KuroMaterialControllerComponent_AddOrGetMaterialControllerComponentFromActorWithoutInit");
static_assert(sizeof(KuroMaterialControllerComponent_AddOrGetMaterialControllerComponentFromActorWithoutInit) == 0x000010, "Wrong size on KuroMaterialControllerComponent_AddOrGetMaterialControllerComponentFromActorWithoutInit");
static_assert(offsetof(KuroMaterialControllerComponent_AddOrGetMaterialControllerComponentFromActorWithoutInit, Actor) == 0x000000, "Member 'KuroMaterialControllerComponent_AddOrGetMaterialControllerComponentFromActorWithoutInit::Actor' has a wrong offset!");
static_assert(offsetof(KuroMaterialControllerComponent_AddOrGetMaterialControllerComponentFromActorWithoutInit, ReturnValue) == 0x000008, "Member 'KuroMaterialControllerComponent_AddOrGetMaterialControllerComponentFromActorWithoutInit::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroMaterialControllerComponent.AddColorUpdateParamPermanent
// 0x0020 (0x0020 - 0x0000)
struct KuroMaterialControllerComponent_AddColorUpdateParamPermanent final
{
public:
	class FName                                   Name_0;                                            // 0x0000(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           Value;                                             // 0x000C(0x0010)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EKuroCharBodySpecifiedType                    BodyType;                                          // 0x001C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EKuroCharSlotSpecifiedType                    SlotType;                                          // 0x001D(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EKuroCharMeshPart                             MeshPart;                                          // 0x001E(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F[0x1];                                       // 0x001F(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroMaterialControllerComponent_AddColorUpdateParamPermanent) == 0x000004, "Wrong alignment on KuroMaterialControllerComponent_AddColorUpdateParamPermanent");
static_assert(sizeof(KuroMaterialControllerComponent_AddColorUpdateParamPermanent) == 0x000020, "Wrong size on KuroMaterialControllerComponent_AddColorUpdateParamPermanent");
static_assert(offsetof(KuroMaterialControllerComponent_AddColorUpdateParamPermanent, Name_0) == 0x000000, "Member 'KuroMaterialControllerComponent_AddColorUpdateParamPermanent::Name_0' has a wrong offset!");
static_assert(offsetof(KuroMaterialControllerComponent_AddColorUpdateParamPermanent, Value) == 0x00000C, "Member 'KuroMaterialControllerComponent_AddColorUpdateParamPermanent::Value' has a wrong offset!");
static_assert(offsetof(KuroMaterialControllerComponent_AddColorUpdateParamPermanent, BodyType) == 0x00001C, "Member 'KuroMaterialControllerComponent_AddColorUpdateParamPermanent::BodyType' has a wrong offset!");
static_assert(offsetof(KuroMaterialControllerComponent_AddColorUpdateParamPermanent, SlotType) == 0x00001D, "Member 'KuroMaterialControllerComponent_AddColorUpdateParamPermanent::SlotType' has a wrong offset!");
static_assert(offsetof(KuroMaterialControllerComponent_AddColorUpdateParamPermanent, MeshPart) == 0x00001E, "Member 'KuroMaterialControllerComponent_AddColorUpdateParamPermanent::MeshPart' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroMaterialControllerComponent.AddColorUpdateParamPermanentByIndex
// 0x002C (0x002C - 0x0000)
struct KuroMaterialControllerComponent_AddColorUpdateParamPermanentByIndex final
{
public:
	class FName                                   Name_0;                                            // 0x0000(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           Value;                                             // 0x000C(0x0010)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BodyName;                                          // 0x001C(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaterialIndex;                                     // 0x0028(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroMaterialControllerComponent_AddColorUpdateParamPermanentByIndex) == 0x000004, "Wrong alignment on KuroMaterialControllerComponent_AddColorUpdateParamPermanentByIndex");
static_assert(sizeof(KuroMaterialControllerComponent_AddColorUpdateParamPermanentByIndex) == 0x00002C, "Wrong size on KuroMaterialControllerComponent_AddColorUpdateParamPermanentByIndex");
static_assert(offsetof(KuroMaterialControllerComponent_AddColorUpdateParamPermanentByIndex, Name_0) == 0x000000, "Member 'KuroMaterialControllerComponent_AddColorUpdateParamPermanentByIndex::Name_0' has a wrong offset!");
static_assert(offsetof(KuroMaterialControllerComponent_AddColorUpdateParamPermanentByIndex, Value) == 0x00000C, "Member 'KuroMaterialControllerComponent_AddColorUpdateParamPermanentByIndex::Value' has a wrong offset!");
static_assert(offsetof(KuroMaterialControllerComponent_AddColorUpdateParamPermanentByIndex, BodyName) == 0x00001C, "Member 'KuroMaterialControllerComponent_AddColorUpdateParamPermanentByIndex::BodyName' has a wrong offset!");
static_assert(offsetof(KuroMaterialControllerComponent_AddColorUpdateParamPermanentByIndex, MaterialIndex) == 0x000028, "Member 'KuroMaterialControllerComponent_AddColorUpdateParamPermanentByIndex::MaterialIndex' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroMaterialControllerComponent.AddColorUpdateParamPermanentCommon
// 0x0020 (0x0020 - 0x0000)
struct KuroMaterialControllerComponent_AddColorUpdateParamPermanentCommon final
{
public:
	class FName                                   Name_0;                                            // 0x0000(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           Value;                                             // 0x000C(0x0010)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EKuroCharBodySpecifiedType                    BodyType;                                          // 0x001C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EKuroCharSlotSpecifiedType                    SlotType;                                          // 0x001D(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1E[0x2];                                       // 0x001E(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroMaterialControllerComponent_AddColorUpdateParamPermanentCommon) == 0x000004, "Wrong alignment on KuroMaterialControllerComponent_AddColorUpdateParamPermanentCommon");
static_assert(sizeof(KuroMaterialControllerComponent_AddColorUpdateParamPermanentCommon) == 0x000020, "Wrong size on KuroMaterialControllerComponent_AddColorUpdateParamPermanentCommon");
static_assert(offsetof(KuroMaterialControllerComponent_AddColorUpdateParamPermanentCommon, Name_0) == 0x000000, "Member 'KuroMaterialControllerComponent_AddColorUpdateParamPermanentCommon::Name_0' has a wrong offset!");
static_assert(offsetof(KuroMaterialControllerComponent_AddColorUpdateParamPermanentCommon, Value) == 0x00000C, "Member 'KuroMaterialControllerComponent_AddColorUpdateParamPermanentCommon::Value' has a wrong offset!");
static_assert(offsetof(KuroMaterialControllerComponent_AddColorUpdateParamPermanentCommon, BodyType) == 0x00001C, "Member 'KuroMaterialControllerComponent_AddColorUpdateParamPermanentCommon::BodyType' has a wrong offset!");
static_assert(offsetof(KuroMaterialControllerComponent_AddColorUpdateParamPermanentCommon, SlotType) == 0x00001D, "Member 'KuroMaterialControllerComponent_AddColorUpdateParamPermanentCommon::SlotType' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroMaterialControllerComponent.AddColorUpdateParamPermanentCustom
// 0x0040 (0x0040 - 0x0000)
struct KuroMaterialControllerComponent_AddColorUpdateParamPermanentCustom final
{
public:
	class FName                                   Name_0;                                            // 0x0000(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           Value;                                             // 0x000C(0x0010)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BodyName;                                          // 0x001C(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EKuroCharSlotSpecifiedType                    SlotType;                                          // 0x0028(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 CustomPartName;                                    // 0x0030(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroMaterialControllerComponent_AddColorUpdateParamPermanentCustom) == 0x000008, "Wrong alignment on KuroMaterialControllerComponent_AddColorUpdateParamPermanentCustom");
static_assert(sizeof(KuroMaterialControllerComponent_AddColorUpdateParamPermanentCustom) == 0x000040, "Wrong size on KuroMaterialControllerComponent_AddColorUpdateParamPermanentCustom");
static_assert(offsetof(KuroMaterialControllerComponent_AddColorUpdateParamPermanentCustom, Name_0) == 0x000000, "Member 'KuroMaterialControllerComponent_AddColorUpdateParamPermanentCustom::Name_0' has a wrong offset!");
static_assert(offsetof(KuroMaterialControllerComponent_AddColorUpdateParamPermanentCustom, Value) == 0x00000C, "Member 'KuroMaterialControllerComponent_AddColorUpdateParamPermanentCustom::Value' has a wrong offset!");
static_assert(offsetof(KuroMaterialControllerComponent_AddColorUpdateParamPermanentCustom, BodyName) == 0x00001C, "Member 'KuroMaterialControllerComponent_AddColorUpdateParamPermanentCustom::BodyName' has a wrong offset!");
static_assert(offsetof(KuroMaterialControllerComponent_AddColorUpdateParamPermanentCustom, SlotType) == 0x000028, "Member 'KuroMaterialControllerComponent_AddColorUpdateParamPermanentCustom::SlotType' has a wrong offset!");
static_assert(offsetof(KuroMaterialControllerComponent_AddColorUpdateParamPermanentCustom, CustomPartName) == 0x000030, "Member 'KuroMaterialControllerComponent_AddColorUpdateParamPermanentCustom::CustomPartName' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroMaterialControllerComponent.AddEffect
// 0x0020 (0x0020 - 0x0000)
struct KuroMaterialControllerComponent_AddEffect final
{
public:
	class UKuroMaterialControllerDataAsset*       DataAsset;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLoop;                                             // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPause;                                            // 0x0009(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x6];                                        // 0x000A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class USkeletalMeshComponent*                 AnimObject;                                        // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0018(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroMaterialControllerComponent_AddEffect) == 0x000008, "Wrong alignment on KuroMaterialControllerComponent_AddEffect");
static_assert(sizeof(KuroMaterialControllerComponent_AddEffect) == 0x000020, "Wrong size on KuroMaterialControllerComponent_AddEffect");
static_assert(offsetof(KuroMaterialControllerComponent_AddEffect, DataAsset) == 0x000000, "Member 'KuroMaterialControllerComponent_AddEffect::DataAsset' has a wrong offset!");
static_assert(offsetof(KuroMaterialControllerComponent_AddEffect, bLoop) == 0x000008, "Member 'KuroMaterialControllerComponent_AddEffect::bLoop' has a wrong offset!");
static_assert(offsetof(KuroMaterialControllerComponent_AddEffect, bPause) == 0x000009, "Member 'KuroMaterialControllerComponent_AddEffect::bPause' has a wrong offset!");
static_assert(offsetof(KuroMaterialControllerComponent_AddEffect, AnimObject) == 0x000010, "Member 'KuroMaterialControllerComponent_AddEffect::AnimObject' has a wrong offset!");
static_assert(offsetof(KuroMaterialControllerComponent_AddEffect, ReturnValue) == 0x000018, "Member 'KuroMaterialControllerComponent_AddEffect::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroMaterialControllerComponent.AddEffect_Ex
// 0x0020 (0x0020 - 0x0000)
struct KuroMaterialControllerComponent_AddEffect_Ex final
{
public:
	class UKuroMaterialControllerDataAsset*       DataAsset;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLoop;                                             // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPause;                                            // 0x0009(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x6];                                        // 0x000A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class USkeletalMeshComponent*                 AnimObject;                                        // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHiddenOnRemove;                                   // 0x0018(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x3];                                       // 0x0019(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ReturnValue;                                       // 0x001C(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroMaterialControllerComponent_AddEffect_Ex) == 0x000008, "Wrong alignment on KuroMaterialControllerComponent_AddEffect_Ex");
static_assert(sizeof(KuroMaterialControllerComponent_AddEffect_Ex) == 0x000020, "Wrong size on KuroMaterialControllerComponent_AddEffect_Ex");
static_assert(offsetof(KuroMaterialControllerComponent_AddEffect_Ex, DataAsset) == 0x000000, "Member 'KuroMaterialControllerComponent_AddEffect_Ex::DataAsset' has a wrong offset!");
static_assert(offsetof(KuroMaterialControllerComponent_AddEffect_Ex, bLoop) == 0x000008, "Member 'KuroMaterialControllerComponent_AddEffect_Ex::bLoop' has a wrong offset!");
static_assert(offsetof(KuroMaterialControllerComponent_AddEffect_Ex, bPause) == 0x000009, "Member 'KuroMaterialControllerComponent_AddEffect_Ex::bPause' has a wrong offset!");
static_assert(offsetof(KuroMaterialControllerComponent_AddEffect_Ex, AnimObject) == 0x000010, "Member 'KuroMaterialControllerComponent_AddEffect_Ex::AnimObject' has a wrong offset!");
static_assert(offsetof(KuroMaterialControllerComponent_AddEffect_Ex, bHiddenOnRemove) == 0x000018, "Member 'KuroMaterialControllerComponent_AddEffect_Ex::bHiddenOnRemove' has a wrong offset!");
static_assert(offsetof(KuroMaterialControllerComponent_AddEffect_Ex, ReturnValue) == 0x00001C, "Member 'KuroMaterialControllerComponent_AddEffect_Ex::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroMaterialControllerComponent.AddEffectRaw
// 0x0020 (0x0020 - 0x0000)
struct KuroMaterialControllerComponent_AddEffectRaw final
{
public:
	class UKuroMaterialContainerDataCache*        DataCache;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLoop;                                             // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPause;                                            // 0x0009(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x6];                                        // 0x000A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class USkeletalMeshComponent*                 AnimObject;                                        // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHiddenOnRemove;                                   // 0x0018(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x3];                                       // 0x0019(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ReturnValue;                                       // 0x001C(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroMaterialControllerComponent_AddEffectRaw) == 0x000008, "Wrong alignment on KuroMaterialControllerComponent_AddEffectRaw");
static_assert(sizeof(KuroMaterialControllerComponent_AddEffectRaw) == 0x000020, "Wrong size on KuroMaterialControllerComponent_AddEffectRaw");
static_assert(offsetof(KuroMaterialControllerComponent_AddEffectRaw, DataCache) == 0x000000, "Member 'KuroMaterialControllerComponent_AddEffectRaw::DataCache' has a wrong offset!");
static_assert(offsetof(KuroMaterialControllerComponent_AddEffectRaw, bLoop) == 0x000008, "Member 'KuroMaterialControllerComponent_AddEffectRaw::bLoop' has a wrong offset!");
static_assert(offsetof(KuroMaterialControllerComponent_AddEffectRaw, bPause) == 0x000009, "Member 'KuroMaterialControllerComponent_AddEffectRaw::bPause' has a wrong offset!");
static_assert(offsetof(KuroMaterialControllerComponent_AddEffectRaw, AnimObject) == 0x000010, "Member 'KuroMaterialControllerComponent_AddEffectRaw::AnimObject' has a wrong offset!");
static_assert(offsetof(KuroMaterialControllerComponent_AddEffectRaw, bHiddenOnRemove) == 0x000018, "Member 'KuroMaterialControllerComponent_AddEffectRaw::bHiddenOnRemove' has a wrong offset!");
static_assert(offsetof(KuroMaterialControllerComponent_AddEffectRaw, ReturnValue) == 0x00001C, "Member 'KuroMaterialControllerComponent_AddEffectRaw::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroMaterialControllerComponent.AddExternalAlphaTestRefCount
// 0x0001 (0x0001 - 0x0000)
struct KuroMaterialControllerComponent_AddExternalAlphaTestRefCount final
{
public:
	EKuroCharBodySpecifiedType                    BodyType;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroMaterialControllerComponent_AddExternalAlphaTestRefCount) == 0x000001, "Wrong alignment on KuroMaterialControllerComponent_AddExternalAlphaTestRefCount");
static_assert(sizeof(KuroMaterialControllerComponent_AddExternalAlphaTestRefCount) == 0x000001, "Wrong size on KuroMaterialControllerComponent_AddExternalAlphaTestRefCount");
static_assert(offsetof(KuroMaterialControllerComponent_AddExternalAlphaTestRefCount, BodyType) == 0x000000, "Member 'KuroMaterialControllerComponent_AddExternalAlphaTestRefCount::BodyType' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroMaterialControllerComponent.AddExternalBattleMaskRefCount
// 0x0001 (0x0001 - 0x0000)
struct KuroMaterialControllerComponent_AddExternalBattleMaskRefCount final
{
public:
	EKuroCharBodySpecifiedType                    BodyType;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroMaterialControllerComponent_AddExternalBattleMaskRefCount) == 0x000001, "Wrong alignment on KuroMaterialControllerComponent_AddExternalBattleMaskRefCount");
static_assert(sizeof(KuroMaterialControllerComponent_AddExternalBattleMaskRefCount) == 0x000001, "Wrong size on KuroMaterialControllerComponent_AddExternalBattleMaskRefCount");
static_assert(offsetof(KuroMaterialControllerComponent_AddExternalBattleMaskRefCount, BodyType) == 0x000000, "Member 'KuroMaterialControllerComponent_AddExternalBattleMaskRefCount::BodyType' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroMaterialControllerComponent.AddExternalBattleRefCount
// 0x0001 (0x0001 - 0x0000)
struct KuroMaterialControllerComponent_AddExternalBattleRefCount final
{
public:
	EKuroCharBodySpecifiedType                    BodyType;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroMaterialControllerComponent_AddExternalBattleRefCount) == 0x000001, "Wrong alignment on KuroMaterialControllerComponent_AddExternalBattleRefCount");
static_assert(sizeof(KuroMaterialControllerComponent_AddExternalBattleRefCount) == 0x000001, "Wrong size on KuroMaterialControllerComponent_AddExternalBattleRefCount");
static_assert(offsetof(KuroMaterialControllerComponent_AddExternalBattleRefCount, BodyType) == 0x000000, "Member 'KuroMaterialControllerComponent_AddExternalBattleRefCount::BodyType' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroMaterialControllerComponent.AddExternalOutlineStencilTestRefCount
// 0x0001 (0x0001 - 0x0000)
struct KuroMaterialControllerComponent_AddExternalOutlineStencilTestRefCount final
{
public:
	EKuroCharBodySpecifiedType                    BodyType;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroMaterialControllerComponent_AddExternalOutlineStencilTestRefCount) == 0x000001, "Wrong alignment on KuroMaterialControllerComponent_AddExternalOutlineStencilTestRefCount");
static_assert(sizeof(KuroMaterialControllerComponent_AddExternalOutlineStencilTestRefCount) == 0x000001, "Wrong size on KuroMaterialControllerComponent_AddExternalOutlineStencilTestRefCount");
static_assert(offsetof(KuroMaterialControllerComponent_AddExternalOutlineStencilTestRefCount, BodyType) == 0x000000, "Member 'KuroMaterialControllerComponent_AddExternalOutlineStencilTestRefCount::BodyType' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroMaterialControllerComponent.AddFloatUpdateParamPermanent
// 0x0014 (0x0014 - 0x0000)
struct KuroMaterialControllerComponent_AddFloatUpdateParamPermanent final
{
public:
	class FName                                   Name_0;                                            // 0x0000(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Value;                                             // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EKuroCharBodySpecifiedType                    BodyType;                                          // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EKuroCharSlotSpecifiedType                    SlotType;                                          // 0x0011(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EKuroCharMeshPart                             MeshPart;                                          // 0x0012(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_13[0x1];                                       // 0x0013(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroMaterialControllerComponent_AddFloatUpdateParamPermanent) == 0x000004, "Wrong alignment on KuroMaterialControllerComponent_AddFloatUpdateParamPermanent");
static_assert(sizeof(KuroMaterialControllerComponent_AddFloatUpdateParamPermanent) == 0x000014, "Wrong size on KuroMaterialControllerComponent_AddFloatUpdateParamPermanent");
static_assert(offsetof(KuroMaterialControllerComponent_AddFloatUpdateParamPermanent, Name_0) == 0x000000, "Member 'KuroMaterialControllerComponent_AddFloatUpdateParamPermanent::Name_0' has a wrong offset!");
static_assert(offsetof(KuroMaterialControllerComponent_AddFloatUpdateParamPermanent, Value) == 0x00000C, "Member 'KuroMaterialControllerComponent_AddFloatUpdateParamPermanent::Value' has a wrong offset!");
static_assert(offsetof(KuroMaterialControllerComponent_AddFloatUpdateParamPermanent, BodyType) == 0x000010, "Member 'KuroMaterialControllerComponent_AddFloatUpdateParamPermanent::BodyType' has a wrong offset!");
static_assert(offsetof(KuroMaterialControllerComponent_AddFloatUpdateParamPermanent, SlotType) == 0x000011, "Member 'KuroMaterialControllerComponent_AddFloatUpdateParamPermanent::SlotType' has a wrong offset!");
static_assert(offsetof(KuroMaterialControllerComponent_AddFloatUpdateParamPermanent, MeshPart) == 0x000012, "Member 'KuroMaterialControllerComponent_AddFloatUpdateParamPermanent::MeshPart' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroMaterialControllerComponent.AddFloatUpdateParamPermanentByIndex
// 0x0020 (0x0020 - 0x0000)
struct KuroMaterialControllerComponent_AddFloatUpdateParamPermanentByIndex final
{
public:
	class FName                                   Name_0;                                            // 0x0000(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Value;                                             // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BodyName;                                          // 0x0010(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaterialIndex;                                     // 0x001C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroMaterialControllerComponent_AddFloatUpdateParamPermanentByIndex) == 0x000004, "Wrong alignment on KuroMaterialControllerComponent_AddFloatUpdateParamPermanentByIndex");
static_assert(sizeof(KuroMaterialControllerComponent_AddFloatUpdateParamPermanentByIndex) == 0x000020, "Wrong size on KuroMaterialControllerComponent_AddFloatUpdateParamPermanentByIndex");
static_assert(offsetof(KuroMaterialControllerComponent_AddFloatUpdateParamPermanentByIndex, Name_0) == 0x000000, "Member 'KuroMaterialControllerComponent_AddFloatUpdateParamPermanentByIndex::Name_0' has a wrong offset!");
static_assert(offsetof(KuroMaterialControllerComponent_AddFloatUpdateParamPermanentByIndex, Value) == 0x00000C, "Member 'KuroMaterialControllerComponent_AddFloatUpdateParamPermanentByIndex::Value' has a wrong offset!");
static_assert(offsetof(KuroMaterialControllerComponent_AddFloatUpdateParamPermanentByIndex, BodyName) == 0x000010, "Member 'KuroMaterialControllerComponent_AddFloatUpdateParamPermanentByIndex::BodyName' has a wrong offset!");
static_assert(offsetof(KuroMaterialControllerComponent_AddFloatUpdateParamPermanentByIndex, MaterialIndex) == 0x00001C, "Member 'KuroMaterialControllerComponent_AddFloatUpdateParamPermanentByIndex::MaterialIndex' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroMaterialControllerComponent.AddFloatUpdateParamPermanentCommon
// 0x0014 (0x0014 - 0x0000)
struct KuroMaterialControllerComponent_AddFloatUpdateParamPermanentCommon final
{
public:
	class FName                                   Name_0;                                            // 0x0000(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Value;                                             // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EKuroCharBodySpecifiedType                    BodyType;                                          // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EKuroCharSlotSpecifiedType                    SlotType;                                          // 0x0011(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12[0x2];                                       // 0x0012(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroMaterialControllerComponent_AddFloatUpdateParamPermanentCommon) == 0x000004, "Wrong alignment on KuroMaterialControllerComponent_AddFloatUpdateParamPermanentCommon");
static_assert(sizeof(KuroMaterialControllerComponent_AddFloatUpdateParamPermanentCommon) == 0x000014, "Wrong size on KuroMaterialControllerComponent_AddFloatUpdateParamPermanentCommon");
static_assert(offsetof(KuroMaterialControllerComponent_AddFloatUpdateParamPermanentCommon, Name_0) == 0x000000, "Member 'KuroMaterialControllerComponent_AddFloatUpdateParamPermanentCommon::Name_0' has a wrong offset!");
static_assert(offsetof(KuroMaterialControllerComponent_AddFloatUpdateParamPermanentCommon, Value) == 0x00000C, "Member 'KuroMaterialControllerComponent_AddFloatUpdateParamPermanentCommon::Value' has a wrong offset!");
static_assert(offsetof(KuroMaterialControllerComponent_AddFloatUpdateParamPermanentCommon, BodyType) == 0x000010, "Member 'KuroMaterialControllerComponent_AddFloatUpdateParamPermanentCommon::BodyType' has a wrong offset!");
static_assert(offsetof(KuroMaterialControllerComponent_AddFloatUpdateParamPermanentCommon, SlotType) == 0x000011, "Member 'KuroMaterialControllerComponent_AddFloatUpdateParamPermanentCommon::SlotType' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroMaterialControllerComponent.AddFloatUpdateParamPermanentCustom
// 0x0030 (0x0030 - 0x0000)
struct KuroMaterialControllerComponent_AddFloatUpdateParamPermanentCustom final
{
public:
	class FName                                   Name_0;                                            // 0x0000(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Value;                                             // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BodyName;                                          // 0x0010(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EKuroCharSlotSpecifiedType                    SlotType;                                          // 0x001C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 CustomPartName;                                    // 0x0020(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroMaterialControllerComponent_AddFloatUpdateParamPermanentCustom) == 0x000008, "Wrong alignment on KuroMaterialControllerComponent_AddFloatUpdateParamPermanentCustom");
static_assert(sizeof(KuroMaterialControllerComponent_AddFloatUpdateParamPermanentCustom) == 0x000030, "Wrong size on KuroMaterialControllerComponent_AddFloatUpdateParamPermanentCustom");
static_assert(offsetof(KuroMaterialControllerComponent_AddFloatUpdateParamPermanentCustom, Name_0) == 0x000000, "Member 'KuroMaterialControllerComponent_AddFloatUpdateParamPermanentCustom::Name_0' has a wrong offset!");
static_assert(offsetof(KuroMaterialControllerComponent_AddFloatUpdateParamPermanentCustom, Value) == 0x00000C, "Member 'KuroMaterialControllerComponent_AddFloatUpdateParamPermanentCustom::Value' has a wrong offset!");
static_assert(offsetof(KuroMaterialControllerComponent_AddFloatUpdateParamPermanentCustom, BodyName) == 0x000010, "Member 'KuroMaterialControllerComponent_AddFloatUpdateParamPermanentCustom::BodyName' has a wrong offset!");
static_assert(offsetof(KuroMaterialControllerComponent_AddFloatUpdateParamPermanentCustom, SlotType) == 0x00001C, "Member 'KuroMaterialControllerComponent_AddFloatUpdateParamPermanentCustom::SlotType' has a wrong offset!");
static_assert(offsetof(KuroMaterialControllerComponent_AddFloatUpdateParamPermanentCustom, CustomPartName) == 0x000020, "Member 'KuroMaterialControllerComponent_AddFloatUpdateParamPermanentCustom::CustomPartName' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroMaterialControllerComponent.AddSkeletalMeshComponent
// 0x0018 (0x0018 - 0x0000)
struct KuroMaterialControllerComponent_AddSkeletalMeshComponent final
{
public:
	class USkeletalMeshComponent*                 SkeletalMeshComponent;                             // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BodyName;                                          // 0x0008(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseEmptyMaterial;                                 // 0x0014(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroMaterialControllerComponent_AddSkeletalMeshComponent) == 0x000008, "Wrong alignment on KuroMaterialControllerComponent_AddSkeletalMeshComponent");
static_assert(sizeof(KuroMaterialControllerComponent_AddSkeletalMeshComponent) == 0x000018, "Wrong size on KuroMaterialControllerComponent_AddSkeletalMeshComponent");
static_assert(offsetof(KuroMaterialControllerComponent_AddSkeletalMeshComponent, SkeletalMeshComponent) == 0x000000, "Member 'KuroMaterialControllerComponent_AddSkeletalMeshComponent::SkeletalMeshComponent' has a wrong offset!");
static_assert(offsetof(KuroMaterialControllerComponent_AddSkeletalMeshComponent, BodyName) == 0x000008, "Member 'KuroMaterialControllerComponent_AddSkeletalMeshComponent::BodyName' has a wrong offset!");
static_assert(offsetof(KuroMaterialControllerComponent_AddSkeletalMeshComponent, bUseEmptyMaterial) == 0x000014, "Member 'KuroMaterialControllerComponent_AddSkeletalMeshComponent::bUseEmptyMaterial' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroMaterialControllerComponent.AddTextureUpdateParamPermanent
// 0x0020 (0x0020 - 0x0000)
struct KuroMaterialControllerComponent_AddTextureUpdateParamPermanent final
{
public:
	class FName                                   Name_0;                                            // 0x0000(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UTexture*                               Value;                                             // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EKuroCharBodySpecifiedType                    BodyType;                                          // 0x0018(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EKuroCharSlotSpecifiedType                    SlotType;                                          // 0x0019(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EKuroCharMeshPart                             MeshPart;                                          // 0x001A(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1B[0x5];                                       // 0x001B(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroMaterialControllerComponent_AddTextureUpdateParamPermanent) == 0x000008, "Wrong alignment on KuroMaterialControllerComponent_AddTextureUpdateParamPermanent");
static_assert(sizeof(KuroMaterialControllerComponent_AddTextureUpdateParamPermanent) == 0x000020, "Wrong size on KuroMaterialControllerComponent_AddTextureUpdateParamPermanent");
static_assert(offsetof(KuroMaterialControllerComponent_AddTextureUpdateParamPermanent, Name_0) == 0x000000, "Member 'KuroMaterialControllerComponent_AddTextureUpdateParamPermanent::Name_0' has a wrong offset!");
static_assert(offsetof(KuroMaterialControllerComponent_AddTextureUpdateParamPermanent, Value) == 0x000010, "Member 'KuroMaterialControllerComponent_AddTextureUpdateParamPermanent::Value' has a wrong offset!");
static_assert(offsetof(KuroMaterialControllerComponent_AddTextureUpdateParamPermanent, BodyType) == 0x000018, "Member 'KuroMaterialControllerComponent_AddTextureUpdateParamPermanent::BodyType' has a wrong offset!");
static_assert(offsetof(KuroMaterialControllerComponent_AddTextureUpdateParamPermanent, SlotType) == 0x000019, "Member 'KuroMaterialControllerComponent_AddTextureUpdateParamPermanent::SlotType' has a wrong offset!");
static_assert(offsetof(KuroMaterialControllerComponent_AddTextureUpdateParamPermanent, MeshPart) == 0x00001A, "Member 'KuroMaterialControllerComponent_AddTextureUpdateParamPermanent::MeshPart' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroMaterialControllerComponent.AddTextureUpdateParamPermanentByIndex
// 0x0028 (0x0028 - 0x0000)
struct KuroMaterialControllerComponent_AddTextureUpdateParamPermanentByIndex final
{
public:
	class FName                                   Name_0;                                            // 0x0000(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UTexture*                               Value;                                             // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BodyName;                                          // 0x0018(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaterialIndex;                                     // 0x0024(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroMaterialControllerComponent_AddTextureUpdateParamPermanentByIndex) == 0x000008, "Wrong alignment on KuroMaterialControllerComponent_AddTextureUpdateParamPermanentByIndex");
static_assert(sizeof(KuroMaterialControllerComponent_AddTextureUpdateParamPermanentByIndex) == 0x000028, "Wrong size on KuroMaterialControllerComponent_AddTextureUpdateParamPermanentByIndex");
static_assert(offsetof(KuroMaterialControllerComponent_AddTextureUpdateParamPermanentByIndex, Name_0) == 0x000000, "Member 'KuroMaterialControllerComponent_AddTextureUpdateParamPermanentByIndex::Name_0' has a wrong offset!");
static_assert(offsetof(KuroMaterialControllerComponent_AddTextureUpdateParamPermanentByIndex, Value) == 0x000010, "Member 'KuroMaterialControllerComponent_AddTextureUpdateParamPermanentByIndex::Value' has a wrong offset!");
static_assert(offsetof(KuroMaterialControllerComponent_AddTextureUpdateParamPermanentByIndex, BodyName) == 0x000018, "Member 'KuroMaterialControllerComponent_AddTextureUpdateParamPermanentByIndex::BodyName' has a wrong offset!");
static_assert(offsetof(KuroMaterialControllerComponent_AddTextureUpdateParamPermanentByIndex, MaterialIndex) == 0x000024, "Member 'KuroMaterialControllerComponent_AddTextureUpdateParamPermanentByIndex::MaterialIndex' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroMaterialControllerComponent.AddTextureUpdateParamPermanentCommon
// 0x0020 (0x0020 - 0x0000)
struct KuroMaterialControllerComponent_AddTextureUpdateParamPermanentCommon final
{
public:
	class FName                                   Name_0;                                            // 0x0000(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UTexture*                               Value;                                             // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EKuroCharBodySpecifiedType                    BodyType;                                          // 0x0018(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EKuroCharSlotSpecifiedType                    SlotType;                                          // 0x0019(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A[0x6];                                       // 0x001A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroMaterialControllerComponent_AddTextureUpdateParamPermanentCommon) == 0x000008, "Wrong alignment on KuroMaterialControllerComponent_AddTextureUpdateParamPermanentCommon");
static_assert(sizeof(KuroMaterialControllerComponent_AddTextureUpdateParamPermanentCommon) == 0x000020, "Wrong size on KuroMaterialControllerComponent_AddTextureUpdateParamPermanentCommon");
static_assert(offsetof(KuroMaterialControllerComponent_AddTextureUpdateParamPermanentCommon, Name_0) == 0x000000, "Member 'KuroMaterialControllerComponent_AddTextureUpdateParamPermanentCommon::Name_0' has a wrong offset!");
static_assert(offsetof(KuroMaterialControllerComponent_AddTextureUpdateParamPermanentCommon, Value) == 0x000010, "Member 'KuroMaterialControllerComponent_AddTextureUpdateParamPermanentCommon::Value' has a wrong offset!");
static_assert(offsetof(KuroMaterialControllerComponent_AddTextureUpdateParamPermanentCommon, BodyType) == 0x000018, "Member 'KuroMaterialControllerComponent_AddTextureUpdateParamPermanentCommon::BodyType' has a wrong offset!");
static_assert(offsetof(KuroMaterialControllerComponent_AddTextureUpdateParamPermanentCommon, SlotType) == 0x000019, "Member 'KuroMaterialControllerComponent_AddTextureUpdateParamPermanentCommon::SlotType' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroMaterialControllerComponent.AddTextureUpdateParamPermanentCustom
// 0x0038 (0x0038 - 0x0000)
struct KuroMaterialControllerComponent_AddTextureUpdateParamPermanentCustom final
{
public:
	class FName                                   Name_0;                                            // 0x0000(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UTexture*                               Value;                                             // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BodyName;                                          // 0x0018(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EKuroCharSlotSpecifiedType                    SlotType;                                          // 0x0024(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_25[0x3];                                       // 0x0025(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 CustomPartName;                                    // 0x0028(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroMaterialControllerComponent_AddTextureUpdateParamPermanentCustom) == 0x000008, "Wrong alignment on KuroMaterialControllerComponent_AddTextureUpdateParamPermanentCustom");
static_assert(sizeof(KuroMaterialControllerComponent_AddTextureUpdateParamPermanentCustom) == 0x000038, "Wrong size on KuroMaterialControllerComponent_AddTextureUpdateParamPermanentCustom");
static_assert(offsetof(KuroMaterialControllerComponent_AddTextureUpdateParamPermanentCustom, Name_0) == 0x000000, "Member 'KuroMaterialControllerComponent_AddTextureUpdateParamPermanentCustom::Name_0' has a wrong offset!");
static_assert(offsetof(KuroMaterialControllerComponent_AddTextureUpdateParamPermanentCustom, Value) == 0x000010, "Member 'KuroMaterialControllerComponent_AddTextureUpdateParamPermanentCustom::Value' has a wrong offset!");
static_assert(offsetof(KuroMaterialControllerComponent_AddTextureUpdateParamPermanentCustom, BodyName) == 0x000018, "Member 'KuroMaterialControllerComponent_AddTextureUpdateParamPermanentCustom::BodyName' has a wrong offset!");
static_assert(offsetof(KuroMaterialControllerComponent_AddTextureUpdateParamPermanentCustom, SlotType) == 0x000024, "Member 'KuroMaterialControllerComponent_AddTextureUpdateParamPermanentCustom::SlotType' has a wrong offset!");
static_assert(offsetof(KuroMaterialControllerComponent_AddTextureUpdateParamPermanentCustom, CustomPartName) == 0x000028, "Member 'KuroMaterialControllerComponent_AddTextureUpdateParamPermanentCustom::CustomPartName' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroMaterialControllerComponent.GetEffectKey
// 0x0010 (0x0010 - 0x0000)
struct KuroMaterialControllerComponent_GetEffectKey final
{
public:
	class FName                                   KeyName;                                           // 0x0000(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x000C(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroMaterialControllerComponent_GetEffectKey) == 0x000004, "Wrong alignment on KuroMaterialControllerComponent_GetEffectKey");
static_assert(sizeof(KuroMaterialControllerComponent_GetEffectKey) == 0x000010, "Wrong size on KuroMaterialControllerComponent_GetEffectKey");
static_assert(offsetof(KuroMaterialControllerComponent_GetEffectKey, KeyName) == 0x000000, "Member 'KuroMaterialControllerComponent_GetEffectKey::KeyName' has a wrong offset!");
static_assert(offsetof(KuroMaterialControllerComponent_GetEffectKey, ReturnValue) == 0x00000C, "Member 'KuroMaterialControllerComponent_GetEffectKey::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroMaterialControllerComponent.ManualTick
// 0x0008 (0x0008 - 0x0000)
struct KuroMaterialControllerComponent_ManualTick final
{
public:
	float                                         DeltaSeconds;                                      // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIncludePaused;                                    // 0x0004(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIncludeNewEffects;                                // 0x0005(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6[0x2];                                        // 0x0006(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroMaterialControllerComponent_ManualTick) == 0x000004, "Wrong alignment on KuroMaterialControllerComponent_ManualTick");
static_assert(sizeof(KuroMaterialControllerComponent_ManualTick) == 0x000008, "Wrong size on KuroMaterialControllerComponent_ManualTick");
static_assert(offsetof(KuroMaterialControllerComponent_ManualTick, DeltaSeconds) == 0x000000, "Member 'KuroMaterialControllerComponent_ManualTick::DeltaSeconds' has a wrong offset!");
static_assert(offsetof(KuroMaterialControllerComponent_ManualTick, bIncludePaused) == 0x000004, "Member 'KuroMaterialControllerComponent_ManualTick::bIncludePaused' has a wrong offset!");
static_assert(offsetof(KuroMaterialControllerComponent_ManualTick, bIncludeNewEffects) == 0x000005, "Member 'KuroMaterialControllerComponent_ManualTick::bIncludeNewEffects' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroMaterialControllerComponent.RefreshFilter
// 0x0004 (0x0004 - 0x0000)
struct KuroMaterialControllerComponent_RefreshFilter final
{
public:
	int32                                         HandleId;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroMaterialControllerComponent_RefreshFilter) == 0x000004, "Wrong alignment on KuroMaterialControllerComponent_RefreshFilter");
static_assert(sizeof(KuroMaterialControllerComponent_RefreshFilter) == 0x000004, "Wrong size on KuroMaterialControllerComponent_RefreshFilter");
static_assert(offsetof(KuroMaterialControllerComponent_RefreshFilter, HandleId) == 0x000000, "Member 'KuroMaterialControllerComponent_RefreshFilter::HandleId' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroMaterialControllerComponent.RegisterEffectKey
// 0x0010 (0x0010 - 0x0000)
struct KuroMaterialControllerComponent_RegisterEffectKey final
{
public:
	class FName                                   KeyName;                                           // 0x0000(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         HandleId;                                          // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroMaterialControllerComponent_RegisterEffectKey) == 0x000004, "Wrong alignment on KuroMaterialControllerComponent_RegisterEffectKey");
static_assert(sizeof(KuroMaterialControllerComponent_RegisterEffectKey) == 0x000010, "Wrong size on KuroMaterialControllerComponent_RegisterEffectKey");
static_assert(offsetof(KuroMaterialControllerComponent_RegisterEffectKey, KeyName) == 0x000000, "Member 'KuroMaterialControllerComponent_RegisterEffectKey::KeyName' has a wrong offset!");
static_assert(offsetof(KuroMaterialControllerComponent_RegisterEffectKey, HandleId) == 0x00000C, "Member 'KuroMaterialControllerComponent_RegisterEffectKey::HandleId' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroMaterialControllerComponent.RemoveColorUpdateParamPermanent
// 0x0010 (0x0010 - 0x0000)
struct KuroMaterialControllerComponent_RemoveColorUpdateParamPermanent final
{
public:
	class FName                                   Name_0;                                            // 0x0000(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EKuroCharBodySpecifiedType                    BodyType;                                          // 0x000C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EKuroCharSlotSpecifiedType                    SlotType;                                          // 0x000D(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EKuroCharMeshPart                             MeshPart;                                          // 0x000E(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F[0x1];                                        // 0x000F(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroMaterialControllerComponent_RemoveColorUpdateParamPermanent) == 0x000004, "Wrong alignment on KuroMaterialControllerComponent_RemoveColorUpdateParamPermanent");
static_assert(sizeof(KuroMaterialControllerComponent_RemoveColorUpdateParamPermanent) == 0x000010, "Wrong size on KuroMaterialControllerComponent_RemoveColorUpdateParamPermanent");
static_assert(offsetof(KuroMaterialControllerComponent_RemoveColorUpdateParamPermanent, Name_0) == 0x000000, "Member 'KuroMaterialControllerComponent_RemoveColorUpdateParamPermanent::Name_0' has a wrong offset!");
static_assert(offsetof(KuroMaterialControllerComponent_RemoveColorUpdateParamPermanent, BodyType) == 0x00000C, "Member 'KuroMaterialControllerComponent_RemoveColorUpdateParamPermanent::BodyType' has a wrong offset!");
static_assert(offsetof(KuroMaterialControllerComponent_RemoveColorUpdateParamPermanent, SlotType) == 0x00000D, "Member 'KuroMaterialControllerComponent_RemoveColorUpdateParamPermanent::SlotType' has a wrong offset!");
static_assert(offsetof(KuroMaterialControllerComponent_RemoveColorUpdateParamPermanent, MeshPart) == 0x00000E, "Member 'KuroMaterialControllerComponent_RemoveColorUpdateParamPermanent::MeshPart' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroMaterialControllerComponent.RemoveColorUpdateParamPermanentByIndex
// 0x001C (0x001C - 0x0000)
struct KuroMaterialControllerComponent_RemoveColorUpdateParamPermanentByIndex final
{
public:
	class FName                                   Name_0;                                            // 0x0000(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BodyName;                                          // 0x000C(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaterialIndex;                                     // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroMaterialControllerComponent_RemoveColorUpdateParamPermanentByIndex) == 0x000004, "Wrong alignment on KuroMaterialControllerComponent_RemoveColorUpdateParamPermanentByIndex");
static_assert(sizeof(KuroMaterialControllerComponent_RemoveColorUpdateParamPermanentByIndex) == 0x00001C, "Wrong size on KuroMaterialControllerComponent_RemoveColorUpdateParamPermanentByIndex");
static_assert(offsetof(KuroMaterialControllerComponent_RemoveColorUpdateParamPermanentByIndex, Name_0) == 0x000000, "Member 'KuroMaterialControllerComponent_RemoveColorUpdateParamPermanentByIndex::Name_0' has a wrong offset!");
static_assert(offsetof(KuroMaterialControllerComponent_RemoveColorUpdateParamPermanentByIndex, BodyName) == 0x00000C, "Member 'KuroMaterialControllerComponent_RemoveColorUpdateParamPermanentByIndex::BodyName' has a wrong offset!");
static_assert(offsetof(KuroMaterialControllerComponent_RemoveColorUpdateParamPermanentByIndex, MaterialIndex) == 0x000018, "Member 'KuroMaterialControllerComponent_RemoveColorUpdateParamPermanentByIndex::MaterialIndex' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroMaterialControllerComponent.RemoveColorUpdateParamPermanentCommon
// 0x0010 (0x0010 - 0x0000)
struct KuroMaterialControllerComponent_RemoveColorUpdateParamPermanentCommon final
{
public:
	class FName                                   Name_0;                                            // 0x0000(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EKuroCharBodySpecifiedType                    BodyType;                                          // 0x000C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EKuroCharSlotSpecifiedType                    SlotType;                                          // 0x000D(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E[0x2];                                        // 0x000E(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroMaterialControllerComponent_RemoveColorUpdateParamPermanentCommon) == 0x000004, "Wrong alignment on KuroMaterialControllerComponent_RemoveColorUpdateParamPermanentCommon");
static_assert(sizeof(KuroMaterialControllerComponent_RemoveColorUpdateParamPermanentCommon) == 0x000010, "Wrong size on KuroMaterialControllerComponent_RemoveColorUpdateParamPermanentCommon");
static_assert(offsetof(KuroMaterialControllerComponent_RemoveColorUpdateParamPermanentCommon, Name_0) == 0x000000, "Member 'KuroMaterialControllerComponent_RemoveColorUpdateParamPermanentCommon::Name_0' has a wrong offset!");
static_assert(offsetof(KuroMaterialControllerComponent_RemoveColorUpdateParamPermanentCommon, BodyType) == 0x00000C, "Member 'KuroMaterialControllerComponent_RemoveColorUpdateParamPermanentCommon::BodyType' has a wrong offset!");
static_assert(offsetof(KuroMaterialControllerComponent_RemoveColorUpdateParamPermanentCommon, SlotType) == 0x00000D, "Member 'KuroMaterialControllerComponent_RemoveColorUpdateParamPermanentCommon::SlotType' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroMaterialControllerComponent.RemoveColorUpdateParamPermanentCustom
// 0x0030 (0x0030 - 0x0000)
struct KuroMaterialControllerComponent_RemoveColorUpdateParamPermanentCustom final
{
public:
	class FName                                   Name_0;                                            // 0x0000(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BodyName;                                          // 0x000C(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EKuroCharSlotSpecifiedType                    SlotType;                                          // 0x0018(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 CustomPartName;                                    // 0x0020(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroMaterialControllerComponent_RemoveColorUpdateParamPermanentCustom) == 0x000008, "Wrong alignment on KuroMaterialControllerComponent_RemoveColorUpdateParamPermanentCustom");
static_assert(sizeof(KuroMaterialControllerComponent_RemoveColorUpdateParamPermanentCustom) == 0x000030, "Wrong size on KuroMaterialControllerComponent_RemoveColorUpdateParamPermanentCustom");
static_assert(offsetof(KuroMaterialControllerComponent_RemoveColorUpdateParamPermanentCustom, Name_0) == 0x000000, "Member 'KuroMaterialControllerComponent_RemoveColorUpdateParamPermanentCustom::Name_0' has a wrong offset!");
static_assert(offsetof(KuroMaterialControllerComponent_RemoveColorUpdateParamPermanentCustom, BodyName) == 0x00000C, "Member 'KuroMaterialControllerComponent_RemoveColorUpdateParamPermanentCustom::BodyName' has a wrong offset!");
static_assert(offsetof(KuroMaterialControllerComponent_RemoveColorUpdateParamPermanentCustom, SlotType) == 0x000018, "Member 'KuroMaterialControllerComponent_RemoveColorUpdateParamPermanentCustom::SlotType' has a wrong offset!");
static_assert(offsetof(KuroMaterialControllerComponent_RemoveColorUpdateParamPermanentCustom, CustomPartName) == 0x000020, "Member 'KuroMaterialControllerComponent_RemoveColorUpdateParamPermanentCustom::CustomPartName' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroMaterialControllerComponent.RemoveDeadEffects
// 0x0010 (0x0010 - 0x0000)
struct KuroMaterialControllerComponent_RemoveDeadEffects final
{
public:
	TArray<int32>                                 ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroMaterialControllerComponent_RemoveDeadEffects) == 0x000008, "Wrong alignment on KuroMaterialControllerComponent_RemoveDeadEffects");
static_assert(sizeof(KuroMaterialControllerComponent_RemoveDeadEffects) == 0x000010, "Wrong size on KuroMaterialControllerComponent_RemoveDeadEffects");
static_assert(offsetof(KuroMaterialControllerComponent_RemoveDeadEffects, ReturnValue) == 0x000000, "Member 'KuroMaterialControllerComponent_RemoveDeadEffects::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroMaterialControllerComponent.RemoveEffect
// 0x0004 (0x0004 - 0x0000)
struct KuroMaterialControllerComponent_RemoveEffect final
{
public:
	int32                                         HandleId;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroMaterialControllerComponent_RemoveEffect) == 0x000004, "Wrong alignment on KuroMaterialControllerComponent_RemoveEffect");
static_assert(sizeof(KuroMaterialControllerComponent_RemoveEffect) == 0x000004, "Wrong size on KuroMaterialControllerComponent_RemoveEffect");
static_assert(offsetof(KuroMaterialControllerComponent_RemoveEffect, HandleId) == 0x000000, "Member 'KuroMaterialControllerComponent_RemoveEffect::HandleId' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroMaterialControllerComponent.RemoveExternalAlphaTestRefCount
// 0x0001 (0x0001 - 0x0000)
struct KuroMaterialControllerComponent_RemoveExternalAlphaTestRefCount final
{
public:
	EKuroCharBodySpecifiedType                    BodyType;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroMaterialControllerComponent_RemoveExternalAlphaTestRefCount) == 0x000001, "Wrong alignment on KuroMaterialControllerComponent_RemoveExternalAlphaTestRefCount");
static_assert(sizeof(KuroMaterialControllerComponent_RemoveExternalAlphaTestRefCount) == 0x000001, "Wrong size on KuroMaterialControllerComponent_RemoveExternalAlphaTestRefCount");
static_assert(offsetof(KuroMaterialControllerComponent_RemoveExternalAlphaTestRefCount, BodyType) == 0x000000, "Member 'KuroMaterialControllerComponent_RemoveExternalAlphaTestRefCount::BodyType' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroMaterialControllerComponent.RemoveExternalBattleMaskRefCount
// 0x0001 (0x0001 - 0x0000)
struct KuroMaterialControllerComponent_RemoveExternalBattleMaskRefCount final
{
public:
	EKuroCharBodySpecifiedType                    BodyType;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroMaterialControllerComponent_RemoveExternalBattleMaskRefCount) == 0x000001, "Wrong alignment on KuroMaterialControllerComponent_RemoveExternalBattleMaskRefCount");
static_assert(sizeof(KuroMaterialControllerComponent_RemoveExternalBattleMaskRefCount) == 0x000001, "Wrong size on KuroMaterialControllerComponent_RemoveExternalBattleMaskRefCount");
static_assert(offsetof(KuroMaterialControllerComponent_RemoveExternalBattleMaskRefCount, BodyType) == 0x000000, "Member 'KuroMaterialControllerComponent_RemoveExternalBattleMaskRefCount::BodyType' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroMaterialControllerComponent.RemoveExternalBattleRefCount
// 0x0001 (0x0001 - 0x0000)
struct KuroMaterialControllerComponent_RemoveExternalBattleRefCount final
{
public:
	EKuroCharBodySpecifiedType                    BodyType;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroMaterialControllerComponent_RemoveExternalBattleRefCount) == 0x000001, "Wrong alignment on KuroMaterialControllerComponent_RemoveExternalBattleRefCount");
static_assert(sizeof(KuroMaterialControllerComponent_RemoveExternalBattleRefCount) == 0x000001, "Wrong size on KuroMaterialControllerComponent_RemoveExternalBattleRefCount");
static_assert(offsetof(KuroMaterialControllerComponent_RemoveExternalBattleRefCount, BodyType) == 0x000000, "Member 'KuroMaterialControllerComponent_RemoveExternalBattleRefCount::BodyType' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroMaterialControllerComponent.RemoveExternalMaterialReplace
// 0x0003 (0x0003 - 0x0000)
struct KuroMaterialControllerComponent_RemoveExternalMaterialReplace final
{
public:
	EKuroCharBodySpecifiedType                    BodyType;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EKuroCharSlotSpecifiedType                    SlotType;                                          // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EKuroCharMeshPart                             MeshPart;                                          // 0x0002(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroMaterialControllerComponent_RemoveExternalMaterialReplace) == 0x000001, "Wrong alignment on KuroMaterialControllerComponent_RemoveExternalMaterialReplace");
static_assert(sizeof(KuroMaterialControllerComponent_RemoveExternalMaterialReplace) == 0x000003, "Wrong size on KuroMaterialControllerComponent_RemoveExternalMaterialReplace");
static_assert(offsetof(KuroMaterialControllerComponent_RemoveExternalMaterialReplace, BodyType) == 0x000000, "Member 'KuroMaterialControllerComponent_RemoveExternalMaterialReplace::BodyType' has a wrong offset!");
static_assert(offsetof(KuroMaterialControllerComponent_RemoveExternalMaterialReplace, SlotType) == 0x000001, "Member 'KuroMaterialControllerComponent_RemoveExternalMaterialReplace::SlotType' has a wrong offset!");
static_assert(offsetof(KuroMaterialControllerComponent_RemoveExternalMaterialReplace, MeshPart) == 0x000002, "Member 'KuroMaterialControllerComponent_RemoveExternalMaterialReplace::MeshPart' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroMaterialControllerComponent.RemoveExternalMaterialReplaceByIndex
// 0x0010 (0x0010 - 0x0000)
struct KuroMaterialControllerComponent_RemoveExternalMaterialReplaceByIndex final
{
public:
	class FName                                   BodyName;                                          // 0x0000(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaterialIndex;                                     // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroMaterialControllerComponent_RemoveExternalMaterialReplaceByIndex) == 0x000004, "Wrong alignment on KuroMaterialControllerComponent_RemoveExternalMaterialReplaceByIndex");
static_assert(sizeof(KuroMaterialControllerComponent_RemoveExternalMaterialReplaceByIndex) == 0x000010, "Wrong size on KuroMaterialControllerComponent_RemoveExternalMaterialReplaceByIndex");
static_assert(offsetof(KuroMaterialControllerComponent_RemoveExternalMaterialReplaceByIndex, BodyName) == 0x000000, "Member 'KuroMaterialControllerComponent_RemoveExternalMaterialReplaceByIndex::BodyName' has a wrong offset!");
static_assert(offsetof(KuroMaterialControllerComponent_RemoveExternalMaterialReplaceByIndex, MaterialIndex) == 0x00000C, "Member 'KuroMaterialControllerComponent_RemoveExternalMaterialReplaceByIndex::MaterialIndex' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroMaterialControllerComponent.RemoveExternalMaterialReplaceCommon
// 0x0002 (0x0002 - 0x0000)
struct KuroMaterialControllerComponent_RemoveExternalMaterialReplaceCommon final
{
public:
	EKuroCharBodySpecifiedType                    BodyType;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EKuroCharSlotSpecifiedType                    SlotType;                                          // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroMaterialControllerComponent_RemoveExternalMaterialReplaceCommon) == 0x000001, "Wrong alignment on KuroMaterialControllerComponent_RemoveExternalMaterialReplaceCommon");
static_assert(sizeof(KuroMaterialControllerComponent_RemoveExternalMaterialReplaceCommon) == 0x000002, "Wrong size on KuroMaterialControllerComponent_RemoveExternalMaterialReplaceCommon");
static_assert(offsetof(KuroMaterialControllerComponent_RemoveExternalMaterialReplaceCommon, BodyType) == 0x000000, "Member 'KuroMaterialControllerComponent_RemoveExternalMaterialReplaceCommon::BodyType' has a wrong offset!");
static_assert(offsetof(KuroMaterialControllerComponent_RemoveExternalMaterialReplaceCommon, SlotType) == 0x000001, "Member 'KuroMaterialControllerComponent_RemoveExternalMaterialReplaceCommon::SlotType' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroMaterialControllerComponent.RemoveExternalMaterialReplaceCustom
// 0x0020 (0x0020 - 0x0000)
struct KuroMaterialControllerComponent_RemoveExternalMaterialReplaceCustom final
{
public:
	class FName                                   BodyName;                                          // 0x0000(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EKuroCharSlotSpecifiedType                    SlotType;                                          // 0x000C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 CustomPartName;                                    // 0x0010(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroMaterialControllerComponent_RemoveExternalMaterialReplaceCustom) == 0x000008, "Wrong alignment on KuroMaterialControllerComponent_RemoveExternalMaterialReplaceCustom");
static_assert(sizeof(KuroMaterialControllerComponent_RemoveExternalMaterialReplaceCustom) == 0x000020, "Wrong size on KuroMaterialControllerComponent_RemoveExternalMaterialReplaceCustom");
static_assert(offsetof(KuroMaterialControllerComponent_RemoveExternalMaterialReplaceCustom, BodyName) == 0x000000, "Member 'KuroMaterialControllerComponent_RemoveExternalMaterialReplaceCustom::BodyName' has a wrong offset!");
static_assert(offsetof(KuroMaterialControllerComponent_RemoveExternalMaterialReplaceCustom, SlotType) == 0x00000C, "Member 'KuroMaterialControllerComponent_RemoveExternalMaterialReplaceCustom::SlotType' has a wrong offset!");
static_assert(offsetof(KuroMaterialControllerComponent_RemoveExternalMaterialReplaceCustom, CustomPartName) == 0x000010, "Member 'KuroMaterialControllerComponent_RemoveExternalMaterialReplaceCustom::CustomPartName' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroMaterialControllerComponent.RemoveExternalOutlineStencilTestRefCount
// 0x0001 (0x0001 - 0x0000)
struct KuroMaterialControllerComponent_RemoveExternalOutlineStencilTestRefCount final
{
public:
	EKuroCharBodySpecifiedType                    BodyType;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroMaterialControllerComponent_RemoveExternalOutlineStencilTestRefCount) == 0x000001, "Wrong alignment on KuroMaterialControllerComponent_RemoveExternalOutlineStencilTestRefCount");
static_assert(sizeof(KuroMaterialControllerComponent_RemoveExternalOutlineStencilTestRefCount) == 0x000001, "Wrong size on KuroMaterialControllerComponent_RemoveExternalOutlineStencilTestRefCount");
static_assert(offsetof(KuroMaterialControllerComponent_RemoveExternalOutlineStencilTestRefCount, BodyType) == 0x000000, "Member 'KuroMaterialControllerComponent_RemoveExternalOutlineStencilTestRefCount::BodyType' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroMaterialControllerComponent.RemoveFloatUpdateParamPermanent
// 0x0010 (0x0010 - 0x0000)
struct KuroMaterialControllerComponent_RemoveFloatUpdateParamPermanent final
{
public:
	class FName                                   Name_0;                                            // 0x0000(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EKuroCharBodySpecifiedType                    BodyType;                                          // 0x000C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EKuroCharSlotSpecifiedType                    SlotType;                                          // 0x000D(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EKuroCharMeshPart                             MeshPart;                                          // 0x000E(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F[0x1];                                        // 0x000F(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroMaterialControllerComponent_RemoveFloatUpdateParamPermanent) == 0x000004, "Wrong alignment on KuroMaterialControllerComponent_RemoveFloatUpdateParamPermanent");
static_assert(sizeof(KuroMaterialControllerComponent_RemoveFloatUpdateParamPermanent) == 0x000010, "Wrong size on KuroMaterialControllerComponent_RemoveFloatUpdateParamPermanent");
static_assert(offsetof(KuroMaterialControllerComponent_RemoveFloatUpdateParamPermanent, Name_0) == 0x000000, "Member 'KuroMaterialControllerComponent_RemoveFloatUpdateParamPermanent::Name_0' has a wrong offset!");
static_assert(offsetof(KuroMaterialControllerComponent_RemoveFloatUpdateParamPermanent, BodyType) == 0x00000C, "Member 'KuroMaterialControllerComponent_RemoveFloatUpdateParamPermanent::BodyType' has a wrong offset!");
static_assert(offsetof(KuroMaterialControllerComponent_RemoveFloatUpdateParamPermanent, SlotType) == 0x00000D, "Member 'KuroMaterialControllerComponent_RemoveFloatUpdateParamPermanent::SlotType' has a wrong offset!");
static_assert(offsetof(KuroMaterialControllerComponent_RemoveFloatUpdateParamPermanent, MeshPart) == 0x00000E, "Member 'KuroMaterialControllerComponent_RemoveFloatUpdateParamPermanent::MeshPart' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroMaterialControllerComponent.RemoveFloatUpdateParamPermanentByIndex
// 0x001C (0x001C - 0x0000)
struct KuroMaterialControllerComponent_RemoveFloatUpdateParamPermanentByIndex final
{
public:
	class FName                                   Name_0;                                            // 0x0000(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BodyName;                                          // 0x000C(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaterialIndex;                                     // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroMaterialControllerComponent_RemoveFloatUpdateParamPermanentByIndex) == 0x000004, "Wrong alignment on KuroMaterialControllerComponent_RemoveFloatUpdateParamPermanentByIndex");
static_assert(sizeof(KuroMaterialControllerComponent_RemoveFloatUpdateParamPermanentByIndex) == 0x00001C, "Wrong size on KuroMaterialControllerComponent_RemoveFloatUpdateParamPermanentByIndex");
static_assert(offsetof(KuroMaterialControllerComponent_RemoveFloatUpdateParamPermanentByIndex, Name_0) == 0x000000, "Member 'KuroMaterialControllerComponent_RemoveFloatUpdateParamPermanentByIndex::Name_0' has a wrong offset!");
static_assert(offsetof(KuroMaterialControllerComponent_RemoveFloatUpdateParamPermanentByIndex, BodyName) == 0x00000C, "Member 'KuroMaterialControllerComponent_RemoveFloatUpdateParamPermanentByIndex::BodyName' has a wrong offset!");
static_assert(offsetof(KuroMaterialControllerComponent_RemoveFloatUpdateParamPermanentByIndex, MaterialIndex) == 0x000018, "Member 'KuroMaterialControllerComponent_RemoveFloatUpdateParamPermanentByIndex::MaterialIndex' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroMaterialControllerComponent.RemoveFloatUpdateParamPermanentCommon
// 0x0010 (0x0010 - 0x0000)
struct KuroMaterialControllerComponent_RemoveFloatUpdateParamPermanentCommon final
{
public:
	class FName                                   Name_0;                                            // 0x0000(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EKuroCharBodySpecifiedType                    BodyType;                                          // 0x000C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EKuroCharSlotSpecifiedType                    SlotType;                                          // 0x000D(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E[0x2];                                        // 0x000E(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroMaterialControllerComponent_RemoveFloatUpdateParamPermanentCommon) == 0x000004, "Wrong alignment on KuroMaterialControllerComponent_RemoveFloatUpdateParamPermanentCommon");
static_assert(sizeof(KuroMaterialControllerComponent_RemoveFloatUpdateParamPermanentCommon) == 0x000010, "Wrong size on KuroMaterialControllerComponent_RemoveFloatUpdateParamPermanentCommon");
static_assert(offsetof(KuroMaterialControllerComponent_RemoveFloatUpdateParamPermanentCommon, Name_0) == 0x000000, "Member 'KuroMaterialControllerComponent_RemoveFloatUpdateParamPermanentCommon::Name_0' has a wrong offset!");
static_assert(offsetof(KuroMaterialControllerComponent_RemoveFloatUpdateParamPermanentCommon, BodyType) == 0x00000C, "Member 'KuroMaterialControllerComponent_RemoveFloatUpdateParamPermanentCommon::BodyType' has a wrong offset!");
static_assert(offsetof(KuroMaterialControllerComponent_RemoveFloatUpdateParamPermanentCommon, SlotType) == 0x00000D, "Member 'KuroMaterialControllerComponent_RemoveFloatUpdateParamPermanentCommon::SlotType' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroMaterialControllerComponent.RemoveFloatUpdateParamPermanentCustom
// 0x0030 (0x0030 - 0x0000)
struct KuroMaterialControllerComponent_RemoveFloatUpdateParamPermanentCustom final
{
public:
	class FName                                   Name_0;                                            // 0x0000(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BodyName;                                          // 0x000C(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EKuroCharSlotSpecifiedType                    SlotType;                                          // 0x0018(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 CustomPartName;                                    // 0x0020(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroMaterialControllerComponent_RemoveFloatUpdateParamPermanentCustom) == 0x000008, "Wrong alignment on KuroMaterialControllerComponent_RemoveFloatUpdateParamPermanentCustom");
static_assert(sizeof(KuroMaterialControllerComponent_RemoveFloatUpdateParamPermanentCustom) == 0x000030, "Wrong size on KuroMaterialControllerComponent_RemoveFloatUpdateParamPermanentCustom");
static_assert(offsetof(KuroMaterialControllerComponent_RemoveFloatUpdateParamPermanentCustom, Name_0) == 0x000000, "Member 'KuroMaterialControllerComponent_RemoveFloatUpdateParamPermanentCustom::Name_0' has a wrong offset!");
static_assert(offsetof(KuroMaterialControllerComponent_RemoveFloatUpdateParamPermanentCustom, BodyName) == 0x00000C, "Member 'KuroMaterialControllerComponent_RemoveFloatUpdateParamPermanentCustom::BodyName' has a wrong offset!");
static_assert(offsetof(KuroMaterialControllerComponent_RemoveFloatUpdateParamPermanentCustom, SlotType) == 0x000018, "Member 'KuroMaterialControllerComponent_RemoveFloatUpdateParamPermanentCustom::SlotType' has a wrong offset!");
static_assert(offsetof(KuroMaterialControllerComponent_RemoveFloatUpdateParamPermanentCustom, CustomPartName) == 0x000020, "Member 'KuroMaterialControllerComponent_RemoveFloatUpdateParamPermanentCustom::CustomPartName' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroMaterialControllerComponent.RemoveSkeletalMeshComponent
// 0x000C (0x000C - 0x0000)
struct KuroMaterialControllerComponent_RemoveSkeletalMeshComponent final
{
public:
	class FName                                   BodyName;                                          // 0x0000(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroMaterialControllerComponent_RemoveSkeletalMeshComponent) == 0x000004, "Wrong alignment on KuroMaterialControllerComponent_RemoveSkeletalMeshComponent");
static_assert(sizeof(KuroMaterialControllerComponent_RemoveSkeletalMeshComponent) == 0x00000C, "Wrong size on KuroMaterialControllerComponent_RemoveSkeletalMeshComponent");
static_assert(offsetof(KuroMaterialControllerComponent_RemoveSkeletalMeshComponent, BodyName) == 0x000000, "Member 'KuroMaterialControllerComponent_RemoveSkeletalMeshComponent::BodyName' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroMaterialControllerComponent.RemoveTextureUpdateParamPermanent
// 0x0010 (0x0010 - 0x0000)
struct KuroMaterialControllerComponent_RemoveTextureUpdateParamPermanent final
{
public:
	class FName                                   Name_0;                                            // 0x0000(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EKuroCharBodySpecifiedType                    BodyType;                                          // 0x000C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EKuroCharSlotSpecifiedType                    SlotType;                                          // 0x000D(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EKuroCharMeshPart                             MeshPart;                                          // 0x000E(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F[0x1];                                        // 0x000F(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroMaterialControllerComponent_RemoveTextureUpdateParamPermanent) == 0x000004, "Wrong alignment on KuroMaterialControllerComponent_RemoveTextureUpdateParamPermanent");
static_assert(sizeof(KuroMaterialControllerComponent_RemoveTextureUpdateParamPermanent) == 0x000010, "Wrong size on KuroMaterialControllerComponent_RemoveTextureUpdateParamPermanent");
static_assert(offsetof(KuroMaterialControllerComponent_RemoveTextureUpdateParamPermanent, Name_0) == 0x000000, "Member 'KuroMaterialControllerComponent_RemoveTextureUpdateParamPermanent::Name_0' has a wrong offset!");
static_assert(offsetof(KuroMaterialControllerComponent_RemoveTextureUpdateParamPermanent, BodyType) == 0x00000C, "Member 'KuroMaterialControllerComponent_RemoveTextureUpdateParamPermanent::BodyType' has a wrong offset!");
static_assert(offsetof(KuroMaterialControllerComponent_RemoveTextureUpdateParamPermanent, SlotType) == 0x00000D, "Member 'KuroMaterialControllerComponent_RemoveTextureUpdateParamPermanent::SlotType' has a wrong offset!");
static_assert(offsetof(KuroMaterialControllerComponent_RemoveTextureUpdateParamPermanent, MeshPart) == 0x00000E, "Member 'KuroMaterialControllerComponent_RemoveTextureUpdateParamPermanent::MeshPart' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroMaterialControllerComponent.RemoveTextureUpdateParamPermanentByIndex
// 0x001C (0x001C - 0x0000)
struct KuroMaterialControllerComponent_RemoveTextureUpdateParamPermanentByIndex final
{
public:
	class FName                                   Name_0;                                            // 0x0000(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BodyName;                                          // 0x000C(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaterialIndex;                                     // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroMaterialControllerComponent_RemoveTextureUpdateParamPermanentByIndex) == 0x000004, "Wrong alignment on KuroMaterialControllerComponent_RemoveTextureUpdateParamPermanentByIndex");
static_assert(sizeof(KuroMaterialControllerComponent_RemoveTextureUpdateParamPermanentByIndex) == 0x00001C, "Wrong size on KuroMaterialControllerComponent_RemoveTextureUpdateParamPermanentByIndex");
static_assert(offsetof(KuroMaterialControllerComponent_RemoveTextureUpdateParamPermanentByIndex, Name_0) == 0x000000, "Member 'KuroMaterialControllerComponent_RemoveTextureUpdateParamPermanentByIndex::Name_0' has a wrong offset!");
static_assert(offsetof(KuroMaterialControllerComponent_RemoveTextureUpdateParamPermanentByIndex, BodyName) == 0x00000C, "Member 'KuroMaterialControllerComponent_RemoveTextureUpdateParamPermanentByIndex::BodyName' has a wrong offset!");
static_assert(offsetof(KuroMaterialControllerComponent_RemoveTextureUpdateParamPermanentByIndex, MaterialIndex) == 0x000018, "Member 'KuroMaterialControllerComponent_RemoveTextureUpdateParamPermanentByIndex::MaterialIndex' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroMaterialControllerComponent.RemoveTextureUpdateParamPermanentCommon
// 0x0010 (0x0010 - 0x0000)
struct KuroMaterialControllerComponent_RemoveTextureUpdateParamPermanentCommon final
{
public:
	class FName                                   Name_0;                                            // 0x0000(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EKuroCharBodySpecifiedType                    BodyType;                                          // 0x000C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EKuroCharSlotSpecifiedType                    SlotType;                                          // 0x000D(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E[0x2];                                        // 0x000E(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroMaterialControllerComponent_RemoveTextureUpdateParamPermanentCommon) == 0x000004, "Wrong alignment on KuroMaterialControllerComponent_RemoveTextureUpdateParamPermanentCommon");
static_assert(sizeof(KuroMaterialControllerComponent_RemoveTextureUpdateParamPermanentCommon) == 0x000010, "Wrong size on KuroMaterialControllerComponent_RemoveTextureUpdateParamPermanentCommon");
static_assert(offsetof(KuroMaterialControllerComponent_RemoveTextureUpdateParamPermanentCommon, Name_0) == 0x000000, "Member 'KuroMaterialControllerComponent_RemoveTextureUpdateParamPermanentCommon::Name_0' has a wrong offset!");
static_assert(offsetof(KuroMaterialControllerComponent_RemoveTextureUpdateParamPermanentCommon, BodyType) == 0x00000C, "Member 'KuroMaterialControllerComponent_RemoveTextureUpdateParamPermanentCommon::BodyType' has a wrong offset!");
static_assert(offsetof(KuroMaterialControllerComponent_RemoveTextureUpdateParamPermanentCommon, SlotType) == 0x00000D, "Member 'KuroMaterialControllerComponent_RemoveTextureUpdateParamPermanentCommon::SlotType' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroMaterialControllerComponent.RemoveTextureUpdateParamPermanentCustom
// 0x0030 (0x0030 - 0x0000)
struct KuroMaterialControllerComponent_RemoveTextureUpdateParamPermanentCustom final
{
public:
	class FName                                   Name_0;                                            // 0x0000(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BodyName;                                          // 0x000C(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EKuroCharSlotSpecifiedType                    SlotType;                                          // 0x0018(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 CustomPartName;                                    // 0x0020(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroMaterialControllerComponent_RemoveTextureUpdateParamPermanentCustom) == 0x000008, "Wrong alignment on KuroMaterialControllerComponent_RemoveTextureUpdateParamPermanentCustom");
static_assert(sizeof(KuroMaterialControllerComponent_RemoveTextureUpdateParamPermanentCustom) == 0x000030, "Wrong size on KuroMaterialControllerComponent_RemoveTextureUpdateParamPermanentCustom");
static_assert(offsetof(KuroMaterialControllerComponent_RemoveTextureUpdateParamPermanentCustom, Name_0) == 0x000000, "Member 'KuroMaterialControllerComponent_RemoveTextureUpdateParamPermanentCustom::Name_0' has a wrong offset!");
static_assert(offsetof(KuroMaterialControllerComponent_RemoveTextureUpdateParamPermanentCustom, BodyName) == 0x00000C, "Member 'KuroMaterialControllerComponent_RemoveTextureUpdateParamPermanentCustom::BodyName' has a wrong offset!");
static_assert(offsetof(KuroMaterialControllerComponent_RemoveTextureUpdateParamPermanentCustom, SlotType) == 0x000018, "Member 'KuroMaterialControllerComponent_RemoveTextureUpdateParamPermanentCustom::SlotType' has a wrong offset!");
static_assert(offsetof(KuroMaterialControllerComponent_RemoveTextureUpdateParamPermanentCustom, CustomPartName) == 0x000020, "Member 'KuroMaterialControllerComponent_RemoveTextureUpdateParamPermanentCustom::CustomPartName' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroMaterialControllerComponent.SeekFactor
// 0x0008 (0x0008 - 0x0000)
struct KuroMaterialControllerComponent_SeekFactor final
{
public:
	float                                         AbsoluteFactor;                                    // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIncludePaused;                                    // 0x0004(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroMaterialControllerComponent_SeekFactor) == 0x000004, "Wrong alignment on KuroMaterialControllerComponent_SeekFactor");
static_assert(sizeof(KuroMaterialControllerComponent_SeekFactor) == 0x000008, "Wrong size on KuroMaterialControllerComponent_SeekFactor");
static_assert(offsetof(KuroMaterialControllerComponent_SeekFactor, AbsoluteFactor) == 0x000000, "Member 'KuroMaterialControllerComponent_SeekFactor::AbsoluteFactor' has a wrong offset!");
static_assert(offsetof(KuroMaterialControllerComponent_SeekFactor, bIncludePaused) == 0x000004, "Member 'KuroMaterialControllerComponent_SeekFactor::bIncludePaused' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroMaterialControllerComponent.SeekHandleFactor
// 0x0008 (0x0008 - 0x0000)
struct KuroMaterialControllerComponent_SeekHandleFactor final
{
public:
	int32                                         HandleId;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AbsoluteFactor;                                    // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroMaterialControllerComponent_SeekHandleFactor) == 0x000004, "Wrong alignment on KuroMaterialControllerComponent_SeekHandleFactor");
static_assert(sizeof(KuroMaterialControllerComponent_SeekHandleFactor) == 0x000008, "Wrong size on KuroMaterialControllerComponent_SeekHandleFactor");
static_assert(offsetof(KuroMaterialControllerComponent_SeekHandleFactor, HandleId) == 0x000000, "Member 'KuroMaterialControllerComponent_SeekHandleFactor::HandleId' has a wrong offset!");
static_assert(offsetof(KuroMaterialControllerComponent_SeekHandleFactor, AbsoluteFactor) == 0x000004, "Member 'KuroMaterialControllerComponent_SeekHandleFactor::AbsoluteFactor' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroMaterialControllerComponent.SetBaseMaterialByIndex
// 0x0018 (0x0018 - 0x0000)
struct KuroMaterialControllerComponent_SetBaseMaterialByIndex final
{
public:
	class UMaterialInterface*                     Mat;                                               // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BodyName;                                          // 0x0008(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaterialIndex;                                     // 0x0014(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroMaterialControllerComponent_SetBaseMaterialByIndex) == 0x000008, "Wrong alignment on KuroMaterialControllerComponent_SetBaseMaterialByIndex");
static_assert(sizeof(KuroMaterialControllerComponent_SetBaseMaterialByIndex) == 0x000018, "Wrong size on KuroMaterialControllerComponent_SetBaseMaterialByIndex");
static_assert(offsetof(KuroMaterialControllerComponent_SetBaseMaterialByIndex, Mat) == 0x000000, "Member 'KuroMaterialControllerComponent_SetBaseMaterialByIndex::Mat' has a wrong offset!");
static_assert(offsetof(KuroMaterialControllerComponent_SetBaseMaterialByIndex, BodyName) == 0x000008, "Member 'KuroMaterialControllerComponent_SetBaseMaterialByIndex::BodyName' has a wrong offset!");
static_assert(offsetof(KuroMaterialControllerComponent_SetBaseMaterialByIndex, MaterialIndex) == 0x000014, "Member 'KuroMaterialControllerComponent_SetBaseMaterialByIndex::MaterialIndex' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroMaterialControllerComponent.SetExternalMaterialReplace
// 0x0010 (0x0010 - 0x0000)
struct KuroMaterialControllerComponent_SetExternalMaterialReplace final
{
public:
	class UMaterialInterface*                     Mat;                                               // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EKuroCharBodySpecifiedType                    BodyType;                                          // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EKuroCharSlotSpecifiedType                    SlotType;                                          // 0x0009(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EKuroCharMeshPart                             MeshPart;                                          // 0x000A(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B[0x5];                                        // 0x000B(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroMaterialControllerComponent_SetExternalMaterialReplace) == 0x000008, "Wrong alignment on KuroMaterialControllerComponent_SetExternalMaterialReplace");
static_assert(sizeof(KuroMaterialControllerComponent_SetExternalMaterialReplace) == 0x000010, "Wrong size on KuroMaterialControllerComponent_SetExternalMaterialReplace");
static_assert(offsetof(KuroMaterialControllerComponent_SetExternalMaterialReplace, Mat) == 0x000000, "Member 'KuroMaterialControllerComponent_SetExternalMaterialReplace::Mat' has a wrong offset!");
static_assert(offsetof(KuroMaterialControllerComponent_SetExternalMaterialReplace, BodyType) == 0x000008, "Member 'KuroMaterialControllerComponent_SetExternalMaterialReplace::BodyType' has a wrong offset!");
static_assert(offsetof(KuroMaterialControllerComponent_SetExternalMaterialReplace, SlotType) == 0x000009, "Member 'KuroMaterialControllerComponent_SetExternalMaterialReplace::SlotType' has a wrong offset!");
static_assert(offsetof(KuroMaterialControllerComponent_SetExternalMaterialReplace, MeshPart) == 0x00000A, "Member 'KuroMaterialControllerComponent_SetExternalMaterialReplace::MeshPart' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroMaterialControllerComponent.SetExternalMaterialReplaceByIndex
// 0x0018 (0x0018 - 0x0000)
struct KuroMaterialControllerComponent_SetExternalMaterialReplaceByIndex final
{
public:
	class UMaterialInterface*                     Mat;                                               // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BodyName;                                          // 0x0008(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaterialIndex;                                     // 0x0014(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroMaterialControllerComponent_SetExternalMaterialReplaceByIndex) == 0x000008, "Wrong alignment on KuroMaterialControllerComponent_SetExternalMaterialReplaceByIndex");
static_assert(sizeof(KuroMaterialControllerComponent_SetExternalMaterialReplaceByIndex) == 0x000018, "Wrong size on KuroMaterialControllerComponent_SetExternalMaterialReplaceByIndex");
static_assert(offsetof(KuroMaterialControllerComponent_SetExternalMaterialReplaceByIndex, Mat) == 0x000000, "Member 'KuroMaterialControllerComponent_SetExternalMaterialReplaceByIndex::Mat' has a wrong offset!");
static_assert(offsetof(KuroMaterialControllerComponent_SetExternalMaterialReplaceByIndex, BodyName) == 0x000008, "Member 'KuroMaterialControllerComponent_SetExternalMaterialReplaceByIndex::BodyName' has a wrong offset!");
static_assert(offsetof(KuroMaterialControllerComponent_SetExternalMaterialReplaceByIndex, MaterialIndex) == 0x000014, "Member 'KuroMaterialControllerComponent_SetExternalMaterialReplaceByIndex::MaterialIndex' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroMaterialControllerComponent.SetExternalMaterialReplaceCommon
// 0x0010 (0x0010 - 0x0000)
struct KuroMaterialControllerComponent_SetExternalMaterialReplaceCommon final
{
public:
	class UMaterialInterface*                     Mat;                                               // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EKuroCharBodySpecifiedType                    BodyType;                                          // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EKuroCharSlotSpecifiedType                    SlotType;                                          // 0x0009(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x6];                                        // 0x000A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroMaterialControllerComponent_SetExternalMaterialReplaceCommon) == 0x000008, "Wrong alignment on KuroMaterialControllerComponent_SetExternalMaterialReplaceCommon");
static_assert(sizeof(KuroMaterialControllerComponent_SetExternalMaterialReplaceCommon) == 0x000010, "Wrong size on KuroMaterialControllerComponent_SetExternalMaterialReplaceCommon");
static_assert(offsetof(KuroMaterialControllerComponent_SetExternalMaterialReplaceCommon, Mat) == 0x000000, "Member 'KuroMaterialControllerComponent_SetExternalMaterialReplaceCommon::Mat' has a wrong offset!");
static_assert(offsetof(KuroMaterialControllerComponent_SetExternalMaterialReplaceCommon, BodyType) == 0x000008, "Member 'KuroMaterialControllerComponent_SetExternalMaterialReplaceCommon::BodyType' has a wrong offset!");
static_assert(offsetof(KuroMaterialControllerComponent_SetExternalMaterialReplaceCommon, SlotType) == 0x000009, "Member 'KuroMaterialControllerComponent_SetExternalMaterialReplaceCommon::SlotType' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroMaterialControllerComponent.SetExternalMaterialReplaceCustom
// 0x0028 (0x0028 - 0x0000)
struct KuroMaterialControllerComponent_SetExternalMaterialReplaceCustom final
{
public:
	class UMaterialInterface*                     Mat;                                               // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BodyName;                                          // 0x0008(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EKuroCharSlotSpecifiedType                    SlotType;                                          // 0x0014(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 CustomPartName;                                    // 0x0018(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroMaterialControllerComponent_SetExternalMaterialReplaceCustom) == 0x000008, "Wrong alignment on KuroMaterialControllerComponent_SetExternalMaterialReplaceCustom");
static_assert(sizeof(KuroMaterialControllerComponent_SetExternalMaterialReplaceCustom) == 0x000028, "Wrong size on KuroMaterialControllerComponent_SetExternalMaterialReplaceCustom");
static_assert(offsetof(KuroMaterialControllerComponent_SetExternalMaterialReplaceCustom, Mat) == 0x000000, "Member 'KuroMaterialControllerComponent_SetExternalMaterialReplaceCustom::Mat' has a wrong offset!");
static_assert(offsetof(KuroMaterialControllerComponent_SetExternalMaterialReplaceCustom, BodyName) == 0x000008, "Member 'KuroMaterialControllerComponent_SetExternalMaterialReplaceCustom::BodyName' has a wrong offset!");
static_assert(offsetof(KuroMaterialControllerComponent_SetExternalMaterialReplaceCustom, SlotType) == 0x000014, "Member 'KuroMaterialControllerComponent_SetExternalMaterialReplaceCustom::SlotType' has a wrong offset!");
static_assert(offsetof(KuroMaterialControllerComponent_SetExternalMaterialReplaceCustom, CustomPartName) == 0x000018, "Member 'KuroMaterialControllerComponent_SetExternalMaterialReplaceCustom::CustomPartName' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroMaterialControllerComponent.SetHandleEnabled
// 0x0008 (0x0008 - 0x0000)
struct KuroMaterialControllerComponent_SetHandleEnabled final
{
public:
	int32                                         HandleId;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnabled;                                          // 0x0004(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroMaterialControllerComponent_SetHandleEnabled) == 0x000004, "Wrong alignment on KuroMaterialControllerComponent_SetHandleEnabled");
static_assert(sizeof(KuroMaterialControllerComponent_SetHandleEnabled) == 0x000008, "Wrong size on KuroMaterialControllerComponent_SetHandleEnabled");
static_assert(offsetof(KuroMaterialControllerComponent_SetHandleEnabled, HandleId) == 0x000000, "Member 'KuroMaterialControllerComponent_SetHandleEnabled::HandleId' has a wrong offset!");
static_assert(offsetof(KuroMaterialControllerComponent_SetHandleEnabled, bEnabled) == 0x000004, "Member 'KuroMaterialControllerComponent_SetHandleEnabled::bEnabled' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroMaterialControllerComponent.SetHandleLoop
// 0x0008 (0x0008 - 0x0000)
struct KuroMaterialControllerComponent_SetHandleLoop final
{
public:
	int32                                         HandleId;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLoop;                                             // 0x0004(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSeekToEnd;                                        // 0x0005(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6[0x2];                                        // 0x0006(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroMaterialControllerComponent_SetHandleLoop) == 0x000004, "Wrong alignment on KuroMaterialControllerComponent_SetHandleLoop");
static_assert(sizeof(KuroMaterialControllerComponent_SetHandleLoop) == 0x000008, "Wrong size on KuroMaterialControllerComponent_SetHandleLoop");
static_assert(offsetof(KuroMaterialControllerComponent_SetHandleLoop, HandleId) == 0x000000, "Member 'KuroMaterialControllerComponent_SetHandleLoop::HandleId' has a wrong offset!");
static_assert(offsetof(KuroMaterialControllerComponent_SetHandleLoop, bLoop) == 0x000004, "Member 'KuroMaterialControllerComponent_SetHandleLoop::bLoop' has a wrong offset!");
static_assert(offsetof(KuroMaterialControllerComponent_SetHandleLoop, bSeekToEnd) == 0x000005, "Member 'KuroMaterialControllerComponent_SetHandleLoop::bSeekToEnd' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroMaterialControllerComponent.SetHandlePause
// 0x0008 (0x0008 - 0x0000)
struct KuroMaterialControllerComponent_SetHandlePause final
{
public:
	int32                                         HandleId;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPause;                                            // 0x0004(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroMaterialControllerComponent_SetHandlePause) == 0x000004, "Wrong alignment on KuroMaterialControllerComponent_SetHandlePause");
static_assert(sizeof(KuroMaterialControllerComponent_SetHandlePause) == 0x000008, "Wrong size on KuroMaterialControllerComponent_SetHandlePause");
static_assert(offsetof(KuroMaterialControllerComponent_SetHandlePause, HandleId) == 0x000000, "Member 'KuroMaterialControllerComponent_SetHandlePause::HandleId' has a wrong offset!");
static_assert(offsetof(KuroMaterialControllerComponent_SetHandlePause, bPause) == 0x000004, "Member 'KuroMaterialControllerComponent_SetHandlePause::bPause' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroMaterialControllerComponent.SetInitTakeOver
// 0x0001 (0x0001 - 0x0000)
struct KuroMaterialControllerComponent_SetInitTakeOver final
{
public:
	bool                                          InTakeOver;                                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroMaterialControllerComponent_SetInitTakeOver) == 0x000001, "Wrong alignment on KuroMaterialControllerComponent_SetInitTakeOver");
static_assert(sizeof(KuroMaterialControllerComponent_SetInitTakeOver) == 0x000001, "Wrong size on KuroMaterialControllerComponent_SetInitTakeOver");
static_assert(offsetof(KuroMaterialControllerComponent_SetInitTakeOver, InTakeOver) == 0x000000, "Member 'KuroMaterialControllerComponent_SetInitTakeOver::InTakeOver' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroMaterialControllerComponent.SetSkeletalMeshComponentUpdateGroup
// 0x0018 (0x0018 - 0x0000)
struct KuroMaterialControllerComponent_SetSkeletalMeshComponentUpdateGroup final
{
public:
	class FName                                   BodyName;                                          // 0x0000(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   NewUpdateGroupId;                                  // 0x000C(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroMaterialControllerComponent_SetSkeletalMeshComponentUpdateGroup) == 0x000004, "Wrong alignment on KuroMaterialControllerComponent_SetSkeletalMeshComponentUpdateGroup");
static_assert(sizeof(KuroMaterialControllerComponent_SetSkeletalMeshComponentUpdateGroup) == 0x000018, "Wrong size on KuroMaterialControllerComponent_SetSkeletalMeshComponentUpdateGroup");
static_assert(offsetof(KuroMaterialControllerComponent_SetSkeletalMeshComponentUpdateGroup, BodyName) == 0x000000, "Member 'KuroMaterialControllerComponent_SetSkeletalMeshComponentUpdateGroup::BodyName' has a wrong offset!");
static_assert(offsetof(KuroMaterialControllerComponent_SetSkeletalMeshComponentUpdateGroup, NewUpdateGroupId) == 0x00000C, "Member 'KuroMaterialControllerComponent_SetSkeletalMeshComponentUpdateGroup::NewUpdateGroupId' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroMaterialControllerComponent.SetToonCustomStencilValue
// 0x0004 (0x0004 - 0x0000)
struct KuroMaterialControllerComponent_SetToonCustomStencilValue final
{
public:
	int32                                         Value;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroMaterialControllerComponent_SetToonCustomStencilValue) == 0x000004, "Wrong alignment on KuroMaterialControllerComponent_SetToonCustomStencilValue");
static_assert(sizeof(KuroMaterialControllerComponent_SetToonCustomStencilValue) == 0x000004, "Wrong size on KuroMaterialControllerComponent_SetToonCustomStencilValue");
static_assert(offsetof(KuroMaterialControllerComponent_SetToonCustomStencilValue, Value) == 0x000000, "Member 'KuroMaterialControllerComponent_SetToonCustomStencilValue::Value' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroMaterialControllerComponent.UnregisterEffectKey
// 0x000C (0x000C - 0x0000)
struct KuroMaterialControllerComponent_UnregisterEffectKey final
{
public:
	class FName                                   KeyName;                                           // 0x0000(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroMaterialControllerComponent_UnregisterEffectKey) == 0x000004, "Wrong alignment on KuroMaterialControllerComponent_UnregisterEffectKey");
static_assert(sizeof(KuroMaterialControllerComponent_UnregisterEffectKey) == 0x00000C, "Wrong size on KuroMaterialControllerComponent_UnregisterEffectKey");
static_assert(offsetof(KuroMaterialControllerComponent_UnregisterEffectKey, KeyName) == 0x000000, "Member 'KuroMaterialControllerComponent_UnregisterEffectKey::KeyName' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroMaterialControllerComponent.CheckInit
// 0x0001 (0x0001 - 0x0000)
struct KuroMaterialControllerComponent_CheckInit final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroMaterialControllerComponent_CheckInit) == 0x000001, "Wrong alignment on KuroMaterialControllerComponent_CheckInit");
static_assert(sizeof(KuroMaterialControllerComponent_CheckInit) == 0x000001, "Wrong size on KuroMaterialControllerComponent_CheckInit");
static_assert(offsetof(KuroMaterialControllerComponent_CheckInit, ReturnValue) == 0x000000, "Member 'KuroMaterialControllerComponent_CheckInit::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroMaterialControllerComponent.GetAllRegisteredBodyNames
// 0x0010 (0x0010 - 0x0000)
struct KuroMaterialControllerComponent_GetAllRegisteredBodyNames final
{
public:
	TArray<class FName>                           ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroMaterialControllerComponent_GetAllRegisteredBodyNames) == 0x000008, "Wrong alignment on KuroMaterialControllerComponent_GetAllRegisteredBodyNames");
static_assert(sizeof(KuroMaterialControllerComponent_GetAllRegisteredBodyNames) == 0x000010, "Wrong size on KuroMaterialControllerComponent_GetAllRegisteredBodyNames");
static_assert(offsetof(KuroMaterialControllerComponent_GetAllRegisteredBodyNames, ReturnValue) == 0x000000, "Member 'KuroMaterialControllerComponent_GetAllRegisteredBodyNames::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroMaterialControllerComponent.GetAnyUnloopEffect
// 0x0001 (0x0001 - 0x0000)
struct KuroMaterialControllerComponent_GetAnyUnloopEffect final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroMaterialControllerComponent_GetAnyUnloopEffect) == 0x000001, "Wrong alignment on KuroMaterialControllerComponent_GetAnyUnloopEffect");
static_assert(sizeof(KuroMaterialControllerComponent_GetAnyUnloopEffect) == 0x000001, "Wrong size on KuroMaterialControllerComponent_GetAnyUnloopEffect");
static_assert(offsetof(KuroMaterialControllerComponent_GetAnyUnloopEffect, ReturnValue) == 0x000000, "Member 'KuroMaterialControllerComponent_GetAnyUnloopEffect::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroMaterialControllerComponent.GetBodyOpacity
// 0x0004 (0x0004 - 0x0000)
struct KuroMaterialControllerComponent_GetBodyOpacity final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroMaterialControllerComponent_GetBodyOpacity) == 0x000004, "Wrong alignment on KuroMaterialControllerComponent_GetBodyOpacity");
static_assert(sizeof(KuroMaterialControllerComponent_GetBodyOpacity) == 0x000004, "Wrong size on KuroMaterialControllerComponent_GetBodyOpacity");
static_assert(offsetof(KuroMaterialControllerComponent_GetBodyOpacity, ReturnValue) == 0x000000, "Member 'KuroMaterialControllerComponent_GetBodyOpacity::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroMaterialControllerComponent.GetRegisteredSkeletalMeshComponent
// 0x0018 (0x0018 - 0x0000)
struct KuroMaterialControllerComponent_GetRegisteredSkeletalMeshComponent final
{
public:
	class FName                                   BodyName;                                          // 0x0000(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class USkeletalMeshComponent*                 ReturnValue;                                       // 0x0010(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroMaterialControllerComponent_GetRegisteredSkeletalMeshComponent) == 0x000008, "Wrong alignment on KuroMaterialControllerComponent_GetRegisteredSkeletalMeshComponent");
static_assert(sizeof(KuroMaterialControllerComponent_GetRegisteredSkeletalMeshComponent) == 0x000018, "Wrong size on KuroMaterialControllerComponent_GetRegisteredSkeletalMeshComponent");
static_assert(offsetof(KuroMaterialControllerComponent_GetRegisteredSkeletalMeshComponent, BodyName) == 0x000000, "Member 'KuroMaterialControllerComponent_GetRegisteredSkeletalMeshComponent::BodyName' has a wrong offset!");
static_assert(offsetof(KuroMaterialControllerComponent_GetRegisteredSkeletalMeshComponent, ReturnValue) == 0x000010, "Member 'KuroMaterialControllerComponent_GetRegisteredSkeletalMeshComponent::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroMaterialControllerComponent.GetRegisteredSkeletalMeshComponentByType
// 0x0010 (0x0010 - 0x0000)
struct KuroMaterialControllerComponent_GetRegisteredSkeletalMeshComponentByType final
{
public:
	EKuroCharBodyType                             BodyType;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Index_0;                                           // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USkeletalMeshComponent*                 ReturnValue;                                       // 0x0008(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroMaterialControllerComponent_GetRegisteredSkeletalMeshComponentByType) == 0x000008, "Wrong alignment on KuroMaterialControllerComponent_GetRegisteredSkeletalMeshComponentByType");
static_assert(sizeof(KuroMaterialControllerComponent_GetRegisteredSkeletalMeshComponentByType) == 0x000010, "Wrong size on KuroMaterialControllerComponent_GetRegisteredSkeletalMeshComponentByType");
static_assert(offsetof(KuroMaterialControllerComponent_GetRegisteredSkeletalMeshComponentByType, BodyType) == 0x000000, "Member 'KuroMaterialControllerComponent_GetRegisteredSkeletalMeshComponentByType::BodyType' has a wrong offset!");
static_assert(offsetof(KuroMaterialControllerComponent_GetRegisteredSkeletalMeshComponentByType, Index_0) == 0x000004, "Member 'KuroMaterialControllerComponent_GetRegisteredSkeletalMeshComponentByType::Index_0' has a wrong offset!");
static_assert(offsetof(KuroMaterialControllerComponent_GetRegisteredSkeletalMeshComponentByType, ReturnValue) == 0x000008, "Member 'KuroMaterialControllerComponent_GetRegisteredSkeletalMeshComponentByType::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroMaterialControllerComponent.GetSkeletalMeshComponentBodyName
// 0x0018 (0x0018 - 0x0000)
struct KuroMaterialControllerComponent_GetSkeletalMeshComponentBodyName final
{
public:
	class USkeletalMeshComponent*                 SkeletalMeshComponent;                             // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ReturnValue;                                       // 0x0008(0x000C)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroMaterialControllerComponent_GetSkeletalMeshComponentBodyName) == 0x000008, "Wrong alignment on KuroMaterialControllerComponent_GetSkeletalMeshComponentBodyName");
static_assert(sizeof(KuroMaterialControllerComponent_GetSkeletalMeshComponentBodyName) == 0x000018, "Wrong size on KuroMaterialControllerComponent_GetSkeletalMeshComponentBodyName");
static_assert(offsetof(KuroMaterialControllerComponent_GetSkeletalMeshComponentBodyName, SkeletalMeshComponent) == 0x000000, "Member 'KuroMaterialControllerComponent_GetSkeletalMeshComponentBodyName::SkeletalMeshComponent' has a wrong offset!");
static_assert(offsetof(KuroMaterialControllerComponent_GetSkeletalMeshComponentBodyName, ReturnValue) == 0x000008, "Member 'KuroMaterialControllerComponent_GetSkeletalMeshComponentBodyName::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroMaterialControllerComponent.HasSkeletalMeshComponent
// 0x0010 (0x0010 - 0x0000)
struct KuroMaterialControllerComponent_HasSkeletalMeshComponent final
{
public:
	class USkeletalMeshComponent*                 SkeletalMeshComponent;                             // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroMaterialControllerComponent_HasSkeletalMeshComponent) == 0x000008, "Wrong alignment on KuroMaterialControllerComponent_HasSkeletalMeshComponent");
static_assert(sizeof(KuroMaterialControllerComponent_HasSkeletalMeshComponent) == 0x000010, "Wrong size on KuroMaterialControllerComponent_HasSkeletalMeshComponent");
static_assert(offsetof(KuroMaterialControllerComponent_HasSkeletalMeshComponent, SkeletalMeshComponent) == 0x000000, "Member 'KuroMaterialControllerComponent_HasSkeletalMeshComponent::SkeletalMeshComponent' has a wrong offset!");
static_assert(offsetof(KuroMaterialControllerComponent_HasSkeletalMeshComponent, ReturnValue) == 0x000008, "Member 'KuroMaterialControllerComponent_HasSkeletalMeshComponent::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroMaterialControllerComponent.HasSkeletalMeshComponentName
// 0x0010 (0x0010 - 0x0000)
struct KuroMaterialControllerComponent_HasSkeletalMeshComponentName final
{
public:
	class FName                                   BodyName;                                          // 0x0000(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x000C(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroMaterialControllerComponent_HasSkeletalMeshComponentName) == 0x000004, "Wrong alignment on KuroMaterialControllerComponent_HasSkeletalMeshComponentName");
static_assert(sizeof(KuroMaterialControllerComponent_HasSkeletalMeshComponentName) == 0x000010, "Wrong size on KuroMaterialControllerComponent_HasSkeletalMeshComponentName");
static_assert(offsetof(KuroMaterialControllerComponent_HasSkeletalMeshComponentName, BodyName) == 0x000000, "Member 'KuroMaterialControllerComponent_HasSkeletalMeshComponentName::BodyName' has a wrong offset!");
static_assert(offsetof(KuroMaterialControllerComponent_HasSkeletalMeshComponentName, ReturnValue) == 0x00000C, "Member 'KuroMaterialControllerComponent_HasSkeletalMeshComponentName::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroMaterialControllerComponent.SetAllBodyNoWater
// 0x0001 (0x0001 - 0x0000)
struct KuroMaterialControllerComponent_SetAllBodyNoWater final
{
public:
	bool                                          bNoWater;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroMaterialControllerComponent_SetAllBodyNoWater) == 0x000001, "Wrong alignment on KuroMaterialControllerComponent_SetAllBodyNoWater");
static_assert(sizeof(KuroMaterialControllerComponent_SetAllBodyNoWater) == 0x000001, "Wrong size on KuroMaterialControllerComponent_SetAllBodyNoWater");
static_assert(offsetof(KuroMaterialControllerComponent_SetAllBodyNoWater, bNoWater) == 0x000000, "Member 'KuroMaterialControllerComponent_SetAllBodyNoWater::bNoWater' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroMaterialControllerComponent.SetUpdateForce
// 0x0001 (0x0001 - 0x0000)
struct KuroMaterialControllerComponent_SetUpdateForce final
{
public:
	bool                                          bInUpdateForce;                                    // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroMaterialControllerComponent_SetUpdateForce) == 0x000001, "Wrong alignment on KuroMaterialControllerComponent_SetUpdateForce");
static_assert(sizeof(KuroMaterialControllerComponent_SetUpdateForce) == 0x000001, "Wrong size on KuroMaterialControllerComponent_SetUpdateForce");
static_assert(offsetof(KuroMaterialControllerComponent_SetUpdateForce, bInUpdateForce) == 0x000000, "Member 'KuroMaterialControllerComponent_SetUpdateForce::bInUpdateForce' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroWorldPartitionPreviewManager.AddPreviewActorType
// 0x0008 (0x0008 - 0x0000)
struct KuroWorldPartitionPreviewManager_AddPreviewActorType final
{
public:
	TSubclassOf<class AActor>                     Class_0;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroWorldPartitionPreviewManager_AddPreviewActorType) == 0x000008, "Wrong alignment on KuroWorldPartitionPreviewManager_AddPreviewActorType");
static_assert(sizeof(KuroWorldPartitionPreviewManager_AddPreviewActorType) == 0x000008, "Wrong size on KuroWorldPartitionPreviewManager_AddPreviewActorType");
static_assert(offsetof(KuroWorldPartitionPreviewManager_AddPreviewActorType, Class_0) == 0x000000, "Member 'KuroWorldPartitionPreviewManager_AddPreviewActorType::Class_0' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroWorldPartitionPreviewManager.RemovePreviewActorType
// 0x0008 (0x0008 - 0x0000)
struct KuroWorldPartitionPreviewManager_RemovePreviewActorType final
{
public:
	TSubclassOf<class AActor>                     Class_0;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroWorldPartitionPreviewManager_RemovePreviewActorType) == 0x000008, "Wrong alignment on KuroWorldPartitionPreviewManager_RemovePreviewActorType");
static_assert(sizeof(KuroWorldPartitionPreviewManager_RemovePreviewActorType) == 0x000008, "Wrong size on KuroWorldPartitionPreviewManager_RemovePreviewActorType");
static_assert(offsetof(KuroWorldPartitionPreviewManager_RemovePreviewActorType, Class_0) == 0x000000, "Member 'KuroWorldPartitionPreviewManager_RemovePreviewActorType::Class_0' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroWorldPartitionPreviewManager.SetPreviewMobile
// 0x0001 (0x0001 - 0x0000)
struct KuroWorldPartitionPreviewManager_SetPreviewMobile final
{
public:
	bool                                          PreviewMobile;                                     // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroWorldPartitionPreviewManager_SetPreviewMobile) == 0x000001, "Wrong alignment on KuroWorldPartitionPreviewManager_SetPreviewMobile");
static_assert(sizeof(KuroWorldPartitionPreviewManager_SetPreviewMobile) == 0x000001, "Wrong size on KuroWorldPartitionPreviewManager_SetPreviewMobile");
static_assert(offsetof(KuroWorldPartitionPreviewManager_SetPreviewMobile, PreviewMobile) == 0x000000, "Member 'KuroWorldPartitionPreviewManager_SetPreviewMobile::PreviewMobile' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroAnimNotify.K2_Notify
// 0x0018 (0x0018 - 0x0000)
struct KuroAnimNotify_K2_Notify final
{
public:
	class USkeletalMeshComponent*                 MeshComp;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      Animation;                                         // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroAnimNotify_K2_Notify) == 0x000008, "Wrong alignment on KuroAnimNotify_K2_Notify");
static_assert(sizeof(KuroAnimNotify_K2_Notify) == 0x000018, "Wrong size on KuroAnimNotify_K2_Notify");
static_assert(offsetof(KuroAnimNotify_K2_Notify, MeshComp) == 0x000000, "Member 'KuroAnimNotify_K2_Notify::MeshComp' has a wrong offset!");
static_assert(offsetof(KuroAnimNotify_K2_Notify, Animation) == 0x000008, "Member 'KuroAnimNotify_K2_Notify::Animation' has a wrong offset!");
static_assert(offsetof(KuroAnimNotify_K2_Notify, ReturnValue) == 0x000010, "Member 'KuroAnimNotify_K2_Notify::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroAnimNotify.K2_PostChangeProperty
// 0x0010 (0x0010 - 0x0000)
struct KuroAnimNotify_K2_PostChangeProperty final
{
public:
	class FName                                   PropertyName;                                      // 0x0000(0x000C)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x000C(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroAnimNotify_K2_PostChangeProperty) == 0x000004, "Wrong alignment on KuroAnimNotify_K2_PostChangeProperty");
static_assert(sizeof(KuroAnimNotify_K2_PostChangeProperty) == 0x000010, "Wrong size on KuroAnimNotify_K2_PostChangeProperty");
static_assert(offsetof(KuroAnimNotify_K2_PostChangeProperty, PropertyName) == 0x000000, "Member 'KuroAnimNotify_K2_PostChangeProperty::PropertyName' has a wrong offset!");
static_assert(offsetof(KuroAnimNotify_K2_PostChangeProperty, ReturnValue) == 0x00000C, "Member 'KuroAnimNotify_K2_PostChangeProperty::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroAnimNotify.K2_ValidateAssets
// 0x0001 (0x0001 - 0x0000)
struct KuroAnimNotify_K2_ValidateAssets final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroAnimNotify_K2_ValidateAssets) == 0x000001, "Wrong alignment on KuroAnimNotify_K2_ValidateAssets");
static_assert(sizeof(KuroAnimNotify_K2_ValidateAssets) == 0x000001, "Wrong size on KuroAnimNotify_K2_ValidateAssets");
static_assert(offsetof(KuroAnimNotify_K2_ValidateAssets, ReturnValue) == 0x000000, "Member 'KuroAnimNotify_K2_ValidateAssets::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroAnimNotifyState.K2_NotifyBegin
// 0x0018 (0x0018 - 0x0000)
struct KuroAnimNotifyState_K2_NotifyBegin final
{
public:
	class USkeletalMeshComponent*                 MeshComp;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      Animation;                                         // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TotalDuration;                                     // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0014(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroAnimNotifyState_K2_NotifyBegin) == 0x000008, "Wrong alignment on KuroAnimNotifyState_K2_NotifyBegin");
static_assert(sizeof(KuroAnimNotifyState_K2_NotifyBegin) == 0x000018, "Wrong size on KuroAnimNotifyState_K2_NotifyBegin");
static_assert(offsetof(KuroAnimNotifyState_K2_NotifyBegin, MeshComp) == 0x000000, "Member 'KuroAnimNotifyState_K2_NotifyBegin::MeshComp' has a wrong offset!");
static_assert(offsetof(KuroAnimNotifyState_K2_NotifyBegin, Animation) == 0x000008, "Member 'KuroAnimNotifyState_K2_NotifyBegin::Animation' has a wrong offset!");
static_assert(offsetof(KuroAnimNotifyState_K2_NotifyBegin, TotalDuration) == 0x000010, "Member 'KuroAnimNotifyState_K2_NotifyBegin::TotalDuration' has a wrong offset!");
static_assert(offsetof(KuroAnimNotifyState_K2_NotifyBegin, ReturnValue) == 0x000014, "Member 'KuroAnimNotifyState_K2_NotifyBegin::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroAnimNotifyState.K2_NotifyEnd
// 0x0018 (0x0018 - 0x0000)
struct KuroAnimNotifyState_K2_NotifyEnd final
{
public:
	class USkeletalMeshComponent*                 MeshComp;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      Animation;                                         // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroAnimNotifyState_K2_NotifyEnd) == 0x000008, "Wrong alignment on KuroAnimNotifyState_K2_NotifyEnd");
static_assert(sizeof(KuroAnimNotifyState_K2_NotifyEnd) == 0x000018, "Wrong size on KuroAnimNotifyState_K2_NotifyEnd");
static_assert(offsetof(KuroAnimNotifyState_K2_NotifyEnd, MeshComp) == 0x000000, "Member 'KuroAnimNotifyState_K2_NotifyEnd::MeshComp' has a wrong offset!");
static_assert(offsetof(KuroAnimNotifyState_K2_NotifyEnd, Animation) == 0x000008, "Member 'KuroAnimNotifyState_K2_NotifyEnd::Animation' has a wrong offset!");
static_assert(offsetof(KuroAnimNotifyState_K2_NotifyEnd, ReturnValue) == 0x000010, "Member 'KuroAnimNotifyState_K2_NotifyEnd::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroAnimNotifyState.K2_NotifyTick
// 0x0018 (0x0018 - 0x0000)
struct KuroAnimNotifyState_K2_NotifyTick final
{
public:
	class USkeletalMeshComponent*                 MeshComp;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      Animation;                                         // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FrameDeltaTime;                                    // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0014(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroAnimNotifyState_K2_NotifyTick) == 0x000008, "Wrong alignment on KuroAnimNotifyState_K2_NotifyTick");
static_assert(sizeof(KuroAnimNotifyState_K2_NotifyTick) == 0x000018, "Wrong size on KuroAnimNotifyState_K2_NotifyTick");
static_assert(offsetof(KuroAnimNotifyState_K2_NotifyTick, MeshComp) == 0x000000, "Member 'KuroAnimNotifyState_K2_NotifyTick::MeshComp' has a wrong offset!");
static_assert(offsetof(KuroAnimNotifyState_K2_NotifyTick, Animation) == 0x000008, "Member 'KuroAnimNotifyState_K2_NotifyTick::Animation' has a wrong offset!");
static_assert(offsetof(KuroAnimNotifyState_K2_NotifyTick, FrameDeltaTime) == 0x000010, "Member 'KuroAnimNotifyState_K2_NotifyTick::FrameDeltaTime' has a wrong offset!");
static_assert(offsetof(KuroAnimNotifyState_K2_NotifyTick, ReturnValue) == 0x000014, "Member 'KuroAnimNotifyState_K2_NotifyTick::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroAnimNotifyState.K2_PostChangeProperty
// 0x0010 (0x0010 - 0x0000)
struct KuroAnimNotifyState_K2_PostChangeProperty final
{
public:
	class FName                                   PropertyName;                                      // 0x0000(0x000C)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x000C(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroAnimNotifyState_K2_PostChangeProperty) == 0x000004, "Wrong alignment on KuroAnimNotifyState_K2_PostChangeProperty");
static_assert(sizeof(KuroAnimNotifyState_K2_PostChangeProperty) == 0x000010, "Wrong size on KuroAnimNotifyState_K2_PostChangeProperty");
static_assert(offsetof(KuroAnimNotifyState_K2_PostChangeProperty, PropertyName) == 0x000000, "Member 'KuroAnimNotifyState_K2_PostChangeProperty::PropertyName' has a wrong offset!");
static_assert(offsetof(KuroAnimNotifyState_K2_PostChangeProperty, ReturnValue) == 0x00000C, "Member 'KuroAnimNotifyState_K2_PostChangeProperty::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroAnimNotifyState.K2_ValidateAssets
// 0x0001 (0x0001 - 0x0000)
struct KuroAnimNotifyState_K2_ValidateAssets final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroAnimNotifyState_K2_ValidateAssets) == 0x000001, "Wrong alignment on KuroAnimNotifyState_K2_ValidateAssets");
static_assert(sizeof(KuroAnimNotifyState_K2_ValidateAssets) == 0x000001, "Wrong size on KuroAnimNotifyState_K2_ValidateAssets");
static_assert(offsetof(KuroAnimNotifyState_K2_ValidateAssets, ReturnValue) == 0x000000, "Member 'KuroAnimNotifyState_K2_ValidateAssets::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRainComponent.AddArraySpawner
// 0x0008 (0x0008 - 0x0000)
struct KuroRainComponent_AddArraySpawner final
{
public:
	int32                                         RenderIndex;                                       // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRainComponent_AddArraySpawner) == 0x000004, "Wrong alignment on KuroRainComponent_AddArraySpawner");
static_assert(sizeof(KuroRainComponent_AddArraySpawner) == 0x000008, "Wrong size on KuroRainComponent_AddArraySpawner");
static_assert(offsetof(KuroRainComponent_AddArraySpawner, RenderIndex) == 0x000000, "Member 'KuroRainComponent_AddArraySpawner::RenderIndex' has a wrong offset!");
static_assert(offsetof(KuroRainComponent_AddArraySpawner, ReturnValue) == 0x000004, "Member 'KuroRainComponent_AddArraySpawner::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRainComponent.AddCustomRandomByNormalizedAgeProcessor
// 0x0098 (0x0098 - 0x0000)
struct KuroRainComponent_AddCustomRandomByNormalizedAgeProcessor final
{
public:
	struct FKuroCurveFloat                        Curve;                                             // 0x0000(0x0090)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	int32                                         Index_0;                                           // 0x0090(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0094(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRainComponent_AddCustomRandomByNormalizedAgeProcessor) == 0x000008, "Wrong alignment on KuroRainComponent_AddCustomRandomByNormalizedAgeProcessor");
static_assert(sizeof(KuroRainComponent_AddCustomRandomByNormalizedAgeProcessor) == 0x000098, "Wrong size on KuroRainComponent_AddCustomRandomByNormalizedAgeProcessor");
static_assert(offsetof(KuroRainComponent_AddCustomRandomByNormalizedAgeProcessor, Curve) == 0x000000, "Member 'KuroRainComponent_AddCustomRandomByNormalizedAgeProcessor::Curve' has a wrong offset!");
static_assert(offsetof(KuroRainComponent_AddCustomRandomByNormalizedAgeProcessor, Index_0) == 0x000090, "Member 'KuroRainComponent_AddCustomRandomByNormalizedAgeProcessor::Index_0' has a wrong offset!");
static_assert(offsetof(KuroRainComponent_AddCustomRandomByNormalizedAgeProcessor, ReturnValue) == 0x000094, "Member 'KuroRainComponent_AddCustomRandomByNormalizedAgeProcessor::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRainComponent.AddCustomRandomByVelocityProcessor
// 0x0098 (0x0098 - 0x0000)
struct KuroRainComponent_AddCustomRandomByVelocityProcessor final
{
public:
	struct FKuroCurveFloat                        Curve;                                             // 0x0000(0x0090)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	int32                                         Index_0;                                           // 0x0090(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0094(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRainComponent_AddCustomRandomByVelocityProcessor) == 0x000008, "Wrong alignment on KuroRainComponent_AddCustomRandomByVelocityProcessor");
static_assert(sizeof(KuroRainComponent_AddCustomRandomByVelocityProcessor) == 0x000098, "Wrong size on KuroRainComponent_AddCustomRandomByVelocityProcessor");
static_assert(offsetof(KuroRainComponent_AddCustomRandomByVelocityProcessor, Curve) == 0x000000, "Member 'KuroRainComponent_AddCustomRandomByVelocityProcessor::Curve' has a wrong offset!");
static_assert(offsetof(KuroRainComponent_AddCustomRandomByVelocityProcessor, Index_0) == 0x000090, "Member 'KuroRainComponent_AddCustomRandomByVelocityProcessor::Index_0' has a wrong offset!");
static_assert(offsetof(KuroRainComponent_AddCustomRandomByVelocityProcessor, ReturnValue) == 0x000094, "Member 'KuroRainComponent_AddCustomRandomByVelocityProcessor::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRainComponent.AddCustomRandomSetProcessor
// 0x000C (0x000C - 0x0000)
struct KuroRainComponent_AddCustomRandomSetProcessor final
{
public:
	float                                         Value;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Index_0;                                           // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRainComponent_AddCustomRandomSetProcessor) == 0x000004, "Wrong alignment on KuroRainComponent_AddCustomRandomSetProcessor");
static_assert(sizeof(KuroRainComponent_AddCustomRandomSetProcessor) == 0x00000C, "Wrong size on KuroRainComponent_AddCustomRandomSetProcessor");
static_assert(offsetof(KuroRainComponent_AddCustomRandomSetProcessor, Value) == 0x000000, "Member 'KuroRainComponent_AddCustomRandomSetProcessor::Value' has a wrong offset!");
static_assert(offsetof(KuroRainComponent_AddCustomRandomSetProcessor, Index_0) == 0x000004, "Member 'KuroRainComponent_AddCustomRandomSetProcessor::Index_0' has a wrong offset!");
static_assert(offsetof(KuroRainComponent_AddCustomRandomSetProcessor, ReturnValue) == 0x000008, "Member 'KuroRainComponent_AddCustomRandomSetProcessor::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRainComponent.AddCycleBoxProcessor
// 0x0020 (0x0020 - 0x0000)
struct KuroRainComponent_AddCycleBoxProcessor final
{
public:
	struct FVector                                Min;                                               // 0x0000(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Max;                                               // 0x000C(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bKillOnZ;                                          // 0x0018(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x3];                                       // 0x0019(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ReturnValue;                                       // 0x001C(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRainComponent_AddCycleBoxProcessor) == 0x000004, "Wrong alignment on KuroRainComponent_AddCycleBoxProcessor");
static_assert(sizeof(KuroRainComponent_AddCycleBoxProcessor) == 0x000020, "Wrong size on KuroRainComponent_AddCycleBoxProcessor");
static_assert(offsetof(KuroRainComponent_AddCycleBoxProcessor, Min) == 0x000000, "Member 'KuroRainComponent_AddCycleBoxProcessor::Min' has a wrong offset!");
static_assert(offsetof(KuroRainComponent_AddCycleBoxProcessor, Max) == 0x00000C, "Member 'KuroRainComponent_AddCycleBoxProcessor::Max' has a wrong offset!");
static_assert(offsetof(KuroRainComponent_AddCycleBoxProcessor, bKillOnZ) == 0x000018, "Member 'KuroRainComponent_AddCycleBoxProcessor::bKillOnZ' has a wrong offset!");
static_assert(offsetof(KuroRainComponent_AddCycleBoxProcessor, ReturnValue) == 0x00001C, "Member 'KuroRainComponent_AddCycleBoxProcessor::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRainComponent.AddDragProcessor
// 0x0008 (0x0008 - 0x0000)
struct KuroRainComponent_AddDragProcessor final
{
public:
	float                                         DragSize;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRainComponent_AddDragProcessor) == 0x000004, "Wrong alignment on KuroRainComponent_AddDragProcessor");
static_assert(sizeof(KuroRainComponent_AddDragProcessor) == 0x000008, "Wrong size on KuroRainComponent_AddDragProcessor");
static_assert(offsetof(KuroRainComponent_AddDragProcessor, DragSize) == 0x000000, "Member 'KuroRainComponent_AddDragProcessor::DragSize' has a wrong offset!");
static_assert(offsetof(KuroRainComponent_AddDragProcessor, ReturnValue) == 0x000004, "Member 'KuroRainComponent_AddDragProcessor::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRainComponent.AddLinearForceProcessor
// 0x0010 (0x0010 - 0x0000)
struct KuroRainComponent_AddLinearForceProcessor final
{
public:
	struct FVector                                Force;                                             // 0x0000(0x000C)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x000C(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRainComponent_AddLinearForceProcessor) == 0x000004, "Wrong alignment on KuroRainComponent_AddLinearForceProcessor");
static_assert(sizeof(KuroRainComponent_AddLinearForceProcessor) == 0x000010, "Wrong size on KuroRainComponent_AddLinearForceProcessor");
static_assert(offsetof(KuroRainComponent_AddLinearForceProcessor, Force) == 0x000000, "Member 'KuroRainComponent_AddLinearForceProcessor::Force' has a wrong offset!");
static_assert(offsetof(KuroRainComponent_AddLinearForceProcessor, ReturnValue) == 0x00000C, "Member 'KuroRainComponent_AddLinearForceProcessor::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRainComponent.AddRandomSpawner
// 0x0008 (0x0008 - 0x0000)
struct KuroRainComponent_AddRandomSpawner final
{
public:
	int32                                         RenderIndex;                                       // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRainComponent_AddRandomSpawner) == 0x000004, "Wrong alignment on KuroRainComponent_AddRandomSpawner");
static_assert(sizeof(KuroRainComponent_AddRandomSpawner) == 0x000008, "Wrong size on KuroRainComponent_AddRandomSpawner");
static_assert(offsetof(KuroRainComponent_AddRandomSpawner, RenderIndex) == 0x000000, "Member 'KuroRainComponent_AddRandomSpawner::RenderIndex' has a wrong offset!");
static_assert(offsetof(KuroRainComponent_AddRandomSpawner, ReturnValue) == 0x000004, "Member 'KuroRainComponent_AddRandomSpawner::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRainComponent.AddVectorFieldForceProcessor
// 0x0028 (0x0028 - 0x0000)
struct KuroRainComponent_AddVectorFieldForceProcessor final
{
public:
	class UVectorFieldStatic*                     InVectorField;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                InPosScale;                                        // 0x0008(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                InMoveSpeed;                                       // 0x0014(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InForceSize;                                       // 0x0020(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0024(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRainComponent_AddVectorFieldForceProcessor) == 0x000008, "Wrong alignment on KuroRainComponent_AddVectorFieldForceProcessor");
static_assert(sizeof(KuroRainComponent_AddVectorFieldForceProcessor) == 0x000028, "Wrong size on KuroRainComponent_AddVectorFieldForceProcessor");
static_assert(offsetof(KuroRainComponent_AddVectorFieldForceProcessor, InVectorField) == 0x000000, "Member 'KuroRainComponent_AddVectorFieldForceProcessor::InVectorField' has a wrong offset!");
static_assert(offsetof(KuroRainComponent_AddVectorFieldForceProcessor, InPosScale) == 0x000008, "Member 'KuroRainComponent_AddVectorFieldForceProcessor::InPosScale' has a wrong offset!");
static_assert(offsetof(KuroRainComponent_AddVectorFieldForceProcessor, InMoveSpeed) == 0x000014, "Member 'KuroRainComponent_AddVectorFieldForceProcessor::InMoveSpeed' has a wrong offset!");
static_assert(offsetof(KuroRainComponent_AddVectorFieldForceProcessor, InForceSize) == 0x000020, "Member 'KuroRainComponent_AddVectorFieldForceProcessor::InForceSize' has a wrong offset!");
static_assert(offsetof(KuroRainComponent_AddVectorFieldForceProcessor, ReturnValue) == 0x000024, "Member 'KuroRainComponent_AddVectorFieldForceProcessor::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRainComponent.AddWindProcessor
// 0x0010 (0x0010 - 0x0000)
struct KuroRainComponent_AddWindProcessor final
{
public:
	struct FVector                                WindVelocity;                                      // 0x0000(0x000C)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x000C(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRainComponent_AddWindProcessor) == 0x000004, "Wrong alignment on KuroRainComponent_AddWindProcessor");
static_assert(sizeof(KuroRainComponent_AddWindProcessor) == 0x000010, "Wrong size on KuroRainComponent_AddWindProcessor");
static_assert(offsetof(KuroRainComponent_AddWindProcessor, WindVelocity) == 0x000000, "Member 'KuroRainComponent_AddWindProcessor::WindVelocity' has a wrong offset!");
static_assert(offsetof(KuroRainComponent_AddWindProcessor, ReturnValue) == 0x00000C, "Member 'KuroRainComponent_AddWindProcessor::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRainComponent.D_SetArraySpawnerRuntime
// 0x0040 (0x0040 - 0x0000)
struct KuroRainComponent_D_SetArraySpawnerRuntime final
{
public:
	int32                                         SpawnerID;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVectorDouble                          SpawnCenter;                                       // 0x0008(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpawnRate;                                         // 0x0020(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                VelocityMin;                                       // 0x0024(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                VelocityMax;                                       // 0x0030(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroRainComponent_D_SetArraySpawnerRuntime) == 0x000008, "Wrong alignment on KuroRainComponent_D_SetArraySpawnerRuntime");
static_assert(sizeof(KuroRainComponent_D_SetArraySpawnerRuntime) == 0x000040, "Wrong size on KuroRainComponent_D_SetArraySpawnerRuntime");
static_assert(offsetof(KuroRainComponent_D_SetArraySpawnerRuntime, SpawnerID) == 0x000000, "Member 'KuroRainComponent_D_SetArraySpawnerRuntime::SpawnerID' has a wrong offset!");
static_assert(offsetof(KuroRainComponent_D_SetArraySpawnerRuntime, SpawnCenter) == 0x000008, "Member 'KuroRainComponent_D_SetArraySpawnerRuntime::SpawnCenter' has a wrong offset!");
static_assert(offsetof(KuroRainComponent_D_SetArraySpawnerRuntime, SpawnRate) == 0x000020, "Member 'KuroRainComponent_D_SetArraySpawnerRuntime::SpawnRate' has a wrong offset!");
static_assert(offsetof(KuroRainComponent_D_SetArraySpawnerRuntime, VelocityMin) == 0x000024, "Member 'KuroRainComponent_D_SetArraySpawnerRuntime::VelocityMin' has a wrong offset!");
static_assert(offsetof(KuroRainComponent_D_SetArraySpawnerRuntime, VelocityMax) == 0x000030, "Member 'KuroRainComponent_D_SetArraySpawnerRuntime::VelocityMax' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRainComponent.D_SetCycleBoxProcessor
// 0x0038 (0x0038 - 0x0000)
struct KuroRainComponent_D_SetCycleBoxProcessor final
{
public:
	int32                                         ProcessorID;                                       // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVectorDouble                          Min;                                               // 0x0008(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVectorDouble                          Max;                                               // 0x0020(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRainComponent_D_SetCycleBoxProcessor) == 0x000008, "Wrong alignment on KuroRainComponent_D_SetCycleBoxProcessor");
static_assert(sizeof(KuroRainComponent_D_SetCycleBoxProcessor) == 0x000038, "Wrong size on KuroRainComponent_D_SetCycleBoxProcessor");
static_assert(offsetof(KuroRainComponent_D_SetCycleBoxProcessor, ProcessorID) == 0x000000, "Member 'KuroRainComponent_D_SetCycleBoxProcessor::ProcessorID' has a wrong offset!");
static_assert(offsetof(KuroRainComponent_D_SetCycleBoxProcessor, Min) == 0x000008, "Member 'KuroRainComponent_D_SetCycleBoxProcessor::Min' has a wrong offset!");
static_assert(offsetof(KuroRainComponent_D_SetCycleBoxProcessor, Max) == 0x000020, "Member 'KuroRainComponent_D_SetCycleBoxProcessor::Max' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRainComponent.D_SetRandomSpawnerRuntime
// 0x0040 (0x0040 - 0x0000)
struct KuroRainComponent_D_SetRandomSpawnerRuntime final
{
public:
	int32                                         SpawnerID;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVectorDouble                          SpawnCenter;                                       // 0x0008(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpawnRate;                                         // 0x0020(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                VelocityMin;                                       // 0x0024(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                VelocityMax;                                       // 0x0030(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroRainComponent_D_SetRandomSpawnerRuntime) == 0x000008, "Wrong alignment on KuroRainComponent_D_SetRandomSpawnerRuntime");
static_assert(sizeof(KuroRainComponent_D_SetRandomSpawnerRuntime) == 0x000040, "Wrong size on KuroRainComponent_D_SetRandomSpawnerRuntime");
static_assert(offsetof(KuroRainComponent_D_SetRandomSpawnerRuntime, SpawnerID) == 0x000000, "Member 'KuroRainComponent_D_SetRandomSpawnerRuntime::SpawnerID' has a wrong offset!");
static_assert(offsetof(KuroRainComponent_D_SetRandomSpawnerRuntime, SpawnCenter) == 0x000008, "Member 'KuroRainComponent_D_SetRandomSpawnerRuntime::SpawnCenter' has a wrong offset!");
static_assert(offsetof(KuroRainComponent_D_SetRandomSpawnerRuntime, SpawnRate) == 0x000020, "Member 'KuroRainComponent_D_SetRandomSpawnerRuntime::SpawnRate' has a wrong offset!");
static_assert(offsetof(KuroRainComponent_D_SetRandomSpawnerRuntime, VelocityMin) == 0x000024, "Member 'KuroRainComponent_D_SetRandomSpawnerRuntime::VelocityMin' has a wrong offset!");
static_assert(offsetof(KuroRainComponent_D_SetRandomSpawnerRuntime, VelocityMax) == 0x000030, "Member 'KuroRainComponent_D_SetRandomSpawnerRuntime::VelocityMax' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRainComponent.GetCycleBoxProcessor_Max
// 0x0010 (0x0010 - 0x0000)
struct KuroRainComponent_GetCycleBoxProcessor_Max final
{
public:
	int32                                         ProcessorID;                                       // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ReturnValue;                                       // 0x0004(0x000C)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRainComponent_GetCycleBoxProcessor_Max) == 0x000004, "Wrong alignment on KuroRainComponent_GetCycleBoxProcessor_Max");
static_assert(sizeof(KuroRainComponent_GetCycleBoxProcessor_Max) == 0x000010, "Wrong size on KuroRainComponent_GetCycleBoxProcessor_Max");
static_assert(offsetof(KuroRainComponent_GetCycleBoxProcessor_Max, ProcessorID) == 0x000000, "Member 'KuroRainComponent_GetCycleBoxProcessor_Max::ProcessorID' has a wrong offset!");
static_assert(offsetof(KuroRainComponent_GetCycleBoxProcessor_Max, ReturnValue) == 0x000004, "Member 'KuroRainComponent_GetCycleBoxProcessor_Max::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRainComponent.GetCycleBoxProcessor_Min
// 0x0010 (0x0010 - 0x0000)
struct KuroRainComponent_GetCycleBoxProcessor_Min final
{
public:
	int32                                         ProcessorID;                                       // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ReturnValue;                                       // 0x0004(0x000C)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRainComponent_GetCycleBoxProcessor_Min) == 0x000004, "Wrong alignment on KuroRainComponent_GetCycleBoxProcessor_Min");
static_assert(sizeof(KuroRainComponent_GetCycleBoxProcessor_Min) == 0x000010, "Wrong size on KuroRainComponent_GetCycleBoxProcessor_Min");
static_assert(offsetof(KuroRainComponent_GetCycleBoxProcessor_Min, ProcessorID) == 0x000000, "Member 'KuroRainComponent_GetCycleBoxProcessor_Min::ProcessorID' has a wrong offset!");
static_assert(offsetof(KuroRainComponent_GetCycleBoxProcessor_Min, ReturnValue) == 0x000004, "Member 'KuroRainComponent_GetCycleBoxProcessor_Min::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRainComponent.GetDragProcessor_DragSize
// 0x0008 (0x0008 - 0x0000)
struct KuroRainComponent_GetDragProcessor_DragSize final
{
public:
	int32                                         ProcessorID;                                       // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRainComponent_GetDragProcessor_DragSize) == 0x000004, "Wrong alignment on KuroRainComponent_GetDragProcessor_DragSize");
static_assert(sizeof(KuroRainComponent_GetDragProcessor_DragSize) == 0x000008, "Wrong size on KuroRainComponent_GetDragProcessor_DragSize");
static_assert(offsetof(KuroRainComponent_GetDragProcessor_DragSize, ProcessorID) == 0x000000, "Member 'KuroRainComponent_GetDragProcessor_DragSize::ProcessorID' has a wrong offset!");
static_assert(offsetof(KuroRainComponent_GetDragProcessor_DragSize, ReturnValue) == 0x000004, "Member 'KuroRainComponent_GetDragProcessor_DragSize::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRainComponent.GetEmitterDataNum
// 0x0004 (0x0004 - 0x0000)
struct KuroRainComponent_GetEmitterDataNum final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRainComponent_GetEmitterDataNum) == 0x000004, "Wrong alignment on KuroRainComponent_GetEmitterDataNum");
static_assert(sizeof(KuroRainComponent_GetEmitterDataNum) == 0x000004, "Wrong size on KuroRainComponent_GetEmitterDataNum");
static_assert(offsetof(KuroRainComponent_GetEmitterDataNum, ReturnValue) == 0x000000, "Member 'KuroRainComponent_GetEmitterDataNum::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRainComponent.GetIsPlaying
// 0x0001 (0x0001 - 0x0000)
struct KuroRainComponent_GetIsPlaying final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRainComponent_GetIsPlaying) == 0x000001, "Wrong alignment on KuroRainComponent_GetIsPlaying");
static_assert(sizeof(KuroRainComponent_GetIsPlaying) == 0x000001, "Wrong size on KuroRainComponent_GetIsPlaying");
static_assert(offsetof(KuroRainComponent_GetIsPlaying, ReturnValue) == 0x000000, "Member 'KuroRainComponent_GetIsPlaying::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRainComponent.GetLinearForceProcessor_Force
// 0x0010 (0x0010 - 0x0000)
struct KuroRainComponent_GetLinearForceProcessor_Force final
{
public:
	int32                                         ProcessorID;                                       // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ReturnValue;                                       // 0x0004(0x000C)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRainComponent_GetLinearForceProcessor_Force) == 0x000004, "Wrong alignment on KuroRainComponent_GetLinearForceProcessor_Force");
static_assert(sizeof(KuroRainComponent_GetLinearForceProcessor_Force) == 0x000010, "Wrong size on KuroRainComponent_GetLinearForceProcessor_Force");
static_assert(offsetof(KuroRainComponent_GetLinearForceProcessor_Force, ProcessorID) == 0x000000, "Member 'KuroRainComponent_GetLinearForceProcessor_Force::ProcessorID' has a wrong offset!");
static_assert(offsetof(KuroRainComponent_GetLinearForceProcessor_Force, ReturnValue) == 0x000004, "Member 'KuroRainComponent_GetLinearForceProcessor_Force::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRainComponent.GetWindProcessor_WindVelocity
// 0x0010 (0x0010 - 0x0000)
struct KuroRainComponent_GetWindProcessor_WindVelocity final
{
public:
	int32                                         ProcessorID;                                       // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ReturnValue;                                       // 0x0004(0x000C)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRainComponent_GetWindProcessor_WindVelocity) == 0x000004, "Wrong alignment on KuroRainComponent_GetWindProcessor_WindVelocity");
static_assert(sizeof(KuroRainComponent_GetWindProcessor_WindVelocity) == 0x000010, "Wrong size on KuroRainComponent_GetWindProcessor_WindVelocity");
static_assert(offsetof(KuroRainComponent_GetWindProcessor_WindVelocity, ProcessorID) == 0x000000, "Member 'KuroRainComponent_GetWindProcessor_WindVelocity::ProcessorID' has a wrong offset!");
static_assert(offsetof(KuroRainComponent_GetWindProcessor_WindVelocity, ReturnValue) == 0x000004, "Member 'KuroRainComponent_GetWindProcessor_WindVelocity::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRainComponent.PreSolveRainParticles
// 0x0004 (0x0004 - 0x0000)
struct KuroRainComponent_PreSolveRainParticles final
{
public:
	float                                         DeltaSeconds;                                      // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRainComponent_PreSolveRainParticles) == 0x000004, "Wrong alignment on KuroRainComponent_PreSolveRainParticles");
static_assert(sizeof(KuroRainComponent_PreSolveRainParticles) == 0x000004, "Wrong size on KuroRainComponent_PreSolveRainParticles");
static_assert(offsetof(KuroRainComponent_PreSolveRainParticles, DeltaSeconds) == 0x000000, "Member 'KuroRainComponent_PreSolveRainParticles::DeltaSeconds' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRainComponent.SetArraySpawnerBasic
// 0x002C (0x002C - 0x0000)
struct KuroRainComponent_SetArraySpawnerBasic final
{
public:
	int32                                         SpawnerID;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ArraySize;                                         // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ArrayLength;                                       // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpawnTimeWiggle;                                   // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpawnPositionWiggle;                               // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LifeTimeMin;                                       // 0x0014(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LifeTimeMax;                                       // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ScaleMin;                                          // 0x001C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ScaleMax;                                          // 0x0020(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BaseMassMin;                                       // 0x0024(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BaseMassMax;                                       // 0x0028(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRainComponent_SetArraySpawnerBasic) == 0x000004, "Wrong alignment on KuroRainComponent_SetArraySpawnerBasic");
static_assert(sizeof(KuroRainComponent_SetArraySpawnerBasic) == 0x00002C, "Wrong size on KuroRainComponent_SetArraySpawnerBasic");
static_assert(offsetof(KuroRainComponent_SetArraySpawnerBasic, SpawnerID) == 0x000000, "Member 'KuroRainComponent_SetArraySpawnerBasic::SpawnerID' has a wrong offset!");
static_assert(offsetof(KuroRainComponent_SetArraySpawnerBasic, ArraySize) == 0x000004, "Member 'KuroRainComponent_SetArraySpawnerBasic::ArraySize' has a wrong offset!");
static_assert(offsetof(KuroRainComponent_SetArraySpawnerBasic, ArrayLength) == 0x000008, "Member 'KuroRainComponent_SetArraySpawnerBasic::ArrayLength' has a wrong offset!");
static_assert(offsetof(KuroRainComponent_SetArraySpawnerBasic, SpawnTimeWiggle) == 0x00000C, "Member 'KuroRainComponent_SetArraySpawnerBasic::SpawnTimeWiggle' has a wrong offset!");
static_assert(offsetof(KuroRainComponent_SetArraySpawnerBasic, SpawnPositionWiggle) == 0x000010, "Member 'KuroRainComponent_SetArraySpawnerBasic::SpawnPositionWiggle' has a wrong offset!");
static_assert(offsetof(KuroRainComponent_SetArraySpawnerBasic, LifeTimeMin) == 0x000014, "Member 'KuroRainComponent_SetArraySpawnerBasic::LifeTimeMin' has a wrong offset!");
static_assert(offsetof(KuroRainComponent_SetArraySpawnerBasic, LifeTimeMax) == 0x000018, "Member 'KuroRainComponent_SetArraySpawnerBasic::LifeTimeMax' has a wrong offset!");
static_assert(offsetof(KuroRainComponent_SetArraySpawnerBasic, ScaleMin) == 0x00001C, "Member 'KuroRainComponent_SetArraySpawnerBasic::ScaleMin' has a wrong offset!");
static_assert(offsetof(KuroRainComponent_SetArraySpawnerBasic, ScaleMax) == 0x000020, "Member 'KuroRainComponent_SetArraySpawnerBasic::ScaleMax' has a wrong offset!");
static_assert(offsetof(KuroRainComponent_SetArraySpawnerBasic, BaseMassMin) == 0x000024, "Member 'KuroRainComponent_SetArraySpawnerBasic::BaseMassMin' has a wrong offset!");
static_assert(offsetof(KuroRainComponent_SetArraySpawnerBasic, BaseMassMax) == 0x000028, "Member 'KuroRainComponent_SetArraySpawnerBasic::BaseMassMax' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRainComponent.SetArraySpawnerRuntime
// 0x002C (0x002C - 0x0000)
struct KuroRainComponent_SetArraySpawnerRuntime final
{
public:
	int32                                         SpawnerID;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                SpawnCenter;                                       // 0x0004(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpawnRate;                                         // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                VelocityMin;                                       // 0x0014(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                VelocityMax;                                       // 0x0020(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRainComponent_SetArraySpawnerRuntime) == 0x000004, "Wrong alignment on KuroRainComponent_SetArraySpawnerRuntime");
static_assert(sizeof(KuroRainComponent_SetArraySpawnerRuntime) == 0x00002C, "Wrong size on KuroRainComponent_SetArraySpawnerRuntime");
static_assert(offsetof(KuroRainComponent_SetArraySpawnerRuntime, SpawnerID) == 0x000000, "Member 'KuroRainComponent_SetArraySpawnerRuntime::SpawnerID' has a wrong offset!");
static_assert(offsetof(KuroRainComponent_SetArraySpawnerRuntime, SpawnCenter) == 0x000004, "Member 'KuroRainComponent_SetArraySpawnerRuntime::SpawnCenter' has a wrong offset!");
static_assert(offsetof(KuroRainComponent_SetArraySpawnerRuntime, SpawnRate) == 0x000010, "Member 'KuroRainComponent_SetArraySpawnerRuntime::SpawnRate' has a wrong offset!");
static_assert(offsetof(KuroRainComponent_SetArraySpawnerRuntime, VelocityMin) == 0x000014, "Member 'KuroRainComponent_SetArraySpawnerRuntime::VelocityMin' has a wrong offset!");
static_assert(offsetof(KuroRainComponent_SetArraySpawnerRuntime, VelocityMax) == 0x000020, "Member 'KuroRainComponent_SetArraySpawnerRuntime::VelocityMax' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRainComponent.SetCustomRandomByNormalizedAgeProcessor
// 0x00A0 (0x00A0 - 0x0000)
struct KuroRainComponent_SetCustomRandomByNormalizedAgeProcessor final
{
public:
	int32                                         ProcessorID;                                       // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FKuroCurveFloat                        Curve;                                             // 0x0008(0x0090)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	int32                                         Index_0;                                           // 0x0098(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9C[0x4];                                       // 0x009C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroRainComponent_SetCustomRandomByNormalizedAgeProcessor) == 0x000008, "Wrong alignment on KuroRainComponent_SetCustomRandomByNormalizedAgeProcessor");
static_assert(sizeof(KuroRainComponent_SetCustomRandomByNormalizedAgeProcessor) == 0x0000A0, "Wrong size on KuroRainComponent_SetCustomRandomByNormalizedAgeProcessor");
static_assert(offsetof(KuroRainComponent_SetCustomRandomByNormalizedAgeProcessor, ProcessorID) == 0x000000, "Member 'KuroRainComponent_SetCustomRandomByNormalizedAgeProcessor::ProcessorID' has a wrong offset!");
static_assert(offsetof(KuroRainComponent_SetCustomRandomByNormalizedAgeProcessor, Curve) == 0x000008, "Member 'KuroRainComponent_SetCustomRandomByNormalizedAgeProcessor::Curve' has a wrong offset!");
static_assert(offsetof(KuroRainComponent_SetCustomRandomByNormalizedAgeProcessor, Index_0) == 0x000098, "Member 'KuroRainComponent_SetCustomRandomByNormalizedAgeProcessor::Index_0' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRainComponent.SetCustomRandomByVelocityProcessor
// 0x00A0 (0x00A0 - 0x0000)
struct KuroRainComponent_SetCustomRandomByVelocityProcessor final
{
public:
	int32                                         ProcessorID;                                       // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FKuroCurveFloat                        Curve;                                             // 0x0008(0x0090)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	int32                                         Index_0;                                           // 0x0098(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9C[0x4];                                       // 0x009C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroRainComponent_SetCustomRandomByVelocityProcessor) == 0x000008, "Wrong alignment on KuroRainComponent_SetCustomRandomByVelocityProcessor");
static_assert(sizeof(KuroRainComponent_SetCustomRandomByVelocityProcessor) == 0x0000A0, "Wrong size on KuroRainComponent_SetCustomRandomByVelocityProcessor");
static_assert(offsetof(KuroRainComponent_SetCustomRandomByVelocityProcessor, ProcessorID) == 0x000000, "Member 'KuroRainComponent_SetCustomRandomByVelocityProcessor::ProcessorID' has a wrong offset!");
static_assert(offsetof(KuroRainComponent_SetCustomRandomByVelocityProcessor, Curve) == 0x000008, "Member 'KuroRainComponent_SetCustomRandomByVelocityProcessor::Curve' has a wrong offset!");
static_assert(offsetof(KuroRainComponent_SetCustomRandomByVelocityProcessor, Index_0) == 0x000098, "Member 'KuroRainComponent_SetCustomRandomByVelocityProcessor::Index_0' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRainComponent.SetCustomRandomSetProcessor
// 0x000C (0x000C - 0x0000)
struct KuroRainComponent_SetCustomRandomSetProcessor final
{
public:
	int32                                         ProcessorID;                                       // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Value;                                             // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Index_0;                                           // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRainComponent_SetCustomRandomSetProcessor) == 0x000004, "Wrong alignment on KuroRainComponent_SetCustomRandomSetProcessor");
static_assert(sizeof(KuroRainComponent_SetCustomRandomSetProcessor) == 0x00000C, "Wrong size on KuroRainComponent_SetCustomRandomSetProcessor");
static_assert(offsetof(KuroRainComponent_SetCustomRandomSetProcessor, ProcessorID) == 0x000000, "Member 'KuroRainComponent_SetCustomRandomSetProcessor::ProcessorID' has a wrong offset!");
static_assert(offsetof(KuroRainComponent_SetCustomRandomSetProcessor, Value) == 0x000004, "Member 'KuroRainComponent_SetCustomRandomSetProcessor::Value' has a wrong offset!");
static_assert(offsetof(KuroRainComponent_SetCustomRandomSetProcessor, Index_0) == 0x000008, "Member 'KuroRainComponent_SetCustomRandomSetProcessor::Index_0' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRainComponent.SetCycleBoxProcessor
// 0x001C (0x001C - 0x0000)
struct KuroRainComponent_SetCycleBoxProcessor final
{
public:
	int32                                         ProcessorID;                                       // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Min;                                               // 0x0004(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Max;                                               // 0x0010(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRainComponent_SetCycleBoxProcessor) == 0x000004, "Wrong alignment on KuroRainComponent_SetCycleBoxProcessor");
static_assert(sizeof(KuroRainComponent_SetCycleBoxProcessor) == 0x00001C, "Wrong size on KuroRainComponent_SetCycleBoxProcessor");
static_assert(offsetof(KuroRainComponent_SetCycleBoxProcessor, ProcessorID) == 0x000000, "Member 'KuroRainComponent_SetCycleBoxProcessor::ProcessorID' has a wrong offset!");
static_assert(offsetof(KuroRainComponent_SetCycleBoxProcessor, Min) == 0x000004, "Member 'KuroRainComponent_SetCycleBoxProcessor::Min' has a wrong offset!");
static_assert(offsetof(KuroRainComponent_SetCycleBoxProcessor, Max) == 0x000010, "Member 'KuroRainComponent_SetCycleBoxProcessor::Max' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRainComponent.SetDragProcessor
// 0x0008 (0x0008 - 0x0000)
struct KuroRainComponent_SetDragProcessor final
{
public:
	int32                                         ProcessorID;                                       // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DragSize;                                          // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRainComponent_SetDragProcessor) == 0x000004, "Wrong alignment on KuroRainComponent_SetDragProcessor");
static_assert(sizeof(KuroRainComponent_SetDragProcessor) == 0x000008, "Wrong size on KuroRainComponent_SetDragProcessor");
static_assert(offsetof(KuroRainComponent_SetDragProcessor, ProcessorID) == 0x000000, "Member 'KuroRainComponent_SetDragProcessor::ProcessorID' has a wrong offset!");
static_assert(offsetof(KuroRainComponent_SetDragProcessor, DragSize) == 0x000004, "Member 'KuroRainComponent_SetDragProcessor::DragSize' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRainComponent.SetLifeTimeDilation
// 0x0004 (0x0004 - 0x0000)
struct KuroRainComponent_SetLifeTimeDilation final
{
public:
	float                                         Dilation;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRainComponent_SetLifeTimeDilation) == 0x000004, "Wrong alignment on KuroRainComponent_SetLifeTimeDilation");
static_assert(sizeof(KuroRainComponent_SetLifeTimeDilation) == 0x000004, "Wrong size on KuroRainComponent_SetLifeTimeDilation");
static_assert(offsetof(KuroRainComponent_SetLifeTimeDilation, Dilation) == 0x000000, "Member 'KuroRainComponent_SetLifeTimeDilation::Dilation' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRainComponent.SetLinearForceProcessor
// 0x0010 (0x0010 - 0x0000)
struct KuroRainComponent_SetLinearForceProcessor final
{
public:
	int32                                         ProcessorID;                                       // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Force;                                             // 0x0004(0x000C)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRainComponent_SetLinearForceProcessor) == 0x000004, "Wrong alignment on KuroRainComponent_SetLinearForceProcessor");
static_assert(sizeof(KuroRainComponent_SetLinearForceProcessor) == 0x000010, "Wrong size on KuroRainComponent_SetLinearForceProcessor");
static_assert(offsetof(KuroRainComponent_SetLinearForceProcessor, ProcessorID) == 0x000000, "Member 'KuroRainComponent_SetLinearForceProcessor::ProcessorID' has a wrong offset!");
static_assert(offsetof(KuroRainComponent_SetLinearForceProcessor, Force) == 0x000004, "Member 'KuroRainComponent_SetLinearForceProcessor::Force' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRainComponent.SetRandomSpawnerBasic
// 0x0024 (0x0024 - 0x0000)
struct KuroRainComponent_SetRandomSpawnerBasic final
{
public:
	int32                                         SpawnerID;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpawnInnerRadius;                                  // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpawnOuterRadius;                                  // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LifeTimeMin;                                       // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LifeTimeMax;                                       // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ScaleMin;                                          // 0x0014(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ScaleMax;                                          // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BaseMassMin;                                       // 0x001C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BaseMassMax;                                       // 0x0020(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRainComponent_SetRandomSpawnerBasic) == 0x000004, "Wrong alignment on KuroRainComponent_SetRandomSpawnerBasic");
static_assert(sizeof(KuroRainComponent_SetRandomSpawnerBasic) == 0x000024, "Wrong size on KuroRainComponent_SetRandomSpawnerBasic");
static_assert(offsetof(KuroRainComponent_SetRandomSpawnerBasic, SpawnerID) == 0x000000, "Member 'KuroRainComponent_SetRandomSpawnerBasic::SpawnerID' has a wrong offset!");
static_assert(offsetof(KuroRainComponent_SetRandomSpawnerBasic, SpawnInnerRadius) == 0x000004, "Member 'KuroRainComponent_SetRandomSpawnerBasic::SpawnInnerRadius' has a wrong offset!");
static_assert(offsetof(KuroRainComponent_SetRandomSpawnerBasic, SpawnOuterRadius) == 0x000008, "Member 'KuroRainComponent_SetRandomSpawnerBasic::SpawnOuterRadius' has a wrong offset!");
static_assert(offsetof(KuroRainComponent_SetRandomSpawnerBasic, LifeTimeMin) == 0x00000C, "Member 'KuroRainComponent_SetRandomSpawnerBasic::LifeTimeMin' has a wrong offset!");
static_assert(offsetof(KuroRainComponent_SetRandomSpawnerBasic, LifeTimeMax) == 0x000010, "Member 'KuroRainComponent_SetRandomSpawnerBasic::LifeTimeMax' has a wrong offset!");
static_assert(offsetof(KuroRainComponent_SetRandomSpawnerBasic, ScaleMin) == 0x000014, "Member 'KuroRainComponent_SetRandomSpawnerBasic::ScaleMin' has a wrong offset!");
static_assert(offsetof(KuroRainComponent_SetRandomSpawnerBasic, ScaleMax) == 0x000018, "Member 'KuroRainComponent_SetRandomSpawnerBasic::ScaleMax' has a wrong offset!");
static_assert(offsetof(KuroRainComponent_SetRandomSpawnerBasic, BaseMassMin) == 0x00001C, "Member 'KuroRainComponent_SetRandomSpawnerBasic::BaseMassMin' has a wrong offset!");
static_assert(offsetof(KuroRainComponent_SetRandomSpawnerBasic, BaseMassMax) == 0x000020, "Member 'KuroRainComponent_SetRandomSpawnerBasic::BaseMassMax' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRainComponent.SetRandomSpawnerRuntime
// 0x002C (0x002C - 0x0000)
struct KuroRainComponent_SetRandomSpawnerRuntime final
{
public:
	int32                                         SpawnerID;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                SpawnCenter;                                       // 0x0004(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpawnRate;                                         // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                VelocityMin;                                       // 0x0014(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                VelocityMax;                                       // 0x0020(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRainComponent_SetRandomSpawnerRuntime) == 0x000004, "Wrong alignment on KuroRainComponent_SetRandomSpawnerRuntime");
static_assert(sizeof(KuroRainComponent_SetRandomSpawnerRuntime) == 0x00002C, "Wrong size on KuroRainComponent_SetRandomSpawnerRuntime");
static_assert(offsetof(KuroRainComponent_SetRandomSpawnerRuntime, SpawnerID) == 0x000000, "Member 'KuroRainComponent_SetRandomSpawnerRuntime::SpawnerID' has a wrong offset!");
static_assert(offsetof(KuroRainComponent_SetRandomSpawnerRuntime, SpawnCenter) == 0x000004, "Member 'KuroRainComponent_SetRandomSpawnerRuntime::SpawnCenter' has a wrong offset!");
static_assert(offsetof(KuroRainComponent_SetRandomSpawnerRuntime, SpawnRate) == 0x000010, "Member 'KuroRainComponent_SetRandomSpawnerRuntime::SpawnRate' has a wrong offset!");
static_assert(offsetof(KuroRainComponent_SetRandomSpawnerRuntime, VelocityMin) == 0x000014, "Member 'KuroRainComponent_SetRandomSpawnerRuntime::VelocityMin' has a wrong offset!");
static_assert(offsetof(KuroRainComponent_SetRandomSpawnerRuntime, VelocityMax) == 0x000020, "Member 'KuroRainComponent_SetRandomSpawnerRuntime::VelocityMax' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRainComponent.SetTimeDilation
// 0x0004 (0x0004 - 0x0000)
struct KuroRainComponent_SetTimeDilation final
{
public:
	float                                         Dilation;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRainComponent_SetTimeDilation) == 0x000004, "Wrong alignment on KuroRainComponent_SetTimeDilation");
static_assert(sizeof(KuroRainComponent_SetTimeDilation) == 0x000004, "Wrong size on KuroRainComponent_SetTimeDilation");
static_assert(offsetof(KuroRainComponent_SetTimeDilation, Dilation) == 0x000000, "Member 'KuroRainComponent_SetTimeDilation::Dilation' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRainComponent.Setup
// 0x0020 (0x0020 - 0x0000)
struct KuroRainComponent_Setup final
{
public:
	TArray<class UStaticMesh*>                    Meshes;                                            // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	TArray<class UMaterialInterface*>             Materials;                                         // 0x0010(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRainComponent_Setup) == 0x000008, "Wrong alignment on KuroRainComponent_Setup");
static_assert(sizeof(KuroRainComponent_Setup) == 0x000020, "Wrong size on KuroRainComponent_Setup");
static_assert(offsetof(KuroRainComponent_Setup, Meshes) == 0x000000, "Member 'KuroRainComponent_Setup::Meshes' has a wrong offset!");
static_assert(offsetof(KuroRainComponent_Setup, Materials) == 0x000010, "Member 'KuroRainComponent_Setup::Materials' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRainComponent.SetVectorFieldForceProcessor_Others
// 0x0020 (0x0020 - 0x0000)
struct KuroRainComponent_SetVectorFieldForceProcessor_Others final
{
public:
	int32                                         ProcessorID;                                       // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                InPosScale;                                        // 0x0004(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                InMoveSpeed;                                       // 0x0010(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InForceSize;                                       // 0x001C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRainComponent_SetVectorFieldForceProcessor_Others) == 0x000004, "Wrong alignment on KuroRainComponent_SetVectorFieldForceProcessor_Others");
static_assert(sizeof(KuroRainComponent_SetVectorFieldForceProcessor_Others) == 0x000020, "Wrong size on KuroRainComponent_SetVectorFieldForceProcessor_Others");
static_assert(offsetof(KuroRainComponent_SetVectorFieldForceProcessor_Others, ProcessorID) == 0x000000, "Member 'KuroRainComponent_SetVectorFieldForceProcessor_Others::ProcessorID' has a wrong offset!");
static_assert(offsetof(KuroRainComponent_SetVectorFieldForceProcessor_Others, InPosScale) == 0x000004, "Member 'KuroRainComponent_SetVectorFieldForceProcessor_Others::InPosScale' has a wrong offset!");
static_assert(offsetof(KuroRainComponent_SetVectorFieldForceProcessor_Others, InMoveSpeed) == 0x000010, "Member 'KuroRainComponent_SetVectorFieldForceProcessor_Others::InMoveSpeed' has a wrong offset!");
static_assert(offsetof(KuroRainComponent_SetVectorFieldForceProcessor_Others, InForceSize) == 0x00001C, "Member 'KuroRainComponent_SetVectorFieldForceProcessor_Others::InForceSize' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRainComponent.SetVectorFieldForceProcessor_VectorField
// 0x0010 (0x0010 - 0x0000)
struct KuroRainComponent_SetVectorFieldForceProcessor_VectorField final
{
public:
	int32                                         ProcessorID;                                       // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UVectorFieldStatic*                     InVectorField;                                     // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRainComponent_SetVectorFieldForceProcessor_VectorField) == 0x000008, "Wrong alignment on KuroRainComponent_SetVectorFieldForceProcessor_VectorField");
static_assert(sizeof(KuroRainComponent_SetVectorFieldForceProcessor_VectorField) == 0x000010, "Wrong size on KuroRainComponent_SetVectorFieldForceProcessor_VectorField");
static_assert(offsetof(KuroRainComponent_SetVectorFieldForceProcessor_VectorField, ProcessorID) == 0x000000, "Member 'KuroRainComponent_SetVectorFieldForceProcessor_VectorField::ProcessorID' has a wrong offset!");
static_assert(offsetof(KuroRainComponent_SetVectorFieldForceProcessor_VectorField, InVectorField) == 0x000008, "Member 'KuroRainComponent_SetVectorFieldForceProcessor_VectorField::InVectorField' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRainComponent.SetWindProcessor
// 0x0010 (0x0010 - 0x0000)
struct KuroRainComponent_SetWindProcessor final
{
public:
	int32                                         ProcessorID;                                       // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                WindVelocity;                                      // 0x0004(0x000C)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRainComponent_SetWindProcessor) == 0x000004, "Wrong alignment on KuroRainComponent_SetWindProcessor");
static_assert(sizeof(KuroRainComponent_SetWindProcessor) == 0x000010, "Wrong size on KuroRainComponent_SetWindProcessor");
static_assert(offsetof(KuroRainComponent_SetWindProcessor, ProcessorID) == 0x000000, "Member 'KuroRainComponent_SetWindProcessor::ProcessorID' has a wrong offset!");
static_assert(offsetof(KuroRainComponent_SetWindProcessor, WindVelocity) == 0x000004, "Member 'KuroRainComponent_SetWindProcessor::WindVelocity' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroWorldRainComponent.GetIsRainActive
// 0x0001 (0x0001 - 0x0000)
struct KuroWorldRainComponent_GetIsRainActive final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroWorldRainComponent_GetIsRainActive) == 0x000001, "Wrong alignment on KuroWorldRainComponent_GetIsRainActive");
static_assert(sizeof(KuroWorldRainComponent_GetIsRainActive) == 0x000001, "Wrong size on KuroWorldRainComponent_GetIsRainActive");
static_assert(offsetof(KuroWorldRainComponent_GetIsRainActive, ReturnValue) == 0x000000, "Member 'KuroWorldRainComponent_GetIsRainActive::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroWorldRainComponent.GetIsRainPlaying
// 0x0001 (0x0001 - 0x0000)
struct KuroWorldRainComponent_GetIsRainPlaying final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroWorldRainComponent_GetIsRainPlaying) == 0x000001, "Wrong alignment on KuroWorldRainComponent_GetIsRainPlaying");
static_assert(sizeof(KuroWorldRainComponent_GetIsRainPlaying) == 0x000001, "Wrong size on KuroWorldRainComponent_GetIsRainPlaying");
static_assert(offsetof(KuroWorldRainComponent_GetIsRainPlaying, ReturnValue) == 0x000000, "Member 'KuroWorldRainComponent_GetIsRainPlaying::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroWorldRainComponent.SetBaseSpawnScale
// 0x0004 (0x0004 - 0x0000)
struct KuroWorldRainComponent_SetBaseSpawnScale final
{
public:
	float                                         SpawnScale;                                        // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroWorldRainComponent_SetBaseSpawnScale) == 0x000004, "Wrong alignment on KuroWorldRainComponent_SetBaseSpawnScale");
static_assert(sizeof(KuroWorldRainComponent_SetBaseSpawnScale) == 0x000004, "Wrong size on KuroWorldRainComponent_SetBaseSpawnScale");
static_assert(offsetof(KuroWorldRainComponent_SetBaseSpawnScale, SpawnScale) == 0x000000, "Member 'KuroWorldRainComponent_SetBaseSpawnScale::SpawnScale' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroWorldRainComponent.SetCenter
// 0x000C (0x000C - 0x0000)
struct KuroWorldRainComponent_SetCenter final
{
public:
	struct FVector                                InCenter;                                          // 0x0000(0x000C)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroWorldRainComponent_SetCenter) == 0x000004, "Wrong alignment on KuroWorldRainComponent_SetCenter");
static_assert(sizeof(KuroWorldRainComponent_SetCenter) == 0x00000C, "Wrong size on KuroWorldRainComponent_SetCenter");
static_assert(offsetof(KuroWorldRainComponent_SetCenter, InCenter) == 0x000000, "Member 'KuroWorldRainComponent_SetCenter::InCenter' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroWorldRainComponent.SetGlobalWind
// 0x000C (0x000C - 0x0000)
struct KuroWorldRainComponent_SetGlobalWind final
{
public:
	struct FVector                                InGlobalWind;                                      // 0x0000(0x000C)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroWorldRainComponent_SetGlobalWind) == 0x000004, "Wrong alignment on KuroWorldRainComponent_SetGlobalWind");
static_assert(sizeof(KuroWorldRainComponent_SetGlobalWind) == 0x00000C, "Wrong size on KuroWorldRainComponent_SetGlobalWind");
static_assert(offsetof(KuroWorldRainComponent_SetGlobalWind, InGlobalWind) == 0x000000, "Member 'KuroWorldRainComponent_SetGlobalWind::InGlobalWind' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroBezierMeshComponent.AddLayer
// 0x0004 (0x0004 - 0x0000)
struct KuroBezierMeshComponent_AddLayer final
{
public:
	float                                         alpha;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroBezierMeshComponent_AddLayer) == 0x000004, "Wrong alignment on KuroBezierMeshComponent_AddLayer");
static_assert(sizeof(KuroBezierMeshComponent_AddLayer) == 0x000004, "Wrong size on KuroBezierMeshComponent_AddLayer");
static_assert(offsetof(KuroBezierMeshComponent_AddLayer, alpha) == 0x000000, "Member 'KuroBezierMeshComponent_AddLayer::alpha' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroBezierMeshComponent.Dissipate
// 0x0004 (0x0004 - 0x0000)
struct KuroBezierMeshComponent_Dissipate final
{
public:
	float                                         SubLayersNum;                                      // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroBezierMeshComponent_Dissipate) == 0x000004, "Wrong alignment on KuroBezierMeshComponent_Dissipate");
static_assert(sizeof(KuroBezierMeshComponent_Dissipate) == 0x000004, "Wrong size on KuroBezierMeshComponent_Dissipate");
static_assert(offsetof(KuroBezierMeshComponent_Dissipate, SubLayersNum) == 0x000000, "Member 'KuroBezierMeshComponent_Dissipate::SubLayersNum' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroBezierMeshComponent.GetLayerNum
// 0x0004 (0x0004 - 0x0000)
struct KuroBezierMeshComponent_GetLayerNum final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroBezierMeshComponent_GetLayerNum) == 0x000004, "Wrong alignment on KuroBezierMeshComponent_GetLayerNum");
static_assert(sizeof(KuroBezierMeshComponent_GetLayerNum) == 0x000004, "Wrong size on KuroBezierMeshComponent_GetLayerNum");
static_assert(offsetof(KuroBezierMeshComponent_GetLayerNum, ReturnValue) == 0x000000, "Member 'KuroBezierMeshComponent_GetLayerNum::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroBezierMeshComponent.GetMeshHeight
// 0x0004 (0x0004 - 0x0000)
struct KuroBezierMeshComponent_GetMeshHeight final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroBezierMeshComponent_GetMeshHeight) == 0x000004, "Wrong alignment on KuroBezierMeshComponent_GetMeshHeight");
static_assert(sizeof(KuroBezierMeshComponent_GetMeshHeight) == 0x000004, "Wrong size on KuroBezierMeshComponent_GetMeshHeight");
static_assert(offsetof(KuroBezierMeshComponent_GetMeshHeight, ReturnValue) == 0x000000, "Member 'KuroBezierMeshComponent_GetMeshHeight::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroBezierMeshComponent.GetMeshPoints
// 0x0010 (0x0010 - 0x0000)
struct KuroBezierMeshComponent_GetMeshPoints final
{
public:
	TArray<struct FVector>                        ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroBezierMeshComponent_GetMeshPoints) == 0x000008, "Wrong alignment on KuroBezierMeshComponent_GetMeshPoints");
static_assert(sizeof(KuroBezierMeshComponent_GetMeshPoints) == 0x000010, "Wrong size on KuroBezierMeshComponent_GetMeshPoints");
static_assert(offsetof(KuroBezierMeshComponent_GetMeshPoints, ReturnValue) == 0x000000, "Member 'KuroBezierMeshComponent_GetMeshPoints::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroBezierMeshComponent.GetMeshTriangles
// 0x0010 (0x0010 - 0x0000)
struct KuroBezierMeshComponent_GetMeshTriangles final
{
public:
	TArray<int32>                                 ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroBezierMeshComponent_GetMeshTriangles) == 0x000008, "Wrong alignment on KuroBezierMeshComponent_GetMeshTriangles");
static_assert(sizeof(KuroBezierMeshComponent_GetMeshTriangles) == 0x000010, "Wrong size on KuroBezierMeshComponent_GetMeshTriangles");
static_assert(offsetof(KuroBezierMeshComponent_GetMeshTriangles, ReturnValue) == 0x000000, "Member 'KuroBezierMeshComponent_GetMeshTriangles::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroBezierMeshComponent.GetMeshWidth
// 0x0004 (0x0004 - 0x0000)
struct KuroBezierMeshComponent_GetMeshWidth final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroBezierMeshComponent_GetMeshWidth) == 0x000004, "Wrong alignment on KuroBezierMeshComponent_GetMeshWidth");
static_assert(sizeof(KuroBezierMeshComponent_GetMeshWidth) == 0x000004, "Wrong size on KuroBezierMeshComponent_GetMeshWidth");
static_assert(offsetof(KuroBezierMeshComponent_GetMeshWidth, ReturnValue) == 0x000000, "Member 'KuroBezierMeshComponent_GetMeshWidth::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroBezierMeshComponent.GetPointsArray
// 0x0010 (0x0010 - 0x0000)
struct KuroBezierMeshComponent_GetPointsArray final
{
public:
	TArray<struct FVector>                        ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroBezierMeshComponent_GetPointsArray) == 0x000008, "Wrong alignment on KuroBezierMeshComponent_GetPointsArray");
static_assert(sizeof(KuroBezierMeshComponent_GetPointsArray) == 0x000010, "Wrong size on KuroBezierMeshComponent_GetPointsArray");
static_assert(offsetof(KuroBezierMeshComponent_GetPointsArray, ReturnValue) == 0x000000, "Member 'KuroBezierMeshComponent_GetPointsArray::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroBezierMeshComponent.SetKeyPoint
// 0x0010 (0x0010 - 0x0000)
struct KuroBezierMeshComponent_SetKeyPoint final
{
public:
	int32                                         Index_0;                                           // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         X;                                                 // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Y;                                                 // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Z;                                                 // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroBezierMeshComponent_SetKeyPoint) == 0x000004, "Wrong alignment on KuroBezierMeshComponent_SetKeyPoint");
static_assert(sizeof(KuroBezierMeshComponent_SetKeyPoint) == 0x000010, "Wrong size on KuroBezierMeshComponent_SetKeyPoint");
static_assert(offsetof(KuroBezierMeshComponent_SetKeyPoint, Index_0) == 0x000000, "Member 'KuroBezierMeshComponent_SetKeyPoint::Index_0' has a wrong offset!");
static_assert(offsetof(KuroBezierMeshComponent_SetKeyPoint, X) == 0x000004, "Member 'KuroBezierMeshComponent_SetKeyPoint::X' has a wrong offset!");
static_assert(offsetof(KuroBezierMeshComponent_SetKeyPoint, Y) == 0x000008, "Member 'KuroBezierMeshComponent_SetKeyPoint::Y' has a wrong offset!");
static_assert(offsetof(KuroBezierMeshComponent_SetKeyPoint, Z) == 0x00000C, "Member 'KuroBezierMeshComponent_SetKeyPoint::Z' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroBezierMeshComponent.Setup
// 0x0008 (0x0008 - 0x0000)
struct KuroBezierMeshComponent_Setup final
{
public:
	int32                                         Width;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InUnitLength;                                      // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroBezierMeshComponent_Setup) == 0x000004, "Wrong alignment on KuroBezierMeshComponent_Setup");
static_assert(sizeof(KuroBezierMeshComponent_Setup) == 0x000008, "Wrong size on KuroBezierMeshComponent_Setup");
static_assert(offsetof(KuroBezierMeshComponent_Setup, Width) == 0x000000, "Member 'KuroBezierMeshComponent_Setup::Width' has a wrong offset!");
static_assert(offsetof(KuroBezierMeshComponent_Setup, InUnitLength) == 0x000004, "Member 'KuroBezierMeshComponent_Setup::InUnitLength' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroBezierMeshComponent.UpdateMesh
// 0x0004 (0x0004 - 0x0000)
struct KuroBezierMeshComponent_UpdateMesh final
{
public:
	int32                                         Section;                                           // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroBezierMeshComponent_UpdateMesh) == 0x000004, "Wrong alignment on KuroBezierMeshComponent_UpdateMesh");
static_assert(sizeof(KuroBezierMeshComponent_UpdateMesh) == 0x000004, "Wrong size on KuroBezierMeshComponent_UpdateMesh");
static_assert(offsetof(KuroBezierMeshComponent_UpdateMesh, Section) == 0x000000, "Member 'KuroBezierMeshComponent_UpdateMesh::Section' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroChangeSkeletalMaterialsComponent.ChangeMaterialsWithDataAsset
// 0x0008 (0x0008 - 0x0000)
struct KuroChangeSkeletalMaterialsComponent_ChangeMaterialsWithDataAsset final
{
public:
	const class UKuroChangeMaterialsTextures*     DataAsset;                                         // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroChangeSkeletalMaterialsComponent_ChangeMaterialsWithDataAsset) == 0x000008, "Wrong alignment on KuroChangeSkeletalMaterialsComponent_ChangeMaterialsWithDataAsset");
static_assert(sizeof(KuroChangeSkeletalMaterialsComponent_ChangeMaterialsWithDataAsset) == 0x000008, "Wrong size on KuroChangeSkeletalMaterialsComponent_ChangeMaterialsWithDataAsset");
static_assert(offsetof(KuroChangeSkeletalMaterialsComponent_ChangeMaterialsWithDataAsset, DataAsset) == 0x000000, "Member 'KuroChangeSkeletalMaterialsComponent_ChangeMaterialsWithDataAsset::DataAsset' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroChangeSkeletalMaterialsComponent.ChangeMaterialsWithTextures
// 0x0028 (0x0028 - 0x0000)
struct KuroChangeSkeletalMaterialsComponent_ChangeMaterialsWithTextures final
{
public:
	class USkeletalMeshComponent*                 SkeletalMeshComponent;                             // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ParameterName;                                     // 0x0008(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSoftObjectPtr<class UTexture2D>>      Textures;                                          // 0x0018(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, UObjectWrapper, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroChangeSkeletalMaterialsComponent_ChangeMaterialsWithTextures) == 0x000008, "Wrong alignment on KuroChangeSkeletalMaterialsComponent_ChangeMaterialsWithTextures");
static_assert(sizeof(KuroChangeSkeletalMaterialsComponent_ChangeMaterialsWithTextures) == 0x000028, "Wrong size on KuroChangeSkeletalMaterialsComponent_ChangeMaterialsWithTextures");
static_assert(offsetof(KuroChangeSkeletalMaterialsComponent_ChangeMaterialsWithTextures, SkeletalMeshComponent) == 0x000000, "Member 'KuroChangeSkeletalMaterialsComponent_ChangeMaterialsWithTextures::SkeletalMeshComponent' has a wrong offset!");
static_assert(offsetof(KuroChangeSkeletalMaterialsComponent_ChangeMaterialsWithTextures, ParameterName) == 0x000008, "Member 'KuroChangeSkeletalMaterialsComponent_ChangeMaterialsWithTextures::ParameterName' has a wrong offset!");
static_assert(offsetof(KuroChangeSkeletalMaterialsComponent_ChangeMaterialsWithTextures, Textures) == 0x000018, "Member 'KuroChangeSkeletalMaterialsComponent_ChangeMaterialsWithTextures::Textures' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroCharacterMaterialControllerCache.GetBaseColorTint
// 0x0018 (0x0018 - 0x0000)
struct KuroCharacterMaterialControllerCache_GetBaseColorTint final
{
public:
	float                                         Factor;                                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Type;                                              // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           ReturnValue;                                       // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroCharacterMaterialControllerCache_GetBaseColorTint) == 0x000004, "Wrong alignment on KuroCharacterMaterialControllerCache_GetBaseColorTint");
static_assert(sizeof(KuroCharacterMaterialControllerCache_GetBaseColorTint) == 0x000018, "Wrong size on KuroCharacterMaterialControllerCache_GetBaseColorTint");
static_assert(offsetof(KuroCharacterMaterialControllerCache_GetBaseColorTint, Factor) == 0x000000, "Member 'KuroCharacterMaterialControllerCache_GetBaseColorTint::Factor' has a wrong offset!");
static_assert(offsetof(KuroCharacterMaterialControllerCache_GetBaseColorTint, Type) == 0x000004, "Member 'KuroCharacterMaterialControllerCache_GetBaseColorTint::Type' has a wrong offset!");
static_assert(offsetof(KuroCharacterMaterialControllerCache_GetBaseColorTint, ReturnValue) == 0x000008, "Member 'KuroCharacterMaterialControllerCache_GetBaseColorTint::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroCharacterMaterialControllerCache.GetBaseRefine
// 0x0018 (0x0018 - 0x0000)
struct KuroCharacterMaterialControllerCache_GetBaseRefine final
{
public:
	float                                         Factor;                                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Type;                                              // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           ReturnValue;                                       // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroCharacterMaterialControllerCache_GetBaseRefine) == 0x000004, "Wrong alignment on KuroCharacterMaterialControllerCache_GetBaseRefine");
static_assert(sizeof(KuroCharacterMaterialControllerCache_GetBaseRefine) == 0x000018, "Wrong size on KuroCharacterMaterialControllerCache_GetBaseRefine");
static_assert(offsetof(KuroCharacterMaterialControllerCache_GetBaseRefine, Factor) == 0x000000, "Member 'KuroCharacterMaterialControllerCache_GetBaseRefine::Factor' has a wrong offset!");
static_assert(offsetof(KuroCharacterMaterialControllerCache_GetBaseRefine, Type) == 0x000004, "Member 'KuroCharacterMaterialControllerCache_GetBaseRefine::Type' has a wrong offset!");
static_assert(offsetof(KuroCharacterMaterialControllerCache_GetBaseRefine, ReturnValue) == 0x000008, "Member 'KuroCharacterMaterialControllerCache_GetBaseRefine::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroCharacterMaterialControllerCache.GetCustomColorParametersValue
// 0x001C (0x001C - 0x0000)
struct KuroCharacterMaterialControllerCache_GetCustomColorParametersValue final
{
public:
	float                                         Factor;                                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Type;                                              // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Index_0;                                           // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           ReturnValue;                                       // 0x000C(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroCharacterMaterialControllerCache_GetCustomColorParametersValue) == 0x000004, "Wrong alignment on KuroCharacterMaterialControllerCache_GetCustomColorParametersValue");
static_assert(sizeof(KuroCharacterMaterialControllerCache_GetCustomColorParametersValue) == 0x00001C, "Wrong size on KuroCharacterMaterialControllerCache_GetCustomColorParametersValue");
static_assert(offsetof(KuroCharacterMaterialControllerCache_GetCustomColorParametersValue, Factor) == 0x000000, "Member 'KuroCharacterMaterialControllerCache_GetCustomColorParametersValue::Factor' has a wrong offset!");
static_assert(offsetof(KuroCharacterMaterialControllerCache_GetCustomColorParametersValue, Type) == 0x000004, "Member 'KuroCharacterMaterialControllerCache_GetCustomColorParametersValue::Type' has a wrong offset!");
static_assert(offsetof(KuroCharacterMaterialControllerCache_GetCustomColorParametersValue, Index_0) == 0x000008, "Member 'KuroCharacterMaterialControllerCache_GetCustomColorParametersValue::Index_0' has a wrong offset!");
static_assert(offsetof(KuroCharacterMaterialControllerCache_GetCustomColorParametersValue, ReturnValue) == 0x00000C, "Member 'KuroCharacterMaterialControllerCache_GetCustomColorParametersValue::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroCharacterMaterialControllerCache.GetCustomFloatParametersValue
// 0x0010 (0x0010 - 0x0000)
struct KuroCharacterMaterialControllerCache_GetCustomFloatParametersValue final
{
public:
	float                                         Factor;                                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Type;                                              // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Index_0;                                           // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x000C(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroCharacterMaterialControllerCache_GetCustomFloatParametersValue) == 0x000004, "Wrong alignment on KuroCharacterMaterialControllerCache_GetCustomFloatParametersValue");
static_assert(sizeof(KuroCharacterMaterialControllerCache_GetCustomFloatParametersValue) == 0x000010, "Wrong size on KuroCharacterMaterialControllerCache_GetCustomFloatParametersValue");
static_assert(offsetof(KuroCharacterMaterialControllerCache_GetCustomFloatParametersValue, Factor) == 0x000000, "Member 'KuroCharacterMaterialControllerCache_GetCustomFloatParametersValue::Factor' has a wrong offset!");
static_assert(offsetof(KuroCharacterMaterialControllerCache_GetCustomFloatParametersValue, Type) == 0x000004, "Member 'KuroCharacterMaterialControllerCache_GetCustomFloatParametersValue::Type' has a wrong offset!");
static_assert(offsetof(KuroCharacterMaterialControllerCache_GetCustomFloatParametersValue, Index_0) == 0x000008, "Member 'KuroCharacterMaterialControllerCache_GetCustomFloatParametersValue::Index_0' has a wrong offset!");
static_assert(offsetof(KuroCharacterMaterialControllerCache_GetCustomFloatParametersValue, ReturnValue) == 0x00000C, "Member 'KuroCharacterMaterialControllerCache_GetCustomFloatParametersValue::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroCharacterMaterialControllerCache.GetDissolveColor
// 0x0018 (0x0018 - 0x0000)
struct KuroCharacterMaterialControllerCache_GetDissolveColor final
{
public:
	float                                         Factor;                                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Type;                                              // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           ReturnValue;                                       // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroCharacterMaterialControllerCache_GetDissolveColor) == 0x000004, "Wrong alignment on KuroCharacterMaterialControllerCache_GetDissolveColor");
static_assert(sizeof(KuroCharacterMaterialControllerCache_GetDissolveColor) == 0x000018, "Wrong size on KuroCharacterMaterialControllerCache_GetDissolveColor");
static_assert(offsetof(KuroCharacterMaterialControllerCache_GetDissolveColor, Factor) == 0x000000, "Member 'KuroCharacterMaterialControllerCache_GetDissolveColor::Factor' has a wrong offset!");
static_assert(offsetof(KuroCharacterMaterialControllerCache_GetDissolveColor, Type) == 0x000004, "Member 'KuroCharacterMaterialControllerCache_GetDissolveColor::Type' has a wrong offset!");
static_assert(offsetof(KuroCharacterMaterialControllerCache_GetDissolveColor, ReturnValue) == 0x000008, "Member 'KuroCharacterMaterialControllerCache_GetDissolveColor::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroCharacterMaterialControllerCache.GetDissolveColorIntensity
// 0x000C (0x000C - 0x0000)
struct KuroCharacterMaterialControllerCache_GetDissolveColorIntensity final
{
public:
	float                                         Factor;                                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Type;                                              // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroCharacterMaterialControllerCache_GetDissolveColorIntensity) == 0x000004, "Wrong alignment on KuroCharacterMaterialControllerCache_GetDissolveColorIntensity");
static_assert(sizeof(KuroCharacterMaterialControllerCache_GetDissolveColorIntensity) == 0x00000C, "Wrong size on KuroCharacterMaterialControllerCache_GetDissolveColorIntensity");
static_assert(offsetof(KuroCharacterMaterialControllerCache_GetDissolveColorIntensity, Factor) == 0x000000, "Member 'KuroCharacterMaterialControllerCache_GetDissolveColorIntensity::Factor' has a wrong offset!");
static_assert(offsetof(KuroCharacterMaterialControllerCache_GetDissolveColorIntensity, Type) == 0x000004, "Member 'KuroCharacterMaterialControllerCache_GetDissolveColorIntensity::Type' has a wrong offset!");
static_assert(offsetof(KuroCharacterMaterialControllerCache_GetDissolveColorIntensity, ReturnValue) == 0x000008, "Member 'KuroCharacterMaterialControllerCache_GetDissolveColorIntensity::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroCharacterMaterialControllerCache.GetDissolveProgress
// 0x000C (0x000C - 0x0000)
struct KuroCharacterMaterialControllerCache_GetDissolveProgress final
{
public:
	float                                         Factor;                                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Type;                                              // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroCharacterMaterialControllerCache_GetDissolveProgress) == 0x000004, "Wrong alignment on KuroCharacterMaterialControllerCache_GetDissolveProgress");
static_assert(sizeof(KuroCharacterMaterialControllerCache_GetDissolveProgress) == 0x00000C, "Wrong size on KuroCharacterMaterialControllerCache_GetDissolveProgress");
static_assert(offsetof(KuroCharacterMaterialControllerCache_GetDissolveProgress, Factor) == 0x000000, "Member 'KuroCharacterMaterialControllerCache_GetDissolveProgress::Factor' has a wrong offset!");
static_assert(offsetof(KuroCharacterMaterialControllerCache_GetDissolveProgress, Type) == 0x000004, "Member 'KuroCharacterMaterialControllerCache_GetDissolveProgress::Type' has a wrong offset!");
static_assert(offsetof(KuroCharacterMaterialControllerCache_GetDissolveProgress, ReturnValue) == 0x000008, "Member 'KuroCharacterMaterialControllerCache_GetDissolveProgress::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroCharacterMaterialControllerCache.GetDissolveSmooth
// 0x000C (0x000C - 0x0000)
struct KuroCharacterMaterialControllerCache_GetDissolveSmooth final
{
public:
	float                                         Factor;                                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Type;                                              // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroCharacterMaterialControllerCache_GetDissolveSmooth) == 0x000004, "Wrong alignment on KuroCharacterMaterialControllerCache_GetDissolveSmooth");
static_assert(sizeof(KuroCharacterMaterialControllerCache_GetDissolveSmooth) == 0x00000C, "Wrong size on KuroCharacterMaterialControllerCache_GetDissolveSmooth");
static_assert(offsetof(KuroCharacterMaterialControllerCache_GetDissolveSmooth, Factor) == 0x000000, "Member 'KuroCharacterMaterialControllerCache_GetDissolveSmooth::Factor' has a wrong offset!");
static_assert(offsetof(KuroCharacterMaterialControllerCache_GetDissolveSmooth, Type) == 0x000004, "Member 'KuroCharacterMaterialControllerCache_GetDissolveSmooth::Type' has a wrong offset!");
static_assert(offsetof(KuroCharacterMaterialControllerCache_GetDissolveSmooth, ReturnValue) == 0x000008, "Member 'KuroCharacterMaterialControllerCache_GetDissolveSmooth::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroCharacterMaterialControllerCache.GetDitherValue
// 0x000C (0x000C - 0x0000)
struct KuroCharacterMaterialControllerCache_GetDitherValue final
{
public:
	float                                         Factor;                                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Type;                                              // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroCharacterMaterialControllerCache_GetDitherValue) == 0x000004, "Wrong alignment on KuroCharacterMaterialControllerCache_GetDitherValue");
static_assert(sizeof(KuroCharacterMaterialControllerCache_GetDitherValue) == 0x00000C, "Wrong size on KuroCharacterMaterialControllerCache_GetDitherValue");
static_assert(offsetof(KuroCharacterMaterialControllerCache_GetDitherValue, Factor) == 0x000000, "Member 'KuroCharacterMaterialControllerCache_GetDitherValue::Factor' has a wrong offset!");
static_assert(offsetof(KuroCharacterMaterialControllerCache_GetDitherValue, Type) == 0x000004, "Member 'KuroCharacterMaterialControllerCache_GetDitherValue::Type' has a wrong offset!");
static_assert(offsetof(KuroCharacterMaterialControllerCache_GetDitherValue, ReturnValue) == 0x000008, "Member 'KuroCharacterMaterialControllerCache_GetDitherValue::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroCharacterMaterialControllerCache.GetEmissionColor
// 0x0018 (0x0018 - 0x0000)
struct KuroCharacterMaterialControllerCache_GetEmissionColor final
{
public:
	float                                         Factor;                                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Type;                                              // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           ReturnValue;                                       // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroCharacterMaterialControllerCache_GetEmissionColor) == 0x000004, "Wrong alignment on KuroCharacterMaterialControllerCache_GetEmissionColor");
static_assert(sizeof(KuroCharacterMaterialControllerCache_GetEmissionColor) == 0x000018, "Wrong size on KuroCharacterMaterialControllerCache_GetEmissionColor");
static_assert(offsetof(KuroCharacterMaterialControllerCache_GetEmissionColor, Factor) == 0x000000, "Member 'KuroCharacterMaterialControllerCache_GetEmissionColor::Factor' has a wrong offset!");
static_assert(offsetof(KuroCharacterMaterialControllerCache_GetEmissionColor, Type) == 0x000004, "Member 'KuroCharacterMaterialControllerCache_GetEmissionColor::Type' has a wrong offset!");
static_assert(offsetof(KuroCharacterMaterialControllerCache_GetEmissionColor, ReturnValue) == 0x000008, "Member 'KuroCharacterMaterialControllerCache_GetEmissionColor::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroCharacterMaterialControllerCache.GetEmissionIntensity
// 0x000C (0x000C - 0x0000)
struct KuroCharacterMaterialControllerCache_GetEmissionIntensity final
{
public:
	float                                         Factor;                                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Type;                                              // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroCharacterMaterialControllerCache_GetEmissionIntensity) == 0x000004, "Wrong alignment on KuroCharacterMaterialControllerCache_GetEmissionIntensity");
static_assert(sizeof(KuroCharacterMaterialControllerCache_GetEmissionIntensity) == 0x00000C, "Wrong size on KuroCharacterMaterialControllerCache_GetEmissionIntensity");
static_assert(offsetof(KuroCharacterMaterialControllerCache_GetEmissionIntensity, Factor) == 0x000000, "Member 'KuroCharacterMaterialControllerCache_GetEmissionIntensity::Factor' has a wrong offset!");
static_assert(offsetof(KuroCharacterMaterialControllerCache_GetEmissionIntensity, Type) == 0x000004, "Member 'KuroCharacterMaterialControllerCache_GetEmissionIntensity::Type' has a wrong offset!");
static_assert(offsetof(KuroCharacterMaterialControllerCache_GetEmissionIntensity, ReturnValue) == 0x000008, "Member 'KuroCharacterMaterialControllerCache_GetEmissionIntensity::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroCharacterMaterialControllerCache.GetHairDisplaceContrast
// 0x000C (0x000C - 0x0000)
struct KuroCharacterMaterialControllerCache_GetHairDisplaceContrast final
{
public:
	float                                         Factor;                                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Type;                                              // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroCharacterMaterialControllerCache_GetHairDisplaceContrast) == 0x000004, "Wrong alignment on KuroCharacterMaterialControllerCache_GetHairDisplaceContrast");
static_assert(sizeof(KuroCharacterMaterialControllerCache_GetHairDisplaceContrast) == 0x00000C, "Wrong size on KuroCharacterMaterialControllerCache_GetHairDisplaceContrast");
static_assert(offsetof(KuroCharacterMaterialControllerCache_GetHairDisplaceContrast, Factor) == 0x000000, "Member 'KuroCharacterMaterialControllerCache_GetHairDisplaceContrast::Factor' has a wrong offset!");
static_assert(offsetof(KuroCharacterMaterialControllerCache_GetHairDisplaceContrast, Type) == 0x000004, "Member 'KuroCharacterMaterialControllerCache_GetHairDisplaceContrast::Type' has a wrong offset!");
static_assert(offsetof(KuroCharacterMaterialControllerCache_GetHairDisplaceContrast, ReturnValue) == 0x000008, "Member 'KuroCharacterMaterialControllerCache_GetHairDisplaceContrast::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroCharacterMaterialControllerCache.GetHairDisplaceProgress
// 0x000C (0x000C - 0x0000)
struct KuroCharacterMaterialControllerCache_GetHairDisplaceProgress final
{
public:
	float                                         Factor;                                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Type;                                              // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroCharacterMaterialControllerCache_GetHairDisplaceProgress) == 0x000004, "Wrong alignment on KuroCharacterMaterialControllerCache_GetHairDisplaceProgress");
static_assert(sizeof(KuroCharacterMaterialControllerCache_GetHairDisplaceProgress) == 0x00000C, "Wrong size on KuroCharacterMaterialControllerCache_GetHairDisplaceProgress");
static_assert(offsetof(KuroCharacterMaterialControllerCache_GetHairDisplaceProgress, Factor) == 0x000000, "Member 'KuroCharacterMaterialControllerCache_GetHairDisplaceProgress::Factor' has a wrong offset!");
static_assert(offsetof(KuroCharacterMaterialControllerCache_GetHairDisplaceProgress, Type) == 0x000004, "Member 'KuroCharacterMaterialControllerCache_GetHairDisplaceProgress::Type' has a wrong offset!");
static_assert(offsetof(KuroCharacterMaterialControllerCache_GetHairDisplaceProgress, ReturnValue) == 0x000008, "Member 'KuroCharacterMaterialControllerCache_GetHairDisplaceProgress::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroCharacterMaterialControllerCache.GetMainTexColorTint
// 0x0018 (0x0018 - 0x0000)
struct KuroCharacterMaterialControllerCache_GetMainTexColorTint final
{
public:
	float                                         Factor;                                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Type;                                              // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           ReturnValue;                                       // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroCharacterMaterialControllerCache_GetMainTexColorTint) == 0x000004, "Wrong alignment on KuroCharacterMaterialControllerCache_GetMainTexColorTint");
static_assert(sizeof(KuroCharacterMaterialControllerCache_GetMainTexColorTint) == 0x000018, "Wrong size on KuroCharacterMaterialControllerCache_GetMainTexColorTint");
static_assert(offsetof(KuroCharacterMaterialControllerCache_GetMainTexColorTint, Factor) == 0x000000, "Member 'KuroCharacterMaterialControllerCache_GetMainTexColorTint::Factor' has a wrong offset!");
static_assert(offsetof(KuroCharacterMaterialControllerCache_GetMainTexColorTint, Type) == 0x000004, "Member 'KuroCharacterMaterialControllerCache_GetMainTexColorTint::Type' has a wrong offset!");
static_assert(offsetof(KuroCharacterMaterialControllerCache_GetMainTexColorTint, ReturnValue) == 0x000008, "Member 'KuroCharacterMaterialControllerCache_GetMainTexColorTint::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroCharacterMaterialControllerCache.GetMotionColorEnd
// 0x0018 (0x0018 - 0x0000)
struct KuroCharacterMaterialControllerCache_GetMotionColorEnd final
{
public:
	float                                         Factor;                                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Type;                                              // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           ReturnValue;                                       // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroCharacterMaterialControllerCache_GetMotionColorEnd) == 0x000004, "Wrong alignment on KuroCharacterMaterialControllerCache_GetMotionColorEnd");
static_assert(sizeof(KuroCharacterMaterialControllerCache_GetMotionColorEnd) == 0x000018, "Wrong size on KuroCharacterMaterialControllerCache_GetMotionColorEnd");
static_assert(offsetof(KuroCharacterMaterialControllerCache_GetMotionColorEnd, Factor) == 0x000000, "Member 'KuroCharacterMaterialControllerCache_GetMotionColorEnd::Factor' has a wrong offset!");
static_assert(offsetof(KuroCharacterMaterialControllerCache_GetMotionColorEnd, Type) == 0x000004, "Member 'KuroCharacterMaterialControllerCache_GetMotionColorEnd::Type' has a wrong offset!");
static_assert(offsetof(KuroCharacterMaterialControllerCache_GetMotionColorEnd, ReturnValue) == 0x000008, "Member 'KuroCharacterMaterialControllerCache_GetMotionColorEnd::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroCharacterMaterialControllerCache.GetMotionColorStart
// 0x0018 (0x0018 - 0x0000)
struct KuroCharacterMaterialControllerCache_GetMotionColorStart final
{
public:
	float                                         Factor;                                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Type;                                              // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           ReturnValue;                                       // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroCharacterMaterialControllerCache_GetMotionColorStart) == 0x000004, "Wrong alignment on KuroCharacterMaterialControllerCache_GetMotionColorStart");
static_assert(sizeof(KuroCharacterMaterialControllerCache_GetMotionColorStart) == 0x000018, "Wrong size on KuroCharacterMaterialControllerCache_GetMotionColorStart");
static_assert(offsetof(KuroCharacterMaterialControllerCache_GetMotionColorStart, Factor) == 0x000000, "Member 'KuroCharacterMaterialControllerCache_GetMotionColorStart::Factor' has a wrong offset!");
static_assert(offsetof(KuroCharacterMaterialControllerCache_GetMotionColorStart, Type) == 0x000004, "Member 'KuroCharacterMaterialControllerCache_GetMotionColorStart::Type' has a wrong offset!");
static_assert(offsetof(KuroCharacterMaterialControllerCache_GetMotionColorStart, ReturnValue) == 0x000008, "Member 'KuroCharacterMaterialControllerCache_GetMotionColorStart::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroCharacterMaterialControllerCache.GetMotionNoiseSpeed
// 0x000C (0x000C - 0x0000)
struct KuroCharacterMaterialControllerCache_GetMotionNoiseSpeed final
{
public:
	float                                         Factor;                                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Type;                                              // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroCharacterMaterialControllerCache_GetMotionNoiseSpeed) == 0x000004, "Wrong alignment on KuroCharacterMaterialControllerCache_GetMotionNoiseSpeed");
static_assert(sizeof(KuroCharacterMaterialControllerCache_GetMotionNoiseSpeed) == 0x00000C, "Wrong size on KuroCharacterMaterialControllerCache_GetMotionNoiseSpeed");
static_assert(offsetof(KuroCharacterMaterialControllerCache_GetMotionNoiseSpeed, Factor) == 0x000000, "Member 'KuroCharacterMaterialControllerCache_GetMotionNoiseSpeed::Factor' has a wrong offset!");
static_assert(offsetof(KuroCharacterMaterialControllerCache_GetMotionNoiseSpeed, Type) == 0x000004, "Member 'KuroCharacterMaterialControllerCache_GetMotionNoiseSpeed::Type' has a wrong offset!");
static_assert(offsetof(KuroCharacterMaterialControllerCache_GetMotionNoiseSpeed, ReturnValue) == 0x000008, "Member 'KuroCharacterMaterialControllerCache_GetMotionNoiseSpeed::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroCharacterMaterialControllerCache.GetOutlineColor
// 0x0018 (0x0018 - 0x0000)
struct KuroCharacterMaterialControllerCache_GetOutlineColor final
{
public:
	float                                         Factor;                                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Type;                                              // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           ReturnValue;                                       // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroCharacterMaterialControllerCache_GetOutlineColor) == 0x000004, "Wrong alignment on KuroCharacterMaterialControllerCache_GetOutlineColor");
static_assert(sizeof(KuroCharacterMaterialControllerCache_GetOutlineColor) == 0x000018, "Wrong size on KuroCharacterMaterialControllerCache_GetOutlineColor");
static_assert(offsetof(KuroCharacterMaterialControllerCache_GetOutlineColor, Factor) == 0x000000, "Member 'KuroCharacterMaterialControllerCache_GetOutlineColor::Factor' has a wrong offset!");
static_assert(offsetof(KuroCharacterMaterialControllerCache_GetOutlineColor, Type) == 0x000004, "Member 'KuroCharacterMaterialControllerCache_GetOutlineColor::Type' has a wrong offset!");
static_assert(offsetof(KuroCharacterMaterialControllerCache_GetOutlineColor, ReturnValue) == 0x000008, "Member 'KuroCharacterMaterialControllerCache_GetOutlineColor::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroCharacterMaterialControllerCache.GetOutlineWidth
// 0x000C (0x000C - 0x0000)
struct KuroCharacterMaterialControllerCache_GetOutlineWidth final
{
public:
	float                                         Factor;                                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Type;                                              // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroCharacterMaterialControllerCache_GetOutlineWidth) == 0x000004, "Wrong alignment on KuroCharacterMaterialControllerCache_GetOutlineWidth");
static_assert(sizeof(KuroCharacterMaterialControllerCache_GetOutlineWidth) == 0x00000C, "Wrong size on KuroCharacterMaterialControllerCache_GetOutlineWidth");
static_assert(offsetof(KuroCharacterMaterialControllerCache_GetOutlineWidth, Factor) == 0x000000, "Member 'KuroCharacterMaterialControllerCache_GetOutlineWidth::Factor' has a wrong offset!");
static_assert(offsetof(KuroCharacterMaterialControllerCache_GetOutlineWidth, Type) == 0x000004, "Member 'KuroCharacterMaterialControllerCache_GetOutlineWidth::Type' has a wrong offset!");
static_assert(offsetof(KuroCharacterMaterialControllerCache_GetOutlineWidth, ReturnValue) == 0x000008, "Member 'KuroCharacterMaterialControllerCache_GetOutlineWidth::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroCharacterMaterialControllerCache.GetRimColor
// 0x0018 (0x0018 - 0x0000)
struct KuroCharacterMaterialControllerCache_GetRimColor final
{
public:
	float                                         Factor;                                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Type;                                              // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           ReturnValue;                                       // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroCharacterMaterialControllerCache_GetRimColor) == 0x000004, "Wrong alignment on KuroCharacterMaterialControllerCache_GetRimColor");
static_assert(sizeof(KuroCharacterMaterialControllerCache_GetRimColor) == 0x000018, "Wrong size on KuroCharacterMaterialControllerCache_GetRimColor");
static_assert(offsetof(KuroCharacterMaterialControllerCache_GetRimColor, Factor) == 0x000000, "Member 'KuroCharacterMaterialControllerCache_GetRimColor::Factor' has a wrong offset!");
static_assert(offsetof(KuroCharacterMaterialControllerCache_GetRimColor, Type) == 0x000004, "Member 'KuroCharacterMaterialControllerCache_GetRimColor::Type' has a wrong offset!");
static_assert(offsetof(KuroCharacterMaterialControllerCache_GetRimColor, ReturnValue) == 0x000008, "Member 'KuroCharacterMaterialControllerCache_GetRimColor::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroCharacterMaterialControllerCache.GetRimRange
// 0x000C (0x000C - 0x0000)
struct KuroCharacterMaterialControllerCache_GetRimRange final
{
public:
	float                                         Factor;                                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Type;                                              // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroCharacterMaterialControllerCache_GetRimRange) == 0x000004, "Wrong alignment on KuroCharacterMaterialControllerCache_GetRimRange");
static_assert(sizeof(KuroCharacterMaterialControllerCache_GetRimRange) == 0x00000C, "Wrong size on KuroCharacterMaterialControllerCache_GetRimRange");
static_assert(offsetof(KuroCharacterMaterialControllerCache_GetRimRange, Factor) == 0x000000, "Member 'KuroCharacterMaterialControllerCache_GetRimRange::Factor' has a wrong offset!");
static_assert(offsetof(KuroCharacterMaterialControllerCache_GetRimRange, Type) == 0x000004, "Member 'KuroCharacterMaterialControllerCache_GetRimRange::Type' has a wrong offset!");
static_assert(offsetof(KuroCharacterMaterialControllerCache_GetRimRange, ReturnValue) == 0x000008, "Member 'KuroCharacterMaterialControllerCache_GetRimRange::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroCharacterMaterialControllerCache.GetRotation
// 0x000C (0x000C - 0x0000)
struct KuroCharacterMaterialControllerCache_GetRotation final
{
public:
	float                                         Factor;                                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Type;                                              // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroCharacterMaterialControllerCache_GetRotation) == 0x000004, "Wrong alignment on KuroCharacterMaterialControllerCache_GetRotation");
static_assert(sizeof(KuroCharacterMaterialControllerCache_GetRotation) == 0x00000C, "Wrong size on KuroCharacterMaterialControllerCache_GetRotation");
static_assert(offsetof(KuroCharacterMaterialControllerCache_GetRotation, Factor) == 0x000000, "Member 'KuroCharacterMaterialControllerCache_GetRotation::Factor' has a wrong offset!");
static_assert(offsetof(KuroCharacterMaterialControllerCache_GetRotation, Type) == 0x000004, "Member 'KuroCharacterMaterialControllerCache_GetRotation::Type' has a wrong offset!");
static_assert(offsetof(KuroCharacterMaterialControllerCache_GetRotation, ReturnValue) == 0x000008, "Member 'KuroCharacterMaterialControllerCache_GetRotation::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroCharacterMaterialControllerCache.GetStripMaskProportion
// 0x000C (0x000C - 0x0000)
struct KuroCharacterMaterialControllerCache_GetStripMaskProportion final
{
public:
	float                                         Factor;                                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Type;                                              // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroCharacterMaterialControllerCache_GetStripMaskProportion) == 0x000004, "Wrong alignment on KuroCharacterMaterialControllerCache_GetStripMaskProportion");
static_assert(sizeof(KuroCharacterMaterialControllerCache_GetStripMaskProportion) == 0x00000C, "Wrong size on KuroCharacterMaterialControllerCache_GetStripMaskProportion");
static_assert(offsetof(KuroCharacterMaterialControllerCache_GetStripMaskProportion, Factor) == 0x000000, "Member 'KuroCharacterMaterialControllerCache_GetStripMaskProportion::Factor' has a wrong offset!");
static_assert(offsetof(KuroCharacterMaterialControllerCache_GetStripMaskProportion, Type) == 0x000004, "Member 'KuroCharacterMaterialControllerCache_GetStripMaskProportion::Type' has a wrong offset!");
static_assert(offsetof(KuroCharacterMaterialControllerCache_GetStripMaskProportion, ReturnValue) == 0x000008, "Member 'KuroCharacterMaterialControllerCache_GetStripMaskProportion::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroCharacterMaterialControllerCache.GetStripMaskVScale
// 0x000C (0x000C - 0x0000)
struct KuroCharacterMaterialControllerCache_GetStripMaskVScale final
{
public:
	float                                         Factor;                                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Type;                                              // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroCharacterMaterialControllerCache_GetStripMaskVScale) == 0x000004, "Wrong alignment on KuroCharacterMaterialControllerCache_GetStripMaskVScale");
static_assert(sizeof(KuroCharacterMaterialControllerCache_GetStripMaskVScale) == 0x00000C, "Wrong size on KuroCharacterMaterialControllerCache_GetStripMaskVScale");
static_assert(offsetof(KuroCharacterMaterialControllerCache_GetStripMaskVScale, Factor) == 0x000000, "Member 'KuroCharacterMaterialControllerCache_GetStripMaskVScale::Factor' has a wrong offset!");
static_assert(offsetof(KuroCharacterMaterialControllerCache_GetStripMaskVScale, Type) == 0x000004, "Member 'KuroCharacterMaterialControllerCache_GetStripMaskVScale::Type' has a wrong offset!");
static_assert(offsetof(KuroCharacterMaterialControllerCache_GetStripMaskVScale, ReturnValue) == 0x000008, "Member 'KuroCharacterMaterialControllerCache_GetStripMaskVScale::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroCharacterMaterialControllerCache.GetStripMaskVSpeed
// 0x000C (0x000C - 0x0000)
struct KuroCharacterMaterialControllerCache_GetStripMaskVSpeed final
{
public:
	float                                         Factor;                                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Type;                                              // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroCharacterMaterialControllerCache_GetStripMaskVSpeed) == 0x000004, "Wrong alignment on KuroCharacterMaterialControllerCache_GetStripMaskVSpeed");
static_assert(sizeof(KuroCharacterMaterialControllerCache_GetStripMaskVSpeed) == 0x00000C, "Wrong size on KuroCharacterMaterialControllerCache_GetStripMaskVSpeed");
static_assert(offsetof(KuroCharacterMaterialControllerCache_GetStripMaskVSpeed, Factor) == 0x000000, "Member 'KuroCharacterMaterialControllerCache_GetStripMaskVSpeed::Factor' has a wrong offset!");
static_assert(offsetof(KuroCharacterMaterialControllerCache_GetStripMaskVSpeed, Type) == 0x000004, "Member 'KuroCharacterMaterialControllerCache_GetStripMaskVSpeed::Type' has a wrong offset!");
static_assert(offsetof(KuroCharacterMaterialControllerCache_GetStripMaskVSpeed, ReturnValue) == 0x000008, "Member 'KuroCharacterMaterialControllerCache_GetStripMaskVSpeed::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroCharacterMaterialControllerCache.GetTextureColorTint
// 0x0018 (0x0018 - 0x0000)
struct KuroCharacterMaterialControllerCache_GetTextureColorTint final
{
public:
	float                                         Factor;                                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Type;                                              // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           ReturnValue;                                       // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroCharacterMaterialControllerCache_GetTextureColorTint) == 0x000004, "Wrong alignment on KuroCharacterMaterialControllerCache_GetTextureColorTint");
static_assert(sizeof(KuroCharacterMaterialControllerCache_GetTextureColorTint) == 0x000018, "Wrong size on KuroCharacterMaterialControllerCache_GetTextureColorTint");
static_assert(offsetof(KuroCharacterMaterialControllerCache_GetTextureColorTint, Factor) == 0x000000, "Member 'KuroCharacterMaterialControllerCache_GetTextureColorTint::Factor' has a wrong offset!");
static_assert(offsetof(KuroCharacterMaterialControllerCache_GetTextureColorTint, Type) == 0x000004, "Member 'KuroCharacterMaterialControllerCache_GetTextureColorTint::Type' has a wrong offset!");
static_assert(offsetof(KuroCharacterMaterialControllerCache_GetTextureColorTint, ReturnValue) == 0x000008, "Member 'KuroCharacterMaterialControllerCache_GetTextureColorTint::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroCharacterMaterialControllerCache.GetTextureLowerLimit
// 0x000C (0x000C - 0x0000)
struct KuroCharacterMaterialControllerCache_GetTextureLowerLimit final
{
public:
	float                                         Factor;                                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Type;                                              // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroCharacterMaterialControllerCache_GetTextureLowerLimit) == 0x000004, "Wrong alignment on KuroCharacterMaterialControllerCache_GetTextureLowerLimit");
static_assert(sizeof(KuroCharacterMaterialControllerCache_GetTextureLowerLimit) == 0x00000C, "Wrong size on KuroCharacterMaterialControllerCache_GetTextureLowerLimit");
static_assert(offsetof(KuroCharacterMaterialControllerCache_GetTextureLowerLimit, Factor) == 0x000000, "Member 'KuroCharacterMaterialControllerCache_GetTextureLowerLimit::Factor' has a wrong offset!");
static_assert(offsetof(KuroCharacterMaterialControllerCache_GetTextureLowerLimit, Type) == 0x000004, "Member 'KuroCharacterMaterialControllerCache_GetTextureLowerLimit::Type' has a wrong offset!");
static_assert(offsetof(KuroCharacterMaterialControllerCache_GetTextureLowerLimit, ReturnValue) == 0x000008, "Member 'KuroCharacterMaterialControllerCache_GetTextureLowerLimit::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroCharacterMaterialControllerCache.GetTextureScaleAndOffset
// 0x0018 (0x0018 - 0x0000)
struct KuroCharacterMaterialControllerCache_GetTextureScaleAndOffset final
{
public:
	float                                         Factor;                                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Type;                                              // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           ReturnValue;                                       // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroCharacterMaterialControllerCache_GetTextureScaleAndOffset) == 0x000004, "Wrong alignment on KuroCharacterMaterialControllerCache_GetTextureScaleAndOffset");
static_assert(sizeof(KuroCharacterMaterialControllerCache_GetTextureScaleAndOffset) == 0x000018, "Wrong size on KuroCharacterMaterialControllerCache_GetTextureScaleAndOffset");
static_assert(offsetof(KuroCharacterMaterialControllerCache_GetTextureScaleAndOffset, Factor) == 0x000000, "Member 'KuroCharacterMaterialControllerCache_GetTextureScaleAndOffset::Factor' has a wrong offset!");
static_assert(offsetof(KuroCharacterMaterialControllerCache_GetTextureScaleAndOffset, Type) == 0x000004, "Member 'KuroCharacterMaterialControllerCache_GetTextureScaleAndOffset::Type' has a wrong offset!");
static_assert(offsetof(KuroCharacterMaterialControllerCache_GetTextureScaleAndOffset, ReturnValue) == 0x000008, "Member 'KuroCharacterMaterialControllerCache_GetTextureScaleAndOffset::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroCharacterMaterialControllerCache.GetTextureSpeed
// 0x0018 (0x0018 - 0x0000)
struct KuroCharacterMaterialControllerCache_GetTextureSpeed final
{
public:
	float                                         Factor;                                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Type;                                              // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           ReturnValue;                                       // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroCharacterMaterialControllerCache_GetTextureSpeed) == 0x000004, "Wrong alignment on KuroCharacterMaterialControllerCache_GetTextureSpeed");
static_assert(sizeof(KuroCharacterMaterialControllerCache_GetTextureSpeed) == 0x000018, "Wrong size on KuroCharacterMaterialControllerCache_GetTextureSpeed");
static_assert(offsetof(KuroCharacterMaterialControllerCache_GetTextureSpeed, Factor) == 0x000000, "Member 'KuroCharacterMaterialControllerCache_GetTextureSpeed::Factor' has a wrong offset!");
static_assert(offsetof(KuroCharacterMaterialControllerCache_GetTextureSpeed, Type) == 0x000004, "Member 'KuroCharacterMaterialControllerCache_GetTextureSpeed::Type' has a wrong offset!");
static_assert(offsetof(KuroCharacterMaterialControllerCache_GetTextureSpeed, ReturnValue) == 0x000008, "Member 'KuroCharacterMaterialControllerCache_GetTextureSpeed::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroCharacterMaterialControllerCache.GetTextureStrength
// 0x000C (0x000C - 0x0000)
struct KuroCharacterMaterialControllerCache_GetTextureStrength final
{
public:
	float                                         Factor;                                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Type;                                              // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroCharacterMaterialControllerCache_GetTextureStrength) == 0x000004, "Wrong alignment on KuroCharacterMaterialControllerCache_GetTextureStrength");
static_assert(sizeof(KuroCharacterMaterialControllerCache_GetTextureStrength) == 0x00000C, "Wrong size on KuroCharacterMaterialControllerCache_GetTextureStrength");
static_assert(offsetof(KuroCharacterMaterialControllerCache_GetTextureStrength, Factor) == 0x000000, "Member 'KuroCharacterMaterialControllerCache_GetTextureStrength::Factor' has a wrong offset!");
static_assert(offsetof(KuroCharacterMaterialControllerCache_GetTextureStrength, Type) == 0x000004, "Member 'KuroCharacterMaterialControllerCache_GetTextureStrength::Type' has a wrong offset!");
static_assert(offsetof(KuroCharacterMaterialControllerCache_GetTextureStrength, ReturnValue) == 0x000008, "Member 'KuroCharacterMaterialControllerCache_GetTextureStrength::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroCharacterMaterialControllerCache.GetTextureUpperLimit
// 0x000C (0x000C - 0x0000)
struct KuroCharacterMaterialControllerCache_GetTextureUpperLimit final
{
public:
	float                                         Factor;                                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Type;                                              // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroCharacterMaterialControllerCache_GetTextureUpperLimit) == 0x000004, "Wrong alignment on KuroCharacterMaterialControllerCache_GetTextureUpperLimit");
static_assert(sizeof(KuroCharacterMaterialControllerCache_GetTextureUpperLimit) == 0x00000C, "Wrong size on KuroCharacterMaterialControllerCache_GetTextureUpperLimit");
static_assert(offsetof(KuroCharacterMaterialControllerCache_GetTextureUpperLimit, Factor) == 0x000000, "Member 'KuroCharacterMaterialControllerCache_GetTextureUpperLimit::Factor' has a wrong offset!");
static_assert(offsetof(KuroCharacterMaterialControllerCache_GetTextureUpperLimit, Type) == 0x000004, "Member 'KuroCharacterMaterialControllerCache_GetTextureUpperLimit::Type' has a wrong offset!");
static_assert(offsetof(KuroCharacterMaterialControllerCache_GetTextureUpperLimit, ReturnValue) == 0x000008, "Member 'KuroCharacterMaterialControllerCache_GetTextureUpperLimit::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroCharacterMaterialControllerCache.SetBaseColorTint
// 0x0660 (0x0660 - 0x0000)
struct KuroCharacterMaterialControllerCache_SetBaseColorTint final
{
public:
	struct FKuroCurveLinearColor                  Start;                                             // 0x0000(0x0220)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FKuroCurveLinearColor                  Loop;                                              // 0x0220(0x0220)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FKuroCurveLinearColor                  End;                                               // 0x0440(0x0220)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroCharacterMaterialControllerCache_SetBaseColorTint) == 0x000008, "Wrong alignment on KuroCharacterMaterialControllerCache_SetBaseColorTint");
static_assert(sizeof(KuroCharacterMaterialControllerCache_SetBaseColorTint) == 0x000660, "Wrong size on KuroCharacterMaterialControllerCache_SetBaseColorTint");
static_assert(offsetof(KuroCharacterMaterialControllerCache_SetBaseColorTint, Start) == 0x000000, "Member 'KuroCharacterMaterialControllerCache_SetBaseColorTint::Start' has a wrong offset!");
static_assert(offsetof(KuroCharacterMaterialControllerCache_SetBaseColorTint, Loop) == 0x000220, "Member 'KuroCharacterMaterialControllerCache_SetBaseColorTint::Loop' has a wrong offset!");
static_assert(offsetof(KuroCharacterMaterialControllerCache_SetBaseColorTint, End) == 0x000440, "Member 'KuroCharacterMaterialControllerCache_SetBaseColorTint::End' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroCharacterMaterialControllerCache.SetBaseRefine
// 0x0660 (0x0660 - 0x0000)
struct KuroCharacterMaterialControllerCache_SetBaseRefine final
{
public:
	struct FKuroCurveLinearColor                  Start;                                             // 0x0000(0x0220)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FKuroCurveLinearColor                  Loop;                                              // 0x0220(0x0220)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FKuroCurveLinearColor                  End;                                               // 0x0440(0x0220)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroCharacterMaterialControllerCache_SetBaseRefine) == 0x000008, "Wrong alignment on KuroCharacterMaterialControllerCache_SetBaseRefine");
static_assert(sizeof(KuroCharacterMaterialControllerCache_SetBaseRefine) == 0x000660, "Wrong size on KuroCharacterMaterialControllerCache_SetBaseRefine");
static_assert(offsetof(KuroCharacterMaterialControllerCache_SetBaseRefine, Start) == 0x000000, "Member 'KuroCharacterMaterialControllerCache_SetBaseRefine::Start' has a wrong offset!");
static_assert(offsetof(KuroCharacterMaterialControllerCache_SetBaseRefine, Loop) == 0x000220, "Member 'KuroCharacterMaterialControllerCache_SetBaseRefine::Loop' has a wrong offset!");
static_assert(offsetof(KuroCharacterMaterialControllerCache_SetBaseRefine, End) == 0x000440, "Member 'KuroCharacterMaterialControllerCache_SetBaseRefine::End' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroCharacterMaterialControllerCache.SetCustomColorParametersValue
// 0x0030 (0x0030 - 0x0000)
struct KuroCharacterMaterialControllerCache_SetCustomColorParametersValue final
{
public:
	TArray<struct FKuroCurveLinearColor>          Start;                                             // 0x0000(0x0010)(ConstParm, Parm, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FKuroCurveLinearColor>          Loop;                                              // 0x0010(0x0010)(ConstParm, Parm, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FKuroCurveLinearColor>          End;                                               // 0x0020(0x0010)(ConstParm, Parm, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroCharacterMaterialControllerCache_SetCustomColorParametersValue) == 0x000008, "Wrong alignment on KuroCharacterMaterialControllerCache_SetCustomColorParametersValue");
static_assert(sizeof(KuroCharacterMaterialControllerCache_SetCustomColorParametersValue) == 0x000030, "Wrong size on KuroCharacterMaterialControllerCache_SetCustomColorParametersValue");
static_assert(offsetof(KuroCharacterMaterialControllerCache_SetCustomColorParametersValue, Start) == 0x000000, "Member 'KuroCharacterMaterialControllerCache_SetCustomColorParametersValue::Start' has a wrong offset!");
static_assert(offsetof(KuroCharacterMaterialControllerCache_SetCustomColorParametersValue, Loop) == 0x000010, "Member 'KuroCharacterMaterialControllerCache_SetCustomColorParametersValue::Loop' has a wrong offset!");
static_assert(offsetof(KuroCharacterMaterialControllerCache_SetCustomColorParametersValue, End) == 0x000020, "Member 'KuroCharacterMaterialControllerCache_SetCustomColorParametersValue::End' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroCharacterMaterialControllerCache.SetCustomFloatParametersValue
// 0x0030 (0x0030 - 0x0000)
struct KuroCharacterMaterialControllerCache_SetCustomFloatParametersValue final
{
public:
	TArray<struct FKuroCurveFloat>                Start;                                             // 0x0000(0x0010)(ConstParm, Parm, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FKuroCurveFloat>                Loop;                                              // 0x0010(0x0010)(ConstParm, Parm, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FKuroCurveFloat>                End;                                               // 0x0020(0x0010)(ConstParm, Parm, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroCharacterMaterialControllerCache_SetCustomFloatParametersValue) == 0x000008, "Wrong alignment on KuroCharacterMaterialControllerCache_SetCustomFloatParametersValue");
static_assert(sizeof(KuroCharacterMaterialControllerCache_SetCustomFloatParametersValue) == 0x000030, "Wrong size on KuroCharacterMaterialControllerCache_SetCustomFloatParametersValue");
static_assert(offsetof(KuroCharacterMaterialControllerCache_SetCustomFloatParametersValue, Start) == 0x000000, "Member 'KuroCharacterMaterialControllerCache_SetCustomFloatParametersValue::Start' has a wrong offset!");
static_assert(offsetof(KuroCharacterMaterialControllerCache_SetCustomFloatParametersValue, Loop) == 0x000010, "Member 'KuroCharacterMaterialControllerCache_SetCustomFloatParametersValue::Loop' has a wrong offset!");
static_assert(offsetof(KuroCharacterMaterialControllerCache_SetCustomFloatParametersValue, End) == 0x000020, "Member 'KuroCharacterMaterialControllerCache_SetCustomFloatParametersValue::End' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroCharacterMaterialControllerCache.SetDissolveColor
// 0x0660 (0x0660 - 0x0000)
struct KuroCharacterMaterialControllerCache_SetDissolveColor final
{
public:
	struct FKuroCurveLinearColor                  Start;                                             // 0x0000(0x0220)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FKuroCurveLinearColor                  Loop;                                              // 0x0220(0x0220)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FKuroCurveLinearColor                  End;                                               // 0x0440(0x0220)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroCharacterMaterialControllerCache_SetDissolveColor) == 0x000008, "Wrong alignment on KuroCharacterMaterialControllerCache_SetDissolveColor");
static_assert(sizeof(KuroCharacterMaterialControllerCache_SetDissolveColor) == 0x000660, "Wrong size on KuroCharacterMaterialControllerCache_SetDissolveColor");
static_assert(offsetof(KuroCharacterMaterialControllerCache_SetDissolveColor, Start) == 0x000000, "Member 'KuroCharacterMaterialControllerCache_SetDissolveColor::Start' has a wrong offset!");
static_assert(offsetof(KuroCharacterMaterialControllerCache_SetDissolveColor, Loop) == 0x000220, "Member 'KuroCharacterMaterialControllerCache_SetDissolveColor::Loop' has a wrong offset!");
static_assert(offsetof(KuroCharacterMaterialControllerCache_SetDissolveColor, End) == 0x000440, "Member 'KuroCharacterMaterialControllerCache_SetDissolveColor::End' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroCharacterMaterialControllerCache.SetDissolveColorIntensity
// 0x01B0 (0x01B0 - 0x0000)
struct KuroCharacterMaterialControllerCache_SetDissolveColorIntensity final
{
public:
	struct FKuroCurveFloat                        Start;                                             // 0x0000(0x0090)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FKuroCurveFloat                        Loop;                                              // 0x0090(0x0090)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FKuroCurveFloat                        End;                                               // 0x0120(0x0090)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroCharacterMaterialControllerCache_SetDissolveColorIntensity) == 0x000008, "Wrong alignment on KuroCharacterMaterialControllerCache_SetDissolveColorIntensity");
static_assert(sizeof(KuroCharacterMaterialControllerCache_SetDissolveColorIntensity) == 0x0001B0, "Wrong size on KuroCharacterMaterialControllerCache_SetDissolveColorIntensity");
static_assert(offsetof(KuroCharacterMaterialControllerCache_SetDissolveColorIntensity, Start) == 0x000000, "Member 'KuroCharacterMaterialControllerCache_SetDissolveColorIntensity::Start' has a wrong offset!");
static_assert(offsetof(KuroCharacterMaterialControllerCache_SetDissolveColorIntensity, Loop) == 0x000090, "Member 'KuroCharacterMaterialControllerCache_SetDissolveColorIntensity::Loop' has a wrong offset!");
static_assert(offsetof(KuroCharacterMaterialControllerCache_SetDissolveColorIntensity, End) == 0x000120, "Member 'KuroCharacterMaterialControllerCache_SetDissolveColorIntensity::End' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroCharacterMaterialControllerCache.SetDissolveProgress
// 0x01B0 (0x01B0 - 0x0000)
struct KuroCharacterMaterialControllerCache_SetDissolveProgress final
{
public:
	struct FKuroCurveFloat                        Start;                                             // 0x0000(0x0090)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FKuroCurveFloat                        Loop;                                              // 0x0090(0x0090)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FKuroCurveFloat                        End;                                               // 0x0120(0x0090)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroCharacterMaterialControllerCache_SetDissolveProgress) == 0x000008, "Wrong alignment on KuroCharacterMaterialControllerCache_SetDissolveProgress");
static_assert(sizeof(KuroCharacterMaterialControllerCache_SetDissolveProgress) == 0x0001B0, "Wrong size on KuroCharacterMaterialControllerCache_SetDissolveProgress");
static_assert(offsetof(KuroCharacterMaterialControllerCache_SetDissolveProgress, Start) == 0x000000, "Member 'KuroCharacterMaterialControllerCache_SetDissolveProgress::Start' has a wrong offset!");
static_assert(offsetof(KuroCharacterMaterialControllerCache_SetDissolveProgress, Loop) == 0x000090, "Member 'KuroCharacterMaterialControllerCache_SetDissolveProgress::Loop' has a wrong offset!");
static_assert(offsetof(KuroCharacterMaterialControllerCache_SetDissolveProgress, End) == 0x000120, "Member 'KuroCharacterMaterialControllerCache_SetDissolveProgress::End' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroCharacterMaterialControllerCache.SetDissolveSmooth
// 0x01B0 (0x01B0 - 0x0000)
struct KuroCharacterMaterialControllerCache_SetDissolveSmooth final
{
public:
	struct FKuroCurveFloat                        Start;                                             // 0x0000(0x0090)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FKuroCurveFloat                        Loop;                                              // 0x0090(0x0090)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FKuroCurveFloat                        End;                                               // 0x0120(0x0090)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroCharacterMaterialControllerCache_SetDissolveSmooth) == 0x000008, "Wrong alignment on KuroCharacterMaterialControllerCache_SetDissolveSmooth");
static_assert(sizeof(KuroCharacterMaterialControllerCache_SetDissolveSmooth) == 0x0001B0, "Wrong size on KuroCharacterMaterialControllerCache_SetDissolveSmooth");
static_assert(offsetof(KuroCharacterMaterialControllerCache_SetDissolveSmooth, Start) == 0x000000, "Member 'KuroCharacterMaterialControllerCache_SetDissolveSmooth::Start' has a wrong offset!");
static_assert(offsetof(KuroCharacterMaterialControllerCache_SetDissolveSmooth, Loop) == 0x000090, "Member 'KuroCharacterMaterialControllerCache_SetDissolveSmooth::Loop' has a wrong offset!");
static_assert(offsetof(KuroCharacterMaterialControllerCache_SetDissolveSmooth, End) == 0x000120, "Member 'KuroCharacterMaterialControllerCache_SetDissolveSmooth::End' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroCharacterMaterialControllerCache.SetDitherValue
// 0x01B0 (0x01B0 - 0x0000)
struct KuroCharacterMaterialControllerCache_SetDitherValue final
{
public:
	struct FKuroCurveFloat                        Start;                                             // 0x0000(0x0090)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FKuroCurveFloat                        Loop;                                              // 0x0090(0x0090)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FKuroCurveFloat                        End;                                               // 0x0120(0x0090)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroCharacterMaterialControllerCache_SetDitherValue) == 0x000008, "Wrong alignment on KuroCharacterMaterialControllerCache_SetDitherValue");
static_assert(sizeof(KuroCharacterMaterialControllerCache_SetDitherValue) == 0x0001B0, "Wrong size on KuroCharacterMaterialControllerCache_SetDitherValue");
static_assert(offsetof(KuroCharacterMaterialControllerCache_SetDitherValue, Start) == 0x000000, "Member 'KuroCharacterMaterialControllerCache_SetDitherValue::Start' has a wrong offset!");
static_assert(offsetof(KuroCharacterMaterialControllerCache_SetDitherValue, Loop) == 0x000090, "Member 'KuroCharacterMaterialControllerCache_SetDitherValue::Loop' has a wrong offset!");
static_assert(offsetof(KuroCharacterMaterialControllerCache_SetDitherValue, End) == 0x000120, "Member 'KuroCharacterMaterialControllerCache_SetDitherValue::End' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroCharacterMaterialControllerCache.SetEmissionColor
// 0x0660 (0x0660 - 0x0000)
struct KuroCharacterMaterialControllerCache_SetEmissionColor final
{
public:
	struct FKuroCurveLinearColor                  Start;                                             // 0x0000(0x0220)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FKuroCurveLinearColor                  Loop;                                              // 0x0220(0x0220)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FKuroCurveLinearColor                  End;                                               // 0x0440(0x0220)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroCharacterMaterialControllerCache_SetEmissionColor) == 0x000008, "Wrong alignment on KuroCharacterMaterialControllerCache_SetEmissionColor");
static_assert(sizeof(KuroCharacterMaterialControllerCache_SetEmissionColor) == 0x000660, "Wrong size on KuroCharacterMaterialControllerCache_SetEmissionColor");
static_assert(offsetof(KuroCharacterMaterialControllerCache_SetEmissionColor, Start) == 0x000000, "Member 'KuroCharacterMaterialControllerCache_SetEmissionColor::Start' has a wrong offset!");
static_assert(offsetof(KuroCharacterMaterialControllerCache_SetEmissionColor, Loop) == 0x000220, "Member 'KuroCharacterMaterialControllerCache_SetEmissionColor::Loop' has a wrong offset!");
static_assert(offsetof(KuroCharacterMaterialControllerCache_SetEmissionColor, End) == 0x000440, "Member 'KuroCharacterMaterialControllerCache_SetEmissionColor::End' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroCharacterMaterialControllerCache.SetEmissionIntensity
// 0x01B0 (0x01B0 - 0x0000)
struct KuroCharacterMaterialControllerCache_SetEmissionIntensity final
{
public:
	struct FKuroCurveFloat                        Start;                                             // 0x0000(0x0090)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FKuroCurveFloat                        Loop;                                              // 0x0090(0x0090)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FKuroCurveFloat                        End;                                               // 0x0120(0x0090)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroCharacterMaterialControllerCache_SetEmissionIntensity) == 0x000008, "Wrong alignment on KuroCharacterMaterialControllerCache_SetEmissionIntensity");
static_assert(sizeof(KuroCharacterMaterialControllerCache_SetEmissionIntensity) == 0x0001B0, "Wrong size on KuroCharacterMaterialControllerCache_SetEmissionIntensity");
static_assert(offsetof(KuroCharacterMaterialControllerCache_SetEmissionIntensity, Start) == 0x000000, "Member 'KuroCharacterMaterialControllerCache_SetEmissionIntensity::Start' has a wrong offset!");
static_assert(offsetof(KuroCharacterMaterialControllerCache_SetEmissionIntensity, Loop) == 0x000090, "Member 'KuroCharacterMaterialControllerCache_SetEmissionIntensity::Loop' has a wrong offset!");
static_assert(offsetof(KuroCharacterMaterialControllerCache_SetEmissionIntensity, End) == 0x000120, "Member 'KuroCharacterMaterialControllerCache_SetEmissionIntensity::End' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroCharacterMaterialControllerCache.SetHairDisplaceContrast
// 0x01B0 (0x01B0 - 0x0000)
struct KuroCharacterMaterialControllerCache_SetHairDisplaceContrast final
{
public:
	struct FKuroCurveFloat                        Start;                                             // 0x0000(0x0090)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FKuroCurveFloat                        Loop;                                              // 0x0090(0x0090)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FKuroCurveFloat                        End;                                               // 0x0120(0x0090)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroCharacterMaterialControllerCache_SetHairDisplaceContrast) == 0x000008, "Wrong alignment on KuroCharacterMaterialControllerCache_SetHairDisplaceContrast");
static_assert(sizeof(KuroCharacterMaterialControllerCache_SetHairDisplaceContrast) == 0x0001B0, "Wrong size on KuroCharacterMaterialControllerCache_SetHairDisplaceContrast");
static_assert(offsetof(KuroCharacterMaterialControllerCache_SetHairDisplaceContrast, Start) == 0x000000, "Member 'KuroCharacterMaterialControllerCache_SetHairDisplaceContrast::Start' has a wrong offset!");
static_assert(offsetof(KuroCharacterMaterialControllerCache_SetHairDisplaceContrast, Loop) == 0x000090, "Member 'KuroCharacterMaterialControllerCache_SetHairDisplaceContrast::Loop' has a wrong offset!");
static_assert(offsetof(KuroCharacterMaterialControllerCache_SetHairDisplaceContrast, End) == 0x000120, "Member 'KuroCharacterMaterialControllerCache_SetHairDisplaceContrast::End' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroCharacterMaterialControllerCache.SetHairDisplaceProgress
// 0x01B0 (0x01B0 - 0x0000)
struct KuroCharacterMaterialControllerCache_SetHairDisplaceProgress final
{
public:
	struct FKuroCurveFloat                        Start;                                             // 0x0000(0x0090)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FKuroCurveFloat                        Loop;                                              // 0x0090(0x0090)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FKuroCurveFloat                        End;                                               // 0x0120(0x0090)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroCharacterMaterialControllerCache_SetHairDisplaceProgress) == 0x000008, "Wrong alignment on KuroCharacterMaterialControllerCache_SetHairDisplaceProgress");
static_assert(sizeof(KuroCharacterMaterialControllerCache_SetHairDisplaceProgress) == 0x0001B0, "Wrong size on KuroCharacterMaterialControllerCache_SetHairDisplaceProgress");
static_assert(offsetof(KuroCharacterMaterialControllerCache_SetHairDisplaceProgress, Start) == 0x000000, "Member 'KuroCharacterMaterialControllerCache_SetHairDisplaceProgress::Start' has a wrong offset!");
static_assert(offsetof(KuroCharacterMaterialControllerCache_SetHairDisplaceProgress, Loop) == 0x000090, "Member 'KuroCharacterMaterialControllerCache_SetHairDisplaceProgress::Loop' has a wrong offset!");
static_assert(offsetof(KuroCharacterMaterialControllerCache_SetHairDisplaceProgress, End) == 0x000120, "Member 'KuroCharacterMaterialControllerCache_SetHairDisplaceProgress::End' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroCharacterMaterialControllerCache.SetMainTexColorTint
// 0x0660 (0x0660 - 0x0000)
struct KuroCharacterMaterialControllerCache_SetMainTexColorTint final
{
public:
	struct FKuroCurveLinearColor                  Start;                                             // 0x0000(0x0220)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FKuroCurveLinearColor                  Loop;                                              // 0x0220(0x0220)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FKuroCurveLinearColor                  End;                                               // 0x0440(0x0220)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroCharacterMaterialControllerCache_SetMainTexColorTint) == 0x000008, "Wrong alignment on KuroCharacterMaterialControllerCache_SetMainTexColorTint");
static_assert(sizeof(KuroCharacterMaterialControllerCache_SetMainTexColorTint) == 0x000660, "Wrong size on KuroCharacterMaterialControllerCache_SetMainTexColorTint");
static_assert(offsetof(KuroCharacterMaterialControllerCache_SetMainTexColorTint, Start) == 0x000000, "Member 'KuroCharacterMaterialControllerCache_SetMainTexColorTint::Start' has a wrong offset!");
static_assert(offsetof(KuroCharacterMaterialControllerCache_SetMainTexColorTint, Loop) == 0x000220, "Member 'KuroCharacterMaterialControllerCache_SetMainTexColorTint::Loop' has a wrong offset!");
static_assert(offsetof(KuroCharacterMaterialControllerCache_SetMainTexColorTint, End) == 0x000440, "Member 'KuroCharacterMaterialControllerCache_SetMainTexColorTint::End' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroCharacterMaterialControllerCache.SetMotionColorEnd
// 0x0660 (0x0660 - 0x0000)
struct KuroCharacterMaterialControllerCache_SetMotionColorEnd final
{
public:
	struct FKuroCurveLinearColor                  Start;                                             // 0x0000(0x0220)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FKuroCurveLinearColor                  Loop;                                              // 0x0220(0x0220)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FKuroCurveLinearColor                  End;                                               // 0x0440(0x0220)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroCharacterMaterialControllerCache_SetMotionColorEnd) == 0x000008, "Wrong alignment on KuroCharacterMaterialControllerCache_SetMotionColorEnd");
static_assert(sizeof(KuroCharacterMaterialControllerCache_SetMotionColorEnd) == 0x000660, "Wrong size on KuroCharacterMaterialControllerCache_SetMotionColorEnd");
static_assert(offsetof(KuroCharacterMaterialControllerCache_SetMotionColorEnd, Start) == 0x000000, "Member 'KuroCharacterMaterialControllerCache_SetMotionColorEnd::Start' has a wrong offset!");
static_assert(offsetof(KuroCharacterMaterialControllerCache_SetMotionColorEnd, Loop) == 0x000220, "Member 'KuroCharacterMaterialControllerCache_SetMotionColorEnd::Loop' has a wrong offset!");
static_assert(offsetof(KuroCharacterMaterialControllerCache_SetMotionColorEnd, End) == 0x000440, "Member 'KuroCharacterMaterialControllerCache_SetMotionColorEnd::End' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroCharacterMaterialControllerCache.SetMotionColorStart
// 0x0660 (0x0660 - 0x0000)
struct KuroCharacterMaterialControllerCache_SetMotionColorStart final
{
public:
	struct FKuroCurveLinearColor                  Start;                                             // 0x0000(0x0220)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FKuroCurveLinearColor                  Loop;                                              // 0x0220(0x0220)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FKuroCurveLinearColor                  End;                                               // 0x0440(0x0220)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroCharacterMaterialControllerCache_SetMotionColorStart) == 0x000008, "Wrong alignment on KuroCharacterMaterialControllerCache_SetMotionColorStart");
static_assert(sizeof(KuroCharacterMaterialControllerCache_SetMotionColorStart) == 0x000660, "Wrong size on KuroCharacterMaterialControllerCache_SetMotionColorStart");
static_assert(offsetof(KuroCharacterMaterialControllerCache_SetMotionColorStart, Start) == 0x000000, "Member 'KuroCharacterMaterialControllerCache_SetMotionColorStart::Start' has a wrong offset!");
static_assert(offsetof(KuroCharacterMaterialControllerCache_SetMotionColorStart, Loop) == 0x000220, "Member 'KuroCharacterMaterialControllerCache_SetMotionColorStart::Loop' has a wrong offset!");
static_assert(offsetof(KuroCharacterMaterialControllerCache_SetMotionColorStart, End) == 0x000440, "Member 'KuroCharacterMaterialControllerCache_SetMotionColorStart::End' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroCharacterMaterialControllerCache.SetMotionNoiseSpeed
// 0x01B0 (0x01B0 - 0x0000)
struct KuroCharacterMaterialControllerCache_SetMotionNoiseSpeed final
{
public:
	struct FKuroCurveFloat                        Start;                                             // 0x0000(0x0090)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FKuroCurveFloat                        Loop;                                              // 0x0090(0x0090)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FKuroCurveFloat                        End;                                               // 0x0120(0x0090)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroCharacterMaterialControllerCache_SetMotionNoiseSpeed) == 0x000008, "Wrong alignment on KuroCharacterMaterialControllerCache_SetMotionNoiseSpeed");
static_assert(sizeof(KuroCharacterMaterialControllerCache_SetMotionNoiseSpeed) == 0x0001B0, "Wrong size on KuroCharacterMaterialControllerCache_SetMotionNoiseSpeed");
static_assert(offsetof(KuroCharacterMaterialControllerCache_SetMotionNoiseSpeed, Start) == 0x000000, "Member 'KuroCharacterMaterialControllerCache_SetMotionNoiseSpeed::Start' has a wrong offset!");
static_assert(offsetof(KuroCharacterMaterialControllerCache_SetMotionNoiseSpeed, Loop) == 0x000090, "Member 'KuroCharacterMaterialControllerCache_SetMotionNoiseSpeed::Loop' has a wrong offset!");
static_assert(offsetof(KuroCharacterMaterialControllerCache_SetMotionNoiseSpeed, End) == 0x000120, "Member 'KuroCharacterMaterialControllerCache_SetMotionNoiseSpeed::End' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroCharacterMaterialControllerCache.SetOutlineColor
// 0x0660 (0x0660 - 0x0000)
struct KuroCharacterMaterialControllerCache_SetOutlineColor final
{
public:
	struct FKuroCurveLinearColor                  Start;                                             // 0x0000(0x0220)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FKuroCurveLinearColor                  Loop;                                              // 0x0220(0x0220)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FKuroCurveLinearColor                  End;                                               // 0x0440(0x0220)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroCharacterMaterialControllerCache_SetOutlineColor) == 0x000008, "Wrong alignment on KuroCharacterMaterialControllerCache_SetOutlineColor");
static_assert(sizeof(KuroCharacterMaterialControllerCache_SetOutlineColor) == 0x000660, "Wrong size on KuroCharacterMaterialControllerCache_SetOutlineColor");
static_assert(offsetof(KuroCharacterMaterialControllerCache_SetOutlineColor, Start) == 0x000000, "Member 'KuroCharacterMaterialControllerCache_SetOutlineColor::Start' has a wrong offset!");
static_assert(offsetof(KuroCharacterMaterialControllerCache_SetOutlineColor, Loop) == 0x000220, "Member 'KuroCharacterMaterialControllerCache_SetOutlineColor::Loop' has a wrong offset!");
static_assert(offsetof(KuroCharacterMaterialControllerCache_SetOutlineColor, End) == 0x000440, "Member 'KuroCharacterMaterialControllerCache_SetOutlineColor::End' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroCharacterMaterialControllerCache.SetOutlineWidth
// 0x01B0 (0x01B0 - 0x0000)
struct KuroCharacterMaterialControllerCache_SetOutlineWidth final
{
public:
	struct FKuroCurveFloat                        Start;                                             // 0x0000(0x0090)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FKuroCurveFloat                        Loop;                                              // 0x0090(0x0090)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FKuroCurveFloat                        End;                                               // 0x0120(0x0090)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroCharacterMaterialControllerCache_SetOutlineWidth) == 0x000008, "Wrong alignment on KuroCharacterMaterialControllerCache_SetOutlineWidth");
static_assert(sizeof(KuroCharacterMaterialControllerCache_SetOutlineWidth) == 0x0001B0, "Wrong size on KuroCharacterMaterialControllerCache_SetOutlineWidth");
static_assert(offsetof(KuroCharacterMaterialControllerCache_SetOutlineWidth, Start) == 0x000000, "Member 'KuroCharacterMaterialControllerCache_SetOutlineWidth::Start' has a wrong offset!");
static_assert(offsetof(KuroCharacterMaterialControllerCache_SetOutlineWidth, Loop) == 0x000090, "Member 'KuroCharacterMaterialControllerCache_SetOutlineWidth::Loop' has a wrong offset!");
static_assert(offsetof(KuroCharacterMaterialControllerCache_SetOutlineWidth, End) == 0x000120, "Member 'KuroCharacterMaterialControllerCache_SetOutlineWidth::End' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroCharacterMaterialControllerCache.SetRimColor
// 0x0660 (0x0660 - 0x0000)
struct KuroCharacterMaterialControllerCache_SetRimColor final
{
public:
	struct FKuroCurveLinearColor                  Start;                                             // 0x0000(0x0220)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FKuroCurveLinearColor                  Loop;                                              // 0x0220(0x0220)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FKuroCurveLinearColor                  End;                                               // 0x0440(0x0220)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroCharacterMaterialControllerCache_SetRimColor) == 0x000008, "Wrong alignment on KuroCharacterMaterialControllerCache_SetRimColor");
static_assert(sizeof(KuroCharacterMaterialControllerCache_SetRimColor) == 0x000660, "Wrong size on KuroCharacterMaterialControllerCache_SetRimColor");
static_assert(offsetof(KuroCharacterMaterialControllerCache_SetRimColor, Start) == 0x000000, "Member 'KuroCharacterMaterialControllerCache_SetRimColor::Start' has a wrong offset!");
static_assert(offsetof(KuroCharacterMaterialControllerCache_SetRimColor, Loop) == 0x000220, "Member 'KuroCharacterMaterialControllerCache_SetRimColor::Loop' has a wrong offset!");
static_assert(offsetof(KuroCharacterMaterialControllerCache_SetRimColor, End) == 0x000440, "Member 'KuroCharacterMaterialControllerCache_SetRimColor::End' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroCharacterMaterialControllerCache.SetRimRange
// 0x01B0 (0x01B0 - 0x0000)
struct KuroCharacterMaterialControllerCache_SetRimRange final
{
public:
	struct FKuroCurveFloat                        Start;                                             // 0x0000(0x0090)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FKuroCurveFloat                        Loop;                                              // 0x0090(0x0090)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FKuroCurveFloat                        End;                                               // 0x0120(0x0090)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroCharacterMaterialControllerCache_SetRimRange) == 0x000008, "Wrong alignment on KuroCharacterMaterialControllerCache_SetRimRange");
static_assert(sizeof(KuroCharacterMaterialControllerCache_SetRimRange) == 0x0001B0, "Wrong size on KuroCharacterMaterialControllerCache_SetRimRange");
static_assert(offsetof(KuroCharacterMaterialControllerCache_SetRimRange, Start) == 0x000000, "Member 'KuroCharacterMaterialControllerCache_SetRimRange::Start' has a wrong offset!");
static_assert(offsetof(KuroCharacterMaterialControllerCache_SetRimRange, Loop) == 0x000090, "Member 'KuroCharacterMaterialControllerCache_SetRimRange::Loop' has a wrong offset!");
static_assert(offsetof(KuroCharacterMaterialControllerCache_SetRimRange, End) == 0x000120, "Member 'KuroCharacterMaterialControllerCache_SetRimRange::End' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroCharacterMaterialControllerCache.SetRotation
// 0x01B0 (0x01B0 - 0x0000)
struct KuroCharacterMaterialControllerCache_SetRotation final
{
public:
	struct FKuroCurveFloat                        Start;                                             // 0x0000(0x0090)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FKuroCurveFloat                        Loop;                                              // 0x0090(0x0090)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FKuroCurveFloat                        End;                                               // 0x0120(0x0090)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroCharacterMaterialControllerCache_SetRotation) == 0x000008, "Wrong alignment on KuroCharacterMaterialControllerCache_SetRotation");
static_assert(sizeof(KuroCharacterMaterialControllerCache_SetRotation) == 0x0001B0, "Wrong size on KuroCharacterMaterialControllerCache_SetRotation");
static_assert(offsetof(KuroCharacterMaterialControllerCache_SetRotation, Start) == 0x000000, "Member 'KuroCharacterMaterialControllerCache_SetRotation::Start' has a wrong offset!");
static_assert(offsetof(KuroCharacterMaterialControllerCache_SetRotation, Loop) == 0x000090, "Member 'KuroCharacterMaterialControllerCache_SetRotation::Loop' has a wrong offset!");
static_assert(offsetof(KuroCharacterMaterialControllerCache_SetRotation, End) == 0x000120, "Member 'KuroCharacterMaterialControllerCache_SetRotation::End' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroCharacterMaterialControllerCache.SetStripMaskProportion
// 0x01B0 (0x01B0 - 0x0000)
struct KuroCharacterMaterialControllerCache_SetStripMaskProportion final
{
public:
	struct FKuroCurveFloat                        Start;                                             // 0x0000(0x0090)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FKuroCurveFloat                        Loop;                                              // 0x0090(0x0090)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FKuroCurveFloat                        End;                                               // 0x0120(0x0090)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroCharacterMaterialControllerCache_SetStripMaskProportion) == 0x000008, "Wrong alignment on KuroCharacterMaterialControllerCache_SetStripMaskProportion");
static_assert(sizeof(KuroCharacterMaterialControllerCache_SetStripMaskProportion) == 0x0001B0, "Wrong size on KuroCharacterMaterialControllerCache_SetStripMaskProportion");
static_assert(offsetof(KuroCharacterMaterialControllerCache_SetStripMaskProportion, Start) == 0x000000, "Member 'KuroCharacterMaterialControllerCache_SetStripMaskProportion::Start' has a wrong offset!");
static_assert(offsetof(KuroCharacterMaterialControllerCache_SetStripMaskProportion, Loop) == 0x000090, "Member 'KuroCharacterMaterialControllerCache_SetStripMaskProportion::Loop' has a wrong offset!");
static_assert(offsetof(KuroCharacterMaterialControllerCache_SetStripMaskProportion, End) == 0x000120, "Member 'KuroCharacterMaterialControllerCache_SetStripMaskProportion::End' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroCharacterMaterialControllerCache.SetStripMaskVScale
// 0x01B0 (0x01B0 - 0x0000)
struct KuroCharacterMaterialControllerCache_SetStripMaskVScale final
{
public:
	struct FKuroCurveFloat                        Start;                                             // 0x0000(0x0090)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FKuroCurveFloat                        Loop;                                              // 0x0090(0x0090)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FKuroCurveFloat                        End;                                               // 0x0120(0x0090)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroCharacterMaterialControllerCache_SetStripMaskVScale) == 0x000008, "Wrong alignment on KuroCharacterMaterialControllerCache_SetStripMaskVScale");
static_assert(sizeof(KuroCharacterMaterialControllerCache_SetStripMaskVScale) == 0x0001B0, "Wrong size on KuroCharacterMaterialControllerCache_SetStripMaskVScale");
static_assert(offsetof(KuroCharacterMaterialControllerCache_SetStripMaskVScale, Start) == 0x000000, "Member 'KuroCharacterMaterialControllerCache_SetStripMaskVScale::Start' has a wrong offset!");
static_assert(offsetof(KuroCharacterMaterialControllerCache_SetStripMaskVScale, Loop) == 0x000090, "Member 'KuroCharacterMaterialControllerCache_SetStripMaskVScale::Loop' has a wrong offset!");
static_assert(offsetof(KuroCharacterMaterialControllerCache_SetStripMaskVScale, End) == 0x000120, "Member 'KuroCharacterMaterialControllerCache_SetStripMaskVScale::End' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroCharacterMaterialControllerCache.SetStripMaskVSpeed
// 0x01B0 (0x01B0 - 0x0000)
struct KuroCharacterMaterialControllerCache_SetStripMaskVSpeed final
{
public:
	struct FKuroCurveFloat                        Start;                                             // 0x0000(0x0090)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FKuroCurveFloat                        Loop;                                              // 0x0090(0x0090)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FKuroCurveFloat                        End;                                               // 0x0120(0x0090)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroCharacterMaterialControllerCache_SetStripMaskVSpeed) == 0x000008, "Wrong alignment on KuroCharacterMaterialControllerCache_SetStripMaskVSpeed");
static_assert(sizeof(KuroCharacterMaterialControllerCache_SetStripMaskVSpeed) == 0x0001B0, "Wrong size on KuroCharacterMaterialControllerCache_SetStripMaskVSpeed");
static_assert(offsetof(KuroCharacterMaterialControllerCache_SetStripMaskVSpeed, Start) == 0x000000, "Member 'KuroCharacterMaterialControllerCache_SetStripMaskVSpeed::Start' has a wrong offset!");
static_assert(offsetof(KuroCharacterMaterialControllerCache_SetStripMaskVSpeed, Loop) == 0x000090, "Member 'KuroCharacterMaterialControllerCache_SetStripMaskVSpeed::Loop' has a wrong offset!");
static_assert(offsetof(KuroCharacterMaterialControllerCache_SetStripMaskVSpeed, End) == 0x000120, "Member 'KuroCharacterMaterialControllerCache_SetStripMaskVSpeed::End' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroCharacterMaterialControllerCache.SetTextureColorTint
// 0x0660 (0x0660 - 0x0000)
struct KuroCharacterMaterialControllerCache_SetTextureColorTint final
{
public:
	struct FKuroCurveLinearColor                  Start;                                             // 0x0000(0x0220)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FKuroCurveLinearColor                  Loop;                                              // 0x0220(0x0220)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FKuroCurveLinearColor                  End;                                               // 0x0440(0x0220)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroCharacterMaterialControllerCache_SetTextureColorTint) == 0x000008, "Wrong alignment on KuroCharacterMaterialControllerCache_SetTextureColorTint");
static_assert(sizeof(KuroCharacterMaterialControllerCache_SetTextureColorTint) == 0x000660, "Wrong size on KuroCharacterMaterialControllerCache_SetTextureColorTint");
static_assert(offsetof(KuroCharacterMaterialControllerCache_SetTextureColorTint, Start) == 0x000000, "Member 'KuroCharacterMaterialControllerCache_SetTextureColorTint::Start' has a wrong offset!");
static_assert(offsetof(KuroCharacterMaterialControllerCache_SetTextureColorTint, Loop) == 0x000220, "Member 'KuroCharacterMaterialControllerCache_SetTextureColorTint::Loop' has a wrong offset!");
static_assert(offsetof(KuroCharacterMaterialControllerCache_SetTextureColorTint, End) == 0x000440, "Member 'KuroCharacterMaterialControllerCache_SetTextureColorTint::End' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroCharacterMaterialControllerCache.SetTextureLowerLimit
// 0x01B0 (0x01B0 - 0x0000)
struct KuroCharacterMaterialControllerCache_SetTextureLowerLimit final
{
public:
	struct FKuroCurveFloat                        Start;                                             // 0x0000(0x0090)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FKuroCurveFloat                        Loop;                                              // 0x0090(0x0090)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FKuroCurveFloat                        End;                                               // 0x0120(0x0090)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroCharacterMaterialControllerCache_SetTextureLowerLimit) == 0x000008, "Wrong alignment on KuroCharacterMaterialControllerCache_SetTextureLowerLimit");
static_assert(sizeof(KuroCharacterMaterialControllerCache_SetTextureLowerLimit) == 0x0001B0, "Wrong size on KuroCharacterMaterialControllerCache_SetTextureLowerLimit");
static_assert(offsetof(KuroCharacterMaterialControllerCache_SetTextureLowerLimit, Start) == 0x000000, "Member 'KuroCharacterMaterialControllerCache_SetTextureLowerLimit::Start' has a wrong offset!");
static_assert(offsetof(KuroCharacterMaterialControllerCache_SetTextureLowerLimit, Loop) == 0x000090, "Member 'KuroCharacterMaterialControllerCache_SetTextureLowerLimit::Loop' has a wrong offset!");
static_assert(offsetof(KuroCharacterMaterialControllerCache_SetTextureLowerLimit, End) == 0x000120, "Member 'KuroCharacterMaterialControllerCache_SetTextureLowerLimit::End' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroCharacterMaterialControllerCache.SetTextureScaleAndOffset
// 0x0660 (0x0660 - 0x0000)
struct KuroCharacterMaterialControllerCache_SetTextureScaleAndOffset final
{
public:
	struct FKuroCurveLinearColor                  Start;                                             // 0x0000(0x0220)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FKuroCurveLinearColor                  Loop;                                              // 0x0220(0x0220)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FKuroCurveLinearColor                  End;                                               // 0x0440(0x0220)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroCharacterMaterialControllerCache_SetTextureScaleAndOffset) == 0x000008, "Wrong alignment on KuroCharacterMaterialControllerCache_SetTextureScaleAndOffset");
static_assert(sizeof(KuroCharacterMaterialControllerCache_SetTextureScaleAndOffset) == 0x000660, "Wrong size on KuroCharacterMaterialControllerCache_SetTextureScaleAndOffset");
static_assert(offsetof(KuroCharacterMaterialControllerCache_SetTextureScaleAndOffset, Start) == 0x000000, "Member 'KuroCharacterMaterialControllerCache_SetTextureScaleAndOffset::Start' has a wrong offset!");
static_assert(offsetof(KuroCharacterMaterialControllerCache_SetTextureScaleAndOffset, Loop) == 0x000220, "Member 'KuroCharacterMaterialControllerCache_SetTextureScaleAndOffset::Loop' has a wrong offset!");
static_assert(offsetof(KuroCharacterMaterialControllerCache_SetTextureScaleAndOffset, End) == 0x000440, "Member 'KuroCharacterMaterialControllerCache_SetTextureScaleAndOffset::End' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroCharacterMaterialControllerCache.SetTextureSpeed
// 0x0660 (0x0660 - 0x0000)
struct KuroCharacterMaterialControllerCache_SetTextureSpeed final
{
public:
	struct FKuroCurveLinearColor                  Start;                                             // 0x0000(0x0220)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FKuroCurveLinearColor                  Loop;                                              // 0x0220(0x0220)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FKuroCurveLinearColor                  End;                                               // 0x0440(0x0220)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroCharacterMaterialControllerCache_SetTextureSpeed) == 0x000008, "Wrong alignment on KuroCharacterMaterialControllerCache_SetTextureSpeed");
static_assert(sizeof(KuroCharacterMaterialControllerCache_SetTextureSpeed) == 0x000660, "Wrong size on KuroCharacterMaterialControllerCache_SetTextureSpeed");
static_assert(offsetof(KuroCharacterMaterialControllerCache_SetTextureSpeed, Start) == 0x000000, "Member 'KuroCharacterMaterialControllerCache_SetTextureSpeed::Start' has a wrong offset!");
static_assert(offsetof(KuroCharacterMaterialControllerCache_SetTextureSpeed, Loop) == 0x000220, "Member 'KuroCharacterMaterialControllerCache_SetTextureSpeed::Loop' has a wrong offset!");
static_assert(offsetof(KuroCharacterMaterialControllerCache_SetTextureSpeed, End) == 0x000440, "Member 'KuroCharacterMaterialControllerCache_SetTextureSpeed::End' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroCharacterMaterialControllerCache.SetTextureStrength
// 0x01B0 (0x01B0 - 0x0000)
struct KuroCharacterMaterialControllerCache_SetTextureStrength final
{
public:
	struct FKuroCurveFloat                        Start;                                             // 0x0000(0x0090)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FKuroCurveFloat                        Loop;                                              // 0x0090(0x0090)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FKuroCurveFloat                        End;                                               // 0x0120(0x0090)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroCharacterMaterialControllerCache_SetTextureStrength) == 0x000008, "Wrong alignment on KuroCharacterMaterialControllerCache_SetTextureStrength");
static_assert(sizeof(KuroCharacterMaterialControllerCache_SetTextureStrength) == 0x0001B0, "Wrong size on KuroCharacterMaterialControllerCache_SetTextureStrength");
static_assert(offsetof(KuroCharacterMaterialControllerCache_SetTextureStrength, Start) == 0x000000, "Member 'KuroCharacterMaterialControllerCache_SetTextureStrength::Start' has a wrong offset!");
static_assert(offsetof(KuroCharacterMaterialControllerCache_SetTextureStrength, Loop) == 0x000090, "Member 'KuroCharacterMaterialControllerCache_SetTextureStrength::Loop' has a wrong offset!");
static_assert(offsetof(KuroCharacterMaterialControllerCache_SetTextureStrength, End) == 0x000120, "Member 'KuroCharacterMaterialControllerCache_SetTextureStrength::End' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroCharacterMaterialControllerCache.SetTextureUpperLimit
// 0x01B0 (0x01B0 - 0x0000)
struct KuroCharacterMaterialControllerCache_SetTextureUpperLimit final
{
public:
	struct FKuroCurveFloat                        Start;                                             // 0x0000(0x0090)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FKuroCurveFloat                        Loop;                                              // 0x0090(0x0090)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FKuroCurveFloat                        End;                                               // 0x0120(0x0090)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroCharacterMaterialControllerCache_SetTextureUpperLimit) == 0x000008, "Wrong alignment on KuroCharacterMaterialControllerCache_SetTextureUpperLimit");
static_assert(sizeof(KuroCharacterMaterialControllerCache_SetTextureUpperLimit) == 0x0001B0, "Wrong size on KuroCharacterMaterialControllerCache_SetTextureUpperLimit");
static_assert(offsetof(KuroCharacterMaterialControllerCache_SetTextureUpperLimit, Start) == 0x000000, "Member 'KuroCharacterMaterialControllerCache_SetTextureUpperLimit::Start' has a wrong offset!");
static_assert(offsetof(KuroCharacterMaterialControllerCache_SetTextureUpperLimit, Loop) == 0x000090, "Member 'KuroCharacterMaterialControllerCache_SetTextureUpperLimit::Loop' has a wrong offset!");
static_assert(offsetof(KuroCharacterMaterialControllerCache_SetTextureUpperLimit, End) == 0x000120, "Member 'KuroCharacterMaterialControllerCache_SetTextureUpperLimit::End' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroCharRenderingComponent.AddHitMeshOnSocket
// 0x0090 (0x0090 - 0x0000)
struct KuroCharRenderingComponent_AddHitMeshOnSocket final
{
public:
	class USkeletalMesh*                          SkeletalMesh;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransformDouble                       WorldTransform;                                    // 0x0010(0x0040)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	class FName                                   Socket;                                            // 0x0050(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LastTime;                                          // 0x005C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTransform                             MeshTransform;                                     // 0x0060(0x0030)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroCharRenderingComponent_AddHitMeshOnSocket) == 0x000010, "Wrong alignment on KuroCharRenderingComponent_AddHitMeshOnSocket");
static_assert(sizeof(KuroCharRenderingComponent_AddHitMeshOnSocket) == 0x000090, "Wrong size on KuroCharRenderingComponent_AddHitMeshOnSocket");
static_assert(offsetof(KuroCharRenderingComponent_AddHitMeshOnSocket, SkeletalMesh) == 0x000000, "Member 'KuroCharRenderingComponent_AddHitMeshOnSocket::SkeletalMesh' has a wrong offset!");
static_assert(offsetof(KuroCharRenderingComponent_AddHitMeshOnSocket, WorldTransform) == 0x000010, "Member 'KuroCharRenderingComponent_AddHitMeshOnSocket::WorldTransform' has a wrong offset!");
static_assert(offsetof(KuroCharRenderingComponent_AddHitMeshOnSocket, Socket) == 0x000050, "Member 'KuroCharRenderingComponent_AddHitMeshOnSocket::Socket' has a wrong offset!");
static_assert(offsetof(KuroCharRenderingComponent_AddHitMeshOnSocket, LastTime) == 0x00005C, "Member 'KuroCharRenderingComponent_AddHitMeshOnSocket::LastTime' has a wrong offset!");
static_assert(offsetof(KuroCharRenderingComponent_AddHitMeshOnSocket, MeshTransform) == 0x000060, "Member 'KuroCharRenderingComponent_AddHitMeshOnSocket::MeshTransform' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroCharRenderingComponent.GetSureMaterialController
// 0x0008 (0x0008 - 0x0000)
struct KuroCharRenderingComponent_GetSureMaterialController final
{
public:
	class UKuroMaterialControllerComponent*       ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroCharRenderingComponent_GetSureMaterialController) == 0x000008, "Wrong alignment on KuroCharRenderingComponent_GetSureMaterialController");
static_assert(sizeof(KuroCharRenderingComponent_GetSureMaterialController) == 0x000008, "Wrong size on KuroCharRenderingComponent_GetSureMaterialController");
static_assert(offsetof(KuroCharRenderingComponent_GetSureMaterialController, ReturnValue) == 0x000000, "Member 'KuroCharRenderingComponent_GetSureMaterialController::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroCharRenderingComponent.UpdateHitMesh
// 0x0004 (0x0004 - 0x0000)
struct KuroCharRenderingComponent_UpdateHitMesh final
{
public:
	float                                         DeltaTime;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroCharRenderingComponent_UpdateHitMesh) == 0x000004, "Wrong alignment on KuroCharRenderingComponent_UpdateHitMesh");
static_assert(sizeof(KuroCharRenderingComponent_UpdateHitMesh) == 0x000004, "Wrong size on KuroCharRenderingComponent_UpdateHitMesh");
static_assert(offsetof(KuroCharRenderingComponent_UpdateHitMesh, DeltaTime) == 0x000000, "Member 'KuroCharRenderingComponent_UpdateHitMesh::DeltaTime' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroEditorTickActor.EditorTick
// 0x0004 (0x0004 - 0x0000)
struct KuroEditorTickActor_EditorTick final
{
public:
	float                                         DeltaSeconds;                                      // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroEditorTickActor_EditorTick) == 0x000004, "Wrong alignment on KuroEditorTickActor_EditorTick");
static_assert(sizeof(KuroEditorTickActor_EditorTick) == 0x000004, "Wrong size on KuroEditorTickActor_EditorTick");
static_assert(offsetof(KuroEditorTickActor_EditorTick, DeltaSeconds) == 0x000000, "Member 'KuroEditorTickActor_EditorTick::DeltaSeconds' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroEditorTickActor.EditorSetActorComponentsTickEnabled
// 0x0001 (0x0001 - 0x0000)
struct KuroEditorTickActor_EditorSetActorComponentsTickEnabled final
{
public:
	bool                                          bValue;                                            // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroEditorTickActor_EditorSetActorComponentsTickEnabled) == 0x000001, "Wrong alignment on KuroEditorTickActor_EditorSetActorComponentsTickEnabled");
static_assert(sizeof(KuroEditorTickActor_EditorSetActorComponentsTickEnabled) == 0x000001, "Wrong size on KuroEditorTickActor_EditorSetActorComponentsTickEnabled");
static_assert(offsetof(KuroEditorTickActor_EditorSetActorComponentsTickEnabled, bValue) == 0x000000, "Member 'KuroEditorTickActor_EditorSetActorComponentsTickEnabled::bValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroCloudPrefabActor.CreateDMI
// 0x0010 (0x0010 - 0x0000)
struct KuroCloudPrefabActor_CreateDMI final
{
public:
	class UStaticMeshComponent*                   Mesh;                                              // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInstanceDynamic*               ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroCloudPrefabActor_CreateDMI) == 0x000008, "Wrong alignment on KuroCloudPrefabActor_CreateDMI");
static_assert(sizeof(KuroCloudPrefabActor_CreateDMI) == 0x000010, "Wrong size on KuroCloudPrefabActor_CreateDMI");
static_assert(offsetof(KuroCloudPrefabActor_CreateDMI, Mesh) == 0x000000, "Member 'KuroCloudPrefabActor_CreateDMI::Mesh' has a wrong offset!");
static_assert(offsetof(KuroCloudPrefabActor_CreateDMI, ReturnValue) == 0x000008, "Member 'KuroCloudPrefabActor_CreateDMI::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroCloudPrefabActor.SetGIParams
// 0x0020 (0x0020 - 0x0000)
struct KuroCloudPrefabActor_SetGIParams final
{
public:
	float                                         CurrentTime;                                       // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialParameterCollection*           CloudCardCollection;                               // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ParameterName;                                     // 0x0010(0x000C)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroCloudPrefabActor_SetGIParams) == 0x000008, "Wrong alignment on KuroCloudPrefabActor_SetGIParams");
static_assert(sizeof(KuroCloudPrefabActor_SetGIParams) == 0x000020, "Wrong size on KuroCloudPrefabActor_SetGIParams");
static_assert(offsetof(KuroCloudPrefabActor_SetGIParams, CurrentTime) == 0x000000, "Member 'KuroCloudPrefabActor_SetGIParams::CurrentTime' has a wrong offset!");
static_assert(offsetof(KuroCloudPrefabActor_SetGIParams, CloudCardCollection) == 0x000008, "Member 'KuroCloudPrefabActor_SetGIParams::CloudCardCollection' has a wrong offset!");
static_assert(offsetof(KuroCloudPrefabActor_SetGIParams, ParameterName) == 0x000010, "Member 'KuroCloudPrefabActor_SetGIParams::ParameterName' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroCloudPrefabActor.SingleBuildingParametersInitial
// 0x0058 (0x0058 - 0x0000)
struct KuroCloudPrefabActor_SingleBuildingParametersInitial final
{
public:
	class UMaterialInstanceDynamic*               DynamicMaterial;                                   // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   Mesh;                                              // 0x0008(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FAnomaliesParameters                   CloudStructParameter;                              // 0x0010(0x0038)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	int32                                         TransSortNumber;                                   // 0x0048(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4C[0x4];                                       // 0x004C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialParameterCollection*           GloablShadingParameters;                           // 0x0050(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroCloudPrefabActor_SingleBuildingParametersInitial) == 0x000008, "Wrong alignment on KuroCloudPrefabActor_SingleBuildingParametersInitial");
static_assert(sizeof(KuroCloudPrefabActor_SingleBuildingParametersInitial) == 0x000058, "Wrong size on KuroCloudPrefabActor_SingleBuildingParametersInitial");
static_assert(offsetof(KuroCloudPrefabActor_SingleBuildingParametersInitial, DynamicMaterial) == 0x000000, "Member 'KuroCloudPrefabActor_SingleBuildingParametersInitial::DynamicMaterial' has a wrong offset!");
static_assert(offsetof(KuroCloudPrefabActor_SingleBuildingParametersInitial, Mesh) == 0x000008, "Member 'KuroCloudPrefabActor_SingleBuildingParametersInitial::Mesh' has a wrong offset!");
static_assert(offsetof(KuroCloudPrefabActor_SingleBuildingParametersInitial, CloudStructParameter) == 0x000010, "Member 'KuroCloudPrefabActor_SingleBuildingParametersInitial::CloudStructParameter' has a wrong offset!");
static_assert(offsetof(KuroCloudPrefabActor_SingleBuildingParametersInitial, TransSortNumber) == 0x000048, "Member 'KuroCloudPrefabActor_SingleBuildingParametersInitial::TransSortNumber' has a wrong offset!");
static_assert(offsetof(KuroCloudPrefabActor_SingleBuildingParametersInitial, GloablShadingParameters) == 0x000050, "Member 'KuroCloudPrefabActor_SingleBuildingParametersInitial::GloablShadingParameters' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroCloudPrefabActor.SingleCloudCoverParametersInitial
// 0x0050 (0x0050 - 0x0000)
struct KuroCloudPrefabActor_SingleCloudCoverParametersInitial final
{
public:
	class UStaticMeshComponent*                   Mesh;                                              // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FCloudCover                            CloudStructParameter;                              // 0x0008(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	int32                                         TransSortNumber;                                   // 0x0020(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialParameterCollection*           GloablShadingParameters;                           // 0x0028(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInstance*                      CurrentCoverMaterial;                              // 0x0030(0x0008)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSetCoverMaterial;                                 // 0x0038(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialParameterCollection*           CloudParameters;                                   // 0x0040(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInstanceDynamic*               ReturnValue;                                       // 0x0048(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroCloudPrefabActor_SingleCloudCoverParametersInitial) == 0x000008, "Wrong alignment on KuroCloudPrefabActor_SingleCloudCoverParametersInitial");
static_assert(sizeof(KuroCloudPrefabActor_SingleCloudCoverParametersInitial) == 0x000050, "Wrong size on KuroCloudPrefabActor_SingleCloudCoverParametersInitial");
static_assert(offsetof(KuroCloudPrefabActor_SingleCloudCoverParametersInitial, Mesh) == 0x000000, "Member 'KuroCloudPrefabActor_SingleCloudCoverParametersInitial::Mesh' has a wrong offset!");
static_assert(offsetof(KuroCloudPrefabActor_SingleCloudCoverParametersInitial, CloudStructParameter) == 0x000008, "Member 'KuroCloudPrefabActor_SingleCloudCoverParametersInitial::CloudStructParameter' has a wrong offset!");
static_assert(offsetof(KuroCloudPrefabActor_SingleCloudCoverParametersInitial, TransSortNumber) == 0x000020, "Member 'KuroCloudPrefabActor_SingleCloudCoverParametersInitial::TransSortNumber' has a wrong offset!");
static_assert(offsetof(KuroCloudPrefabActor_SingleCloudCoverParametersInitial, GloablShadingParameters) == 0x000028, "Member 'KuroCloudPrefabActor_SingleCloudCoverParametersInitial::GloablShadingParameters' has a wrong offset!");
static_assert(offsetof(KuroCloudPrefabActor_SingleCloudCoverParametersInitial, CurrentCoverMaterial) == 0x000030, "Member 'KuroCloudPrefabActor_SingleCloudCoverParametersInitial::CurrentCoverMaterial' has a wrong offset!");
static_assert(offsetof(KuroCloudPrefabActor_SingleCloudCoverParametersInitial, bSetCoverMaterial) == 0x000038, "Member 'KuroCloudPrefabActor_SingleCloudCoverParametersInitial::bSetCoverMaterial' has a wrong offset!");
static_assert(offsetof(KuroCloudPrefabActor_SingleCloudCoverParametersInitial, CloudParameters) == 0x000040, "Member 'KuroCloudPrefabActor_SingleCloudCoverParametersInitial::CloudParameters' has a wrong offset!");
static_assert(offsetof(KuroCloudPrefabActor_SingleCloudCoverParametersInitial, ReturnValue) == 0x000048, "Member 'KuroCloudPrefabActor_SingleCloudCoverParametersInitial::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroCloudPrefabActor.SingleCloudParametersInitial
// 0x00E0 (0x00E0 - 0x0000)
struct KuroCloudPrefabActor_SingleCloudParametersInitial final
{
public:
	class UMaterialInstanceDynamic*               DynamicMaterial;                                   // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   Mesh;                                              // 0x0008(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FCloudParameters                       CloudStructParameter;                              // 0x0010(0x00C0)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	int32                                         TransSortNumber;                                   // 0x00D0(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D4[0x4];                                       // 0x00D4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialParameterCollection*           GloablShadingParameters;                           // 0x00D8(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroCloudPrefabActor_SingleCloudParametersInitial) == 0x000008, "Wrong alignment on KuroCloudPrefabActor_SingleCloudParametersInitial");
static_assert(sizeof(KuroCloudPrefabActor_SingleCloudParametersInitial) == 0x0000E0, "Wrong size on KuroCloudPrefabActor_SingleCloudParametersInitial");
static_assert(offsetof(KuroCloudPrefabActor_SingleCloudParametersInitial, DynamicMaterial) == 0x000000, "Member 'KuroCloudPrefabActor_SingleCloudParametersInitial::DynamicMaterial' has a wrong offset!");
static_assert(offsetof(KuroCloudPrefabActor_SingleCloudParametersInitial, Mesh) == 0x000008, "Member 'KuroCloudPrefabActor_SingleCloudParametersInitial::Mesh' has a wrong offset!");
static_assert(offsetof(KuroCloudPrefabActor_SingleCloudParametersInitial, CloudStructParameter) == 0x000010, "Member 'KuroCloudPrefabActor_SingleCloudParametersInitial::CloudStructParameter' has a wrong offset!");
static_assert(offsetof(KuroCloudPrefabActor_SingleCloudParametersInitial, TransSortNumber) == 0x0000D0, "Member 'KuroCloudPrefabActor_SingleCloudParametersInitial::TransSortNumber' has a wrong offset!");
static_assert(offsetof(KuroCloudPrefabActor_SingleCloudParametersInitial, GloablShadingParameters) == 0x0000D8, "Member 'KuroCloudPrefabActor_SingleCloudParametersInitial::GloablShadingParameters' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroCloudPrefabActor.SingleMountainParametersInitial
// 0x0018 (0x0018 - 0x0000)
struct KuroCloudPrefabActor_SingleMountainParametersInitial final
{
public:
	class UStaticMeshComponent*                   Mesh;                                              // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasMountain;                                      // 0x0008(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialParameterCollection*           GloablShadingParameters;                           // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroCloudPrefabActor_SingleMountainParametersInitial) == 0x000008, "Wrong alignment on KuroCloudPrefabActor_SingleMountainParametersInitial");
static_assert(sizeof(KuroCloudPrefabActor_SingleMountainParametersInitial) == 0x000018, "Wrong size on KuroCloudPrefabActor_SingleMountainParametersInitial");
static_assert(offsetof(KuroCloudPrefabActor_SingleMountainParametersInitial, Mesh) == 0x000000, "Member 'KuroCloudPrefabActor_SingleMountainParametersInitial::Mesh' has a wrong offset!");
static_assert(offsetof(KuroCloudPrefabActor_SingleMountainParametersInitial, bHasMountain) == 0x000008, "Member 'KuroCloudPrefabActor_SingleMountainParametersInitial::bHasMountain' has a wrong offset!");
static_assert(offsetof(KuroCloudPrefabActor_SingleMountainParametersInitial, GloablShadingParameters) == 0x000010, "Member 'KuroCloudPrefabActor_SingleMountainParametersInitial::GloablShadingParameters' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroCloudPrefabActor.SinglePOICloudParametersInitial
// 0x0070 (0x0070 - 0x0000)
struct KuroCloudPrefabActor_SinglePOICloudParametersInitial final
{
public:
	class UMaterialInstanceDynamic*               DynamicMaterial;                                   // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   Mesh;                                              // 0x0008(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPOICloudParameters                    CloudStructParameter;                              // 0x0010(0x0040)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	int32                                         TransSortNumber;                                   // 0x0050(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_54[0x4];                                       // 0x0054(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialParameterCollection*           GloablShadingParameters;                           // 0x0058(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialParameterCollection*           CloudParameters;                                   // 0x0060(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Random;                                            // 0x0068(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6C[0x4];                                       // 0x006C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroCloudPrefabActor_SinglePOICloudParametersInitial) == 0x000008, "Wrong alignment on KuroCloudPrefabActor_SinglePOICloudParametersInitial");
static_assert(sizeof(KuroCloudPrefabActor_SinglePOICloudParametersInitial) == 0x000070, "Wrong size on KuroCloudPrefabActor_SinglePOICloudParametersInitial");
static_assert(offsetof(KuroCloudPrefabActor_SinglePOICloudParametersInitial, DynamicMaterial) == 0x000000, "Member 'KuroCloudPrefabActor_SinglePOICloudParametersInitial::DynamicMaterial' has a wrong offset!");
static_assert(offsetof(KuroCloudPrefabActor_SinglePOICloudParametersInitial, Mesh) == 0x000008, "Member 'KuroCloudPrefabActor_SinglePOICloudParametersInitial::Mesh' has a wrong offset!");
static_assert(offsetof(KuroCloudPrefabActor_SinglePOICloudParametersInitial, CloudStructParameter) == 0x000010, "Member 'KuroCloudPrefabActor_SinglePOICloudParametersInitial::CloudStructParameter' has a wrong offset!");
static_assert(offsetof(KuroCloudPrefabActor_SinglePOICloudParametersInitial, TransSortNumber) == 0x000050, "Member 'KuroCloudPrefabActor_SinglePOICloudParametersInitial::TransSortNumber' has a wrong offset!");
static_assert(offsetof(KuroCloudPrefabActor_SinglePOICloudParametersInitial, GloablShadingParameters) == 0x000058, "Member 'KuroCloudPrefabActor_SinglePOICloudParametersInitial::GloablShadingParameters' has a wrong offset!");
static_assert(offsetof(KuroCloudPrefabActor_SinglePOICloudParametersInitial, CloudParameters) == 0x000060, "Member 'KuroCloudPrefabActor_SinglePOICloudParametersInitial::CloudParameters' has a wrong offset!");
static_assert(offsetof(KuroCloudPrefabActor_SinglePOICloudParametersInitial, Random) == 0x000068, "Member 'KuroCloudPrefabActor_SinglePOICloudParametersInitial::Random' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroCloudsActor.GetGIParams
// 0x0030 (0x0030 - 0x0000)
struct KuroCloudsActor_GetGIParams final
{
public:
	bool                                          bCounting;                                         // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UChildActorComponent*                   Child01;                                           // 0x0008(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UChildActorComponent*                   Child02;                                           // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialParameterCollection*           CloudCardCollection;                               // 0x0018(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ParameterName;                                     // 0x0020(0x000C)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CurrentTime;                                       // 0x002C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroCloudsActor_GetGIParams) == 0x000008, "Wrong alignment on KuroCloudsActor_GetGIParams");
static_assert(sizeof(KuroCloudsActor_GetGIParams) == 0x000030, "Wrong size on KuroCloudsActor_GetGIParams");
static_assert(offsetof(KuroCloudsActor_GetGIParams, bCounting) == 0x000000, "Member 'KuroCloudsActor_GetGIParams::bCounting' has a wrong offset!");
static_assert(offsetof(KuroCloudsActor_GetGIParams, Child01) == 0x000008, "Member 'KuroCloudsActor_GetGIParams::Child01' has a wrong offset!");
static_assert(offsetof(KuroCloudsActor_GetGIParams, Child02) == 0x000010, "Member 'KuroCloudsActor_GetGIParams::Child02' has a wrong offset!");
static_assert(offsetof(KuroCloudsActor_GetGIParams, CloudCardCollection) == 0x000018, "Member 'KuroCloudsActor_GetGIParams::CloudCardCollection' has a wrong offset!");
static_assert(offsetof(KuroCloudsActor_GetGIParams, ParameterName) == 0x000020, "Member 'KuroCloudsActor_GetGIParams::ParameterName' has a wrong offset!");
static_assert(offsetof(KuroCloudsActor_GetGIParams, CurrentTime) == 0x00002C, "Member 'KuroCloudsActor_GetGIParams::CurrentTime' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingDataDistortionProxyManageSystem.SetWaveConfig
// 0x0020 (0x0020 - 0x0000)
struct KuroRenderingDataDistortionProxyManageSystem_SetWaveConfig final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                WaveDirection;                                     // 0x0008(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WaveInterval;                                      // 0x0014(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WaveDuration;                                      // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WavePhaseSpeed;                                    // 0x001C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRenderingDataDistortionProxyManageSystem_SetWaveConfig) == 0x000008, "Wrong alignment on KuroRenderingDataDistortionProxyManageSystem_SetWaveConfig");
static_assert(sizeof(KuroRenderingDataDistortionProxyManageSystem_SetWaveConfig) == 0x000020, "Wrong size on KuroRenderingDataDistortionProxyManageSystem_SetWaveConfig");
static_assert(offsetof(KuroRenderingDataDistortionProxyManageSystem_SetWaveConfig, WorldContextObject) == 0x000000, "Member 'KuroRenderingDataDistortionProxyManageSystem_SetWaveConfig::WorldContextObject' has a wrong offset!");
static_assert(offsetof(KuroRenderingDataDistortionProxyManageSystem_SetWaveConfig, WaveDirection) == 0x000008, "Member 'KuroRenderingDataDistortionProxyManageSystem_SetWaveConfig::WaveDirection' has a wrong offset!");
static_assert(offsetof(KuroRenderingDataDistortionProxyManageSystem_SetWaveConfig, WaveInterval) == 0x000014, "Member 'KuroRenderingDataDistortionProxyManageSystem_SetWaveConfig::WaveInterval' has a wrong offset!");
static_assert(offsetof(KuroRenderingDataDistortionProxyManageSystem_SetWaveConfig, WaveDuration) == 0x000018, "Member 'KuroRenderingDataDistortionProxyManageSystem_SetWaveConfig::WaveDuration' has a wrong offset!");
static_assert(offsetof(KuroRenderingDataDistortionProxyManageSystem_SetWaveConfig, WavePhaseSpeed) == 0x00001C, "Member 'KuroRenderingDataDistortionProxyManageSystem_SetWaveConfig::WavePhaseSpeed' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroDestructibleActor.ApplyDamage
// 0x0018 (0x0018 - 0x0000)
struct KuroDestructibleActor_ApplyDamage final
{
public:
	struct FVector                                HurtOrigin;                                        // 0x0000(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                HurtDirection;                                     // 0x000C(0x000C)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroDestructibleActor_ApplyDamage) == 0x000004, "Wrong alignment on KuroDestructibleActor_ApplyDamage");
static_assert(sizeof(KuroDestructibleActor_ApplyDamage) == 0x000018, "Wrong size on KuroDestructibleActor_ApplyDamage");
static_assert(offsetof(KuroDestructibleActor_ApplyDamage, HurtOrigin) == 0x000000, "Member 'KuroDestructibleActor_ApplyDamage::HurtOrigin' has a wrong offset!");
static_assert(offsetof(KuroDestructibleActor_ApplyDamage, HurtDirection) == 0x00000C, "Member 'KuroDestructibleActor_ApplyDamage::HurtDirection' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroDestructibleActor.ApplyTransformToPoseableMeshComponent
// 0x0001 (0x0001 - 0x0000)
struct KuroDestructibleActor_ApplyTransformToPoseableMeshComponent final
{
public:
	EBoneSpaces                                   BoneSpace;                                         // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroDestructibleActor_ApplyTransformToPoseableMeshComponent) == 0x000001, "Wrong alignment on KuroDestructibleActor_ApplyTransformToPoseableMeshComponent");
static_assert(sizeof(KuroDestructibleActor_ApplyTransformToPoseableMeshComponent) == 0x000001, "Wrong size on KuroDestructibleActor_ApplyTransformToPoseableMeshComponent");
static_assert(offsetof(KuroDestructibleActor_ApplyTransformToPoseableMeshComponent, BoneSpace) == 0x000000, "Member 'KuroDestructibleActor_ApplyTransformToPoseableMeshComponent::BoneSpace' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroDestructibleActor.SetStaticMeshChunkListPhysicsSimulation
// 0x0001 (0x0001 - 0x0000)
struct KuroDestructibleActor_SetStaticMeshChunkListPhysicsSimulation final
{
public:
	bool                                          bSimulate;                                         // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroDestructibleActor_SetStaticMeshChunkListPhysicsSimulation) == 0x000001, "Wrong alignment on KuroDestructibleActor_SetStaticMeshChunkListPhysicsSimulation");
static_assert(sizeof(KuroDestructibleActor_SetStaticMeshChunkListPhysicsSimulation) == 0x000001, "Wrong size on KuroDestructibleActor_SetStaticMeshChunkListPhysicsSimulation");
static_assert(offsetof(KuroDestructibleActor_SetStaticMeshChunkListPhysicsSimulation, bSimulate) == 0x000000, "Member 'KuroDestructibleActor_SetStaticMeshChunkListPhysicsSimulation::bSimulate' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroDestructibleActor.ToggleMeshComponent
// 0x0001 (0x0001 - 0x0000)
struct KuroDestructibleActor_ToggleMeshComponent final
{
public:
	bool                                          bShowPoseableMeshComponent;                        // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroDestructibleActor_ToggleMeshComponent) == 0x000001, "Wrong alignment on KuroDestructibleActor_ToggleMeshComponent");
static_assert(sizeof(KuroDestructibleActor_ToggleMeshComponent) == 0x000001, "Wrong size on KuroDestructibleActor_ToggleMeshComponent");
static_assert(offsetof(KuroDestructibleActor_ToggleMeshComponent, bShowPoseableMeshComponent) == 0x000000, "Member 'KuroDestructibleActor_ToggleMeshComponent::bShowPoseableMeshComponent' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroDestructibleActor.UpdatePoseableMeshComponent
// 0x0001 (0x0001 - 0x0000)
struct KuroDestructibleActor_UpdatePoseableMeshComponent final
{
public:
	bool                                          bSnapToProxyMeshComponent;                         // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroDestructibleActor_UpdatePoseableMeshComponent) == 0x000001, "Wrong alignment on KuroDestructibleActor_UpdatePoseableMeshComponent");
static_assert(sizeof(KuroDestructibleActor_UpdatePoseableMeshComponent) == 0x000001, "Wrong size on KuroDestructibleActor_UpdatePoseableMeshComponent");
static_assert(offsetof(KuroDestructibleActor_UpdatePoseableMeshComponent, bSnapToProxyMeshComponent) == 0x000000, "Member 'KuroDestructibleActor_UpdatePoseableMeshComponent::bSnapToProxyMeshComponent' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroEffectActor.DoHiddenInGame
// 0x0001 (0x0001 - 0x0000)
struct KuroEffectActor_DoHiddenInGame final
{
public:
	bool                                          bValue;                                            // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroEffectActor_DoHiddenInGame) == 0x000001, "Wrong alignment on KuroEffectActor_DoHiddenInGame");
static_assert(sizeof(KuroEffectActor_DoHiddenInGame) == 0x000001, "Wrong size on KuroEffectActor_DoHiddenInGame");
static_assert(offsetof(KuroEffectActor_DoHiddenInGame, bValue) == 0x000000, "Member 'KuroEffectActor_DoHiddenInGame::bValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroEffectActor.EditorTick
// 0x0004 (0x0004 - 0x0000)
struct KuroEffectActor_EditorTick final
{
public:
	float                                         DeltaSeconds;                                      // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroEffectActor_EditorTick) == 0x000004, "Wrong alignment on KuroEffectActor_EditorTick");
static_assert(sizeof(KuroEffectActor_EditorTick) == 0x000004, "Wrong size on KuroEffectActor_EditorTick");
static_assert(offsetof(KuroEffectActor_EditorTick, DeltaSeconds) == 0x000000, "Member 'KuroEffectActor_EditorTick::DeltaSeconds' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroEffectActor.EditorSetActorComponentsTickEnabled
// 0x0001 (0x0001 - 0x0000)
struct KuroEffectActor_EditorSetActorComponentsTickEnabled final
{
public:
	bool                                          bValue;                                            // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroEffectActor_EditorSetActorComponentsTickEnabled) == 0x000001, "Wrong alignment on KuroEffectActor_EditorSetActorComponentsTickEnabled");
static_assert(sizeof(KuroEffectActor_EditorSetActorComponentsTickEnabled) == 0x000001, "Wrong size on KuroEffectActor_EditorSetActorComponentsTickEnabled");
static_assert(offsetof(KuroEffectActor_EditorSetActorComponentsTickEnabled, bValue) == 0x000000, "Member 'KuroEffectActor_EditorSetActorComponentsTickEnabled::bValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroFlickerLightActor.CalculateIntensity
// 0x0004 (0x0004 - 0x0000)
struct KuroFlickerLightActor_CalculateIntensity final
{
public:
	float                                         DeltaTime;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroFlickerLightActor_CalculateIntensity) == 0x000004, "Wrong alignment on KuroFlickerLightActor_CalculateIntensity");
static_assert(sizeof(KuroFlickerLightActor_CalculateIntensity) == 0x000004, "Wrong size on KuroFlickerLightActor_CalculateIntensity");
static_assert(offsetof(KuroFlickerLightActor_CalculateIntensity, DeltaTime) == 0x000000, "Member 'KuroFlickerLightActor_CalculateIntensity::DeltaTime' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroFlickerLightActor.ForeachPointLight
// 0x0008 (0x0008 - 0x0000)
struct KuroFlickerLightActor_ForeachPointLight final
{
public:
	class UPointLightComponent*                   PointLightComponent;                               // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroFlickerLightActor_ForeachPointLight) == 0x000008, "Wrong alignment on KuroFlickerLightActor_ForeachPointLight");
static_assert(sizeof(KuroFlickerLightActor_ForeachPointLight) == 0x000008, "Wrong size on KuroFlickerLightActor_ForeachPointLight");
static_assert(offsetof(KuroFlickerLightActor_ForeachPointLight, PointLightComponent) == 0x000000, "Member 'KuroFlickerLightActor_ForeachPointLight::PointLightComponent' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroFloatingStaticMesh.SetLogicallyShow
// 0x0001 (0x0001 - 0x0000)
struct KuroFloatingStaticMesh_SetLogicallyShow final
{
public:
	ECollisionEnabled                             Type;                                              // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroFloatingStaticMesh_SetLogicallyShow) == 0x000001, "Wrong alignment on KuroFloatingStaticMesh_SetLogicallyShow");
static_assert(sizeof(KuroFloatingStaticMesh_SetLogicallyShow) == 0x000001, "Wrong size on KuroFloatingStaticMesh_SetLogicallyShow");
static_assert(offsetof(KuroFloatingStaticMesh_SetLogicallyShow, Type) == 0x000000, "Member 'KuroFloatingStaticMesh_SetLogicallyShow::Type' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroGISystem.GetKuroGISystem
// 0x0010 (0x0010 - 0x0000)
struct KuroGISystem_GetKuroGISystem final
{
public:
	class UWorld*                                 InWorld;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UKuroGISystem*                          ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroGISystem_GetKuroGISystem) == 0x000008, "Wrong alignment on KuroGISystem_GetKuroGISystem");
static_assert(sizeof(KuroGISystem_GetKuroGISystem) == 0x000010, "Wrong size on KuroGISystem_GetKuroGISystem");
static_assert(offsetof(KuroGISystem_GetKuroGISystem, InWorld) == 0x000000, "Member 'KuroGISystem_GetKuroGISystem::InWorld' has a wrong offset!");
static_assert(offsetof(KuroGISystem_GetKuroGISystem, ReturnValue) == 0x000008, "Member 'KuroGISystem_GetKuroGISystem::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroGISystem.SetKuroScreenFilterInterpolation
// 0x0018 (0x0018 - 0x0000)
struct KuroGISystem_SetKuroScreenFilterInterpolation final
{
public:
	class UWorld*                                 InWorld;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ScreenFilterIndex;                                 // 0x0008(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         X;                                                 // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Y;                                                 // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Intensity;                                         // 0x0014(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroGISystem_SetKuroScreenFilterInterpolation) == 0x000008, "Wrong alignment on KuroGISystem_SetKuroScreenFilterInterpolation");
static_assert(sizeof(KuroGISystem_SetKuroScreenFilterInterpolation) == 0x000018, "Wrong size on KuroGISystem_SetKuroScreenFilterInterpolation");
static_assert(offsetof(KuroGISystem_SetKuroScreenFilterInterpolation, InWorld) == 0x000000, "Member 'KuroGISystem_SetKuroScreenFilterInterpolation::InWorld' has a wrong offset!");
static_assert(offsetof(KuroGISystem_SetKuroScreenFilterInterpolation, ScreenFilterIndex) == 0x000008, "Member 'KuroGISystem_SetKuroScreenFilterInterpolation::ScreenFilterIndex' has a wrong offset!");
static_assert(offsetof(KuroGISystem_SetKuroScreenFilterInterpolation, X) == 0x00000C, "Member 'KuroGISystem_SetKuroScreenFilterInterpolation::X' has a wrong offset!");
static_assert(offsetof(KuroGISystem_SetKuroScreenFilterInterpolation, Y) == 0x000010, "Member 'KuroGISystem_SetKuroScreenFilterInterpolation::Y' has a wrong offset!");
static_assert(offsetof(KuroGISystem_SetKuroScreenFilterInterpolation, Intensity) == 0x000014, "Member 'KuroGISystem_SetKuroScreenFilterInterpolation::Intensity' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroGISystem.End3DUISceneRendering
// 0x0001 (0x0001 - 0x0000)
struct KuroGISystem_End3DUISceneRendering final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroGISystem_End3DUISceneRendering) == 0x000001, "Wrong alignment on KuroGISystem_End3DUISceneRendering");
static_assert(sizeof(KuroGISystem_End3DUISceneRendering) == 0x000001, "Wrong size on KuroGISystem_End3DUISceneRendering");
static_assert(offsetof(KuroGISystem_End3DUISceneRendering, ReturnValue) == 0x000000, "Member 'KuroGISystem_End3DUISceneRendering::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroGISystem.GetKuroGlobalGIActor
// 0x0008 (0x0008 - 0x0000)
struct KuroGISystem_GetKuroGlobalGIActor final
{
public:
	class AKuroGlobalGI*                          ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroGISystem_GetKuroGlobalGIActor) == 0x000008, "Wrong alignment on KuroGISystem_GetKuroGlobalGIActor");
static_assert(sizeof(KuroGISystem_GetKuroGlobalGIActor) == 0x000008, "Wrong size on KuroGISystem_GetKuroGlobalGIActor");
static_assert(offsetof(KuroGISystem_GetKuroGlobalGIActor, ReturnValue) == 0x000000, "Member 'KuroGISystem_GetKuroGlobalGIActor::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroGISystem.IsLastTickGIActor
// 0x0010 (0x0010 - 0x0000)
struct KuroGISystem_IsLastTickGIActor final
{
public:
	class AKuroGlobalGI*                          Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroGISystem_IsLastTickGIActor) == 0x000008, "Wrong alignment on KuroGISystem_IsLastTickGIActor");
static_assert(sizeof(KuroGISystem_IsLastTickGIActor) == 0x000010, "Wrong size on KuroGISystem_IsLastTickGIActor");
static_assert(offsetof(KuroGISystem_IsLastTickGIActor, Actor) == 0x000000, "Member 'KuroGISystem_IsLastTickGIActor::Actor' has a wrong offset!");
static_assert(offsetof(KuroGISystem_IsLastTickGIActor, ReturnValue) == 0x000008, "Member 'KuroGISystem_IsLastTickGIActor::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroGISystem.IsUISceneRendering
// 0x0001 (0x0001 - 0x0000)
struct KuroGISystem_IsUISceneRendering final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroGISystem_IsUISceneRendering) == 0x000001, "Wrong alignment on KuroGISystem_IsUISceneRendering");
static_assert(sizeof(KuroGISystem_IsUISceneRendering) == 0x000001, "Wrong size on KuroGISystem_IsUISceneRendering");
static_assert(offsetof(KuroGISystem_IsUISceneRendering, ReturnValue) == 0x000000, "Member 'KuroGISystem_IsUISceneRendering::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroGISystem.Start3DUISceneRendering
// 0x0018 (0x0018 - 0x0000)
struct KuroGISystem_Start3DUISceneRendering final
{
public:
	class FString                                 InLevelName;                                       // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroGISystem_Start3DUISceneRendering) == 0x000008, "Wrong alignment on KuroGISystem_Start3DUISceneRendering");
static_assert(sizeof(KuroGISystem_Start3DUISceneRendering) == 0x000018, "Wrong size on KuroGISystem_Start3DUISceneRendering");
static_assert(offsetof(KuroGISystem_Start3DUISceneRendering, InLevelName) == 0x000000, "Member 'KuroGISystem_Start3DUISceneRendering::InLevelName' has a wrong offset!");
static_assert(offsetof(KuroGISystem_Start3DUISceneRendering, ReturnValue) == 0x000010, "Member 'KuroGISystem_Start3DUISceneRendering::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroGISystem.GetUISceneRenderingState
// 0x0001 (0x0001 - 0x0000)
struct KuroGISystem_GetUISceneRenderingState final
{
public:
	EKuroUI3DState                                ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroGISystem_GetUISceneRenderingState) == 0x000001, "Wrong alignment on KuroGISystem_GetUISceneRenderingState");
static_assert(sizeof(KuroGISystem_GetUISceneRenderingState) == 0x000001, "Wrong size on KuroGISystem_GetUISceneRenderingState");
static_assert(offsetof(KuroGISystem_GetUISceneRenderingState, ReturnValue) == 0x000000, "Member 'KuroGISystem_GetUISceneRenderingState::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroGlobalColorMapComponent.UpdateColorMap
// 0x0018 (0x0018 - 0x0000)
struct KuroGlobalColorMapComponent_UpdateColorMap final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ViewLocation;                                      // 0x0008(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroGlobalColorMapComponent_UpdateColorMap) == 0x000008, "Wrong alignment on KuroGlobalColorMapComponent_UpdateColorMap");
static_assert(sizeof(KuroGlobalColorMapComponent_UpdateColorMap) == 0x000018, "Wrong size on KuroGlobalColorMapComponent_UpdateColorMap");
static_assert(offsetof(KuroGlobalColorMapComponent_UpdateColorMap, WorldContextObject) == 0x000000, "Member 'KuroGlobalColorMapComponent_UpdateColorMap::WorldContextObject' has a wrong offset!");
static_assert(offsetof(KuroGlobalColorMapComponent_UpdateColorMap, ViewLocation) == 0x000008, "Member 'KuroGlobalColorMapComponent_UpdateColorMap::ViewLocation' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroGlobalGI.BindEventForbidWeatherStateChanged
// 0x0028 (0x0028 - 0x0000)
struct KuroGlobalGI_BindEventForbidWeatherStateChanged final
{
public:
	TDelegate<void(bool InForbidWeather)>         InDelegate;                                        // 0x0000(0x0028)(Parm, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroGlobalGI_BindEventForbidWeatherStateChanged) == 0x000004, "Wrong alignment on KuroGlobalGI_BindEventForbidWeatherStateChanged");
static_assert(sizeof(KuroGlobalGI_BindEventForbidWeatherStateChanged) == 0x000028, "Wrong size on KuroGlobalGI_BindEventForbidWeatherStateChanged");
static_assert(offsetof(KuroGlobalGI_BindEventForbidWeatherStateChanged, InDelegate) == 0x000000, "Member 'KuroGlobalGI_BindEventForbidWeatherStateChanged::InDelegate' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroGlobalGI.BindEventGlobalFootstepMaterialUpdate
// 0x0028 (0x0028 - 0x0000)
struct KuroGlobalGI_BindEventGlobalFootstepMaterialUpdate final
{
public:
	TDelegate<void(class UPhysicalMaterial* Material)> InDelegate;                                   // 0x0000(0x0028)(Parm, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroGlobalGI_BindEventGlobalFootstepMaterialUpdate) == 0x000004, "Wrong alignment on KuroGlobalGI_BindEventGlobalFootstepMaterialUpdate");
static_assert(sizeof(KuroGlobalGI_BindEventGlobalFootstepMaterialUpdate) == 0x000028, "Wrong size on KuroGlobalGI_BindEventGlobalFootstepMaterialUpdate");
static_assert(offsetof(KuroGlobalGI_BindEventGlobalFootstepMaterialUpdate, InDelegate) == 0x000000, "Member 'KuroGlobalGI_BindEventGlobalFootstepMaterialUpdate::InDelegate' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroGlobalGI.ApplayShadowTintRampOffset
// 0x0008 (0x0008 - 0x0000)
struct KuroGlobalGI_ApplayShadowTintRampOffset final
{
public:
	class USkyLightComponent*                     SkyLight;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroGlobalGI_ApplayShadowTintRampOffset) == 0x000008, "Wrong alignment on KuroGlobalGI_ApplayShadowTintRampOffset");
static_assert(sizeof(KuroGlobalGI_ApplayShadowTintRampOffset) == 0x000008, "Wrong size on KuroGlobalGI_ApplayShadowTintRampOffset");
static_assert(offsetof(KuroGlobalGI_ApplayShadowTintRampOffset, SkyLight) == 0x000000, "Member 'KuroGlobalGI_ApplayShadowTintRampOffset::SkyLight' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroGlobalGI.Apply3DUISceneSkyLight
// 0x0008 (0x0008 - 0x0000)
struct KuroGlobalGI_Apply3DUISceneSkyLight final
{
public:
	class USkyLightComponent*                     SkyLight;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroGlobalGI_Apply3DUISceneSkyLight) == 0x000008, "Wrong alignment on KuroGlobalGI_Apply3DUISceneSkyLight");
static_assert(sizeof(KuroGlobalGI_Apply3DUISceneSkyLight) == 0x000008, "Wrong size on KuroGlobalGI_Apply3DUISceneSkyLight");
static_assert(offsetof(KuroGlobalGI_Apply3DUISceneSkyLight, SkyLight) == 0x000000, "Member 'KuroGlobalGI_Apply3DUISceneSkyLight::SkyLight' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroGlobalGI.ApplyAndUpdateDayNightDataLayer
// 0x0008 (0x0008 - 0x0000)
struct KuroGlobalGI_ApplyAndUpdateDayNightDataLayer final
{
public:
	float                                         TimeOfDay;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TODLightLoadingWait;                               // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroGlobalGI_ApplyAndUpdateDayNightDataLayer) == 0x000004, "Wrong alignment on KuroGlobalGI_ApplyAndUpdateDayNightDataLayer");
static_assert(sizeof(KuroGlobalGI_ApplyAndUpdateDayNightDataLayer) == 0x000008, "Wrong size on KuroGlobalGI_ApplyAndUpdateDayNightDataLayer");
static_assert(offsetof(KuroGlobalGI_ApplyAndUpdateDayNightDataLayer, TimeOfDay) == 0x000000, "Member 'KuroGlobalGI_ApplyAndUpdateDayNightDataLayer::TimeOfDay' has a wrong offset!");
static_assert(offsetof(KuroGlobalGI_ApplyAndUpdateDayNightDataLayer, TODLightLoadingWait) == 0x000004, "Member 'KuroGlobalGI_ApplyAndUpdateDayNightDataLayer::TODLightLoadingWait' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroGlobalGI.ApplyKuroSkyLight
// 0x0018 (0x0018 - 0x0000)
struct KuroGlobalGI_ApplyKuroSkyLight final
{
public:
	class USkyLightComponent*                     SkyLight;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimeOfDay;                                         // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DefaultShadowSupplement;                           // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DefaultReflectionAddIntensity;                     // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableLumen;                                      // 0x0014(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroGlobalGI_ApplyKuroSkyLight) == 0x000008, "Wrong alignment on KuroGlobalGI_ApplyKuroSkyLight");
static_assert(sizeof(KuroGlobalGI_ApplyKuroSkyLight) == 0x000018, "Wrong size on KuroGlobalGI_ApplyKuroSkyLight");
static_assert(offsetof(KuroGlobalGI_ApplyKuroSkyLight, SkyLight) == 0x000000, "Member 'KuroGlobalGI_ApplyKuroSkyLight::SkyLight' has a wrong offset!");
static_assert(offsetof(KuroGlobalGI_ApplyKuroSkyLight, TimeOfDay) == 0x000008, "Member 'KuroGlobalGI_ApplyKuroSkyLight::TimeOfDay' has a wrong offset!");
static_assert(offsetof(KuroGlobalGI_ApplyKuroSkyLight, DefaultShadowSupplement) == 0x00000C, "Member 'KuroGlobalGI_ApplyKuroSkyLight::DefaultShadowSupplement' has a wrong offset!");
static_assert(offsetof(KuroGlobalGI_ApplyKuroSkyLight, DefaultReflectionAddIntensity) == 0x000010, "Member 'KuroGlobalGI_ApplyKuroSkyLight::DefaultReflectionAddIntensity' has a wrong offset!");
static_assert(offsetof(KuroGlobalGI_ApplyKuroSkyLight, bEnableLumen) == 0x000014, "Member 'KuroGlobalGI_ApplyKuroSkyLight::bEnableLumen' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroGlobalGI.ApplyLensflare
// 0x0018 (0x0018 - 0x0000)
struct KuroGlobalGI_ApplyLensflare final
{
public:
	float                                         DeltaTime;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                SunForward;                                        // 0x0004(0x000C)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialParameterCollection*           Collection;                                        // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroGlobalGI_ApplyLensflare) == 0x000008, "Wrong alignment on KuroGlobalGI_ApplyLensflare");
static_assert(sizeof(KuroGlobalGI_ApplyLensflare) == 0x000018, "Wrong size on KuroGlobalGI_ApplyLensflare");
static_assert(offsetof(KuroGlobalGI_ApplyLensflare, DeltaTime) == 0x000000, "Member 'KuroGlobalGI_ApplyLensflare::DeltaTime' has a wrong offset!");
static_assert(offsetof(KuroGlobalGI_ApplyLensflare, SunForward) == 0x000004, "Member 'KuroGlobalGI_ApplyLensflare::SunForward' has a wrong offset!");
static_assert(offsetof(KuroGlobalGI_ApplyLensflare, Collection) == 0x000010, "Member 'KuroGlobalGI_ApplyLensflare::Collection' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroGlobalGI.ApplyLightFunctionSetting
// 0x0028 (0x0028 - 0x0000)
struct KuroGlobalGI_ApplyLightFunctionSetting final
{
public:
	class UTexture*                               DefaultLightFucntionTexture;                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDirectionalLightComponent*             SceneLight;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInstance*                      LightFunctionMaterial;                             // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInstance*                      LightFunctionPerShadowMaterial;                    // 0x0018(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInstance*                      VolumetricLightFunctionMaterial;                   // 0x0020(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroGlobalGI_ApplyLightFunctionSetting) == 0x000008, "Wrong alignment on KuroGlobalGI_ApplyLightFunctionSetting");
static_assert(sizeof(KuroGlobalGI_ApplyLightFunctionSetting) == 0x000028, "Wrong size on KuroGlobalGI_ApplyLightFunctionSetting");
static_assert(offsetof(KuroGlobalGI_ApplyLightFunctionSetting, DefaultLightFucntionTexture) == 0x000000, "Member 'KuroGlobalGI_ApplyLightFunctionSetting::DefaultLightFucntionTexture' has a wrong offset!");
static_assert(offsetof(KuroGlobalGI_ApplyLightFunctionSetting, SceneLight) == 0x000008, "Member 'KuroGlobalGI_ApplyLightFunctionSetting::SceneLight' has a wrong offset!");
static_assert(offsetof(KuroGlobalGI_ApplyLightFunctionSetting, LightFunctionMaterial) == 0x000010, "Member 'KuroGlobalGI_ApplyLightFunctionSetting::LightFunctionMaterial' has a wrong offset!");
static_assert(offsetof(KuroGlobalGI_ApplyLightFunctionSetting, LightFunctionPerShadowMaterial) == 0x000018, "Member 'KuroGlobalGI_ApplyLightFunctionSetting::LightFunctionPerShadowMaterial' has a wrong offset!");
static_assert(offsetof(KuroGlobalGI_ApplyLightFunctionSetting, VolumetricLightFunctionMaterial) == 0x000020, "Member 'KuroGlobalGI_ApplyLightFunctionSetting::VolumetricLightFunctionMaterial' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroGlobalGI.ApplyLightParameters_Conch
// 0x0028 (0x0028 - 0x0000)
struct KuroGlobalGI_ApplyLightParameters_Conch final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialParameterCollection*           Collection;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDirectionalLightComponent*             SceneLight;                                        // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableLumen;                                      // 0x0018(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x3];                                       // 0x0019(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               SceneLightRotation;                                // 0x001C(0x000C)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroGlobalGI_ApplyLightParameters_Conch) == 0x000008, "Wrong alignment on KuroGlobalGI_ApplyLightParameters_Conch");
static_assert(sizeof(KuroGlobalGI_ApplyLightParameters_Conch) == 0x000028, "Wrong size on KuroGlobalGI_ApplyLightParameters_Conch");
static_assert(offsetof(KuroGlobalGI_ApplyLightParameters_Conch, WorldContextObject) == 0x000000, "Member 'KuroGlobalGI_ApplyLightParameters_Conch::WorldContextObject' has a wrong offset!");
static_assert(offsetof(KuroGlobalGI_ApplyLightParameters_Conch, Collection) == 0x000008, "Member 'KuroGlobalGI_ApplyLightParameters_Conch::Collection' has a wrong offset!");
static_assert(offsetof(KuroGlobalGI_ApplyLightParameters_Conch, SceneLight) == 0x000010, "Member 'KuroGlobalGI_ApplyLightParameters_Conch::SceneLight' has a wrong offset!");
static_assert(offsetof(KuroGlobalGI_ApplyLightParameters_Conch, bEnableLumen) == 0x000018, "Member 'KuroGlobalGI_ApplyLightParameters_Conch::bEnableLumen' has a wrong offset!");
static_assert(offsetof(KuroGlobalGI_ApplyLightParameters_Conch, SceneLightRotation) == 0x00001C, "Member 'KuroGlobalGI_ApplyLightParameters_Conch::SceneLightRotation' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroGlobalGI.ApplyMilkyWayParameters
// 0x0018 (0x0018 - 0x0000)
struct KuroGlobalGI_ApplyMilkyWayParameters final
{
public:
	class UMaterialInstance*                      MilkyWayMaterial;                                  // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   MilkyWayMeshComponent;                             // 0x0008(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Time;                                              // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroGlobalGI_ApplyMilkyWayParameters) == 0x000008, "Wrong alignment on KuroGlobalGI_ApplyMilkyWayParameters");
static_assert(sizeof(KuroGlobalGI_ApplyMilkyWayParameters) == 0x000018, "Wrong size on KuroGlobalGI_ApplyMilkyWayParameters");
static_assert(offsetof(KuroGlobalGI_ApplyMilkyWayParameters, MilkyWayMaterial) == 0x000000, "Member 'KuroGlobalGI_ApplyMilkyWayParameters::MilkyWayMaterial' has a wrong offset!");
static_assert(offsetof(KuroGlobalGI_ApplyMilkyWayParameters, MilkyWayMeshComponent) == 0x000008, "Member 'KuroGlobalGI_ApplyMilkyWayParameters::MilkyWayMeshComponent' has a wrong offset!");
static_assert(offsetof(KuroGlobalGI_ApplyMilkyWayParameters, Time) == 0x000010, "Member 'KuroGlobalGI_ApplyMilkyWayParameters::Time' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroGlobalGI.ApplyRainOverrider
// 0x0008 (0x0008 - 0x0000)
struct KuroGlobalGI_ApplyRainOverrider final
{
public:
	class AKuroWorldRainGlobalOverrider*          Overrider;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroGlobalGI_ApplyRainOverrider) == 0x000008, "Wrong alignment on KuroGlobalGI_ApplyRainOverrider");
static_assert(sizeof(KuroGlobalGI_ApplyRainOverrider) == 0x000008, "Wrong size on KuroGlobalGI_ApplyRainOverrider");
static_assert(offsetof(KuroGlobalGI_ApplyRainOverrider, Overrider) == 0x000000, "Member 'KuroGlobalGI_ApplyRainOverrider::Overrider' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroGlobalGI.ApplySkyBoxSetting
// 0x0028 (0x0028 - 0x0000)
struct KuroGlobalGI_ApplySkyBoxSetting final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialParameterCollection*           Collection;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInstance*                      SkyBoxMaterial;                                    // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   SkyBoxMeshComponent;                               // 0x0018(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Time;                                              // 0x0020(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroGlobalGI_ApplySkyBoxSetting) == 0x000008, "Wrong alignment on KuroGlobalGI_ApplySkyBoxSetting");
static_assert(sizeof(KuroGlobalGI_ApplySkyBoxSetting) == 0x000028, "Wrong size on KuroGlobalGI_ApplySkyBoxSetting");
static_assert(offsetof(KuroGlobalGI_ApplySkyBoxSetting, WorldContextObject) == 0x000000, "Member 'KuroGlobalGI_ApplySkyBoxSetting::WorldContextObject' has a wrong offset!");
static_assert(offsetof(KuroGlobalGI_ApplySkyBoxSetting, Collection) == 0x000008, "Member 'KuroGlobalGI_ApplySkyBoxSetting::Collection' has a wrong offset!");
static_assert(offsetof(KuroGlobalGI_ApplySkyBoxSetting, SkyBoxMaterial) == 0x000010, "Member 'KuroGlobalGI_ApplySkyBoxSetting::SkyBoxMaterial' has a wrong offset!");
static_assert(offsetof(KuroGlobalGI_ApplySkyBoxSetting, SkyBoxMeshComponent) == 0x000018, "Member 'KuroGlobalGI_ApplySkyBoxSetting::SkyBoxMeshComponent' has a wrong offset!");
static_assert(offsetof(KuroGlobalGI_ApplySkyBoxSetting, Time) == 0x000020, "Member 'KuroGlobalGI_ApplySkyBoxSetting::Time' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroGlobalGI.ApplyStarsParameters
// 0x0020 (0x0020 - 0x0000)
struct KuroGlobalGI_ApplyStarsParameters final
{
public:
	class UMaterialInstance*                      StarMaterial;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   StarMeshComponent;                                 // 0x0008(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Time;                                              // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialInstance*                      StarMaterial_V2;                                   // 0x0018(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroGlobalGI_ApplyStarsParameters) == 0x000008, "Wrong alignment on KuroGlobalGI_ApplyStarsParameters");
static_assert(sizeof(KuroGlobalGI_ApplyStarsParameters) == 0x000020, "Wrong size on KuroGlobalGI_ApplyStarsParameters");
static_assert(offsetof(KuroGlobalGI_ApplyStarsParameters, StarMaterial) == 0x000000, "Member 'KuroGlobalGI_ApplyStarsParameters::StarMaterial' has a wrong offset!");
static_assert(offsetof(KuroGlobalGI_ApplyStarsParameters, StarMeshComponent) == 0x000008, "Member 'KuroGlobalGI_ApplyStarsParameters::StarMeshComponent' has a wrong offset!");
static_assert(offsetof(KuroGlobalGI_ApplyStarsParameters, Time) == 0x000010, "Member 'KuroGlobalGI_ApplyStarsParameters::Time' has a wrong offset!");
static_assert(offsetof(KuroGlobalGI_ApplyStarsParameters, StarMaterial_V2) == 0x000018, "Member 'KuroGlobalGI_ApplyStarsParameters::StarMaterial_V2' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroGlobalGI.CalLightDirectionWithLimit
// 0x0014 (0x0014 - 0x0000)
struct KuroGlobalGI_CalLightDirectionWithLimit final
{
public:
	float                                         Time;                                              // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LightAngleLimit;                                   // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               LightRotation;                                     // 0x0008(0x000C)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroGlobalGI_CalLightDirectionWithLimit) == 0x000004, "Wrong alignment on KuroGlobalGI_CalLightDirectionWithLimit");
static_assert(sizeof(KuroGlobalGI_CalLightDirectionWithLimit) == 0x000014, "Wrong size on KuroGlobalGI_CalLightDirectionWithLimit");
static_assert(offsetof(KuroGlobalGI_CalLightDirectionWithLimit, Time) == 0x000000, "Member 'KuroGlobalGI_CalLightDirectionWithLimit::Time' has a wrong offset!");
static_assert(offsetof(KuroGlobalGI_CalLightDirectionWithLimit, LightAngleLimit) == 0x000004, "Member 'KuroGlobalGI_CalLightDirectionWithLimit::LightAngleLimit' has a wrong offset!");
static_assert(offsetof(KuroGlobalGI_CalLightDirectionWithLimit, LightRotation) == 0x000008, "Member 'KuroGlobalGI_CalLightDirectionWithLimit::LightRotation' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroGlobalGI.GetCachedGISystem
// 0x0008 (0x0008 - 0x0000)
struct KuroGlobalGI_GetCachedGISystem final
{
public:
	class UKuroGISystem*                          ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroGlobalGI_GetCachedGISystem) == 0x000008, "Wrong alignment on KuroGlobalGI_GetCachedGISystem");
static_assert(sizeof(KuroGlobalGI_GetCachedGISystem) == 0x000008, "Wrong size on KuroGlobalGI_GetCachedGISystem");
static_assert(offsetof(KuroGlobalGI_GetCachedGISystem, ReturnValue) == 0x000000, "Member 'KuroGlobalGI_GetCachedGISystem::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroGlobalGI.GetGITime
// 0x0004 (0x0004 - 0x0000)
struct KuroGlobalGI_GetGITime final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroGlobalGI_GetGITime) == 0x000004, "Wrong alignment on KuroGlobalGI_GetGITime");
static_assert(sizeof(KuroGlobalGI_GetGITime) == 0x000004, "Wrong size on KuroGlobalGI_GetGITime");
static_assert(offsetof(KuroGlobalGI_GetGITime, ReturnValue) == 0x000000, "Member 'KuroGlobalGI_GetGITime::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroGlobalGI.GetPostProcessVolumeWeight
// 0x0010 (0x0010 - 0x0000)
struct KuroGlobalGI_GetPostProcessVolumeWeight final
{
public:
	class AKuroPostProcessVolume*                 InPostProcessVolume;                               // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroGlobalGI_GetPostProcessVolumeWeight) == 0x000008, "Wrong alignment on KuroGlobalGI_GetPostProcessVolumeWeight");
static_assert(sizeof(KuroGlobalGI_GetPostProcessVolumeWeight) == 0x000010, "Wrong size on KuroGlobalGI_GetPostProcessVolumeWeight");
static_assert(offsetof(KuroGlobalGI_GetPostProcessVolumeWeight, InPostProcessVolume) == 0x000000, "Member 'KuroGlobalGI_GetPostProcessVolumeWeight::InPostProcessVolume' has a wrong offset!");
static_assert(offsetof(KuroGlobalGI_GetPostProcessVolumeWeight, ReturnValue) == 0x000008, "Member 'KuroGlobalGI_GetPostProcessVolumeWeight::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroGlobalGI.OnKuroSetRuntimeTime
// 0x0004 (0x0004 - 0x0000)
struct KuroGlobalGI_OnKuroSetRuntimeTime final
{
public:
	float                                         CurrentTime;                                       // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroGlobalGI_OnKuroSetRuntimeTime) == 0x000004, "Wrong alignment on KuroGlobalGI_OnKuroSetRuntimeTime");
static_assert(sizeof(KuroGlobalGI_OnKuroSetRuntimeTime) == 0x000004, "Wrong size on KuroGlobalGI_OnKuroSetRuntimeTime");
static_assert(offsetof(KuroGlobalGI_OnKuroSetRuntimeTime, CurrentTime) == 0x000000, "Member 'KuroGlobalGI_OnKuroSetRuntimeTime::CurrentTime' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroGlobalGI.OnKuroStartUI
// 0x0018 (0x0018 - 0x0000)
struct KuroGlobalGI_OnKuroStartUI final
{
public:
	class FString                                 InName;                                            // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ULevel*                                 InUILevel;                                         // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroGlobalGI_OnKuroStartUI) == 0x000008, "Wrong alignment on KuroGlobalGI_OnKuroStartUI");
static_assert(sizeof(KuroGlobalGI_OnKuroStartUI) == 0x000018, "Wrong size on KuroGlobalGI_OnKuroStartUI");
static_assert(offsetof(KuroGlobalGI_OnKuroStartUI, InName) == 0x000000, "Member 'KuroGlobalGI_OnKuroStartUI::InName' has a wrong offset!");
static_assert(offsetof(KuroGlobalGI_OnKuroStartUI, InUILevel) == 0x000010, "Member 'KuroGlobalGI_OnKuroStartUI::InUILevel' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroGlobalGI.OnKuroStartUiScene
// 0x0018 (0x0018 - 0x0000)
struct KuroGlobalGI_OnKuroStartUiScene final
{
public:
	class FString                                 InName;                                            // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ULevel*                                 InUILevel;                                         // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroGlobalGI_OnKuroStartUiScene) == 0x000008, "Wrong alignment on KuroGlobalGI_OnKuroStartUiScene");
static_assert(sizeof(KuroGlobalGI_OnKuroStartUiScene) == 0x000018, "Wrong size on KuroGlobalGI_OnKuroStartUiScene");
static_assert(offsetof(KuroGlobalGI_OnKuroStartUiScene, InName) == 0x000000, "Member 'KuroGlobalGI_OnKuroStartUiScene::InName' has a wrong offset!");
static_assert(offsetof(KuroGlobalGI_OnKuroStartUiScene, InUILevel) == 0x000010, "Member 'KuroGlobalGI_OnKuroStartUiScene::InUILevel' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroGlobalGI.OnKuroTick
// 0x0004 (0x0004 - 0x0000)
struct KuroGlobalGI_OnKuroTick final
{
public:
	float                                         DeltaTime;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroGlobalGI_OnKuroTick) == 0x000004, "Wrong alignment on KuroGlobalGI_OnKuroTick");
static_assert(sizeof(KuroGlobalGI_OnKuroTick) == 0x000004, "Wrong size on KuroGlobalGI_OnKuroTick");
static_assert(offsetof(KuroGlobalGI_OnKuroTick, DeltaTime) == 0x000000, "Member 'KuroGlobalGI_OnKuroTick::DeltaTime' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroGlobalGI.OnKuroTickEditor
// 0x0004 (0x0004 - 0x0000)
struct KuroGlobalGI_OnKuroTickEditor final
{
public:
	float                                         DeltaTime;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroGlobalGI_OnKuroTickEditor) == 0x000004, "Wrong alignment on KuroGlobalGI_OnKuroTickEditor");
static_assert(sizeof(KuroGlobalGI_OnKuroTickEditor) == 0x000004, "Wrong size on KuroGlobalGI_OnKuroTickEditor");
static_assert(offsetof(KuroGlobalGI_OnKuroTickEditor, DeltaTime) == 0x000000, "Member 'KuroGlobalGI_OnKuroTickEditor::DeltaTime' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroGlobalGI.SetGITime
// 0x0004 (0x0004 - 0x0000)
struct KuroGlobalGI_SetGITime final
{
public:
	float                                         Time;                                              // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroGlobalGI_SetGITime) == 0x000004, "Wrong alignment on KuroGlobalGI_SetGITime");
static_assert(sizeof(KuroGlobalGI_SetGITime) == 0x000004, "Wrong size on KuroGlobalGI_SetGITime");
static_assert(offsetof(KuroGlobalGI_SetGITime, Time) == 0x000000, "Member 'KuroGlobalGI_SetGITime::Time' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroGlobalGI.SetGlobalTimeDilation
// 0x0004 (0x0004 - 0x0000)
struct KuroGlobalGI_SetGlobalTimeDilation final
{
public:
	float                                         TimeDilation;                                      // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroGlobalGI_SetGlobalTimeDilation) == 0x000004, "Wrong alignment on KuroGlobalGI_SetGlobalTimeDilation");
static_assert(sizeof(KuroGlobalGI_SetGlobalTimeDilation) == 0x000004, "Wrong size on KuroGlobalGI_SetGlobalTimeDilation");
static_assert(offsetof(KuroGlobalGI_SetGlobalTimeDilation, TimeDilation) == 0x000000, "Member 'KuroGlobalGI_SetGlobalTimeDilation::TimeDilation' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroGlobalGI.SetSunLensflareEnabled
// 0x0001 (0x0001 - 0x0000)
struct KuroGlobalGI_SetSunLensflareEnabled final
{
public:
	bool                                          bEnable;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroGlobalGI_SetSunLensflareEnabled) == 0x000001, "Wrong alignment on KuroGlobalGI_SetSunLensflareEnabled");
static_assert(sizeof(KuroGlobalGI_SetSunLensflareEnabled) == 0x000001, "Wrong size on KuroGlobalGI_SetSunLensflareEnabled");
static_assert(offsetof(KuroGlobalGI_SetSunLensflareEnabled, bEnable) == 0x000000, "Member 'KuroGlobalGI_SetSunLensflareEnabled::bEnable' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroGlobalGI.TickWeatherTransitionData
// 0x0004 (0x0004 - 0x0000)
struct KuroGlobalGI_TickWeatherTransitionData final
{
public:
	float                                         DeltaTime;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroGlobalGI_TickWeatherTransitionData) == 0x000004, "Wrong alignment on KuroGlobalGI_TickWeatherTransitionData");
static_assert(sizeof(KuroGlobalGI_TickWeatherTransitionData) == 0x000004, "Wrong size on KuroGlobalGI_TickWeatherTransitionData");
static_assert(offsetof(KuroGlobalGI_TickWeatherTransitionData, DeltaTime) == 0x000000, "Member 'KuroGlobalGI_TickWeatherTransitionData::DeltaTime' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroGlobalGI.UpdateAndApplyWind
// 0x0010 (0x0010 - 0x0000)
struct KuroGlobalGI_UpdateAndApplyWind final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialParameterCollection*           Collection;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroGlobalGI_UpdateAndApplyWind) == 0x000008, "Wrong alignment on KuroGlobalGI_UpdateAndApplyWind");
static_assert(sizeof(KuroGlobalGI_UpdateAndApplyWind) == 0x000010, "Wrong size on KuroGlobalGI_UpdateAndApplyWind");
static_assert(offsetof(KuroGlobalGI_UpdateAndApplyWind, WorldContextObject) == 0x000000, "Member 'KuroGlobalGI_UpdateAndApplyWind::WorldContextObject' has a wrong offset!");
static_assert(offsetof(KuroGlobalGI_UpdateAndApplyWind, Collection) == 0x000008, "Member 'KuroGlobalGI_UpdateAndApplyWind::Collection' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroGlobalGI.UpdateCharLightHorizontal
// 0x0030 (0x0030 - 0x0000)
struct KuroGlobalGI_UpdateCharLightHorizontal final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               SceneLightRot;                                     // 0x0008(0x000C)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialParameterCollection*           Collection;                                        // 0x0018(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDebugCharLightHorizontal;                         // 0x0020(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x3];                                       // 0x0021(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DebugCharLightHorizontal;                          // 0x0024(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DebugCharLightVertical;                            // 0x0028(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroGlobalGI_UpdateCharLightHorizontal) == 0x000008, "Wrong alignment on KuroGlobalGI_UpdateCharLightHorizontal");
static_assert(sizeof(KuroGlobalGI_UpdateCharLightHorizontal) == 0x000030, "Wrong size on KuroGlobalGI_UpdateCharLightHorizontal");
static_assert(offsetof(KuroGlobalGI_UpdateCharLightHorizontal, WorldContextObject) == 0x000000, "Member 'KuroGlobalGI_UpdateCharLightHorizontal::WorldContextObject' has a wrong offset!");
static_assert(offsetof(KuroGlobalGI_UpdateCharLightHorizontal, SceneLightRot) == 0x000008, "Member 'KuroGlobalGI_UpdateCharLightHorizontal::SceneLightRot' has a wrong offset!");
static_assert(offsetof(KuroGlobalGI_UpdateCharLightHorizontal, Collection) == 0x000018, "Member 'KuroGlobalGI_UpdateCharLightHorizontal::Collection' has a wrong offset!");
static_assert(offsetof(KuroGlobalGI_UpdateCharLightHorizontal, bDebugCharLightHorizontal) == 0x000020, "Member 'KuroGlobalGI_UpdateCharLightHorizontal::bDebugCharLightHorizontal' has a wrong offset!");
static_assert(offsetof(KuroGlobalGI_UpdateCharLightHorizontal, DebugCharLightHorizontal) == 0x000024, "Member 'KuroGlobalGI_UpdateCharLightHorizontal::DebugCharLightHorizontal' has a wrong offset!");
static_assert(offsetof(KuroGlobalGI_UpdateCharLightHorizontal, DebugCharLightVertical) == 0x000028, "Member 'KuroGlobalGI_UpdateCharLightHorizontal::DebugCharLightVertical' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroGlobalGI.UpdateKuroTrailSystem
// 0x0010 (0x0010 - 0x0000)
struct KuroGlobalGI_UpdateKuroTrailSystem final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialParameterCollection*           Collection;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroGlobalGI_UpdateKuroTrailSystem) == 0x000008, "Wrong alignment on KuroGlobalGI_UpdateKuroTrailSystem");
static_assert(sizeof(KuroGlobalGI_UpdateKuroTrailSystem) == 0x000010, "Wrong size on KuroGlobalGI_UpdateKuroTrailSystem");
static_assert(offsetof(KuroGlobalGI_UpdateKuroTrailSystem, WorldContextObject) == 0x000000, "Member 'KuroGlobalGI_UpdateKuroTrailSystem::WorldContextObject' has a wrong offset!");
static_assert(offsetof(KuroGlobalGI_UpdateKuroTrailSystem, Collection) == 0x000008, "Member 'KuroGlobalGI_UpdateKuroTrailSystem::Collection' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroGlobalGI.UpdateLightDirection
// 0x0018 (0x0018 - 0x0000)
struct KuroGlobalGI_UpdateLightDirection final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDirectionalLightComponent*             AtmoSunLight;                                      // 0x0008(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDirectionalLightComponent*             AtmoMoonLight;                                     // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroGlobalGI_UpdateLightDirection) == 0x000008, "Wrong alignment on KuroGlobalGI_UpdateLightDirection");
static_assert(sizeof(KuroGlobalGI_UpdateLightDirection) == 0x000018, "Wrong size on KuroGlobalGI_UpdateLightDirection");
static_assert(offsetof(KuroGlobalGI_UpdateLightDirection, WorldContextObject) == 0x000000, "Member 'KuroGlobalGI_UpdateLightDirection::WorldContextObject' has a wrong offset!");
static_assert(offsetof(KuroGlobalGI_UpdateLightDirection, AtmoSunLight) == 0x000008, "Member 'KuroGlobalGI_UpdateLightDirection::AtmoSunLight' has a wrong offset!");
static_assert(offsetof(KuroGlobalGI_UpdateLightDirection, AtmoMoonLight) == 0x000010, "Member 'KuroGlobalGI_UpdateLightDirection::AtmoMoonLight' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroGlobalGI.UpdateLightEnableCastShadow
// 0x0010 (0x0010 - 0x0000)
struct KuroGlobalGI_UpdateLightEnableCastShadow final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDirectionalLightComponent*             SceneLight;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroGlobalGI_UpdateLightEnableCastShadow) == 0x000008, "Wrong alignment on KuroGlobalGI_UpdateLightEnableCastShadow");
static_assert(sizeof(KuroGlobalGI_UpdateLightEnableCastShadow) == 0x000010, "Wrong size on KuroGlobalGI_UpdateLightEnableCastShadow");
static_assert(offsetof(KuroGlobalGI_UpdateLightEnableCastShadow, WorldContextObject) == 0x000000, "Member 'KuroGlobalGI_UpdateLightEnableCastShadow::WorldContextObject' has a wrong offset!");
static_assert(offsetof(KuroGlobalGI_UpdateLightEnableCastShadow, SceneLight) == 0x000008, "Member 'KuroGlobalGI_UpdateLightEnableCastShadow::SceneLight' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroGlobalGI.UpdatePostProcessSettingData
// 0x0010 (0x0010 - 0x0000)
struct KuroGlobalGI_UpdatePostProcessSettingData final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CurTime;                                           // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSkipLerpData;                                     // 0x000C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableLumen;                                      // 0x000D(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E[0x2];                                        // 0x000E(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroGlobalGI_UpdatePostProcessSettingData) == 0x000008, "Wrong alignment on KuroGlobalGI_UpdatePostProcessSettingData");
static_assert(sizeof(KuroGlobalGI_UpdatePostProcessSettingData) == 0x000010, "Wrong size on KuroGlobalGI_UpdatePostProcessSettingData");
static_assert(offsetof(KuroGlobalGI_UpdatePostProcessSettingData, WorldContextObject) == 0x000000, "Member 'KuroGlobalGI_UpdatePostProcessSettingData::WorldContextObject' has a wrong offset!");
static_assert(offsetof(KuroGlobalGI_UpdatePostProcessSettingData, CurTime) == 0x000008, "Member 'KuroGlobalGI_UpdatePostProcessSettingData::CurTime' has a wrong offset!");
static_assert(offsetof(KuroGlobalGI_UpdatePostProcessSettingData, bSkipLerpData) == 0x00000C, "Member 'KuroGlobalGI_UpdatePostProcessSettingData::bSkipLerpData' has a wrong offset!");
static_assert(offsetof(KuroGlobalGI_UpdatePostProcessSettingData, bEnableLumen) == 0x00000D, "Member 'KuroGlobalGI_UpdatePostProcessSettingData::bEnableLumen' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroGlobalGI.UpdateTODData
// 0x0018 (0x0018 - 0x0000)
struct KuroGlobalGI_UpdateTODData final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                WorldPosition;                                     // 0x0008(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimeSecnod;                                        // 0x0014(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroGlobalGI_UpdateTODData) == 0x000008, "Wrong alignment on KuroGlobalGI_UpdateTODData");
static_assert(sizeof(KuroGlobalGI_UpdateTODData) == 0x000018, "Wrong size on KuroGlobalGI_UpdateTODData");
static_assert(offsetof(KuroGlobalGI_UpdateTODData, WorldContextObject) == 0x000000, "Member 'KuroGlobalGI_UpdateTODData::WorldContextObject' has a wrong offset!");
static_assert(offsetof(KuroGlobalGI_UpdateTODData, WorldPosition) == 0x000008, "Member 'KuroGlobalGI_UpdateTODData::WorldPosition' has a wrong offset!");
static_assert(offsetof(KuroGlobalGI_UpdateTODData, TimeSecnod) == 0x000014, "Member 'KuroGlobalGI_UpdateTODData::TimeSecnod' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroGlobalGI.ApplyCloudCardSetting
// 0x0018 (0x0018 - 0x0000)
struct KuroGlobalGI_ApplyCloudCardSetting final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialParameterCollection*           Collection;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableLumen;                                      // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroGlobalGI_ApplyCloudCardSetting) == 0x000008, "Wrong alignment on KuroGlobalGI_ApplyCloudCardSetting");
static_assert(sizeof(KuroGlobalGI_ApplyCloudCardSetting) == 0x000018, "Wrong size on KuroGlobalGI_ApplyCloudCardSetting");
static_assert(offsetof(KuroGlobalGI_ApplyCloudCardSetting, WorldContextObject) == 0x000000, "Member 'KuroGlobalGI_ApplyCloudCardSetting::WorldContextObject' has a wrong offset!");
static_assert(offsetof(KuroGlobalGI_ApplyCloudCardSetting, Collection) == 0x000008, "Member 'KuroGlobalGI_ApplyCloudCardSetting::Collection' has a wrong offset!");
static_assert(offsetof(KuroGlobalGI_ApplyCloudCardSetting, bEnableLumen) == 0x000010, "Member 'KuroGlobalGI_ApplyCloudCardSetting::bEnableLumen' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroGlobalGI.ApplyFog
// 0x0040 (0x0040 - 0x0000)
struct KuroGlobalGI_ApplyFog final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UExponentialHeightFogComponent*         HeightFog;                                         // 0x0008(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialParameterCollection*           Collection;                                        // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WorldZOffset;                                      // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UStaticMeshComponent*                   CloudOcean;                                        // 0x0020(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   VolumeCloudMesh;                                   // 0x0028(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USceneComponent*                        VolumeCloud;                                       // 0x0030(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USceneComponent*                        VolumeCloudRange;                                  // 0x0038(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroGlobalGI_ApplyFog) == 0x000008, "Wrong alignment on KuroGlobalGI_ApplyFog");
static_assert(sizeof(KuroGlobalGI_ApplyFog) == 0x000040, "Wrong size on KuroGlobalGI_ApplyFog");
static_assert(offsetof(KuroGlobalGI_ApplyFog, WorldContextObject) == 0x000000, "Member 'KuroGlobalGI_ApplyFog::WorldContextObject' has a wrong offset!");
static_assert(offsetof(KuroGlobalGI_ApplyFog, HeightFog) == 0x000008, "Member 'KuroGlobalGI_ApplyFog::HeightFog' has a wrong offset!");
static_assert(offsetof(KuroGlobalGI_ApplyFog, Collection) == 0x000010, "Member 'KuroGlobalGI_ApplyFog::Collection' has a wrong offset!");
static_assert(offsetof(KuroGlobalGI_ApplyFog, WorldZOffset) == 0x000018, "Member 'KuroGlobalGI_ApplyFog::WorldZOffset' has a wrong offset!");
static_assert(offsetof(KuroGlobalGI_ApplyFog, CloudOcean) == 0x000020, "Member 'KuroGlobalGI_ApplyFog::CloudOcean' has a wrong offset!");
static_assert(offsetof(KuroGlobalGI_ApplyFog, VolumeCloudMesh) == 0x000028, "Member 'KuroGlobalGI_ApplyFog::VolumeCloudMesh' has a wrong offset!");
static_assert(offsetof(KuroGlobalGI_ApplyFog, VolumeCloud) == 0x000030, "Member 'KuroGlobalGI_ApplyFog::VolumeCloud' has a wrong offset!");
static_assert(offsetof(KuroGlobalGI_ApplyFog, VolumeCloudRange) == 0x000038, "Member 'KuroGlobalGI_ApplyFog::VolumeCloudRange' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroGlobalGI.ApplyGlobalShaderParameters
// 0x0010 (0x0010 - 0x0000)
struct KuroGlobalGI_ApplyGlobalShaderParameters final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialParameterCollection*           Collection;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroGlobalGI_ApplyGlobalShaderParameters) == 0x000008, "Wrong alignment on KuroGlobalGI_ApplyGlobalShaderParameters");
static_assert(sizeof(KuroGlobalGI_ApplyGlobalShaderParameters) == 0x000010, "Wrong size on KuroGlobalGI_ApplyGlobalShaderParameters");
static_assert(offsetof(KuroGlobalGI_ApplyGlobalShaderParameters, WorldContextObject) == 0x000000, "Member 'KuroGlobalGI_ApplyGlobalShaderParameters::WorldContextObject' has a wrong offset!");
static_assert(offsetof(KuroGlobalGI_ApplyGlobalShaderParameters, Collection) == 0x000008, "Member 'KuroGlobalGI_ApplyGlobalShaderParameters::Collection' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroGlobalGI.ApplyKuroOceanMPC
// 0x0010 (0x0010 - 0x0000)
struct KuroGlobalGI_ApplyKuroOceanMPC final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialParameterCollection*           Collection;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroGlobalGI_ApplyKuroOceanMPC) == 0x000008, "Wrong alignment on KuroGlobalGI_ApplyKuroOceanMPC");
static_assert(sizeof(KuroGlobalGI_ApplyKuroOceanMPC) == 0x000010, "Wrong size on KuroGlobalGI_ApplyKuroOceanMPC");
static_assert(offsetof(KuroGlobalGI_ApplyKuroOceanMPC, WorldContextObject) == 0x000000, "Member 'KuroGlobalGI_ApplyKuroOceanMPC::WorldContextObject' has a wrong offset!");
static_assert(offsetof(KuroGlobalGI_ApplyKuroOceanMPC, Collection) == 0x000008, "Member 'KuroGlobalGI_ApplyKuroOceanMPC::Collection' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroGlobalGI.ApplyLightParameters
// 0x0020 (0x0020 - 0x0000)
struct KuroGlobalGI_ApplyLightParameters final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialParameterCollection*           Collection;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDirectionalLightComponent*             SceneLight;                                        // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableLumen;                                      // 0x0018(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroGlobalGI_ApplyLightParameters) == 0x000008, "Wrong alignment on KuroGlobalGI_ApplyLightParameters");
static_assert(sizeof(KuroGlobalGI_ApplyLightParameters) == 0x000020, "Wrong size on KuroGlobalGI_ApplyLightParameters");
static_assert(offsetof(KuroGlobalGI_ApplyLightParameters, WorldContextObject) == 0x000000, "Member 'KuroGlobalGI_ApplyLightParameters::WorldContextObject' has a wrong offset!");
static_assert(offsetof(KuroGlobalGI_ApplyLightParameters, Collection) == 0x000008, "Member 'KuroGlobalGI_ApplyLightParameters::Collection' has a wrong offset!");
static_assert(offsetof(KuroGlobalGI_ApplyLightParameters, SceneLight) == 0x000010, "Member 'KuroGlobalGI_ApplyLightParameters::SceneLight' has a wrong offset!");
static_assert(offsetof(KuroGlobalGI_ApplyLightParameters, bEnableLumen) == 0x000018, "Member 'KuroGlobalGI_ApplyLightParameters::bEnableLumen' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroGlobalGI.ApplyLightShaft
// 0x0008 (0x0008 - 0x0000)
struct KuroGlobalGI_ApplyLightShaft final
{
public:
	class UDirectionalLightComponent*             SceneLight;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroGlobalGI_ApplyLightShaft) == 0x000008, "Wrong alignment on KuroGlobalGI_ApplyLightShaft");
static_assert(sizeof(KuroGlobalGI_ApplyLightShaft) == 0x000008, "Wrong size on KuroGlobalGI_ApplyLightShaft");
static_assert(offsetof(KuroGlobalGI_ApplyLightShaft, SceneLight) == 0x000000, "Member 'KuroGlobalGI_ApplyLightShaft::SceneLight' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroGlobalGI.ApplyMultipleLayerSkySetting
// 0x0010 (0x0010 - 0x0000)
struct KuroGlobalGI_ApplyMultipleLayerSkySetting final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialParameterCollection*           Collection;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroGlobalGI_ApplyMultipleLayerSkySetting) == 0x000008, "Wrong alignment on KuroGlobalGI_ApplyMultipleLayerSkySetting");
static_assert(sizeof(KuroGlobalGI_ApplyMultipleLayerSkySetting) == 0x000010, "Wrong size on KuroGlobalGI_ApplyMultipleLayerSkySetting");
static_assert(offsetof(KuroGlobalGI_ApplyMultipleLayerSkySetting, WorldContextObject) == 0x000000, "Member 'KuroGlobalGI_ApplyMultipleLayerSkySetting::WorldContextObject' has a wrong offset!");
static_assert(offsetof(KuroGlobalGI_ApplyMultipleLayerSkySetting, Collection) == 0x000008, "Member 'KuroGlobalGI_ApplyMultipleLayerSkySetting::Collection' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroGlobalGI.ApplySkyEffectsParameters
// 0x0010 (0x0010 - 0x0000)
struct KuroGlobalGI_ApplySkyEffectsParameters final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialParameterCollection*           Collection;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroGlobalGI_ApplySkyEffectsParameters) == 0x000008, "Wrong alignment on KuroGlobalGI_ApplySkyEffectsParameters");
static_assert(sizeof(KuroGlobalGI_ApplySkyEffectsParameters) == 0x000010, "Wrong size on KuroGlobalGI_ApplySkyEffectsParameters");
static_assert(offsetof(KuroGlobalGI_ApplySkyEffectsParameters, WorldContextObject) == 0x000000, "Member 'KuroGlobalGI_ApplySkyEffectsParameters::WorldContextObject' has a wrong offset!");
static_assert(offsetof(KuroGlobalGI_ApplySkyEffectsParameters, Collection) == 0x000008, "Member 'KuroGlobalGI_ApplySkyEffectsParameters::Collection' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroGlobalGI.CalcTODTimeFactor
// 0x0010 (0x0010 - 0x0000)
struct KuroGlobalGI_CalcTODTimeFactor final
{
public:
	float                                         StartTime;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EndTime;                                           // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CurrTime;                                          // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x000C(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroGlobalGI_CalcTODTimeFactor) == 0x000004, "Wrong alignment on KuroGlobalGI_CalcTODTimeFactor");
static_assert(sizeof(KuroGlobalGI_CalcTODTimeFactor) == 0x000010, "Wrong size on KuroGlobalGI_CalcTODTimeFactor");
static_assert(offsetof(KuroGlobalGI_CalcTODTimeFactor, StartTime) == 0x000000, "Member 'KuroGlobalGI_CalcTODTimeFactor::StartTime' has a wrong offset!");
static_assert(offsetof(KuroGlobalGI_CalcTODTimeFactor, EndTime) == 0x000004, "Member 'KuroGlobalGI_CalcTODTimeFactor::EndTime' has a wrong offset!");
static_assert(offsetof(KuroGlobalGI_CalcTODTimeFactor, CurrTime) == 0x000008, "Member 'KuroGlobalGI_CalcTODTimeFactor::CurrTime' has a wrong offset!");
static_assert(offsetof(KuroGlobalGI_CalcTODTimeFactor, ReturnValue) == 0x00000C, "Member 'KuroGlobalGI_CalcTODTimeFactor::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroGlobalGI.K2_IsInPersistentLevel
// 0x0001 (0x0001 - 0x0000)
struct KuroGlobalGI_K2_IsInPersistentLevel final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroGlobalGI_K2_IsInPersistentLevel) == 0x000001, "Wrong alignment on KuroGlobalGI_K2_IsInPersistentLevel");
static_assert(sizeof(KuroGlobalGI_K2_IsInPersistentLevel) == 0x000001, "Wrong size on KuroGlobalGI_K2_IsInPersistentLevel");
static_assert(offsetof(KuroGlobalGI_K2_IsInPersistentLevel, ReturnValue) == 0x000000, "Member 'KuroGlobalGI_K2_IsInPersistentLevel::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroGPUParticleComponent.DoTick
// 0x0004 (0x0004 - 0x0000)
struct KuroGPUParticleComponent_DoTick final
{
public:
	float                                         DeltaTime;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroGPUParticleComponent_DoTick) == 0x000004, "Wrong alignment on KuroGPUParticleComponent_DoTick");
static_assert(sizeof(KuroGPUParticleComponent_DoTick) == 0x000004, "Wrong size on KuroGPUParticleComponent_DoTick");
static_assert(offsetof(KuroGPUParticleComponent_DoTick, DeltaTime) == 0x000000, "Member 'KuroGPUParticleComponent_DoTick::DeltaTime' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroGPUParticleComponent.SetGPUData
// 0x0008 (0x0008 - 0x0000)
struct KuroGPUParticleComponent_SetGPUData final
{
public:
	class UKuroGPUParticleDA*                     TargetData;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroGPUParticleComponent_SetGPUData) == 0x000008, "Wrong alignment on KuroGPUParticleComponent_SetGPUData");
static_assert(sizeof(KuroGPUParticleComponent_SetGPUData) == 0x000008, "Wrong size on KuroGPUParticleComponent_SetGPUData");
static_assert(offsetof(KuroGPUParticleComponent_SetGPUData, TargetData) == 0x000000, "Member 'KuroGPUParticleComponent_SetGPUData::TargetData' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroGPUParticleComponent.SetupParticle
// 0x0004 (0x0004 - 0x0000)
struct KuroGPUParticleComponent_SetupParticle final
{
public:
	float                                         DeltaTime;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroGPUParticleComponent_SetupParticle) == 0x000004, "Wrong alignment on KuroGPUParticleComponent_SetupParticle");
static_assert(sizeof(KuroGPUParticleComponent_SetupParticle) == 0x000004, "Wrong size on KuroGPUParticleComponent_SetupParticle");
static_assert(offsetof(KuroGPUParticleComponent_SetupParticle, DeltaTime) == 0x000000, "Member 'KuroGPUParticleComponent_SetupParticle::DeltaTime' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroGPUParticleSubsystem.GetKuroGPUParticleSystem
// 0x0010 (0x0010 - 0x0000)
struct KuroGPUParticleSubsystem_GetKuroGPUParticleSystem final
{
public:
	class UWorld*                                 InWorld;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UKuroGPUParticleSubsystem*              ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroGPUParticleSubsystem_GetKuroGPUParticleSystem) == 0x000008, "Wrong alignment on KuroGPUParticleSubsystem_GetKuroGPUParticleSystem");
static_assert(sizeof(KuroGPUParticleSubsystem_GetKuroGPUParticleSystem) == 0x000010, "Wrong size on KuroGPUParticleSubsystem_GetKuroGPUParticleSystem");
static_assert(offsetof(KuroGPUParticleSubsystem_GetKuroGPUParticleSystem, InWorld) == 0x000000, "Member 'KuroGPUParticleSubsystem_GetKuroGPUParticleSystem::InWorld' has a wrong offset!");
static_assert(offsetof(KuroGPUParticleSubsystem_GetKuroGPUParticleSystem, ReturnValue) == 0x000008, "Member 'KuroGPUParticleSubsystem_GetKuroGPUParticleSystem::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroHaloComponent.SetRadius
// 0x0004 (0x0004 - 0x0000)
struct KuroHaloComponent_SetRadius final
{
public:
	float                                         Radius;                                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroHaloComponent_SetRadius) == 0x000004, "Wrong alignment on KuroHaloComponent_SetRadius");
static_assert(sizeof(KuroHaloComponent_SetRadius) == 0x000004, "Wrong size on KuroHaloComponent_SetRadius");
static_assert(offsetof(KuroHaloComponent_SetRadius, Radius) == 0x000000, "Member 'KuroHaloComponent_SetRadius::Radius' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroHaloComponent.GetLightRadius
// 0x0004 (0x0004 - 0x0000)
struct KuroHaloComponent_GetLightRadius final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroHaloComponent_GetLightRadius) == 0x000004, "Wrong alignment on KuroHaloComponent_GetLightRadius");
static_assert(sizeof(KuroHaloComponent_GetLightRadius) == 0x000004, "Wrong size on KuroHaloComponent_GetLightRadius");
static_assert(offsetof(KuroHaloComponent_GetLightRadius, ReturnValue) == 0x000000, "Member 'KuroHaloComponent_GetLightRadius::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroHighResLandscapeActor.GetLandscapeComponentVisible
// 0x0010 (0x0010 - 0x0000)
struct KuroHighResLandscapeActor_GetLandscapeComponentVisible final
{
public:
	class ALandscapeStreamingProxy*               Proxy;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ComponentIndex;                                    // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x000C(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroHighResLandscapeActor_GetLandscapeComponentVisible) == 0x000008, "Wrong alignment on KuroHighResLandscapeActor_GetLandscapeComponentVisible");
static_assert(sizeof(KuroHighResLandscapeActor_GetLandscapeComponentVisible) == 0x000010, "Wrong size on KuroHighResLandscapeActor_GetLandscapeComponentVisible");
static_assert(offsetof(KuroHighResLandscapeActor_GetLandscapeComponentVisible, Proxy) == 0x000000, "Member 'KuroHighResLandscapeActor_GetLandscapeComponentVisible::Proxy' has a wrong offset!");
static_assert(offsetof(KuroHighResLandscapeActor_GetLandscapeComponentVisible, ComponentIndex) == 0x000008, "Member 'KuroHighResLandscapeActor_GetLandscapeComponentVisible::ComponentIndex' has a wrong offset!");
static_assert(offsetof(KuroHighResLandscapeActor_GetLandscapeComponentVisible, ReturnValue) == 0x00000C, "Member 'KuroHighResLandscapeActor_GetLandscapeComponentVisible::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroHighResLandscapeActor.IsEnabled
// 0x0001 (0x0001 - 0x0000)
struct KuroHighResLandscapeActor_IsEnabled final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroHighResLandscapeActor_IsEnabled) == 0x000001, "Wrong alignment on KuroHighResLandscapeActor_IsEnabled");
static_assert(sizeof(KuroHighResLandscapeActor_IsEnabled) == 0x000001, "Wrong size on KuroHighResLandscapeActor_IsEnabled");
static_assert(offsetof(KuroHighResLandscapeActor_IsEnabled, ReturnValue) == 0x000000, "Member 'KuroHighResLandscapeActor_IsEnabled::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroHighResLandscapeActor.OnHideLandscapeStreamingProxy
// 0x0008 (0x0008 - 0x0000)
struct KuroHighResLandscapeActor_OnHideLandscapeStreamingProxy final
{
public:
	class ALandscapeStreamingProxy*               Proxy;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroHighResLandscapeActor_OnHideLandscapeStreamingProxy) == 0x000008, "Wrong alignment on KuroHighResLandscapeActor_OnHideLandscapeStreamingProxy");
static_assert(sizeof(KuroHighResLandscapeActor_OnHideLandscapeStreamingProxy) == 0x000008, "Wrong size on KuroHighResLandscapeActor_OnHideLandscapeStreamingProxy");
static_assert(offsetof(KuroHighResLandscapeActor_OnHideLandscapeStreamingProxy, Proxy) == 0x000000, "Member 'KuroHighResLandscapeActor_OnHideLandscapeStreamingProxy::Proxy' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroHighResLandscapeActor.OnProxyHide
// 0x0008 (0x0008 - 0x0000)
struct KuroHighResLandscapeActor_OnProxyHide final
{
public:
	class ALandscapeStreamingProxy*               Proxy;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroHighResLandscapeActor_OnProxyHide) == 0x000008, "Wrong alignment on KuroHighResLandscapeActor_OnProxyHide");
static_assert(sizeof(KuroHighResLandscapeActor_OnProxyHide) == 0x000008, "Wrong size on KuroHighResLandscapeActor_OnProxyHide");
static_assert(offsetof(KuroHighResLandscapeActor_OnProxyHide, Proxy) == 0x000000, "Member 'KuroHighResLandscapeActor_OnProxyHide::Proxy' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroHighResLandscapeActor.OnProxyShow
// 0x0008 (0x0008 - 0x0000)
struct KuroHighResLandscapeActor_OnProxyShow final
{
public:
	class ALandscapeStreamingProxy*               Proxy;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroHighResLandscapeActor_OnProxyShow) == 0x000008, "Wrong alignment on KuroHighResLandscapeActor_OnProxyShow");
static_assert(sizeof(KuroHighResLandscapeActor_OnProxyShow) == 0x000008, "Wrong size on KuroHighResLandscapeActor_OnProxyShow");
static_assert(offsetof(KuroHighResLandscapeActor_OnProxyShow, Proxy) == 0x000000, "Member 'KuroHighResLandscapeActor_OnProxyShow::Proxy' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroHighResLandscapeActor.OnShowLandscapeStreamingProxy
// 0x0008 (0x0008 - 0x0000)
struct KuroHighResLandscapeActor_OnShowLandscapeStreamingProxy final
{
public:
	class ALandscapeStreamingProxy*               Proxy;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroHighResLandscapeActor_OnShowLandscapeStreamingProxy) == 0x000008, "Wrong alignment on KuroHighResLandscapeActor_OnShowLandscapeStreamingProxy");
static_assert(sizeof(KuroHighResLandscapeActor_OnShowLandscapeStreamingProxy) == 0x000008, "Wrong size on KuroHighResLandscapeActor_OnShowLandscapeStreamingProxy");
static_assert(offsetof(KuroHighResLandscapeActor_OnShowLandscapeStreamingProxy, Proxy) == 0x000000, "Member 'KuroHighResLandscapeActor_OnShowLandscapeStreamingProxy::Proxy' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroHighResLandscapeActor.SetLandscapeComponentVisible
// 0x0010 (0x0010 - 0x0000)
struct KuroHighResLandscapeActor_SetLandscapeComponentVisible final
{
public:
	class ALandscapeStreamingProxy*               Proxy;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ComponentIndex;                                    // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsVisible;                                         // 0x000C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroHighResLandscapeActor_SetLandscapeComponentVisible) == 0x000008, "Wrong alignment on KuroHighResLandscapeActor_SetLandscapeComponentVisible");
static_assert(sizeof(KuroHighResLandscapeActor_SetLandscapeComponentVisible) == 0x000010, "Wrong size on KuroHighResLandscapeActor_SetLandscapeComponentVisible");
static_assert(offsetof(KuroHighResLandscapeActor_SetLandscapeComponentVisible, Proxy) == 0x000000, "Member 'KuroHighResLandscapeActor_SetLandscapeComponentVisible::Proxy' has a wrong offset!");
static_assert(offsetof(KuroHighResLandscapeActor_SetLandscapeComponentVisible, ComponentIndex) == 0x000008, "Member 'KuroHighResLandscapeActor_SetLandscapeComponentVisible::ComponentIndex' has a wrong offset!");
static_assert(offsetof(KuroHighResLandscapeActor_SetLandscapeComponentVisible, IsVisible) == 0x00000C, "Member 'KuroHighResLandscapeActor_SetLandscapeComponentVisible::IsVisible' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroHighResLandscapeActor.UpdateLandscapeStatus
// 0x0020 (0x0020 - 0x0000)
struct KuroHighResLandscapeActor_UpdateLandscapeStatus final
{
public:
	TArray<class ALandscapeStreamingProxy*>       LowLandProxies;                                    // 0x0000(0x0010)(Parm, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class ALandscapeStreamingProxy*>       HighLandProxies;                                   // 0x0010(0x0010)(Parm, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroHighResLandscapeActor_UpdateLandscapeStatus) == 0x000008, "Wrong alignment on KuroHighResLandscapeActor_UpdateLandscapeStatus");
static_assert(sizeof(KuroHighResLandscapeActor_UpdateLandscapeStatus) == 0x000020, "Wrong size on KuroHighResLandscapeActor_UpdateLandscapeStatus");
static_assert(offsetof(KuroHighResLandscapeActor_UpdateLandscapeStatus, LowLandProxies) == 0x000000, "Member 'KuroHighResLandscapeActor_UpdateLandscapeStatus::LowLandProxies' has a wrong offset!");
static_assert(offsetof(KuroHighResLandscapeActor_UpdateLandscapeStatus, HighLandProxies) == 0x000010, "Member 'KuroHighResLandscapeActor_UpdateLandscapeStatus::HighLandProxies' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroLensFlare.GetViewportSize
// 0x0008 (0x0008 - 0x0000)
struct KuroLensFlare_GetViewportSize final
{
public:
	struct FVector2D                              ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroLensFlare_GetViewportSize) == 0x000004, "Wrong alignment on KuroLensFlare_GetViewportSize");
static_assert(sizeof(KuroLensFlare_GetViewportSize) == 0x000008, "Wrong size on KuroLensFlare_GetViewportSize");
static_assert(offsetof(KuroLensFlare_GetViewportSize, ReturnValue) == 0x000000, "Member 'KuroLensFlare_GetViewportSize::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroLensFlare.Init
// 0x0008 (0x0008 - 0x0000)
struct KuroLensFlare_Init final
{
public:
	class UProceduralMeshComponent*               InputMeshComponent;                                // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroLensFlare_Init) == 0x000008, "Wrong alignment on KuroLensFlare_Init");
static_assert(sizeof(KuroLensFlare_Init) == 0x000008, "Wrong size on KuroLensFlare_Init");
static_assert(offsetof(KuroLensFlare_Init, InputMeshComponent) == 0x000000, "Member 'KuroLensFlare_Init::InputMeshComponent' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroLensFlare.InitVecticesData
// 0x0004 (0x0004 - 0x0000)
struct KuroLensFlare_InitVecticesData final
{
public:
	int32                                         LensImageLengths;                                  // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroLensFlare_InitVecticesData) == 0x000004, "Wrong alignment on KuroLensFlare_InitVecticesData");
static_assert(sizeof(KuroLensFlare_InitVecticesData) == 0x000004, "Wrong size on KuroLensFlare_InitVecticesData");
static_assert(offsetof(KuroLensFlare_InitVecticesData, LensImageLengths) == 0x000000, "Member 'KuroLensFlare_InitVecticesData::LensImageLengths' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroLensFlare.IsInit
// 0x0001 (0x0001 - 0x0000)
struct KuroLensFlare_IsInit final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroLensFlare_IsInit) == 0x000001, "Wrong alignment on KuroLensFlare_IsInit");
static_assert(sizeof(KuroLensFlare_IsInit) == 0x000001, "Wrong size on KuroLensFlare_IsInit");
static_assert(offsetof(KuroLensFlare_IsInit, ReturnValue) == 0x000000, "Member 'KuroLensFlare_IsInit::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroLensFlare.IsViewportEnable
// 0x0001 (0x0001 - 0x0000)
struct KuroLensFlare_IsViewportEnable final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroLensFlare_IsViewportEnable) == 0x000001, "Wrong alignment on KuroLensFlare_IsViewportEnable");
static_assert(sizeof(KuroLensFlare_IsViewportEnable) == 0x000001, "Wrong size on KuroLensFlare_IsViewportEnable");
static_assert(offsetof(KuroLensFlare_IsViewportEnable, ReturnValue) == 0x000000, "Member 'KuroLensFlare_IsViewportEnable::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroLensFlare.SetVertsProperties
// 0x004C (0x004C - 0x0000)
struct KuroLensFlare_SetVertsProperties final
{
public:
	struct FVector2D                              ViewportScale;                                     // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PrimityIndex;                                      // 0x0008(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              UVCenter;                                          // 0x000C(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              UVSize;                                            // 0x0014(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              LensFlareScale;                                    // 0x001C(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LensFlareOffset;                                   // 0x0024(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LensFlareRotation;                                 // 0x0028(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           LensFlareTint;                                     // 0x002C(0x0010)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              LensFlareScreenPosition;                           // 0x003C(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              LensFlareDirection;                                // 0x0044(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroLensFlare_SetVertsProperties) == 0x000004, "Wrong alignment on KuroLensFlare_SetVertsProperties");
static_assert(sizeof(KuroLensFlare_SetVertsProperties) == 0x00004C, "Wrong size on KuroLensFlare_SetVertsProperties");
static_assert(offsetof(KuroLensFlare_SetVertsProperties, ViewportScale) == 0x000000, "Member 'KuroLensFlare_SetVertsProperties::ViewportScale' has a wrong offset!");
static_assert(offsetof(KuroLensFlare_SetVertsProperties, PrimityIndex) == 0x000008, "Member 'KuroLensFlare_SetVertsProperties::PrimityIndex' has a wrong offset!");
static_assert(offsetof(KuroLensFlare_SetVertsProperties, UVCenter) == 0x00000C, "Member 'KuroLensFlare_SetVertsProperties::UVCenter' has a wrong offset!");
static_assert(offsetof(KuroLensFlare_SetVertsProperties, UVSize) == 0x000014, "Member 'KuroLensFlare_SetVertsProperties::UVSize' has a wrong offset!");
static_assert(offsetof(KuroLensFlare_SetVertsProperties, LensFlareScale) == 0x00001C, "Member 'KuroLensFlare_SetVertsProperties::LensFlareScale' has a wrong offset!");
static_assert(offsetof(KuroLensFlare_SetVertsProperties, LensFlareOffset) == 0x000024, "Member 'KuroLensFlare_SetVertsProperties::LensFlareOffset' has a wrong offset!");
static_assert(offsetof(KuroLensFlare_SetVertsProperties, LensFlareRotation) == 0x000028, "Member 'KuroLensFlare_SetVertsProperties::LensFlareRotation' has a wrong offset!");
static_assert(offsetof(KuroLensFlare_SetVertsProperties, LensFlareTint) == 0x00002C, "Member 'KuroLensFlare_SetVertsProperties::LensFlareTint' has a wrong offset!");
static_assert(offsetof(KuroLensFlare_SetVertsProperties, LensFlareScreenPosition) == 0x00003C, "Member 'KuroLensFlare_SetVertsProperties::LensFlareScreenPosition' has a wrong offset!");
static_assert(offsetof(KuroLensFlare_SetVertsProperties, LensFlareDirection) == 0x000044, "Member 'KuroLensFlare_SetVertsProperties::LensFlareDirection' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroMaterialControllerDataAsset.IsDataCacheValid
// 0x0001 (0x0001 - 0x0000)
struct KuroMaterialControllerDataAsset_IsDataCacheValid final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroMaterialControllerDataAsset_IsDataCacheValid) == 0x000001, "Wrong alignment on KuroMaterialControllerDataAsset_IsDataCacheValid");
static_assert(sizeof(KuroMaterialControllerDataAsset_IsDataCacheValid) == 0x000001, "Wrong size on KuroMaterialControllerDataAsset_IsDataCacheValid");
static_assert(offsetof(KuroMaterialControllerDataAsset_IsDataCacheValid, ReturnValue) == 0x000000, "Member 'KuroMaterialControllerDataAsset_IsDataCacheValid::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroMaterialControllerDataAsset.ResetDataCache
// 0x0001 (0x0001 - 0x0000)
struct KuroMaterialControllerDataAsset_ResetDataCache final
{
public:
	bool                                          bForce;                                            // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroMaterialControllerDataAsset_ResetDataCache) == 0x000001, "Wrong alignment on KuroMaterialControllerDataAsset_ResetDataCache");
static_assert(sizeof(KuroMaterialControllerDataAsset_ResetDataCache) == 0x000001, "Wrong size on KuroMaterialControllerDataAsset_ResetDataCache");
static_assert(offsetof(KuroMaterialControllerDataAsset_ResetDataCache, bForce) == 0x000000, "Member 'KuroMaterialControllerDataAsset_ResetDataCache::bForce' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroMaterialParameterCollectionManager.SetScalarParameterValueTimeCurve
// 0x0038 (0x0038 - 0x0000)
struct KuroMaterialParameterCollectionManager_SetScalarParameterValueTimeCurve final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialParameterCollection*           Collection;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ParameterName;                                     // 0x0010(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ParameterValueTarget;                              // 0x001C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ParameterValueStart;                               // 0x0020(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Duration;                                          // 0x0024(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWorld*                                 World;                                             // 0x0028(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UseStartVal;                                       // 0x0030(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroMaterialParameterCollectionManager_SetScalarParameterValueTimeCurve) == 0x000008, "Wrong alignment on KuroMaterialParameterCollectionManager_SetScalarParameterValueTimeCurve");
static_assert(sizeof(KuroMaterialParameterCollectionManager_SetScalarParameterValueTimeCurve) == 0x000038, "Wrong size on KuroMaterialParameterCollectionManager_SetScalarParameterValueTimeCurve");
static_assert(offsetof(KuroMaterialParameterCollectionManager_SetScalarParameterValueTimeCurve, WorldContextObject) == 0x000000, "Member 'KuroMaterialParameterCollectionManager_SetScalarParameterValueTimeCurve::WorldContextObject' has a wrong offset!");
static_assert(offsetof(KuroMaterialParameterCollectionManager_SetScalarParameterValueTimeCurve, Collection) == 0x000008, "Member 'KuroMaterialParameterCollectionManager_SetScalarParameterValueTimeCurve::Collection' has a wrong offset!");
static_assert(offsetof(KuroMaterialParameterCollectionManager_SetScalarParameterValueTimeCurve, ParameterName) == 0x000010, "Member 'KuroMaterialParameterCollectionManager_SetScalarParameterValueTimeCurve::ParameterName' has a wrong offset!");
static_assert(offsetof(KuroMaterialParameterCollectionManager_SetScalarParameterValueTimeCurve, ParameterValueTarget) == 0x00001C, "Member 'KuroMaterialParameterCollectionManager_SetScalarParameterValueTimeCurve::ParameterValueTarget' has a wrong offset!");
static_assert(offsetof(KuroMaterialParameterCollectionManager_SetScalarParameterValueTimeCurve, ParameterValueStart) == 0x000020, "Member 'KuroMaterialParameterCollectionManager_SetScalarParameterValueTimeCurve::ParameterValueStart' has a wrong offset!");
static_assert(offsetof(KuroMaterialParameterCollectionManager_SetScalarParameterValueTimeCurve, Duration) == 0x000024, "Member 'KuroMaterialParameterCollectionManager_SetScalarParameterValueTimeCurve::Duration' has a wrong offset!");
static_assert(offsetof(KuroMaterialParameterCollectionManager_SetScalarParameterValueTimeCurve, World) == 0x000028, "Member 'KuroMaterialParameterCollectionManager_SetScalarParameterValueTimeCurve::World' has a wrong offset!");
static_assert(offsetof(KuroMaterialParameterCollectionManager_SetScalarParameterValueTimeCurve, UseStartVal) == 0x000030, "Member 'KuroMaterialParameterCollectionManager_SetScalarParameterValueTimeCurve::UseStartVal' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroMaterialParameterCollectionManager.SetVectorParameterValueTimeCurve
// 0x0050 (0x0050 - 0x0000)
struct KuroMaterialParameterCollectionManager_SetVectorParameterValueTimeCurve final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialParameterCollection*           Collection;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ParameterName;                                     // 0x0010(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           ParameterValueTarget;                              // 0x001C(0x0010)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           ParameterValueStart;                               // 0x002C(0x0010)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Duration;                                          // 0x003C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWorld*                                 World;                                             // 0x0040(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UseStartVal;                                       // 0x0048(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49[0x7];                                       // 0x0049(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroMaterialParameterCollectionManager_SetVectorParameterValueTimeCurve) == 0x000008, "Wrong alignment on KuroMaterialParameterCollectionManager_SetVectorParameterValueTimeCurve");
static_assert(sizeof(KuroMaterialParameterCollectionManager_SetVectorParameterValueTimeCurve) == 0x000050, "Wrong size on KuroMaterialParameterCollectionManager_SetVectorParameterValueTimeCurve");
static_assert(offsetof(KuroMaterialParameterCollectionManager_SetVectorParameterValueTimeCurve, WorldContextObject) == 0x000000, "Member 'KuroMaterialParameterCollectionManager_SetVectorParameterValueTimeCurve::WorldContextObject' has a wrong offset!");
static_assert(offsetof(KuroMaterialParameterCollectionManager_SetVectorParameterValueTimeCurve, Collection) == 0x000008, "Member 'KuroMaterialParameterCollectionManager_SetVectorParameterValueTimeCurve::Collection' has a wrong offset!");
static_assert(offsetof(KuroMaterialParameterCollectionManager_SetVectorParameterValueTimeCurve, ParameterName) == 0x000010, "Member 'KuroMaterialParameterCollectionManager_SetVectorParameterValueTimeCurve::ParameterName' has a wrong offset!");
static_assert(offsetof(KuroMaterialParameterCollectionManager_SetVectorParameterValueTimeCurve, ParameterValueTarget) == 0x00001C, "Member 'KuroMaterialParameterCollectionManager_SetVectorParameterValueTimeCurve::ParameterValueTarget' has a wrong offset!");
static_assert(offsetof(KuroMaterialParameterCollectionManager_SetVectorParameterValueTimeCurve, ParameterValueStart) == 0x00002C, "Member 'KuroMaterialParameterCollectionManager_SetVectorParameterValueTimeCurve::ParameterValueStart' has a wrong offset!");
static_assert(offsetof(KuroMaterialParameterCollectionManager_SetVectorParameterValueTimeCurve, Duration) == 0x00003C, "Member 'KuroMaterialParameterCollectionManager_SetVectorParameterValueTimeCurve::Duration' has a wrong offset!");
static_assert(offsetof(KuroMaterialParameterCollectionManager_SetVectorParameterValueTimeCurve, World) == 0x000040, "Member 'KuroMaterialParameterCollectionManager_SetVectorParameterValueTimeCurve::World' has a wrong offset!");
static_assert(offsetof(KuroMaterialParameterCollectionManager_SetVectorParameterValueTimeCurve, UseStartVal) == 0x000048, "Member 'KuroMaterialParameterCollectionManager_SetVectorParameterValueTimeCurve::UseStartVal' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroMaterialVariationComponent.GetKeywordState
// 0x0014 (0x0014 - 0x0000)
struct KuroMaterialVariationComponent_GetKeywordState final
{
public:
	class FName                                   PropertyName;                                      // 0x0000(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaterialIndex;                                     // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroMaterialVariationComponent_GetKeywordState) == 0x000004, "Wrong alignment on KuroMaterialVariationComponent_GetKeywordState");
static_assert(sizeof(KuroMaterialVariationComponent_GetKeywordState) == 0x000014, "Wrong size on KuroMaterialVariationComponent_GetKeywordState");
static_assert(offsetof(KuroMaterialVariationComponent_GetKeywordState, PropertyName) == 0x000000, "Member 'KuroMaterialVariationComponent_GetKeywordState::PropertyName' has a wrong offset!");
static_assert(offsetof(KuroMaterialVariationComponent_GetKeywordState, MaterialIndex) == 0x00000C, "Member 'KuroMaterialVariationComponent_GetKeywordState::MaterialIndex' has a wrong offset!");
static_assert(offsetof(KuroMaterialVariationComponent_GetKeywordState, ReturnValue) == 0x000010, "Member 'KuroMaterialVariationComponent_GetKeywordState::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroMaterialVariationComponent.GetMaterialFloat
// 0x0014 (0x0014 - 0x0000)
struct KuroMaterialVariationComponent_GetMaterialFloat final
{
public:
	class FName                                   PropertyName;                                      // 0x0000(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaterialIndex;                                     // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0010(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroMaterialVariationComponent_GetMaterialFloat) == 0x000004, "Wrong alignment on KuroMaterialVariationComponent_GetMaterialFloat");
static_assert(sizeof(KuroMaterialVariationComponent_GetMaterialFloat) == 0x000014, "Wrong size on KuroMaterialVariationComponent_GetMaterialFloat");
static_assert(offsetof(KuroMaterialVariationComponent_GetMaterialFloat, PropertyName) == 0x000000, "Member 'KuroMaterialVariationComponent_GetMaterialFloat::PropertyName' has a wrong offset!");
static_assert(offsetof(KuroMaterialVariationComponent_GetMaterialFloat, MaterialIndex) == 0x00000C, "Member 'KuroMaterialVariationComponent_GetMaterialFloat::MaterialIndex' has a wrong offset!");
static_assert(offsetof(KuroMaterialVariationComponent_GetMaterialFloat, ReturnValue) == 0x000010, "Member 'KuroMaterialVariationComponent_GetMaterialFloat::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroMaterialVariationComponent.GetMaterialLinearColor
// 0x0020 (0x0020 - 0x0000)
struct KuroMaterialVariationComponent_GetMaterialLinearColor final
{
public:
	class FName                                   PropertyName;                                      // 0x0000(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaterialIndex;                                     // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           ReturnValue;                                       // 0x0010(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroMaterialVariationComponent_GetMaterialLinearColor) == 0x000004, "Wrong alignment on KuroMaterialVariationComponent_GetMaterialLinearColor");
static_assert(sizeof(KuroMaterialVariationComponent_GetMaterialLinearColor) == 0x000020, "Wrong size on KuroMaterialVariationComponent_GetMaterialLinearColor");
static_assert(offsetof(KuroMaterialVariationComponent_GetMaterialLinearColor, PropertyName) == 0x000000, "Member 'KuroMaterialVariationComponent_GetMaterialLinearColor::PropertyName' has a wrong offset!");
static_assert(offsetof(KuroMaterialVariationComponent_GetMaterialLinearColor, MaterialIndex) == 0x00000C, "Member 'KuroMaterialVariationComponent_GetMaterialLinearColor::MaterialIndex' has a wrong offset!");
static_assert(offsetof(KuroMaterialVariationComponent_GetMaterialLinearColor, ReturnValue) == 0x000010, "Member 'KuroMaterialVariationComponent_GetMaterialLinearColor::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroMaterialVariationComponent.GetMaterialTexture
// 0x0018 (0x0018 - 0x0000)
struct KuroMaterialVariationComponent_GetMaterialTexture final
{
public:
	class FName                                   PropertyName;                                      // 0x0000(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaterialIndex;                                     // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture*                               ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroMaterialVariationComponent_GetMaterialTexture) == 0x000008, "Wrong alignment on KuroMaterialVariationComponent_GetMaterialTexture");
static_assert(sizeof(KuroMaterialVariationComponent_GetMaterialTexture) == 0x000018, "Wrong size on KuroMaterialVariationComponent_GetMaterialTexture");
static_assert(offsetof(KuroMaterialVariationComponent_GetMaterialTexture, PropertyName) == 0x000000, "Member 'KuroMaterialVariationComponent_GetMaterialTexture::PropertyName' has a wrong offset!");
static_assert(offsetof(KuroMaterialVariationComponent_GetMaterialTexture, MaterialIndex) == 0x00000C, "Member 'KuroMaterialVariationComponent_GetMaterialTexture::MaterialIndex' has a wrong offset!");
static_assert(offsetof(KuroMaterialVariationComponent_GetMaterialTexture, ReturnValue) == 0x000010, "Member 'KuroMaterialVariationComponent_GetMaterialTexture::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroMaterialVariationComponent.InitWithSkeletalMeshComponent
// 0x0010 (0x0010 - 0x0000)
struct KuroMaterialVariationComponent_InitWithSkeletalMeshComponent final
{
public:
	class USkeletalMeshComponent*                 InSkeletalMeshComponent;                           // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroMaterialVariationComponent_InitWithSkeletalMeshComponent) == 0x000008, "Wrong alignment on KuroMaterialVariationComponent_InitWithSkeletalMeshComponent");
static_assert(sizeof(KuroMaterialVariationComponent_InitWithSkeletalMeshComponent) == 0x000010, "Wrong size on KuroMaterialVariationComponent_InitWithSkeletalMeshComponent");
static_assert(offsetof(KuroMaterialVariationComponent_InitWithSkeletalMeshComponent, InSkeletalMeshComponent) == 0x000000, "Member 'KuroMaterialVariationComponent_InitWithSkeletalMeshComponent::InSkeletalMeshComponent' has a wrong offset!");
static_assert(offsetof(KuroMaterialVariationComponent_InitWithSkeletalMeshComponent, ReturnValue) == 0x000008, "Member 'KuroMaterialVariationComponent_InitWithSkeletalMeshComponent::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroMaterialVariationComponent.InitWithStaticMeshComponent
// 0x0010 (0x0010 - 0x0000)
struct KuroMaterialVariationComponent_InitWithStaticMeshComponent final
{
public:
	class UStaticMeshComponent*                   InStaticMeshComponent;                             // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroMaterialVariationComponent_InitWithStaticMeshComponent) == 0x000008, "Wrong alignment on KuroMaterialVariationComponent_InitWithStaticMeshComponent");
static_assert(sizeof(KuroMaterialVariationComponent_InitWithStaticMeshComponent) == 0x000010, "Wrong size on KuroMaterialVariationComponent_InitWithStaticMeshComponent");
static_assert(offsetof(KuroMaterialVariationComponent_InitWithStaticMeshComponent, InStaticMeshComponent) == 0x000000, "Member 'KuroMaterialVariationComponent_InitWithStaticMeshComponent::InStaticMeshComponent' has a wrong offset!");
static_assert(offsetof(KuroMaterialVariationComponent_InitWithStaticMeshComponent, ReturnValue) == 0x000008, "Member 'KuroMaterialVariationComponent_InitWithStaticMeshComponent::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroMaterialVariationComponent.IsComponentValid
// 0x0001 (0x0001 - 0x0000)
struct KuroMaterialVariationComponent_IsComponentValid final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroMaterialVariationComponent_IsComponentValid) == 0x000001, "Wrong alignment on KuroMaterialVariationComponent_IsComponentValid");
static_assert(sizeof(KuroMaterialVariationComponent_IsComponentValid) == 0x000001, "Wrong size on KuroMaterialVariationComponent_IsComponentValid");
static_assert(offsetof(KuroMaterialVariationComponent_IsComponentValid, ReturnValue) == 0x000000, "Member 'KuroMaterialVariationComponent_IsComponentValid::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroMaterialVariationComponent.IsMaterialVariationDataValid
// 0x0020 (0x0020 - 0x0000)
struct KuroMaterialVariationComponent_IsMaterialVariationDataValid final
{
public:
	class UMeshComponent*                         CheckMeshComponent;                                // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UKuroMaterialVariationCollection*> CheckCollection;                                 // 0x0008(0x0010)(Parm, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0018(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroMaterialVariationComponent_IsMaterialVariationDataValid) == 0x000008, "Wrong alignment on KuroMaterialVariationComponent_IsMaterialVariationDataValid");
static_assert(sizeof(KuroMaterialVariationComponent_IsMaterialVariationDataValid) == 0x000020, "Wrong size on KuroMaterialVariationComponent_IsMaterialVariationDataValid");
static_assert(offsetof(KuroMaterialVariationComponent_IsMaterialVariationDataValid, CheckMeshComponent) == 0x000000, "Member 'KuroMaterialVariationComponent_IsMaterialVariationDataValid::CheckMeshComponent' has a wrong offset!");
static_assert(offsetof(KuroMaterialVariationComponent_IsMaterialVariationDataValid, CheckCollection) == 0x000008, "Member 'KuroMaterialVariationComponent_IsMaterialVariationDataValid::CheckCollection' has a wrong offset!");
static_assert(offsetof(KuroMaterialVariationComponent_IsMaterialVariationDataValid, ReturnValue) == 0x000018, "Member 'KuroMaterialVariationComponent_IsMaterialVariationDataValid::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroMaterialVariationComponent.ReplaceMaterial
// 0x0010 (0x0010 - 0x0000)
struct KuroMaterialVariationComponent_ReplaceMaterial final
{
public:
	class UMaterialInterface*                     MatToReplace;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaterialIndex;                                     // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroMaterialVariationComponent_ReplaceMaterial) == 0x000008, "Wrong alignment on KuroMaterialVariationComponent_ReplaceMaterial");
static_assert(sizeof(KuroMaterialVariationComponent_ReplaceMaterial) == 0x000010, "Wrong size on KuroMaterialVariationComponent_ReplaceMaterial");
static_assert(offsetof(KuroMaterialVariationComponent_ReplaceMaterial, MatToReplace) == 0x000000, "Member 'KuroMaterialVariationComponent_ReplaceMaterial::MatToReplace' has a wrong offset!");
static_assert(offsetof(KuroMaterialVariationComponent_ReplaceMaterial, MaterialIndex) == 0x000008, "Member 'KuroMaterialVariationComponent_ReplaceMaterial::MaterialIndex' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroMaterialVariationComponent.RevertMaterial
// 0x0004 (0x0004 - 0x0000)
struct KuroMaterialVariationComponent_RevertMaterial final
{
public:
	int32                                         MaterialIndex;                                     // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroMaterialVariationComponent_RevertMaterial) == 0x000004, "Wrong alignment on KuroMaterialVariationComponent_RevertMaterial");
static_assert(sizeof(KuroMaterialVariationComponent_RevertMaterial) == 0x000004, "Wrong size on KuroMaterialVariationComponent_RevertMaterial");
static_assert(offsetof(KuroMaterialVariationComponent_RevertMaterial, MaterialIndex) == 0x000000, "Member 'KuroMaterialVariationComponent_RevertMaterial::MaterialIndex' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroMaterialVariationComponent.RevertMaterialFloat
// 0x0010 (0x0010 - 0x0000)
struct KuroMaterialVariationComponent_RevertMaterialFloat final
{
public:
	class FName                                   PropertyName;                                      // 0x0000(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaterialIndex;                                     // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroMaterialVariationComponent_RevertMaterialFloat) == 0x000004, "Wrong alignment on KuroMaterialVariationComponent_RevertMaterialFloat");
static_assert(sizeof(KuroMaterialVariationComponent_RevertMaterialFloat) == 0x000010, "Wrong size on KuroMaterialVariationComponent_RevertMaterialFloat");
static_assert(offsetof(KuroMaterialVariationComponent_RevertMaterialFloat, PropertyName) == 0x000000, "Member 'KuroMaterialVariationComponent_RevertMaterialFloat::PropertyName' has a wrong offset!");
static_assert(offsetof(KuroMaterialVariationComponent_RevertMaterialFloat, MaterialIndex) == 0x00000C, "Member 'KuroMaterialVariationComponent_RevertMaterialFloat::MaterialIndex' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroMaterialVariationComponent.RevertMaterialFloatAll
// 0x000C (0x000C - 0x0000)
struct KuroMaterialVariationComponent_RevertMaterialFloatAll final
{
public:
	class FName                                   PropertyName;                                      // 0x0000(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroMaterialVariationComponent_RevertMaterialFloatAll) == 0x000004, "Wrong alignment on KuroMaterialVariationComponent_RevertMaterialFloatAll");
static_assert(sizeof(KuroMaterialVariationComponent_RevertMaterialFloatAll) == 0x00000C, "Wrong size on KuroMaterialVariationComponent_RevertMaterialFloatAll");
static_assert(offsetof(KuroMaterialVariationComponent_RevertMaterialFloatAll, PropertyName) == 0x000000, "Member 'KuroMaterialVariationComponent_RevertMaterialFloatAll::PropertyName' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroMaterialVariationComponent.RevertMaterialLinearColor
// 0x0010 (0x0010 - 0x0000)
struct KuroMaterialVariationComponent_RevertMaterialLinearColor final
{
public:
	class FName                                   PropertyName;                                      // 0x0000(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaterialIndex;                                     // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroMaterialVariationComponent_RevertMaterialLinearColor) == 0x000004, "Wrong alignment on KuroMaterialVariationComponent_RevertMaterialLinearColor");
static_assert(sizeof(KuroMaterialVariationComponent_RevertMaterialLinearColor) == 0x000010, "Wrong size on KuroMaterialVariationComponent_RevertMaterialLinearColor");
static_assert(offsetof(KuroMaterialVariationComponent_RevertMaterialLinearColor, PropertyName) == 0x000000, "Member 'KuroMaterialVariationComponent_RevertMaterialLinearColor::PropertyName' has a wrong offset!");
static_assert(offsetof(KuroMaterialVariationComponent_RevertMaterialLinearColor, MaterialIndex) == 0x00000C, "Member 'KuroMaterialVariationComponent_RevertMaterialLinearColor::MaterialIndex' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroMaterialVariationComponent.RevertMaterialLinearColorAll
// 0x000C (0x000C - 0x0000)
struct KuroMaterialVariationComponent_RevertMaterialLinearColorAll final
{
public:
	class FName                                   PropertyName;                                      // 0x0000(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroMaterialVariationComponent_RevertMaterialLinearColorAll) == 0x000004, "Wrong alignment on KuroMaterialVariationComponent_RevertMaterialLinearColorAll");
static_assert(sizeof(KuroMaterialVariationComponent_RevertMaterialLinearColorAll) == 0x00000C, "Wrong size on KuroMaterialVariationComponent_RevertMaterialLinearColorAll");
static_assert(offsetof(KuroMaterialVariationComponent_RevertMaterialLinearColorAll, PropertyName) == 0x000000, "Member 'KuroMaterialVariationComponent_RevertMaterialLinearColorAll::PropertyName' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroMaterialVariationComponent.RevertMaterialTexture
// 0x0010 (0x0010 - 0x0000)
struct KuroMaterialVariationComponent_RevertMaterialTexture final
{
public:
	class FName                                   PropertyName;                                      // 0x0000(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaterialIndex;                                     // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroMaterialVariationComponent_RevertMaterialTexture) == 0x000004, "Wrong alignment on KuroMaterialVariationComponent_RevertMaterialTexture");
static_assert(sizeof(KuroMaterialVariationComponent_RevertMaterialTexture) == 0x000010, "Wrong size on KuroMaterialVariationComponent_RevertMaterialTexture");
static_assert(offsetof(KuroMaterialVariationComponent_RevertMaterialTexture, PropertyName) == 0x000000, "Member 'KuroMaterialVariationComponent_RevertMaterialTexture::PropertyName' has a wrong offset!");
static_assert(offsetof(KuroMaterialVariationComponent_RevertMaterialTexture, MaterialIndex) == 0x00000C, "Member 'KuroMaterialVariationComponent_RevertMaterialTexture::MaterialIndex' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroMaterialVariationComponent.RevertMaterialTextureAll
// 0x000C (0x000C - 0x0000)
struct KuroMaterialVariationComponent_RevertMaterialTextureAll final
{
public:
	class FName                                   PropertyName;                                      // 0x0000(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroMaterialVariationComponent_RevertMaterialTextureAll) == 0x000004, "Wrong alignment on KuroMaterialVariationComponent_RevertMaterialTextureAll");
static_assert(sizeof(KuroMaterialVariationComponent_RevertMaterialTextureAll) == 0x00000C, "Wrong size on KuroMaterialVariationComponent_RevertMaterialTextureAll");
static_assert(offsetof(KuroMaterialVariationComponent_RevertMaterialTextureAll, PropertyName) == 0x000000, "Member 'KuroMaterialVariationComponent_RevertMaterialTextureAll::PropertyName' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroMaterialVariationComponent.SetKeywordState
// 0x0014 (0x0014 - 0x0000)
struct KuroMaterialVariationComponent_SetKeywordState final
{
public:
	class FName                                   Keyword;                                           // 0x0000(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          InIsEnable;                                        // 0x000C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MaterialIndex;                                     // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroMaterialVariationComponent_SetKeywordState) == 0x000004, "Wrong alignment on KuroMaterialVariationComponent_SetKeywordState");
static_assert(sizeof(KuroMaterialVariationComponent_SetKeywordState) == 0x000014, "Wrong size on KuroMaterialVariationComponent_SetKeywordState");
static_assert(offsetof(KuroMaterialVariationComponent_SetKeywordState, Keyword) == 0x000000, "Member 'KuroMaterialVariationComponent_SetKeywordState::Keyword' has a wrong offset!");
static_assert(offsetof(KuroMaterialVariationComponent_SetKeywordState, InIsEnable) == 0x00000C, "Member 'KuroMaterialVariationComponent_SetKeywordState::InIsEnable' has a wrong offset!");
static_assert(offsetof(KuroMaterialVariationComponent_SetKeywordState, MaterialIndex) == 0x000010, "Member 'KuroMaterialVariationComponent_SetKeywordState::MaterialIndex' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroMaterialVariationComponent.SetKeywordStateAll
// 0x0010 (0x0010 - 0x0000)
struct KuroMaterialVariationComponent_SetKeywordStateAll final
{
public:
	class FName                                   Keyword;                                           // 0x0000(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          InIsEnable;                                        // 0x000C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroMaterialVariationComponent_SetKeywordStateAll) == 0x000004, "Wrong alignment on KuroMaterialVariationComponent_SetKeywordStateAll");
static_assert(sizeof(KuroMaterialVariationComponent_SetKeywordStateAll) == 0x000010, "Wrong size on KuroMaterialVariationComponent_SetKeywordStateAll");
static_assert(offsetof(KuroMaterialVariationComponent_SetKeywordStateAll, Keyword) == 0x000000, "Member 'KuroMaterialVariationComponent_SetKeywordStateAll::Keyword' has a wrong offset!");
static_assert(offsetof(KuroMaterialVariationComponent_SetKeywordStateAll, InIsEnable) == 0x00000C, "Member 'KuroMaterialVariationComponent_SetKeywordStateAll::InIsEnable' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroMaterialVariationComponent.SetMaterialFloat
// 0x0014 (0x0014 - 0x0000)
struct KuroMaterialVariationComponent_SetMaterialFloat final
{
public:
	class FName                                   PropertyName;                                      // 0x0000(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InValue;                                           // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaterialIndex;                                     // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroMaterialVariationComponent_SetMaterialFloat) == 0x000004, "Wrong alignment on KuroMaterialVariationComponent_SetMaterialFloat");
static_assert(sizeof(KuroMaterialVariationComponent_SetMaterialFloat) == 0x000014, "Wrong size on KuroMaterialVariationComponent_SetMaterialFloat");
static_assert(offsetof(KuroMaterialVariationComponent_SetMaterialFloat, PropertyName) == 0x000000, "Member 'KuroMaterialVariationComponent_SetMaterialFloat::PropertyName' has a wrong offset!");
static_assert(offsetof(KuroMaterialVariationComponent_SetMaterialFloat, InValue) == 0x00000C, "Member 'KuroMaterialVariationComponent_SetMaterialFloat::InValue' has a wrong offset!");
static_assert(offsetof(KuroMaterialVariationComponent_SetMaterialFloat, MaterialIndex) == 0x000010, "Member 'KuroMaterialVariationComponent_SetMaterialFloat::MaterialIndex' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroMaterialVariationComponent.SetMaterialFloatAll
// 0x0010 (0x0010 - 0x0000)
struct KuroMaterialVariationComponent_SetMaterialFloatAll final
{
public:
	class FName                                   PropertyName;                                      // 0x0000(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InValue;                                           // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroMaterialVariationComponent_SetMaterialFloatAll) == 0x000004, "Wrong alignment on KuroMaterialVariationComponent_SetMaterialFloatAll");
static_assert(sizeof(KuroMaterialVariationComponent_SetMaterialFloatAll) == 0x000010, "Wrong size on KuroMaterialVariationComponent_SetMaterialFloatAll");
static_assert(offsetof(KuroMaterialVariationComponent_SetMaterialFloatAll, PropertyName) == 0x000000, "Member 'KuroMaterialVariationComponent_SetMaterialFloatAll::PropertyName' has a wrong offset!");
static_assert(offsetof(KuroMaterialVariationComponent_SetMaterialFloatAll, InValue) == 0x00000C, "Member 'KuroMaterialVariationComponent_SetMaterialFloatAll::InValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroMaterialVariationComponent.SetMaterialLinearColor
// 0x0020 (0x0020 - 0x0000)
struct KuroMaterialVariationComponent_SetMaterialLinearColor final
{
public:
	class FName                                   PropertyName;                                      // 0x0000(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           InValue;                                           // 0x000C(0x0010)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaterialIndex;                                     // 0x001C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroMaterialVariationComponent_SetMaterialLinearColor) == 0x000004, "Wrong alignment on KuroMaterialVariationComponent_SetMaterialLinearColor");
static_assert(sizeof(KuroMaterialVariationComponent_SetMaterialLinearColor) == 0x000020, "Wrong size on KuroMaterialVariationComponent_SetMaterialLinearColor");
static_assert(offsetof(KuroMaterialVariationComponent_SetMaterialLinearColor, PropertyName) == 0x000000, "Member 'KuroMaterialVariationComponent_SetMaterialLinearColor::PropertyName' has a wrong offset!");
static_assert(offsetof(KuroMaterialVariationComponent_SetMaterialLinearColor, InValue) == 0x00000C, "Member 'KuroMaterialVariationComponent_SetMaterialLinearColor::InValue' has a wrong offset!");
static_assert(offsetof(KuroMaterialVariationComponent_SetMaterialLinearColor, MaterialIndex) == 0x00001C, "Member 'KuroMaterialVariationComponent_SetMaterialLinearColor::MaterialIndex' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroMaterialVariationComponent.SetMaterialLinearColorAll
// 0x001C (0x001C - 0x0000)
struct KuroMaterialVariationComponent_SetMaterialLinearColorAll final
{
public:
	class FName                                   PropertyName;                                      // 0x0000(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           InValue;                                           // 0x000C(0x0010)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroMaterialVariationComponent_SetMaterialLinearColorAll) == 0x000004, "Wrong alignment on KuroMaterialVariationComponent_SetMaterialLinearColorAll");
static_assert(sizeof(KuroMaterialVariationComponent_SetMaterialLinearColorAll) == 0x00001C, "Wrong size on KuroMaterialVariationComponent_SetMaterialLinearColorAll");
static_assert(offsetof(KuroMaterialVariationComponent_SetMaterialLinearColorAll, PropertyName) == 0x000000, "Member 'KuroMaterialVariationComponent_SetMaterialLinearColorAll::PropertyName' has a wrong offset!");
static_assert(offsetof(KuroMaterialVariationComponent_SetMaterialLinearColorAll, InValue) == 0x00000C, "Member 'KuroMaterialVariationComponent_SetMaterialLinearColorAll::InValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroMaterialVariationComponent.SetMaterialTexture
// 0x0020 (0x0020 - 0x0000)
struct KuroMaterialVariationComponent_SetMaterialTexture final
{
public:
	class FName                                   PropertyName;                                      // 0x0000(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UTexture*                               InValue;                                           // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaterialIndex;                                     // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroMaterialVariationComponent_SetMaterialTexture) == 0x000008, "Wrong alignment on KuroMaterialVariationComponent_SetMaterialTexture");
static_assert(sizeof(KuroMaterialVariationComponent_SetMaterialTexture) == 0x000020, "Wrong size on KuroMaterialVariationComponent_SetMaterialTexture");
static_assert(offsetof(KuroMaterialVariationComponent_SetMaterialTexture, PropertyName) == 0x000000, "Member 'KuroMaterialVariationComponent_SetMaterialTexture::PropertyName' has a wrong offset!");
static_assert(offsetof(KuroMaterialVariationComponent_SetMaterialTexture, InValue) == 0x000010, "Member 'KuroMaterialVariationComponent_SetMaterialTexture::InValue' has a wrong offset!");
static_assert(offsetof(KuroMaterialVariationComponent_SetMaterialTexture, MaterialIndex) == 0x000018, "Member 'KuroMaterialVariationComponent_SetMaterialTexture::MaterialIndex' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroMaterialVariationComponent.SetMaterialTextureAll
// 0x0018 (0x0018 - 0x0000)
struct KuroMaterialVariationComponent_SetMaterialTextureAll final
{
public:
	class FName                                   PropertyName;                                      // 0x0000(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UTexture*                               InValue;                                           // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroMaterialVariationComponent_SetMaterialTextureAll) == 0x000008, "Wrong alignment on KuroMaterialVariationComponent_SetMaterialTextureAll");
static_assert(sizeof(KuroMaterialVariationComponent_SetMaterialTextureAll) == 0x000018, "Wrong size on KuroMaterialVariationComponent_SetMaterialTextureAll");
static_assert(offsetof(KuroMaterialVariationComponent_SetMaterialTextureAll, PropertyName) == 0x000000, "Member 'KuroMaterialVariationComponent_SetMaterialTextureAll::PropertyName' has a wrong offset!");
static_assert(offsetof(KuroMaterialVariationComponent_SetMaterialTextureAll, InValue) == 0x000010, "Member 'KuroMaterialVariationComponent_SetMaterialTextureAll::InValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroNvClothPlacement.IsEnabled
// 0x0001 (0x0001 - 0x0000)
struct KuroNvClothPlacement_IsEnabled final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroNvClothPlacement_IsEnabled) == 0x000001, "Wrong alignment on KuroNvClothPlacement_IsEnabled");
static_assert(sizeof(KuroNvClothPlacement_IsEnabled) == 0x000001, "Wrong size on KuroNvClothPlacement_IsEnabled");
static_assert(offsetof(KuroNvClothPlacement_IsEnabled, ReturnValue) == 0x000000, "Member 'KuroNvClothPlacement_IsEnabled::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroNvClothPlacement.SetEnabled
// 0x0001 (0x0001 - 0x0000)
struct KuroNvClothPlacement_SetEnabled final
{
public:
	bool                                          Enable;                                            // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroNvClothPlacement_SetEnabled) == 0x000001, "Wrong alignment on KuroNvClothPlacement_SetEnabled");
static_assert(sizeof(KuroNvClothPlacement_SetEnabled) == 0x000001, "Wrong size on KuroNvClothPlacement_SetEnabled");
static_assert(offsetof(KuroNvClothPlacement_SetEnabled, Enable) == 0x000000, "Member 'KuroNvClothPlacement_SetEnabled::Enable' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.ThunderGenerator.SpawnThunderInWorld
// 0x0018 (0x0018 - 0x0000)
struct ThunderGenerator_SpawnThunderInWorld final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Location;                                          // 0x0008(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAttack;                                           // 0x0014(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(ThunderGenerator_SpawnThunderInWorld) == 0x000008, "Wrong alignment on ThunderGenerator_SpawnThunderInWorld");
static_assert(sizeof(ThunderGenerator_SpawnThunderInWorld) == 0x000018, "Wrong size on ThunderGenerator_SpawnThunderInWorld");
static_assert(offsetof(ThunderGenerator_SpawnThunderInWorld, WorldContextObject) == 0x000000, "Member 'ThunderGenerator_SpawnThunderInWorld::WorldContextObject' has a wrong offset!");
static_assert(offsetof(ThunderGenerator_SpawnThunderInWorld, Location) == 0x000008, "Member 'ThunderGenerator_SpawnThunderInWorld::Location' has a wrong offset!");
static_assert(offsetof(ThunderGenerator_SpawnThunderInWorld, bAttack) == 0x000014, "Member 'ThunderGenerator_SpawnThunderInWorld::bAttack' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.ThunderGenerator.CalculateThunderPosition
// 0x0040 (0x0040 - 0x0000)
struct ThunderGenerator_CalculateThunderPosition final
{
public:
	struct FTransform                             CameraTransform;                                   // 0x0000(0x0030)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                OutPosition;                                       // 0x0030(0x000C)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAttack;                                           // 0x003C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x003D(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3E[0x2];                                       // 0x003E(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(ThunderGenerator_CalculateThunderPosition) == 0x000010, "Wrong alignment on ThunderGenerator_CalculateThunderPosition");
static_assert(sizeof(ThunderGenerator_CalculateThunderPosition) == 0x000040, "Wrong size on ThunderGenerator_CalculateThunderPosition");
static_assert(offsetof(ThunderGenerator_CalculateThunderPosition, CameraTransform) == 0x000000, "Member 'ThunderGenerator_CalculateThunderPosition::CameraTransform' has a wrong offset!");
static_assert(offsetof(ThunderGenerator_CalculateThunderPosition, OutPosition) == 0x000030, "Member 'ThunderGenerator_CalculateThunderPosition::OutPosition' has a wrong offset!");
static_assert(offsetof(ThunderGenerator_CalculateThunderPosition, bAttack) == 0x00003C, "Member 'ThunderGenerator_CalculateThunderPosition::bAttack' has a wrong offset!");
static_assert(offsetof(ThunderGenerator_CalculateThunderPosition, ReturnValue) == 0x00003D, "Member 'ThunderGenerator_CalculateThunderPosition::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.ThunderGenerator.OnReceiveThunderAttack
// 0x0010 (0x0010 - 0x0000)
struct ThunderGenerator_OnReceiveThunderAttack final
{
public:
	struct FVector                                Location;                                          // 0x0000(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAttack;                                           // 0x000C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(ThunderGenerator_OnReceiveThunderAttack) == 0x000004, "Wrong alignment on ThunderGenerator_OnReceiveThunderAttack");
static_assert(sizeof(ThunderGenerator_OnReceiveThunderAttack) == 0x000010, "Wrong size on ThunderGenerator_OnReceiveThunderAttack");
static_assert(offsetof(ThunderGenerator_OnReceiveThunderAttack, Location) == 0x000000, "Member 'ThunderGenerator_OnReceiveThunderAttack::Location' has a wrong offset!");
static_assert(offsetof(ThunderGenerator_OnReceiveThunderAttack, bAttack) == 0x00000C, "Member 'ThunderGenerator_OnReceiveThunderAttack::bAttack' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.ThunderGenerator.OnReceiveThunderTrigger
// 0x0040 (0x0040 - 0x0000)
struct ThunderGenerator_OnReceiveThunderTrigger final
{
public:
	class AThunderTrigger*                        Trigger;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             CameraTransform;                                   // 0x0010(0x0030)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(ThunderGenerator_OnReceiveThunderTrigger) == 0x000010, "Wrong alignment on ThunderGenerator_OnReceiveThunderTrigger");
static_assert(sizeof(ThunderGenerator_OnReceiveThunderTrigger) == 0x000040, "Wrong size on ThunderGenerator_OnReceiveThunderTrigger");
static_assert(offsetof(ThunderGenerator_OnReceiveThunderTrigger, Trigger) == 0x000000, "Member 'ThunderGenerator_OnReceiveThunderTrigger::Trigger' has a wrong offset!");
static_assert(offsetof(ThunderGenerator_OnReceiveThunderTrigger, CameraTransform) == 0x000010, "Member 'ThunderGenerator_OnReceiveThunderTrigger::CameraTransform' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.ThunderGenerator.OnUpdateThunderEffect
// 0x0004 (0x0004 - 0x0000)
struct ThunderGenerator_OnUpdateThunderEffect final
{
public:
	float                                         DeltaSeconds;                                      // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ThunderGenerator_OnUpdateThunderEffect) == 0x000004, "Wrong alignment on ThunderGenerator_OnUpdateThunderEffect");
static_assert(sizeof(ThunderGenerator_OnUpdateThunderEffect) == 0x000004, "Wrong size on ThunderGenerator_OnUpdateThunderEffect");
static_assert(offsetof(ThunderGenerator_OnUpdateThunderEffect, DeltaSeconds) == 0x000000, "Member 'ThunderGenerator_OnUpdateThunderEffect::DeltaSeconds' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.ThunderGenerator.SpawnThunder
// 0x0010 (0x0010 - 0x0000)
struct ThunderGenerator_SpawnThunder final
{
public:
	struct FVector                                HitLocation;                                       // 0x0000(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAttack;                                           // 0x000C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(ThunderGenerator_SpawnThunder) == 0x000004, "Wrong alignment on ThunderGenerator_SpawnThunder");
static_assert(sizeof(ThunderGenerator_SpawnThunder) == 0x000010, "Wrong size on ThunderGenerator_SpawnThunder");
static_assert(offsetof(ThunderGenerator_SpawnThunder, HitLocation) == 0x000000, "Member 'ThunderGenerator_SpawnThunder::HitLocation' has a wrong offset!");
static_assert(offsetof(ThunderGenerator_SpawnThunder, bAttack) == 0x00000C, "Member 'ThunderGenerator_SpawnThunder::bAttack' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroPlayerPrefsSystem.DeleteKey
// 0x0010 (0x0010 - 0x0000)
struct KuroPlayerPrefsSystem_DeleteKey final
{
public:
	class FString                                 Key;                                               // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroPlayerPrefsSystem_DeleteKey) == 0x000008, "Wrong alignment on KuroPlayerPrefsSystem_DeleteKey");
static_assert(sizeof(KuroPlayerPrefsSystem_DeleteKey) == 0x000010, "Wrong size on KuroPlayerPrefsSystem_DeleteKey");
static_assert(offsetof(KuroPlayerPrefsSystem_DeleteKey, Key) == 0x000000, "Member 'KuroPlayerPrefsSystem_DeleteKey::Key' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroPlayerPrefsSystem.GetFloat
// 0x0018 (0x0018 - 0x0000)
struct KuroPlayerPrefsSystem_GetFloat final
{
public:
	class FString                                 Key;                                               // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DefaultValue;                                      // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0014(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroPlayerPrefsSystem_GetFloat) == 0x000008, "Wrong alignment on KuroPlayerPrefsSystem_GetFloat");
static_assert(sizeof(KuroPlayerPrefsSystem_GetFloat) == 0x000018, "Wrong size on KuroPlayerPrefsSystem_GetFloat");
static_assert(offsetof(KuroPlayerPrefsSystem_GetFloat, Key) == 0x000000, "Member 'KuroPlayerPrefsSystem_GetFloat::Key' has a wrong offset!");
static_assert(offsetof(KuroPlayerPrefsSystem_GetFloat, DefaultValue) == 0x000010, "Member 'KuroPlayerPrefsSystem_GetFloat::DefaultValue' has a wrong offset!");
static_assert(offsetof(KuroPlayerPrefsSystem_GetFloat, ReturnValue) == 0x000014, "Member 'KuroPlayerPrefsSystem_GetFloat::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroPlayerPrefsSystem.GetInt
// 0x0018 (0x0018 - 0x0000)
struct KuroPlayerPrefsSystem_GetInt final
{
public:
	class FString                                 Key;                                               // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DefaultValue;                                      // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0014(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroPlayerPrefsSystem_GetInt) == 0x000008, "Wrong alignment on KuroPlayerPrefsSystem_GetInt");
static_assert(sizeof(KuroPlayerPrefsSystem_GetInt) == 0x000018, "Wrong size on KuroPlayerPrefsSystem_GetInt");
static_assert(offsetof(KuroPlayerPrefsSystem_GetInt, Key) == 0x000000, "Member 'KuroPlayerPrefsSystem_GetInt::Key' has a wrong offset!");
static_assert(offsetof(KuroPlayerPrefsSystem_GetInt, DefaultValue) == 0x000010, "Member 'KuroPlayerPrefsSystem_GetInt::DefaultValue' has a wrong offset!");
static_assert(offsetof(KuroPlayerPrefsSystem_GetInt, ReturnValue) == 0x000014, "Member 'KuroPlayerPrefsSystem_GetInt::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroPlayerPrefsSystem.GetString
// 0x0030 (0x0030 - 0x0000)
struct KuroPlayerPrefsSystem_GetString final
{
public:
	class FString                                 Key;                                               // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 DefaultValue;                                      // 0x0010(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ReturnValue;                                       // 0x0020(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroPlayerPrefsSystem_GetString) == 0x000008, "Wrong alignment on KuroPlayerPrefsSystem_GetString");
static_assert(sizeof(KuroPlayerPrefsSystem_GetString) == 0x000030, "Wrong size on KuroPlayerPrefsSystem_GetString");
static_assert(offsetof(KuroPlayerPrefsSystem_GetString, Key) == 0x000000, "Member 'KuroPlayerPrefsSystem_GetString::Key' has a wrong offset!");
static_assert(offsetof(KuroPlayerPrefsSystem_GetString, DefaultValue) == 0x000010, "Member 'KuroPlayerPrefsSystem_GetString::DefaultValue' has a wrong offset!");
static_assert(offsetof(KuroPlayerPrefsSystem_GetString, ReturnValue) == 0x000020, "Member 'KuroPlayerPrefsSystem_GetString::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroPlayerPrefsSystem.HasKey
// 0x0018 (0x0018 - 0x0000)
struct KuroPlayerPrefsSystem_HasKey final
{
public:
	class FString                                 Key;                                               // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroPlayerPrefsSystem_HasKey) == 0x000008, "Wrong alignment on KuroPlayerPrefsSystem_HasKey");
static_assert(sizeof(KuroPlayerPrefsSystem_HasKey) == 0x000018, "Wrong size on KuroPlayerPrefsSystem_HasKey");
static_assert(offsetof(KuroPlayerPrefsSystem_HasKey, Key) == 0x000000, "Member 'KuroPlayerPrefsSystem_HasKey::Key' has a wrong offset!");
static_assert(offsetof(KuroPlayerPrefsSystem_HasKey, ReturnValue) == 0x000010, "Member 'KuroPlayerPrefsSystem_HasKey::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroPlayerPrefsSystem.SetFloat
// 0x0018 (0x0018 - 0x0000)
struct KuroPlayerPrefsSystem_SetFloat final
{
public:
	class FString                                 Key;                                               // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Value;                                             // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroPlayerPrefsSystem_SetFloat) == 0x000008, "Wrong alignment on KuroPlayerPrefsSystem_SetFloat");
static_assert(sizeof(KuroPlayerPrefsSystem_SetFloat) == 0x000018, "Wrong size on KuroPlayerPrefsSystem_SetFloat");
static_assert(offsetof(KuroPlayerPrefsSystem_SetFloat, Key) == 0x000000, "Member 'KuroPlayerPrefsSystem_SetFloat::Key' has a wrong offset!");
static_assert(offsetof(KuroPlayerPrefsSystem_SetFloat, Value) == 0x000010, "Member 'KuroPlayerPrefsSystem_SetFloat::Value' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroPlayerPrefsSystem.SetInt
// 0x0018 (0x0018 - 0x0000)
struct KuroPlayerPrefsSystem_SetInt final
{
public:
	class FString                                 Key;                                               // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Value;                                             // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroPlayerPrefsSystem_SetInt) == 0x000008, "Wrong alignment on KuroPlayerPrefsSystem_SetInt");
static_assert(sizeof(KuroPlayerPrefsSystem_SetInt) == 0x000018, "Wrong size on KuroPlayerPrefsSystem_SetInt");
static_assert(offsetof(KuroPlayerPrefsSystem_SetInt, Key) == 0x000000, "Member 'KuroPlayerPrefsSystem_SetInt::Key' has a wrong offset!");
static_assert(offsetof(KuroPlayerPrefsSystem_SetInt, Value) == 0x000010, "Member 'KuroPlayerPrefsSystem_SetInt::Value' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroPlayerPrefsSystem.SetString
// 0x0020 (0x0020 - 0x0000)
struct KuroPlayerPrefsSystem_SetString final
{
public:
	class FString                                 Key;                                               // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Value;                                             // 0x0010(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroPlayerPrefsSystem_SetString) == 0x000008, "Wrong alignment on KuroPlayerPrefsSystem_SetString");
static_assert(sizeof(KuroPlayerPrefsSystem_SetString) == 0x000020, "Wrong size on KuroPlayerPrefsSystem_SetString");
static_assert(offsetof(KuroPlayerPrefsSystem_SetString, Key) == 0x000000, "Member 'KuroPlayerPrefsSystem_SetString::Key' has a wrong offset!");
static_assert(offsetof(KuroPlayerPrefsSystem_SetString, Value) == 0x000010, "Member 'KuroPlayerPrefsSystem_SetString::Value' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroPostProcessComponent.SetPPTODDataAsset
// 0x0008 (0x0008 - 0x0000)
struct KuroPostProcessComponent_SetPPTODDataAsset final
{
public:
	class UKuroTODData*                           InPPTODDataAsset;                                  // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroPostProcessComponent_SetPPTODDataAsset) == 0x000008, "Wrong alignment on KuroPostProcessComponent_SetPPTODDataAsset");
static_assert(sizeof(KuroPostProcessComponent_SetPPTODDataAsset) == 0x000008, "Wrong size on KuroPostProcessComponent_SetPPTODDataAsset");
static_assert(offsetof(KuroPostProcessComponent_SetPPTODDataAsset, InPPTODDataAsset) == 0x000000, "Member 'KuroPostProcessComponent_SetPPTODDataAsset::InPPTODDataAsset' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroPostProcessComponent.SetReferencedVolumeActor
// 0x0008 (0x0008 - 0x0000)
struct KuroPostProcessComponent_SetReferencedVolumeActor final
{
public:
	class AVolume*                                InReferencedVolumeActor;                           // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroPostProcessComponent_SetReferencedVolumeActor) == 0x000008, "Wrong alignment on KuroPostProcessComponent_SetReferencedVolumeActor");
static_assert(sizeof(KuroPostProcessComponent_SetReferencedVolumeActor) == 0x000008, "Wrong size on KuroPostProcessComponent_SetReferencedVolumeActor");
static_assert(offsetof(KuroPostProcessComponent_SetReferencedVolumeActor, InReferencedVolumeActor) == 0x000000, "Member 'KuroPostProcessComponent_SetReferencedVolumeActor::InReferencedVolumeActor' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroPostProcessComponent.SetWeatherDataAsset
// 0x0008 (0x0008 - 0x0000)
struct KuroPostProcessComponent_SetWeatherDataAsset final
{
public:
	class UKuroWeatherDataAsset*                  InWeatherDataAsset;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroPostProcessComponent_SetWeatherDataAsset) == 0x000008, "Wrong alignment on KuroPostProcessComponent_SetWeatherDataAsset");
static_assert(sizeof(KuroPostProcessComponent_SetWeatherDataAsset) == 0x000008, "Wrong size on KuroPostProcessComponent_SetWeatherDataAsset");
static_assert(offsetof(KuroPostProcessComponent_SetWeatherDataAsset, InWeatherDataAsset) == 0x000000, "Member 'KuroPostProcessComponent_SetWeatherDataAsset::InWeatherDataAsset' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroPostProcessVolume.SetPPTODDataAsset
// 0x0008 (0x0008 - 0x0000)
struct KuroPostProcessVolume_SetPPTODDataAsset final
{
public:
	class UKuroTODData*                           InPPTODDataAsset;                                  // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroPostProcessVolume_SetPPTODDataAsset) == 0x000008, "Wrong alignment on KuroPostProcessVolume_SetPPTODDataAsset");
static_assert(sizeof(KuroPostProcessVolume_SetPPTODDataAsset) == 0x000008, "Wrong size on KuroPostProcessVolume_SetPPTODDataAsset");
static_assert(offsetof(KuroPostProcessVolume_SetPPTODDataAsset, InPPTODDataAsset) == 0x000000, "Member 'KuroPostProcessVolume_SetPPTODDataAsset::InPPTODDataAsset' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroPostProcessVolume.SetWeatherDataAsset
// 0x0008 (0x0008 - 0x0000)
struct KuroPostProcessVolume_SetWeatherDataAsset final
{
public:
	class UKuroWeatherDataAsset*                  InWeatherDataAsset;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroPostProcessVolume_SetWeatherDataAsset) == 0x000008, "Wrong alignment on KuroPostProcessVolume_SetWeatherDataAsset");
static_assert(sizeof(KuroPostProcessVolume_SetWeatherDataAsset) == 0x000008, "Wrong size on KuroPostProcessVolume_SetWeatherDataAsset");
static_assert(offsetof(KuroPostProcessVolume_SetWeatherDataAsset, InWeatherDataAsset) == 0x000000, "Member 'KuroPostProcessVolume_SetWeatherDataAsset::InWeatherDataAsset' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRainActor.GetDynamicMaterial
// 0x0008 (0x0008 - 0x0000)
struct KuroRainActor_GetDynamicMaterial final
{
public:
	class UMaterialInstanceDynamic*               ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRainActor_GetDynamicMaterial) == 0x000008, "Wrong alignment on KuroRainActor_GetDynamicMaterial");
static_assert(sizeof(KuroRainActor_GetDynamicMaterial) == 0x000008, "Wrong size on KuroRainActor_GetDynamicMaterial");
static_assert(offsetof(KuroRainActor_GetDynamicMaterial, ReturnValue) == 0x000000, "Member 'KuroRainActor_GetDynamicMaterial::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRainActor.GetIsInit
// 0x0001 (0x0001 - 0x0000)
struct KuroRainActor_GetIsInit final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRainActor_GetIsInit) == 0x000001, "Wrong alignment on KuroRainActor_GetIsInit");
static_assert(sizeof(KuroRainActor_GetIsInit) == 0x000001, "Wrong size on KuroRainActor_GetIsInit");
static_assert(offsetof(KuroRainActor_GetIsInit, ReturnValue) == 0x000000, "Member 'KuroRainActor_GetIsInit::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRainActor.SetCurrentRain
// 0x0014 (0x0014 - 0x0000)
struct KuroRainActor_SetCurrentRain final
{
public:
	float                                         InDensity;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InGravity;                                         // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InWindX;                                           // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InWindY;                                           // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InWindZ;                                           // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRainActor_SetCurrentRain) == 0x000004, "Wrong alignment on KuroRainActor_SetCurrentRain");
static_assert(sizeof(KuroRainActor_SetCurrentRain) == 0x000014, "Wrong size on KuroRainActor_SetCurrentRain");
static_assert(offsetof(KuroRainActor_SetCurrentRain, InDensity) == 0x000000, "Member 'KuroRainActor_SetCurrentRain::InDensity' has a wrong offset!");
static_assert(offsetof(KuroRainActor_SetCurrentRain, InGravity) == 0x000004, "Member 'KuroRainActor_SetCurrentRain::InGravity' has a wrong offset!");
static_assert(offsetof(KuroRainActor_SetCurrentRain, InWindX) == 0x000008, "Member 'KuroRainActor_SetCurrentRain::InWindX' has a wrong offset!");
static_assert(offsetof(KuroRainActor_SetCurrentRain, InWindY) == 0x00000C, "Member 'KuroRainActor_SetCurrentRain::InWindY' has a wrong offset!");
static_assert(offsetof(KuroRainActor_SetCurrentRain, InWindZ) == 0x000010, "Member 'KuroRainActor_SetCurrentRain::InWindZ' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRainActor.SetMaterialParameterOverrideColor
// 0x001C (0x001C - 0x0000)
struct KuroRainActor_SetMaterialParameterOverrideColor final
{
public:
	class FName                                   Name_0;                                            // 0x0000(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           Value;                                             // 0x000C(0x0010)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRainActor_SetMaterialParameterOverrideColor) == 0x000004, "Wrong alignment on KuroRainActor_SetMaterialParameterOverrideColor");
static_assert(sizeof(KuroRainActor_SetMaterialParameterOverrideColor) == 0x00001C, "Wrong size on KuroRainActor_SetMaterialParameterOverrideColor");
static_assert(offsetof(KuroRainActor_SetMaterialParameterOverrideColor, Name_0) == 0x000000, "Member 'KuroRainActor_SetMaterialParameterOverrideColor::Name_0' has a wrong offset!");
static_assert(offsetof(KuroRainActor_SetMaterialParameterOverrideColor, Value) == 0x00000C, "Member 'KuroRainActor_SetMaterialParameterOverrideColor::Value' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRainActor.SetMaterialParameterOverrideFloat
// 0x0010 (0x0010 - 0x0000)
struct KuroRainActor_SetMaterialParameterOverrideFloat final
{
public:
	class FName                                   Name_0;                                            // 0x0000(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Value;                                             // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRainActor_SetMaterialParameterOverrideFloat) == 0x000004, "Wrong alignment on KuroRainActor_SetMaterialParameterOverrideFloat");
static_assert(sizeof(KuroRainActor_SetMaterialParameterOverrideFloat) == 0x000010, "Wrong size on KuroRainActor_SetMaterialParameterOverrideFloat");
static_assert(offsetof(KuroRainActor_SetMaterialParameterOverrideFloat, Name_0) == 0x000000, "Member 'KuroRainActor_SetMaterialParameterOverrideFloat::Name_0' has a wrong offset!");
static_assert(offsetof(KuroRainActor_SetMaterialParameterOverrideFloat, Value) == 0x00000C, "Member 'KuroRainActor_SetMaterialParameterOverrideFloat::Value' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRainActor.Update
// 0x0004 (0x0004 - 0x0000)
struct KuroRainActor_Update final
{
public:
	float                                         DeltaSeconds;                                      // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRainActor_Update) == 0x000004, "Wrong alignment on KuroRainActor_Update");
static_assert(sizeof(KuroRainActor_Update) == 0x000004, "Wrong size on KuroRainActor_Update");
static_assert(offsetof(KuroRainActor_Update, DeltaSeconds) == 0x000000, "Member 'KuroRainActor_Update::DeltaSeconds' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRainActorV2.AddRainComponent
// 0x0010 (0x0010 - 0x0000)
struct KuroRainActorV2_AddRainComponent final
{
public:
	TSubclassOf<class UKuroRainComponent>         ClassType;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UKuroRainComponent*                     ReturnValue;                                       // 0x0008(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRainActorV2_AddRainComponent) == 0x000008, "Wrong alignment on KuroRainActorV2_AddRainComponent");
static_assert(sizeof(KuroRainActorV2_AddRainComponent) == 0x000010, "Wrong size on KuroRainActorV2_AddRainComponent");
static_assert(offsetof(KuroRainActorV2_AddRainComponent, ClassType) == 0x000000, "Member 'KuroRainActorV2_AddRainComponent::ClassType' has a wrong offset!");
static_assert(offsetof(KuroRainActorV2_AddRainComponent, ReturnValue) == 0x000008, "Member 'KuroRainActorV2_AddRainComponent::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRainActorV2.D_GetPlayerOrEditorCameraLocation
// 0x0018 (0x0018 - 0x0000)
struct KuroRainActorV2_D_GetPlayerOrEditorCameraLocation final
{
public:
	struct FVectorDouble                          OutLocation;                                       // 0x0000(0x0018)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRainActorV2_D_GetPlayerOrEditorCameraLocation) == 0x000008, "Wrong alignment on KuroRainActorV2_D_GetPlayerOrEditorCameraLocation");
static_assert(sizeof(KuroRainActorV2_D_GetPlayerOrEditorCameraLocation) == 0x000018, "Wrong size on KuroRainActorV2_D_GetPlayerOrEditorCameraLocation");
static_assert(offsetof(KuroRainActorV2_D_GetPlayerOrEditorCameraLocation, OutLocation) == 0x000000, "Member 'KuroRainActorV2_D_GetPlayerOrEditorCameraLocation::OutLocation' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRainActorV2.GetPlayerOrEditorCameraLocation
// 0x000C (0x000C - 0x0000)
struct KuroRainActorV2_GetPlayerOrEditorCameraLocation final
{
public:
	struct FVector                                OutLocation;                                       // 0x0000(0x000C)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRainActorV2_GetPlayerOrEditorCameraLocation) == 0x000004, "Wrong alignment on KuroRainActorV2_GetPlayerOrEditorCameraLocation");
static_assert(sizeof(KuroRainActorV2_GetPlayerOrEditorCameraLocation) == 0x00000C, "Wrong size on KuroRainActorV2_GetPlayerOrEditorCameraLocation");
static_assert(offsetof(KuroRainActorV2_GetPlayerOrEditorCameraLocation, OutLocation) == 0x000000, "Member 'KuroRainActorV2_GetPlayerOrEditorCameraLocation::OutLocation' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRainActorV2.RemoveRainComponent
// 0x0008 (0x0008 - 0x0000)
struct KuroRainActorV2_RemoveRainComponent final
{
public:
	class UKuroRainComponent*                     Comp;                                              // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRainActorV2_RemoveRainComponent) == 0x000008, "Wrong alignment on KuroRainActorV2_RemoveRainComponent");
static_assert(sizeof(KuroRainActorV2_RemoveRainComponent) == 0x000008, "Wrong size on KuroRainActorV2_RemoveRainComponent");
static_assert(offsetof(KuroRainActorV2_RemoveRainComponent, Comp) == 0x000000, "Member 'KuroRainActorV2_RemoveRainComponent::Comp' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRainActorV2.SetCameraFrustum
// 0x0008 (0x0008 - 0x0000)
struct KuroRainActorV2_SetCameraFrustum final
{
public:
	class UKuroRainComponent*                     Comp;                                              // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRainActorV2_SetCameraFrustum) == 0x000008, "Wrong alignment on KuroRainActorV2_SetCameraFrustum");
static_assert(sizeof(KuroRainActorV2_SetCameraFrustum) == 0x000008, "Wrong size on KuroRainActorV2_SetCameraFrustum");
static_assert(offsetof(KuroRainActorV2_SetCameraFrustum, Comp) == 0x000000, "Member 'KuroRainActorV2_SetCameraFrustum::Comp' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRainActorV2.UpdatePlayingRainComponent
// 0x0008 (0x0008 - 0x0000)
struct KuroRainActorV2_UpdatePlayingRainComponent final
{
public:
	class UKuroRainComponent*                     RainComponent;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRainActorV2_UpdatePlayingRainComponent) == 0x000008, "Wrong alignment on KuroRainActorV2_UpdatePlayingRainComponent");
static_assert(sizeof(KuroRainActorV2_UpdatePlayingRainComponent) == 0x000008, "Wrong size on KuroRainActorV2_UpdatePlayingRainComponent");
static_assert(offsetof(KuroRainActorV2_UpdatePlayingRainComponent, RainComponent) == 0x000000, "Member 'KuroRainActorV2_UpdatePlayingRainComponent::RainComponent' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.AddAdditionalClusteredStuff
// 0x0010 (0x0010 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_AddAdditionalClusteredStuff final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UClusteredStuffDataAsset*               Asset;                                             // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_AddAdditionalClusteredStuff) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_AddAdditionalClusteredStuff");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_AddAdditionalClusteredStuff) == 0x000010, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_AddAdditionalClusteredStuff");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_AddAdditionalClusteredStuff, WorldContextObject) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_AddAdditionalClusteredStuff::WorldContextObject' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_AddAdditionalClusteredStuff, Asset) == 0x000008, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_AddAdditionalClusteredStuff::Asset' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.AddKuroCellLayer
// 0x0010 (0x0010 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_AddKuroCellLayer final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EKuroCellLayerType                            ControlType;                                       // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_AddKuroCellLayer) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_AddKuroCellLayer");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_AddKuroCellLayer) == 0x000010, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_AddKuroCellLayer");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_AddKuroCellLayer, WorldContextObject) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_AddKuroCellLayer::WorldContextObject' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_AddKuroCellLayer, ControlType) == 0x000008, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_AddKuroCellLayer::ControlType' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.AddPostprocessMaterial
// 0x0020 (0x0020 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_AddPostprocessMaterial final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInterface*                     Material;                                          // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Priority;                                          // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsUiPostprocess;                                  // 0x0014(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ReturnValue;                                       // 0x0018(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_AddPostprocessMaterial) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_AddPostprocessMaterial");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_AddPostprocessMaterial) == 0x000020, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_AddPostprocessMaterial");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_AddPostprocessMaterial, WorldContextObject) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_AddPostprocessMaterial::WorldContextObject' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_AddPostprocessMaterial, Material) == 0x000008, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_AddPostprocessMaterial::Material' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_AddPostprocessMaterial, Priority) == 0x000010, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_AddPostprocessMaterial::Priority' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_AddPostprocessMaterial, bIsUiPostprocess) == 0x000014, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_AddPostprocessMaterial::bIsUiPostprocess' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_AddPostprocessMaterial, ReturnValue) == 0x000018, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_AddPostprocessMaterial::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.AddWeatherDataType
// 0x0028 (0x0028 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_AddWeatherDataType final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Identifier;                                        // 0x0008(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UClass*                                 ClassType;                                         // 0x0018(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0020(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_AddWeatherDataType) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_AddWeatherDataType");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_AddWeatherDataType) == 0x000028, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_AddWeatherDataType");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_AddWeatherDataType, WorldContextObject) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_AddWeatherDataType::WorldContextObject' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_AddWeatherDataType, Identifier) == 0x000008, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_AddWeatherDataType::Identifier' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_AddWeatherDataType, ClassType) == 0x000018, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_AddWeatherDataType::ClassType' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_AddWeatherDataType, ReturnValue) == 0x000020, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_AddWeatherDataType::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.AddWorldPartitionRequiredDataLayer
// 0x0018 (0x0018 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_AddWorldPartitionRequiredDataLayer final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FName>                           InDataLayerNames;                                  // 0x0008(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_AddWorldPartitionRequiredDataLayer) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_AddWorldPartitionRequiredDataLayer");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_AddWorldPartitionRequiredDataLayer) == 0x000018, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_AddWorldPartitionRequiredDataLayer");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_AddWorldPartitionRequiredDataLayer, WorldContextObject) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_AddWorldPartitionRequiredDataLayer::WorldContextObject' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_AddWorldPartitionRequiredDataLayer, InDataLayerNames) == 0x000008, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_AddWorldPartitionRequiredDataLayer::InDataLayerNames' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.CatmullRomPoints
// 0x0040 (0x0040 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_CatmullRomPoints final
{
public:
	struct FVector2D                              P0;                                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              P1;                                                // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              P2;                                                // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              P3;                                                // 0x0018(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FVector2D>                      CurveList;                                         // 0x0020(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         alpha;                                             // 0x0030(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         tension;                                           // 0x0034(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Step;                                              // 0x0038(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_CatmullRomPoints) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_CatmullRomPoints");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_CatmullRomPoints) == 0x000040, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_CatmullRomPoints");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_CatmullRomPoints, P0) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_CatmullRomPoints::P0' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_CatmullRomPoints, P1) == 0x000008, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_CatmullRomPoints::P1' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_CatmullRomPoints, P2) == 0x000010, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_CatmullRomPoints::P2' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_CatmullRomPoints, P3) == 0x000018, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_CatmullRomPoints::P3' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_CatmullRomPoints, CurveList) == 0x000020, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_CatmullRomPoints::CurveList' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_CatmullRomPoints, alpha) == 0x000030, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_CatmullRomPoints::alpha' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_CatmullRomPoints, tension) == 0x000034, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_CatmullRomPoints::tension' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_CatmullRomPoints, Step) == 0x000038, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_CatmullRomPoints::Step' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.CatmullRomPointsFromLists
// 0x0030 (0x0030 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_CatmullRomPointsFromLists final
{
public:
	TArray<struct FVectorDouble>                  PointList;                                         // 0x0000(0x0010)(Parm, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FVector2D>                      CurveList;                                         // 0x0010(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         alpha;                                             // 0x0020(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         tension;                                           // 0x0024(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Step;                                              // 0x0028(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_CatmullRomPointsFromLists) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_CatmullRomPointsFromLists");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_CatmullRomPointsFromLists) == 0x000030, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_CatmullRomPointsFromLists");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_CatmullRomPointsFromLists, PointList) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_CatmullRomPointsFromLists::PointList' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_CatmullRomPointsFromLists, CurveList) == 0x000010, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_CatmullRomPointsFromLists::CurveList' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_CatmullRomPointsFromLists, alpha) == 0x000020, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_CatmullRomPointsFromLists::alpha' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_CatmullRomPointsFromLists, tension) == 0x000024, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_CatmullRomPointsFromLists::tension' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_CatmullRomPointsFromLists, Step) == 0x000028, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_CatmullRomPointsFromLists::Step' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.ClearKuroCellLayer
// 0x0010 (0x0010 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_ClearKuroCellLayer final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EKuroCellLayerType                            ControlType;                                       // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_ClearKuroCellLayer) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_ClearKuroCellLayer");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_ClearKuroCellLayer) == 0x000010, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_ClearKuroCellLayer");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_ClearKuroCellLayer, WorldContextObject) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_ClearKuroCellLayer::WorldContextObject' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_ClearKuroCellLayer, ControlType) == 0x000008, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_ClearKuroCellLayer::ControlType' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.ClearObjectFlags
// 0x0010 (0x0010 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_ClearObjectFlags final
{
public:
	class UObject*                                Object;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         flags;                                             // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_ClearObjectFlags) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_ClearObjectFlags");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_ClearObjectFlags) == 0x000010, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_ClearObjectFlags");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_ClearObjectFlags, Object) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_ClearObjectFlags::Object' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_ClearObjectFlags, flags) == 0x000008, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_ClearObjectFlags::flags' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.ClearWorldPartitionRequiredDataLayers
// 0x0008 (0x0008 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_ClearWorldPartitionRequiredDataLayers final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_ClearWorldPartitionRequiredDataLayers) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_ClearWorldPartitionRequiredDataLayers");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_ClearWorldPartitionRequiredDataLayers) == 0x000008, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_ClearWorldPartitionRequiredDataLayers");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_ClearWorldPartitionRequiredDataLayers, WorldContextObject) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_ClearWorldPartitionRequiredDataLayers::WorldContextObject' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.ClipboardCopy_EditorOnly
// 0x0010 (0x0010 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_ClipboardCopy_EditorOnly final
{
public:
	class FString                                 Str;                                               // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_ClipboardCopy_EditorOnly) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_ClipboardCopy_EditorOnly");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_ClipboardCopy_EditorOnly) == 0x000010, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_ClipboardCopy_EditorOnly");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_ClipboardCopy_EditorOnly, Str) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_ClipboardCopy_EditorOnly::Str' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.ClipboardPaste_EditorOnly
// 0x0010 (0x0010 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_ClipboardPaste_EditorOnly final
{
public:
	class FString                                 Dest;                                              // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_ClipboardPaste_EditorOnly) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_ClipboardPaste_EditorOnly");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_ClipboardPaste_EditorOnly) == 0x000010, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_ClipboardPaste_EditorOnly");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_ClipboardPaste_EditorOnly, Dest) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_ClipboardPaste_EditorOnly::Dest' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.CopyKuroCharColorGroupArray
// 0x0040 (0x0040 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_CopyKuroCharColorGroupArray final
{
public:
	TArray<struct FKuroCharMaterialControllerColorGroup> Target;                                     // 0x0000(0x0010)(Parm, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FKuroCurveLinearColor>          Start;                                             // 0x0010(0x0010)(ConstParm, Parm, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FKuroCurveLinearColor>          Loop;                                              // 0x0020(0x0010)(ConstParm, Parm, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FKuroCurveLinearColor>          End;                                               // 0x0030(0x0010)(ConstParm, Parm, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_CopyKuroCharColorGroupArray) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_CopyKuroCharColorGroupArray");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_CopyKuroCharColorGroupArray) == 0x000040, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_CopyKuroCharColorGroupArray");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_CopyKuroCharColorGroupArray, Target) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_CopyKuroCharColorGroupArray::Target' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_CopyKuroCharColorGroupArray, Start) == 0x000010, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_CopyKuroCharColorGroupArray::Start' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_CopyKuroCharColorGroupArray, Loop) == 0x000020, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_CopyKuroCharColorGroupArray::Loop' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_CopyKuroCharColorGroupArray, End) == 0x000030, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_CopyKuroCharColorGroupArray::End' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.CopyKuroCharColorParameter
// 0x0460 (0x0460 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_CopyKuroCharColorParameter final
{
public:
	struct FKuroCharMaterialControllerColorParameter Target;                                         // 0x0000(0x0230)(Parm, OutParm, NativeAccessSpecifierPublic)
	class FName                                   ParameterName;                                     // 0x0230(0x000C)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_23C[0x4];                                      // 0x023C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FKuroCurveLinearColor                  ParameterValue;                                    // 0x0240(0x0220)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_CopyKuroCharColorParameter) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_CopyKuroCharColorParameter");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_CopyKuroCharColorParameter) == 0x000460, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_CopyKuroCharColorParameter");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_CopyKuroCharColorParameter, Target) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_CopyKuroCharColorParameter::Target' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_CopyKuroCharColorParameter, ParameterName) == 0x000230, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_CopyKuroCharColorParameter::ParameterName' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_CopyKuroCharColorParameter, ParameterValue) == 0x000240, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_CopyKuroCharColorParameter::ParameterValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.CopyKuroCharFloatGroup
// 0x0360 (0x0360 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_CopyKuroCharFloatGroup final
{
public:
	struct FKuroCharMaterialControllerFloatGroup  Target;                                            // 0x0000(0x01B0)(Parm, OutParm, NativeAccessSpecifierPublic)
	struct FKuroCurveFloat                        Start;                                             // 0x01B0(0x0090)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FKuroCurveFloat                        Loop;                                              // 0x0240(0x0090)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FKuroCurveFloat                        End;                                               // 0x02D0(0x0090)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_CopyKuroCharFloatGroup) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_CopyKuroCharFloatGroup");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_CopyKuroCharFloatGroup) == 0x000360, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_CopyKuroCharFloatGroup");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_CopyKuroCharFloatGroup, Target) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_CopyKuroCharFloatGroup::Target' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_CopyKuroCharFloatGroup, Start) == 0x0001B0, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_CopyKuroCharFloatGroup::Start' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_CopyKuroCharFloatGroup, Loop) == 0x000240, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_CopyKuroCharFloatGroup::Loop' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_CopyKuroCharFloatGroup, End) == 0x0002D0, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_CopyKuroCharFloatGroup::End' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.CopyKuroCharFloatGroupArray
// 0x0040 (0x0040 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_CopyKuroCharFloatGroupArray final
{
public:
	TArray<struct FKuroCharMaterialControllerFloatGroup> Target;                                     // 0x0000(0x0010)(Parm, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FKuroCurveFloat>                Start;                                             // 0x0010(0x0010)(ConstParm, Parm, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FKuroCurveFloat>                Loop;                                              // 0x0020(0x0010)(ConstParm, Parm, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FKuroCurveFloat>                End;                                               // 0x0030(0x0010)(ConstParm, Parm, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_CopyKuroCharFloatGroupArray) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_CopyKuroCharFloatGroupArray");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_CopyKuroCharFloatGroupArray) == 0x000040, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_CopyKuroCharFloatGroupArray");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_CopyKuroCharFloatGroupArray, Target) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_CopyKuroCharFloatGroupArray::Target' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_CopyKuroCharFloatGroupArray, Start) == 0x000010, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_CopyKuroCharFloatGroupArray::Start' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_CopyKuroCharFloatGroupArray, Loop) == 0x000020, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_CopyKuroCharFloatGroupArray::Loop' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_CopyKuroCharFloatGroupArray, End) == 0x000030, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_CopyKuroCharFloatGroupArray::End' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.CopyKuroCharFloatParameter
// 0x0140 (0x0140 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_CopyKuroCharFloatParameter final
{
public:
	struct FKuroCharMaterialControllerFloatParameter Target;                                         // 0x0000(0x00A0)(Parm, OutParm, NativeAccessSpecifierPublic)
	class FName                                   ParameterName;                                     // 0x00A0(0x000C)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_AC[0x4];                                       // 0x00AC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FKuroCurveFloat                        ParameterValue;                                    // 0x00B0(0x0090)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_CopyKuroCharFloatParameter) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_CopyKuroCharFloatParameter");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_CopyKuroCharFloatParameter) == 0x000140, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_CopyKuroCharFloatParameter");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_CopyKuroCharFloatParameter, Target) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_CopyKuroCharFloatParameter::Target' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_CopyKuroCharFloatParameter, ParameterName) == 0x0000A0, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_CopyKuroCharFloatParameter::ParameterName' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_CopyKuroCharFloatParameter, ParameterValue) == 0x0000B0, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_CopyKuroCharFloatParameter::ParameterValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.CopyKuroCharLinearColorGroup
// 0x0CC0 (0x0CC0 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_CopyKuroCharLinearColorGroup final
{
public:
	struct FKuroCharMaterialControllerColorGroup  Target;                                            // 0x0000(0x0660)(Parm, OutParm, NativeAccessSpecifierPublic)
	struct FKuroCurveLinearColor                  Start;                                             // 0x0660(0x0220)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FKuroCurveLinearColor                  Loop;                                              // 0x0880(0x0220)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FKuroCurveLinearColor                  End;                                               // 0x0AA0(0x0220)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_CopyKuroCharLinearColorGroup) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_CopyKuroCharLinearColorGroup");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_CopyKuroCharLinearColorGroup) == 0x000CC0, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_CopyKuroCharLinearColorGroup");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_CopyKuroCharLinearColorGroup, Target) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_CopyKuroCharLinearColorGroup::Target' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_CopyKuroCharLinearColorGroup, Start) == 0x000660, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_CopyKuroCharLinearColorGroup::Start' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_CopyKuroCharLinearColorGroup, Loop) == 0x000880, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_CopyKuroCharLinearColorGroup::Loop' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_CopyKuroCharLinearColorGroup, End) == 0x000AA0, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_CopyKuroCharLinearColorGroup::End' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.CreateGITransientActor
// 0x0030 (0x0030 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_CreateGITransientActor final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   IdName;                                            // 0x0008(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAttachToPlayer;                                   // 0x0014(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAttachToEditorCamera;                             // 0x0015(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_16[0x2];                                       // 0x0016(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   EditorFolderPath;                                  // 0x0018(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 ReturnValue;                                       // 0x0028(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_CreateGITransientActor) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_CreateGITransientActor");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_CreateGITransientActor) == 0x000030, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_CreateGITransientActor");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_CreateGITransientActor, WorldContextObject) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_CreateGITransientActor::WorldContextObject' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_CreateGITransientActor, IdName) == 0x000008, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_CreateGITransientActor::IdName' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_CreateGITransientActor, bAttachToPlayer) == 0x000014, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_CreateGITransientActor::bAttachToPlayer' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_CreateGITransientActor, bAttachToEditorCamera) == 0x000015, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_CreateGITransientActor::bAttachToEditorCamera' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_CreateGITransientActor, EditorFolderPath) == 0x000018, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_CreateGITransientActor::EditorFolderPath' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_CreateGITransientActor, ReturnValue) == 0x000028, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_CreateGITransientActor::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.D_SpawnActorFromClass
// 0x0080 (0x0080 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_D_SpawnActorFromClass final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AActor>                     ActorClass;                                        // 0x0008(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTransformDouble                       SpawnTransform;                                    // 0x0010(0x0040)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	ESpawnActorCollisionHandlingMethod            CollisionHandlingOverride;                         // 0x0050(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_51[0x7];                                       // 0x0051(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 Owner;                                             // 0x0058(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class APawn*                                  Instigator;                                        // 0x0060(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTemporaryEditorActor;                             // 0x0068(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_69[0x7];                                       // 0x0069(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 ReturnValue;                                       // 0x0070(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_78[0x8];                                       // 0x0078(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_D_SpawnActorFromClass) == 0x000010, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_D_SpawnActorFromClass");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_D_SpawnActorFromClass) == 0x000080, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_D_SpawnActorFromClass");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_D_SpawnActorFromClass, WorldContextObject) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_D_SpawnActorFromClass::WorldContextObject' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_D_SpawnActorFromClass, ActorClass) == 0x000008, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_D_SpawnActorFromClass::ActorClass' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_D_SpawnActorFromClass, SpawnTransform) == 0x000010, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_D_SpawnActorFromClass::SpawnTransform' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_D_SpawnActorFromClass, CollisionHandlingOverride) == 0x000050, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_D_SpawnActorFromClass::CollisionHandlingOverride' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_D_SpawnActorFromClass, Owner) == 0x000058, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_D_SpawnActorFromClass::Owner' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_D_SpawnActorFromClass, Instigator) == 0x000060, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_D_SpawnActorFromClass::Instigator' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_D_SpawnActorFromClass, bTemporaryEditorActor) == 0x000068, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_D_SpawnActorFromClass::bTemporaryEditorActor' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_D_SpawnActorFromClass, ReturnValue) == 0x000070, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_D_SpawnActorFromClass::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.DeleteAll
// 0x0008 (0x0008 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_DeleteAll final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_DeleteAll) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_DeleteAll");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_DeleteAll) == 0x000008, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_DeleteAll");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_DeleteAll, WorldContextObject) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_DeleteAll::WorldContextObject' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.DeleteKey
// 0x0018 (0x0018 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_DeleteKey final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Key;                                               // 0x0008(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_DeleteKey) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_DeleteKey");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_DeleteKey) == 0x000018, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_DeleteKey");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_DeleteKey, WorldContextObject) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_DeleteKey::WorldContextObject' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_DeleteKey, Key) == 0x000008, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_DeleteKey::Key' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.DestroyGITransientActor
// 0x0018 (0x0018 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_DestroyGITransientActor final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   IdName;                                            // 0x0008(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_DestroyGITransientActor) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_DestroyGITransientActor");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_DestroyGITransientActor) == 0x000018, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_DestroyGITransientActor");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_DestroyGITransientActor, WorldContextObject) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_DestroyGITransientActor::WorldContextObject' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_DestroyGITransientActor, IdName) == 0x000008, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_DestroyGITransientActor::IdName' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.FreezeWorldLevelStreaming
// 0x0008 (0x0008 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_FreezeWorldLevelStreaming final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_FreezeWorldLevelStreaming) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_FreezeWorldLevelStreaming");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_FreezeWorldLevelStreaming) == 0x000008, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_FreezeWorldLevelStreaming");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_FreezeWorldLevelStreaming, WorldContextObject) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_FreezeWorldLevelStreaming::WorldContextObject' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.GetActorForwardVectorRef
// 0x0018 (0x0018 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_GetActorForwardVectorRef final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                RefForwardVector;                                  // 0x0008(0x000C)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_GetActorForwardVectorRef) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_GetActorForwardVectorRef");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_GetActorForwardVectorRef) == 0x000018, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_GetActorForwardVectorRef");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetActorForwardVectorRef, Actor) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetActorForwardVectorRef::Actor' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetActorForwardVectorRef, RefForwardVector) == 0x000008, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetActorForwardVectorRef::RefForwardVector' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.GetActorForwardVectorRefXYZ
// 0x0018 (0x0018 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_GetActorForwardVectorRefXYZ final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         X;                                                 // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Y;                                                 // 0x000C(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Z;                                                 // 0x0010(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_GetActorForwardVectorRefXYZ) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_GetActorForwardVectorRefXYZ");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_GetActorForwardVectorRefXYZ) == 0x000018, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_GetActorForwardVectorRefXYZ");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetActorForwardVectorRefXYZ, Actor) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetActorForwardVectorRefXYZ::Actor' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetActorForwardVectorRefXYZ, X) == 0x000008, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetActorForwardVectorRefXYZ::X' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetActorForwardVectorRefXYZ, Y) == 0x00000C, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetActorForwardVectorRefXYZ::Y' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetActorForwardVectorRefXYZ, Z) == 0x000010, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetActorForwardVectorRefXYZ::Z' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.GetActorLocationRef
// 0x0018 (0x0018 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_GetActorLocationRef final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                RefLocation;                                       // 0x0008(0x000C)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_GetActorLocationRef) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_GetActorLocationRef");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_GetActorLocationRef) == 0x000018, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_GetActorLocationRef");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetActorLocationRef, Actor) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetActorLocationRef::Actor' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetActorLocationRef, RefLocation) == 0x000008, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetActorLocationRef::RefLocation' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.GetActorLocationRefXYZ
// 0x0018 (0x0018 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_GetActorLocationRefXYZ final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         X;                                                 // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Y;                                                 // 0x000C(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Z;                                                 // 0x0010(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_GetActorLocationRefXYZ) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_GetActorLocationRefXYZ");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_GetActorLocationRefXYZ) == 0x000018, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_GetActorLocationRefXYZ");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetActorLocationRefXYZ, Actor) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetActorLocationRefXYZ::Actor' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetActorLocationRefXYZ, X) == 0x000008, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetActorLocationRefXYZ::X' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetActorLocationRefXYZ, Y) == 0x00000C, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetActorLocationRefXYZ::Y' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetActorLocationRefXYZ, Z) == 0x000010, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetActorLocationRefXYZ::Z' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.GetActorOfClass
// 0x0018 (0x0018 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_GetActorOfClass final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AActor>                     ActorClass;                                        // 0x0008(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_GetActorOfClass) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_GetActorOfClass");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_GetActorOfClass) == 0x000018, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_GetActorOfClass");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetActorOfClass, WorldContextObject) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetActorOfClass::WorldContextObject' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetActorOfClass, ActorClass) == 0x000008, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetActorOfClass::ActorClass' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetActorOfClass, ReturnValue) == 0x000010, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetActorOfClass::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.GetActorsInLevel
// 0x0020 (0x0020 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_GetActorsInLevel final
{
public:
	const class ULevel*                           InLevel;                                           // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AActor>                     ActorClass;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class AActor*>                         OutActors;                                         // 0x0010(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_GetActorsInLevel) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_GetActorsInLevel");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_GetActorsInLevel) == 0x000020, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_GetActorsInLevel");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetActorsInLevel, InLevel) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetActorsInLevel::InLevel' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetActorsInLevel, ActorClass) == 0x000008, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetActorsInLevel::ActorClass' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetActorsInLevel, OutActors) == 0x000010, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetActorsInLevel::OutActors' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.GetAndAddCurveFloatSampleTask
// 0x00B0 (0x00B0 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_GetAndAddCurveFloatSampleTask final
{
public:
	int64                                         LastFrameHandle;                                   // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FKuroCurveFloat                        Curve;                                             // 0x0008(0x0090)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	float                                         Time;                                              // 0x0098(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Default;                                           // 0x009C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         OutHandle;                                         // 0x00A0(0x0008)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x00A8(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_AC[0x4];                                       // 0x00AC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_GetAndAddCurveFloatSampleTask) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_GetAndAddCurveFloatSampleTask");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_GetAndAddCurveFloatSampleTask) == 0x0000B0, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_GetAndAddCurveFloatSampleTask");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetAndAddCurveFloatSampleTask, LastFrameHandle) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetAndAddCurveFloatSampleTask::LastFrameHandle' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetAndAddCurveFloatSampleTask, Curve) == 0x000008, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetAndAddCurveFloatSampleTask::Curve' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetAndAddCurveFloatSampleTask, Time) == 0x000098, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetAndAddCurveFloatSampleTask::Time' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetAndAddCurveFloatSampleTask, Default) == 0x00009C, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetAndAddCurveFloatSampleTask::Default' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetAndAddCurveFloatSampleTask, OutHandle) == 0x0000A0, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetAndAddCurveFloatSampleTask::OutHandle' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetAndAddCurveFloatSampleTask, ReturnValue) == 0x0000A8, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetAndAddCurveFloatSampleTask::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.GetAndroidRawResolution
// 0x0008 (0x0008 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_GetAndroidRawResolution final
{
public:
	struct FVector2D                              ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_GetAndroidRawResolution) == 0x000004, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_GetAndroidRawResolution");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_GetAndroidRawResolution) == 0x000008, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_GetAndroidRawResolution");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetAndroidRawResolution, ReturnValue) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetAndroidRawResolution::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.GetAssetsByPath
// 0x0020 (0x0020 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_GetAssetsByPath final
{
public:
	class FName                                   PackagePath;                                       // 0x0000(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRecursive;                                        // 0x000C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIncludeOnlyOnDiskAssets;                          // 0x000D(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E[0x2];                                        // 0x000E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FAssetData>                     ReturnValue;                                       // 0x0010(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_GetAssetsByPath) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_GetAssetsByPath");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_GetAssetsByPath) == 0x000020, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_GetAssetsByPath");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetAssetsByPath, PackagePath) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetAssetsByPath::PackagePath' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetAssetsByPath, bRecursive) == 0x00000C, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetAssetsByPath::bRecursive' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetAssetsByPath, bIncludeOnlyOnDiskAssets) == 0x00000D, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetAssetsByPath::bIncludeOnlyOnDiskAssets' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetAssetsByPath, ReturnValue) == 0x000010, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetAssetsByPath::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.GetBatteryTemperature
// 0x0004 (0x0004 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_GetBatteryTemperature final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_GetBatteryTemperature) == 0x000004, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_GetBatteryTemperature");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_GetBatteryTemperature) == 0x000004, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_GetBatteryTemperature");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetBatteryTemperature, ReturnValue) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetBatteryTemperature::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.GetBoneDirection
// 0x0030 (0x0030 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_GetBoneDirection final
{
public:
	class USkeletalMeshComponent*                 SkeletalMeshComponent;                             // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BoneName;                                          // 0x0008(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0xC];                                       // 0x0014(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FQuat                                  ReturnValue;                                       // 0x0020(0x0010)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_GetBoneDirection) == 0x000010, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_GetBoneDirection");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_GetBoneDirection) == 0x000030, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_GetBoneDirection");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetBoneDirection, SkeletalMeshComponent) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetBoneDirection::SkeletalMeshComponent' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetBoneDirection, BoneName) == 0x000008, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetBoneDirection::BoneName' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetBoneDirection, ReturnValue) == 0x000020, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetBoneDirection::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.GetCacheCameraInfo
// 0x0910 (0x0910 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_GetCacheCameraInfo final
{
public:
	class APlayerCameraManager*                   Owner;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FMinimalViewInfo                       Inout;                                             // 0x0010(0x0900)(Parm, OutParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_GetCacheCameraInfo) == 0x000010, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_GetCacheCameraInfo");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_GetCacheCameraInfo) == 0x000910, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_GetCacheCameraInfo");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetCacheCameraInfo, Owner) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetCacheCameraInfo::Owner' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetCacheCameraInfo, Inout) == 0x000010, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetCacheCameraInfo::Inout' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.GetCaveOrRoomState
// 0x0038 (0x0038 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_GetCaveOrRoomState final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 EnClosetDataLayer;                                 // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 EnCloseSubDataLayer;                               // 0x0018(0x0010)(Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECaveOrRoomLoadType                           OutLoadType;                                       // 0x0028(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x3];                                       // 0x0029(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         OutLoadCoef;                                       // 0x002C(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0030(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_GetCaveOrRoomState) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_GetCaveOrRoomState");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_GetCaveOrRoomState) == 0x000038, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_GetCaveOrRoomState");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetCaveOrRoomState, WorldContextObject) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetCaveOrRoomState::WorldContextObject' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetCaveOrRoomState, EnClosetDataLayer) == 0x000008, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetCaveOrRoomState::EnClosetDataLayer' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetCaveOrRoomState, EnCloseSubDataLayer) == 0x000018, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetCaveOrRoomState::EnCloseSubDataLayer' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetCaveOrRoomState, OutLoadType) == 0x000028, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetCaveOrRoomState::OutLoadType' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetCaveOrRoomState, OutLoadCoef) == 0x00002C, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetCaveOrRoomState::OutLoadCoef' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetCaveOrRoomState, ReturnValue) == 0x000030, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetCaveOrRoomState::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.GetCharacterSectionCount
// 0x0010 (0x0010 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_GetCharacterSectionCount final
{
public:
	class USkeletalMesh*                          Mesh;                                              // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_GetCharacterSectionCount) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_GetCharacterSectionCount");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_GetCharacterSectionCount) == 0x000010, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_GetCharacterSectionCount");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetCharacterSectionCount, Mesh) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetCharacterSectionCount::Mesh' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetCharacterSectionCount, ReturnValue) == 0x000008, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetCharacterSectionCount::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.GetCharacterSectionInfo
// 0x0020 (0x0020 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_GetCharacterSectionInfo final
{
public:
	class USkeletalMesh*                          Mesh;                                              // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SectionIndex;                                      // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 ReturnValue;                                       // 0x0010(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_GetCharacterSectionInfo) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_GetCharacterSectionInfo");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_GetCharacterSectionInfo) == 0x000020, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_GetCharacterSectionInfo");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetCharacterSectionInfo, Mesh) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetCharacterSectionInfo::Mesh' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetCharacterSectionInfo, SectionIndex) == 0x000008, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetCharacterSectionInfo::SectionIndex' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetCharacterSectionInfo, ReturnValue) == 0x000010, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetCharacterSectionInfo::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.GetCharacterSectionMaterialIndex
// 0x0010 (0x0010 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_GetCharacterSectionMaterialIndex final
{
public:
	class USkeletalMesh*                          SkeletalMesh;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SectionIndex;                                      // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x000C(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_GetCharacterSectionMaterialIndex) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_GetCharacterSectionMaterialIndex");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_GetCharacterSectionMaterialIndex) == 0x000010, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_GetCharacterSectionMaterialIndex");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetCharacterSectionMaterialIndex, SkeletalMesh) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetCharacterSectionMaterialIndex::SkeletalMesh' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetCharacterSectionMaterialIndex, SectionIndex) == 0x000008, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetCharacterSectionMaterialIndex::SectionIndex' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetCharacterSectionMaterialIndex, ReturnValue) == 0x00000C, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetCharacterSectionMaterialIndex::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.GetColorFromGroup
// 0x0678 (0x0678 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_GetColorFromGroup final
{
public:
	struct FKuroCharMaterialControllerColorGroup  Target;                                            // 0x0000(0x0660)(Parm, OutParm, NativeAccessSpecifierPublic)
	float                                         Factor;                                            // 0x0660(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Type;                                              // 0x0664(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           ReturnValue;                                       // 0x0668(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_GetColorFromGroup) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_GetColorFromGroup");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_GetColorFromGroup) == 0x000678, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_GetColorFromGroup");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetColorFromGroup, Target) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetColorFromGroup::Target' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetColorFromGroup, Factor) == 0x000660, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetColorFromGroup::Factor' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetColorFromGroup, Type) == 0x000664, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetColorFromGroup::Type' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetColorFromGroup, ReturnValue) == 0x000668, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetColorFromGroup::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.GetComponentPhysicalMaterial
// 0x0010 (0x0010 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_GetComponentPhysicalMaterial final
{
public:
	class UPrimitiveComponent*                    Component;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPhysicalMaterial*                      ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_GetComponentPhysicalMaterial) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_GetComponentPhysicalMaterial");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_GetComponentPhysicalMaterial) == 0x000010, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_GetComponentPhysicalMaterial");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetComponentPhysicalMaterial, Component) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetComponentPhysicalMaterial::Component' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetComponentPhysicalMaterial, ReturnValue) == 0x000008, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetComponentPhysicalMaterial::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.GetCPUBrand
// 0x0010 (0x0010 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_GetCPUBrand final
{
public:
	class FString                                 ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_GetCPUBrand) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_GetCPUBrand");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_GetCPUBrand) == 0x000010, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_GetCPUBrand");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetCPUBrand, ReturnValue) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetCPUBrand::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.GetCPUCores
// 0x0004 (0x0004 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_GetCPUCores final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_GetCPUCores) == 0x000004, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_GetCPUCores");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_GetCPUCores) == 0x000004, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_GetCPUCores");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetCPUCores, ReturnValue) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetCPUCores::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.GetCPUCoresIncludingHyperthreads
// 0x0004 (0x0004 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_GetCPUCoresIncludingHyperthreads final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_GetCPUCoresIncludingHyperthreads) == 0x000004, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_GetCPUCoresIncludingHyperthreads");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_GetCPUCoresIncludingHyperthreads) == 0x000004, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_GetCPUCoresIncludingHyperthreads");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetCPUCoresIncludingHyperthreads, ReturnValue) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetCPUCoresIncludingHyperthreads::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.GetCpuFreq
// 0x0008 (0x0008 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_GetCpuFreq final
{
public:
	int32                                         core;                                              // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_GetCpuFreq) == 0x000004, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_GetCpuFreq");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_GetCpuFreq) == 0x000008, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_GetCpuFreq");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetCpuFreq, core) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetCpuFreq::core' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetCpuFreq, ReturnValue) == 0x000004, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetCpuFreq::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.GetCPUFrequency
// 0x0004 (0x0004 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_GetCPUFrequency final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_GetCPUFrequency) == 0x000004, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_GetCPUFrequency");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_GetCPUFrequency) == 0x000004, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_GetCPUFrequency");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetCPUFrequency, ReturnValue) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetCPUFrequency::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.GetCpuTemperature
// 0x0004 (0x0004 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_GetCpuTemperature final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_GetCpuTemperature) == 0x000004, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_GetCpuTemperature");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_GetCpuTemperature) == 0x000004, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_GetCpuTemperature");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetCpuTemperature, ReturnValue) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetCpuTemperature::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.GetCpuUsage
// 0x0004 (0x0004 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_GetCpuUsage final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_GetCpuUsage) == 0x000004, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_GetCpuUsage");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_GetCpuUsage) == 0x000004, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_GetCpuUsage");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetCpuUsage, ReturnValue) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetCpuUsage::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.GetCurrentNow
// 0x0004 (0x0004 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_GetCurrentNow final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_GetCurrentNow) == 0x000004, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_GetCurrentNow");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_GetCurrentNow) == 0x000004, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_GetCurrentNow");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetCurrentNow, ReturnValue) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetCurrentNow::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.GetCVarFloat
// 0x0018 (0x0018 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_GetCVarFloat final
{
public:
	class FString                                 CVarKey;                                           // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0010(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_GetCVarFloat) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_GetCVarFloat");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_GetCVarFloat) == 0x000018, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_GetCVarFloat");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetCVarFloat, CVarKey) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetCVarFloat::CVarKey' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetCVarFloat, ReturnValue) == 0x000010, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetCVarFloat::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.GetDeviceHardwareLevel
// 0x0004 (0x0004 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_GetDeviceHardwareLevel final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_GetDeviceHardwareLevel) == 0x000004, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_GetDeviceHardwareLevel");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_GetDeviceHardwareLevel) == 0x000004, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_GetDeviceHardwareLevel");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetDeviceHardwareLevel, ReturnValue) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetDeviceHardwareLevel::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.GetDeviceProfileBaseProfileName
// 0x0010 (0x0010 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_GetDeviceProfileBaseProfileName final
{
public:
	class FString                                 ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_GetDeviceProfileBaseProfileName) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_GetDeviceProfileBaseProfileName");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_GetDeviceProfileBaseProfileName) == 0x000010, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_GetDeviceProfileBaseProfileName");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetDeviceProfileBaseProfileName, ReturnValue) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetDeviceProfileBaseProfileName::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.GetDeviceProfileDeviceScore
// 0x0004 (0x0004 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_GetDeviceProfileDeviceScore final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_GetDeviceProfileDeviceScore) == 0x000004, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_GetDeviceProfileDeviceScore");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_GetDeviceProfileDeviceScore) == 0x000004, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_GetDeviceProfileDeviceScore");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetDeviceProfileDeviceScore, ReturnValue) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetDeviceProfileDeviceScore::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.GetDeviceProfileDeviceType
// 0x0010 (0x0010 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_GetDeviceProfileDeviceType final
{
public:
	class FString                                 ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_GetDeviceProfileDeviceType) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_GetDeviceProfileDeviceType");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_GetDeviceProfileDeviceType) == 0x000010, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_GetDeviceProfileDeviceType");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetDeviceProfileDeviceType, ReturnValue) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetDeviceProfileDeviceType::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.GetDeviceProfileProfileName
// 0x0010 (0x0010 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_GetDeviceProfileProfileName final
{
public:
	class FString                                 ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_GetDeviceProfileProfileName) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_GetDeviceProfileProfileName");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_GetDeviceProfileProfileName) == 0x000010, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_GetDeviceProfileProfileName");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetDeviceProfileProfileName, ReturnValue) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetDeviceProfileProfileName::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.GetDisableNPCOptAsRayTracing
// 0x0010 (0x0010 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_GetDisableNPCOptAsRayTracing final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_GetDisableNPCOptAsRayTracing) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_GetDisableNPCOptAsRayTracing");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_GetDisableNPCOptAsRayTracing) == 0x000010, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_GetDisableNPCOptAsRayTracing");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetDisableNPCOptAsRayTracing, WorldContextObject) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetDisableNPCOptAsRayTracing::WorldContextObject' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetDisableNPCOptAsRayTracing, ReturnValue) == 0x000008, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetDisableNPCOptAsRayTracing::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.GetDriverValid
// 0x0001 (0x0001 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_GetDriverValid final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_GetDriverValid) == 0x000001, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_GetDriverValid");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_GetDriverValid) == 0x000001, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_GetDriverValid");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetDriverValid, ReturnValue) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetDriverValid::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.GetFloat
// 0x0020 (0x0020 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_GetFloat final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Key;                                               // 0x0008(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DefaultValue;                                      // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x001C(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_GetFloat) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_GetFloat");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_GetFloat) == 0x000020, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_GetFloat");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetFloat, WorldContextObject) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetFloat::WorldContextObject' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetFloat, Key) == 0x000008, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetFloat::Key' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetFloat, DefaultValue) == 0x000018, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetFloat::DefaultValue' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetFloat, ReturnValue) == 0x00001C, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetFloat::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.GetFloatGromGroup
// 0x01C0 (0x01C0 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_GetFloatGromGroup final
{
public:
	struct FKuroCharMaterialControllerFloatGroup  Target;                                            // 0x0000(0x01B0)(Parm, OutParm, NativeAccessSpecifierPublic)
	float                                         Factor;                                            // 0x01B0(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Type;                                              // 0x01B4(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x01B8(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1BC[0x4];                                      // 0x01BC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_GetFloatGromGroup) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_GetFloatGromGroup");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_GetFloatGromGroup) == 0x0001C0, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_GetFloatGromGroup");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetFloatGromGroup, Target) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetFloatGromGroup::Target' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetFloatGromGroup, Factor) == 0x0001B0, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetFloatGromGroup::Factor' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetFloatGromGroup, Type) == 0x0001B4, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetFloatGromGroup::Type' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetFloatGromGroup, ReturnValue) == 0x0001B8, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetFloatGromGroup::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.GetGameResolution
// 0x0008 (0x0008 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_GetGameResolution final
{
public:
	struct FVector2D                              ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_GetGameResolution) == 0x000004, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_GetGameResolution");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_GetGameResolution) == 0x000008, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_GetGameResolution");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetGameResolution, ReturnValue) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetGameResolution::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.GetGameThreadTime
// 0x0004 (0x0004 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_GetGameThreadTime final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_GetGameThreadTime) == 0x000004, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_GetGameThreadTime");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_GetGameThreadTime) == 0x000004, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_GetGameThreadTime");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetGameThreadTime, ReturnValue) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetGameThreadTime::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.GetGameViewportSize
// 0x0008 (0x0008 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_GetGameViewportSize final
{
public:
	struct FVector2D                              ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_GetGameViewportSize) == 0x000004, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_GetGameViewportSize");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_GetGameViewportSize) == 0x000008, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_GetGameViewportSize");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetGameViewportSize, ReturnValue) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetGameViewportSize::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.GetGITransientActor
// 0x0020 (0x0020 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_GetGITransientActor final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   IdName;                                            // 0x0008(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 ReturnValue;                                       // 0x0018(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_GetGITransientActor) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_GetGITransientActor");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_GetGITransientActor) == 0x000020, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_GetGITransientActor");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetGITransientActor, WorldContextObject) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetGITransientActor::WorldContextObject' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetGITransientActor, IdName) == 0x000008, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetGITransientActor::IdName' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetGITransientActor, ReturnValue) == 0x000018, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetGITransientActor::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.GetGlobalFootstepMaterial
// 0x0010 (0x0010 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_GetGlobalFootstepMaterial final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPhysicalMaterial*                      ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_GetGlobalFootstepMaterial) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_GetGlobalFootstepMaterial");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_GetGlobalFootstepMaterial) == 0x000010, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_GetGlobalFootstepMaterial");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetGlobalFootstepMaterial, WorldContextObject) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetGlobalFootstepMaterial::WorldContextObject' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetGlobalFootstepMaterial, ReturnValue) == 0x000008, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetGlobalFootstepMaterial::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.GetGlobalGIActor
// 0x0010 (0x0010 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_GetGlobalGIActor final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_GetGlobalGIActor) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_GetGlobalGIActor");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_GetGlobalGIActor) == 0x000010, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_GetGlobalGIActor");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetGlobalGIActor, WorldContextObject) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetGlobalGIActor::WorldContextObject' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetGlobalGIActor, ReturnValue) == 0x000008, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetGlobalGIActor::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.GetInt
// 0x0020 (0x0020 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_GetInt final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Key;                                               // 0x0008(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DefaultValue;                                      // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x001C(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_GetInt) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_GetInt");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_GetInt) == 0x000020, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_GetInt");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetInt, WorldContextObject) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetInt::WorldContextObject' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetInt, Key) == 0x000008, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetInt::Key' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetInt, DefaultValue) == 0x000018, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetInt::DefaultValue' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetInt, ReturnValue) == 0x00001C, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetInt::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.GetKuroLandscapeParametersDataAsset
// 0x0008 (0x0008 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_GetKuroLandscapeParametersDataAsset final
{
public:
	class UKuroLandscapeParametersData*           ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_GetKuroLandscapeParametersDataAsset) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_GetKuroLandscapeParametersDataAsset");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_GetKuroLandscapeParametersDataAsset) == 0x000008, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_GetKuroLandscapeParametersDataAsset");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetKuroLandscapeParametersDataAsset, ReturnValue) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetKuroLandscapeParametersDataAsset::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.GetLevel
// 0x0010 (0x0010 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_GetLevel final
{
public:
	const class UWorld*                           World;                                             // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ULevel*                                 ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_GetLevel) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_GetLevel");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_GetLevel) == 0x000010, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_GetLevel");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetLevel, World) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetLevel::World' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetLevel, ReturnValue) == 0x000008, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetLevel::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.GetLevelActors
// 0x0018 (0x0018 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_GetLevelActors final
{
public:
	class ULevel*                                 InLevel;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class AActor*>                         ReturnValue;                                       // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_GetLevelActors) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_GetLevelActors");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_GetLevelActors) == 0x000018, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_GetLevelActors");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetLevelActors, InLevel) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetLevelActors::InLevel' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetLevelActors, ReturnValue) == 0x000008, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetLevelActors::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.GetLevelEditorCameraLocationAndForward
// 0x0028 (0x0028 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_GetLevelEditorCameraLocationAndForward final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Position;                                          // 0x0008(0x000C)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               Rotation;                                          // 0x0014(0x000C)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0020(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_GetLevelEditorCameraLocationAndForward) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_GetLevelEditorCameraLocationAndForward");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_GetLevelEditorCameraLocationAndForward) == 0x000028, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_GetLevelEditorCameraLocationAndForward");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetLevelEditorCameraLocationAndForward, WorldContextObject) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetLevelEditorCameraLocationAndForward::WorldContextObject' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetLevelEditorCameraLocationAndForward, Position) == 0x000008, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetLevelEditorCameraLocationAndForward::Position' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetLevelEditorCameraLocationAndForward, Rotation) == 0x000014, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetLevelEditorCameraLocationAndForward::Rotation' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetLevelEditorCameraLocationAndForward, ReturnValue) == 0x000020, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetLevelEditorCameraLocationAndForward::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.GetLevelEditorViewPortSize
// 0x0018 (0x0018 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_GetLevelEditorViewPortSize final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              viewPortSize;                                      // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_GetLevelEditorViewPortSize) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_GetLevelEditorViewPortSize");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_GetLevelEditorViewPortSize) == 0x000018, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_GetLevelEditorViewPortSize");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetLevelEditorViewPortSize, WorldContextObject) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetLevelEditorViewPortSize::WorldContextObject' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetLevelEditorViewPortSize, viewPortSize) == 0x000008, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetLevelEditorViewPortSize::viewPortSize' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetLevelEditorViewPortSize, ReturnValue) == 0x000010, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetLevelEditorViewPortSize::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.GetLumenDiffuseGIFeatureEnabled
// 0x0010 (0x0010 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_GetLumenDiffuseGIFeatureEnabled final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_GetLumenDiffuseGIFeatureEnabled) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_GetLumenDiffuseGIFeatureEnabled");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_GetLumenDiffuseGIFeatureEnabled) == 0x000010, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_GetLumenDiffuseGIFeatureEnabled");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetLumenDiffuseGIFeatureEnabled, WorldContextObject) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetLumenDiffuseGIFeatureEnabled::WorldContextObject' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetLumenDiffuseGIFeatureEnabled, ReturnValue) == 0x000008, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetLumenDiffuseGIFeatureEnabled::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.GetLumenGIEnable
// 0x0001 (0x0001 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_GetLumenGIEnable final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_GetLumenGIEnable) == 0x000001, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_GetLumenGIEnable");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_GetLumenGIEnable) == 0x000001, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_GetLumenGIEnable");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetLumenGIEnable, ReturnValue) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetLumenGIEnable::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.GetLumenGISupported
// 0x0001 (0x0001 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_GetLumenGISupported final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_GetLumenGISupported) == 0x000001, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_GetLumenGISupported");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_GetLumenGISupported) == 0x000001, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_GetLumenGISupported");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetLumenGISupported, ReturnValue) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetLumenGISupported::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.GetLumenReflectionsEnable
// 0x0001 (0x0001 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_GetLumenReflectionsEnable final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_GetLumenReflectionsEnable) == 0x000001, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_GetLumenReflectionsEnable");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_GetLumenReflectionsEnable) == 0x000001, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_GetLumenReflectionsEnable");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetLumenReflectionsEnable, ReturnValue) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetLumenReflectionsEnable::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.GetLumenReflectionsSupported
// 0x0001 (0x0001 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_GetLumenReflectionsSupported final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_GetLumenReflectionsSupported) == 0x000001, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_GetLumenReflectionsSupported");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_GetLumenReflectionsSupported) == 0x000001, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_GetLumenReflectionsSupported");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetLumenReflectionsSupported, ReturnValue) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetLumenReflectionsSupported::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.GetMaxFps
// 0x0004 (0x0004 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_GetMaxFps final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_GetMaxFps) == 0x000004, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_GetMaxFps");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_GetMaxFps) == 0x000004, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_GetMaxFps");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetMaxFps, ReturnValue) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetMaxFps::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.GetMobileDeviceModel
// 0x0010 (0x0010 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_GetMobileDeviceModel final
{
public:
	class FString                                 ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_GetMobileDeviceModel) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_GetMobileDeviceModel");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_GetMobileDeviceModel) == 0x000010, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_GetMobileDeviceModel");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetMobileDeviceModel, ReturnValue) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetMobileDeviceModel::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.GetNiagaraParticleCount
// 0x0010 (0x0010 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_GetNiagaraParticleCount final
{
public:
	class UNiagaraComponent*                      NiagaraComponent;                                  // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ActiveEmitters;                                    // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ActiveParticles;                                   // 0x000C(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_GetNiagaraParticleCount) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_GetNiagaraParticleCount");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_GetNiagaraParticleCount) == 0x000010, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_GetNiagaraParticleCount");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetNiagaraParticleCount, NiagaraComponent) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetNiagaraParticleCount::NiagaraComponent' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetNiagaraParticleCount, ActiveEmitters) == 0x000008, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetNiagaraParticleCount::ActiveEmitters' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetNiagaraParticleCount, ActiveParticles) == 0x00000C, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetNiagaraParticleCount::ActiveParticles' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.GetObjectMaskedFlags
// 0x0010 (0x0010 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_GetObjectMaskedFlags final
{
public:
	class UObject*                                Object;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Mask;                                              // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x000C(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_GetObjectMaskedFlags) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_GetObjectMaskedFlags");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_GetObjectMaskedFlags) == 0x000010, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_GetObjectMaskedFlags");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetObjectMaskedFlags, Object) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetObjectMaskedFlags::Object' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetObjectMaskedFlags, Mask) == 0x000008, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetObjectMaskedFlags::Mask' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetObjectMaskedFlags, ReturnValue) == 0x00000C, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetObjectMaskedFlags::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.GetOverlappingBoxCountForAllFoliageActors
// 0x0038 (0x0038 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_GetOverlappingBoxCountForAllFoliageActors final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	const class UFoliageType*                     FoliageType;                                       // 0x0008(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBox                                   Box;                                               // 0x0010(0x001C)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	int32                                         Max;                                               // 0x002C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0030(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_GetOverlappingBoxCountForAllFoliageActors) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_GetOverlappingBoxCountForAllFoliageActors");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_GetOverlappingBoxCountForAllFoliageActors) == 0x000038, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_GetOverlappingBoxCountForAllFoliageActors");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetOverlappingBoxCountForAllFoliageActors, WorldContextObject) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetOverlappingBoxCountForAllFoliageActors::WorldContextObject' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetOverlappingBoxCountForAllFoliageActors, FoliageType) == 0x000008, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetOverlappingBoxCountForAllFoliageActors::FoliageType' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetOverlappingBoxCountForAllFoliageActors, Box) == 0x000010, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetOverlappingBoxCountForAllFoliageActors::Box' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetOverlappingBoxCountForAllFoliageActors, Max) == 0x00002C, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetOverlappingBoxCountForAllFoliageActors::Max' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetOverlappingBoxCountForAllFoliageActors, ReturnValue) == 0x000030, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetOverlappingBoxCountForAllFoliageActors::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.GetPcLightCullParameters
// 0x0018 (0x0018 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_GetPcLightCullParameters final
{
public:
	class ULightComponent*                        LightComponent;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LightMinDistance;                                  // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LightMaxDistance;                                  // 0x000C(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LightMinFade;                                      // 0x0010(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LightMaxFade;                                      // 0x0014(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_GetPcLightCullParameters) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_GetPcLightCullParameters");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_GetPcLightCullParameters) == 0x000018, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_GetPcLightCullParameters");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetPcLightCullParameters, LightComponent) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetPcLightCullParameters::LightComponent' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetPcLightCullParameters, LightMinDistance) == 0x000008, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetPcLightCullParameters::LightMinDistance' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetPcLightCullParameters, LightMaxDistance) == 0x00000C, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetPcLightCullParameters::LightMaxDistance' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetPcLightCullParameters, LightMinFade) == 0x000010, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetPcLightCullParameters::LightMinFade' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetPcLightCullParameters, LightMaxFade) == 0x000014, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetPcLightCullParameters::LightMaxFade' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.GetPhysicalGBRam
// 0x0004 (0x0004 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_GetPhysicalGBRam final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_GetPhysicalGBRam) == 0x000004, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_GetPhysicalGBRam");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_GetPhysicalGBRam) == 0x000004, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_GetPhysicalGBRam");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetPhysicalGBRam, ReturnValue) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetPhysicalGBRam::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.GetPostProcessGIDataDebugInfo
// 0x0040 (0x0040 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_GetPostProcessGIDataDebugInfo final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                WorldPosition;                                     // 0x0008(0x000C)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FPostprocessGIDebugInfo>        OutDAResult;                                       // 0x0018(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FPostprocessGIDebugInfo>        OutOverrideResult;                                 // 0x0028(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0038(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_GetPostProcessGIDataDebugInfo) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_GetPostProcessGIDataDebugInfo");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_GetPostProcessGIDataDebugInfo) == 0x000040, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_GetPostProcessGIDataDebugInfo");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetPostProcessGIDataDebugInfo, WorldContextObject) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetPostProcessGIDataDebugInfo::WorldContextObject' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetPostProcessGIDataDebugInfo, WorldPosition) == 0x000008, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetPostProcessGIDataDebugInfo::WorldPosition' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetPostProcessGIDataDebugInfo, OutDAResult) == 0x000018, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetPostProcessGIDataDebugInfo::OutDAResult' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetPostProcessGIDataDebugInfo, OutOverrideResult) == 0x000028, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetPostProcessGIDataDebugInfo::OutOverrideResult' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetPostProcessGIDataDebugInfo, ReturnValue) == 0x000038, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetPostProcessGIDataDebugInfo::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.GetPostProcessGIDataDebugNames
// 0x0020 (0x0020 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_GetPostProcessGIDataDebugNames final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FName>                           OutDANames;                                        // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0018(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_GetPostProcessGIDataDebugNames) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_GetPostProcessGIDataDebugNames");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_GetPostProcessGIDataDebugNames) == 0x000020, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_GetPostProcessGIDataDebugNames");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetPostProcessGIDataDebugNames, WorldContextObject) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetPostProcessGIDataDebugNames::WorldContextObject' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetPostProcessGIDataDebugNames, OutDANames) == 0x000008, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetPostProcessGIDataDebugNames::OutDANames' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetPostProcessGIDataDebugNames, ReturnValue) == 0x000018, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetPostProcessGIDataDebugNames::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.GetPostProcessGIDataNames
// 0x0030 (0x0030 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_GetPostProcessGIDataNames final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                WorldPosition;                                     // 0x0008(0x000C)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FString>                         OutDANames;                                        // 0x0018(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0028(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_GetPostProcessGIDataNames) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_GetPostProcessGIDataNames");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_GetPostProcessGIDataNames) == 0x000030, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_GetPostProcessGIDataNames");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetPostProcessGIDataNames, WorldContextObject) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetPostProcessGIDataNames::WorldContextObject' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetPostProcessGIDataNames, WorldPosition) == 0x000008, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetPostProcessGIDataNames::WorldPosition' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetPostProcessGIDataNames, OutDANames) == 0x000018, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetPostProcessGIDataNames::OutDANames' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetPostProcessGIDataNames, ReturnValue) == 0x000028, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetPostProcessGIDataNames::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.GetRayTracingEnable
// 0x0001 (0x0001 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_GetRayTracingEnable final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_GetRayTracingEnable) == 0x000001, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_GetRayTracingEnable");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_GetRayTracingEnable) == 0x000001, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_GetRayTracingEnable");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetRayTracingEnable, ReturnValue) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetRayTracingEnable::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.GetRayTracingReflectionsEnable
// 0x0001 (0x0001 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_GetRayTracingReflectionsEnable final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_GetRayTracingReflectionsEnable) == 0x000001, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_GetRayTracingReflectionsEnable");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_GetRayTracingReflectionsEnable) == 0x000001, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_GetRayTracingReflectionsEnable");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetRayTracingReflectionsEnable, ReturnValue) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetRayTracingReflectionsEnable::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.GetRayTracingReflectionsSupported
// 0x0001 (0x0001 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_GetRayTracingReflectionsSupported final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_GetRayTracingReflectionsSupported) == 0x000001, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_GetRayTracingReflectionsSupported");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_GetRayTracingReflectionsSupported) == 0x000001, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_GetRayTracingReflectionsSupported");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetRayTracingReflectionsSupported, ReturnValue) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetRayTracingReflectionsSupported::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.GetRayTracingShadowsEnable
// 0x0001 (0x0001 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_GetRayTracingShadowsEnable final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_GetRayTracingShadowsEnable) == 0x000001, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_GetRayTracingShadowsEnable");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_GetRayTracingShadowsEnable) == 0x000001, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_GetRayTracingShadowsEnable");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetRayTracingShadowsEnable, ReturnValue) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetRayTracingShadowsEnable::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.GetRayTracingShadowsSupported
// 0x0001 (0x0001 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_GetRayTracingShadowsSupported final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_GetRayTracingShadowsSupported) == 0x000001, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_GetRayTracingShadowsSupported");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_GetRayTracingShadowsSupported) == 0x000001, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_GetRayTracingShadowsSupported");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetRayTracingShadowsSupported, ReturnValue) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetRayTracingShadowsSupported::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.GetRayTracingSupported
// 0x0001 (0x0001 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_GetRayTracingSupported final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_GetRayTracingSupported) == 0x000001, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_GetRayTracingSupported");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_GetRayTracingSupported) == 0x000001, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_GetRayTracingSupported");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetRayTracingSupported, ReturnValue) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetRayTracingSupported::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.GetRayTracingSupportedType
// 0x0001 (0x0001 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_GetRayTracingSupportedType final
{
public:
	EURayTracingSupport                           ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_GetRayTracingSupportedType) == 0x000001, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_GetRayTracingSupportedType");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_GetRayTracingSupportedType) == 0x000001, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_GetRayTracingSupportedType");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetRayTracingSupportedType, ReturnValue) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetRayTracingSupportedType::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.GetRenderThreadTime
// 0x0004 (0x0004 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_GetRenderThreadTime final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_GetRenderThreadTime) == 0x000004, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_GetRenderThreadTime");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_GetRenderThreadTime) == 0x000004, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_GetRenderThreadTime");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetRenderThreadTime, ReturnValue) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetRenderThreadTime::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.GetRHIDeviceName
// 0x0010 (0x0010 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_GetRHIDeviceName final
{
public:
	class FString                                 ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_GetRHIDeviceName) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_GetRHIDeviceName");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_GetRHIDeviceName) == 0x000010, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_GetRHIDeviceName");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetRHIDeviceName, ReturnValue) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetRHIDeviceName::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.GetRHIDriverDate
// 0x0010 (0x0010 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_GetRHIDriverDate final
{
public:
	class FString                                 ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_GetRHIDriverDate) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_GetRHIDriverDate");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_GetRHIDriverDate) == 0x000010, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_GetRHIDriverDate");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetRHIDriverDate, ReturnValue) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetRHIDriverDate::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.GetRHIDriverVersion
// 0x0010 (0x0010 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_GetRHIDriverVersion final
{
public:
	class FString                                 ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_GetRHIDriverVersion) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_GetRHIDriverVersion");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_GetRHIDriverVersion) == 0x000010, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_GetRHIDriverVersion");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetRHIDriverVersion, ReturnValue) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetRHIDriverVersion::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.GetRHIName
// 0x0010 (0x0010 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_GetRHIName final
{
public:
	class FString                                 ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_GetRHIName) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_GetRHIName");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_GetRHIName) == 0x000010, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_GetRHIName");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetRHIName, ReturnValue) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetRHIName::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.GetRHIThreadTime
// 0x0004 (0x0004 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_GetRHIThreadTime final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_GetRHIThreadTime) == 0x000004, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_GetRHIThreadTime");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_GetRHIThreadTime) == 0x000004, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_GetRHIThreadTime");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetRHIThreadTime, ReturnValue) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetRHIThreadTime::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.GetRHIVendorName
// 0x0010 (0x0010 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_GetRHIVendorName final
{
public:
	class FString                                 ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_GetRHIVendorName) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_GetRHIVendorName");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_GetRHIVendorName) == 0x000010, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_GetRHIVendorName");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetRHIVendorName, ReturnValue) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetRHIVendorName::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.GetSceneColorShotBeforeTonemap
// 0x0001 (0x0001 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_GetSceneColorShotBeforeTonemap final
{
public:
	bool                                          bRelease;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_GetSceneColorShotBeforeTonemap) == 0x000001, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_GetSceneColorShotBeforeTonemap");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_GetSceneColorShotBeforeTonemap) == 0x000001, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_GetSceneColorShotBeforeTonemap");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetSceneColorShotBeforeTonemap, bRelease) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetSceneColorShotBeforeTonemap::bRelease' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.GetSceneInteractionLevelActor
// 0x0010 (0x0010 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_GetSceneInteractionLevelActor final
{
public:
	class ULevel*                                 InLevel;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_GetSceneInteractionLevelActor) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_GetSceneInteractionLevelActor");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_GetSceneInteractionLevelActor) == 0x000010, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_GetSceneInteractionLevelActor");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetSceneInteractionLevelActor, InLevel) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetSceneInteractionLevelActor::InLevel' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetSceneInteractionLevelActor, ReturnValue) == 0x000008, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetSceneInteractionLevelActor::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.GetSkeletalMaterialCount
// 0x0010 (0x0010 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_GetSkeletalMaterialCount final
{
public:
	class USkeletalMesh*                          Skel;                                              // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_GetSkeletalMaterialCount) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_GetSkeletalMaterialCount");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_GetSkeletalMaterialCount) == 0x000010, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_GetSkeletalMaterialCount");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetSkeletalMaterialCount, Skel) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetSkeletalMaterialCount::Skel' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetSkeletalMaterialCount, ReturnValue) == 0x000008, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetSkeletalMaterialCount::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.GetSkeletalMaterialInterface
// 0x0018 (0x0018 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_GetSkeletalMaterialInterface final
{
public:
	class USkeletalMesh*                          Skel;                                              // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaterialIndex;                                     // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialInterface*                     ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_GetSkeletalMaterialInterface) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_GetSkeletalMaterialInterface");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_GetSkeletalMaterialInterface) == 0x000018, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_GetSkeletalMaterialInterface");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetSkeletalMaterialInterface, Skel) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetSkeletalMaterialInterface::Skel' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetSkeletalMaterialInterface, MaterialIndex) == 0x000008, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetSkeletalMaterialInterface::MaterialIndex' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetSkeletalMaterialInterface, ReturnValue) == 0x000010, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetSkeletalMaterialInterface::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.GetSkeletalMaterialSlotName
// 0x0020 (0x0020 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_GetSkeletalMaterialSlotName final
{
public:
	class USkeletalMesh*                          Skel;                                              // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaterialIndex;                                     // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 ReturnValue;                                       // 0x0010(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_GetSkeletalMaterialSlotName) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_GetSkeletalMaterialSlotName");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_GetSkeletalMaterialSlotName) == 0x000020, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_GetSkeletalMaterialSlotName");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetSkeletalMaterialSlotName, Skel) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetSkeletalMaterialSlotName::Skel' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetSkeletalMaterialSlotName, MaterialIndex) == 0x000008, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetSkeletalMaterialSlotName::MaterialIndex' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetSkeletalMaterialSlotName, ReturnValue) == 0x000010, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetSkeletalMaterialSlotName::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.GetSpaceStateByPosition
// 0x0040 (0x0040 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_GetSpaceStateByPosition final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                InPoisition;                                       // 0x0008(0x000C)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECaveOrRoom                                   OutSpaceType;                                      // 0x0014(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 OutEnClosetDataLayer;                              // 0x0018(0x0010)(Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 OutEnCloseSubDataLayer;                            // 0x0028(0x0010)(Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0038(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_GetSpaceStateByPosition) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_GetSpaceStateByPosition");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_GetSpaceStateByPosition) == 0x000040, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_GetSpaceStateByPosition");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetSpaceStateByPosition, WorldContextObject) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetSpaceStateByPosition::WorldContextObject' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetSpaceStateByPosition, InPoisition) == 0x000008, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetSpaceStateByPosition::InPoisition' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetSpaceStateByPosition, OutSpaceType) == 0x000014, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetSpaceStateByPosition::OutSpaceType' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetSpaceStateByPosition, OutEnClosetDataLayer) == 0x000018, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetSpaceStateByPosition::OutEnClosetDataLayer' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetSpaceStateByPosition, OutEnCloseSubDataLayer) == 0x000028, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetSpaceStateByPosition::OutEnCloseSubDataLayer' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetSpaceStateByPosition, ReturnValue) == 0x000038, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetSpaceStateByPosition::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.GetStreamingCells
// 0x00C0 (0x00C0 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_GetStreamingCells final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FWorldPartitionStreamingQuerySource    QuerySource;                                       // 0x0008(0x00A0)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	TArray<struct FWorldPartitionRuntimeSpatialHashCell> OutCells;                                   // 0x00A8(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x00B8(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B9[0x7];                                       // 0x00B9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_GetStreamingCells) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_GetStreamingCells");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_GetStreamingCells) == 0x0000C0, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_GetStreamingCells");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetStreamingCells, WorldContextObject) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetStreamingCells::WorldContextObject' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetStreamingCells, QuerySource) == 0x000008, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetStreamingCells::QuerySource' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetStreamingCells, OutCells) == 0x0000A8, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetStreamingCells::OutCells' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetStreamingCells, ReturnValue) == 0x0000B8, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetStreamingCells::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.GetString
// 0x0038 (0x0038 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_GetString final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Key;                                               // 0x0008(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 DefaultValue;                                      // 0x0018(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ReturnValue;                                       // 0x0028(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_GetString) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_GetString");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_GetString) == 0x000038, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_GetString");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetString, WorldContextObject) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetString::WorldContextObject' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetString, Key) == 0x000008, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetString::Key' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetString, DefaultValue) == 0x000018, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetString::DefaultValue' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetString, ReturnValue) == 0x000028, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetString::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.GetSubsystem
// 0x0018 (0x0018 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_GetSubsystem final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UWorldSubsystem>            WorldSubsystemClass;                               // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWorldSubsystem*                        ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_GetSubsystem) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_GetSubsystem");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_GetSubsystem) == 0x000018, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_GetSubsystem");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetSubsystem, WorldContextObject) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetSubsystem::WorldContextObject' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetSubsystem, WorldSubsystemClass) == 0x000008, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetSubsystem::WorldSubsystemClass' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetSubsystem, ReturnValue) == 0x000010, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetSubsystem::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.GetSupportedRefreshRates
// 0x0010 (0x0010 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_GetSupportedRefreshRates final
{
public:
	TArray<int32>                                 ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_GetSupportedRefreshRates) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_GetSupportedRefreshRates");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_GetSupportedRefreshRates) == 0x000010, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_GetSupportedRefreshRates");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetSupportedRefreshRates, ReturnValue) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetSupportedRefreshRates::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.GetSwapBufferTime
// 0x0004 (0x0004 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_GetSwapBufferTime final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_GetSwapBufferTime) == 0x000004, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_GetSwapBufferTime");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_GetSwapBufferTime) == 0x000004, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_GetSwapBufferTime");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetSwapBufferTime, ReturnValue) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetSwapBufferTime::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.GetVectorParameterValueRef
// 0x0030 (0x0030 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_GetVectorParameterValueRef final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialParameterCollection*           Collection;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ParameterName;                                     // 0x0010(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           RefLinearColor;                                    // 0x001C(0x0010)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_GetVectorParameterValueRef) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_GetVectorParameterValueRef");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_GetVectorParameterValueRef) == 0x000030, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_GetVectorParameterValueRef");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetVectorParameterValueRef, WorldContextObject) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetVectorParameterValueRef::WorldContextObject' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetVectorParameterValueRef, Collection) == 0x000008, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetVectorParameterValueRef::Collection' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetVectorParameterValueRef, ParameterName) == 0x000010, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetVectorParameterValueRef::ParameterName' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetVectorParameterValueRef, RefLinearColor) == 0x00001C, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetVectorParameterValueRef::RefLinearColor' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.GetVectorParameterValueRefRGBA
// 0x0030 (0x0030 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_GetVectorParameterValueRefRGBA final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialParameterCollection*           Collection;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ParameterName;                                     // 0x0010(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RefLinearColorR;                                   // 0x001C(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RefLinearColorG;                                   // 0x0020(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RefLinearColorB;                                   // 0x0024(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RefLinearColorA;                                   // 0x0028(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_GetVectorParameterValueRefRGBA) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_GetVectorParameterValueRefRGBA");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_GetVectorParameterValueRefRGBA) == 0x000030, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_GetVectorParameterValueRefRGBA");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetVectorParameterValueRefRGBA, WorldContextObject) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetVectorParameterValueRefRGBA::WorldContextObject' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetVectorParameterValueRefRGBA, Collection) == 0x000008, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetVectorParameterValueRefRGBA::Collection' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetVectorParameterValueRefRGBA, ParameterName) == 0x000010, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetVectorParameterValueRefRGBA::ParameterName' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetVectorParameterValueRefRGBA, RefLinearColorR) == 0x00001C, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetVectorParameterValueRefRGBA::RefLinearColorR' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetVectorParameterValueRefRGBA, RefLinearColorG) == 0x000020, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetVectorParameterValueRefRGBA::RefLinearColorG' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetVectorParameterValueRefRGBA, RefLinearColorB) == 0x000024, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetVectorParameterValueRefRGBA::RefLinearColorB' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetVectorParameterValueRefRGBA, RefLinearColorA) == 0x000028, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetVectorParameterValueRefRGBA::RefLinearColorA' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.GetViewportSizeInLink
// 0x0010 (0x0010 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_GetViewportSizeInLink final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              ViewportSize;                                      // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_GetViewportSizeInLink) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_GetViewportSizeInLink");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_GetViewportSizeInLink) == 0x000010, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_GetViewportSizeInLink");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetViewportSizeInLink, WorldContextObject) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetViewportSizeInLink::WorldContextObject' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetViewportSizeInLink, ViewportSize) == 0x000008, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetViewportSizeInLink::ViewportSize' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.GetVoltage
// 0x0004 (0x0004 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_GetVoltage final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_GetVoltage) == 0x000004, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_GetVoltage");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_GetVoltage) == 0x000004, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_GetVoltage");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetVoltage, ReturnValue) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetVoltage::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.GetWeatherDataRef
// 0x0020 (0x0020 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_GetWeatherDataRef final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Identifier;                                        // 0x0008(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UObject*                                ReturnValue;                                       // 0x0018(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_GetWeatherDataRef) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_GetWeatherDataRef");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_GetWeatherDataRef) == 0x000020, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_GetWeatherDataRef");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetWeatherDataRef, WorldContextObject) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetWeatherDataRef::WorldContextObject' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetWeatherDataRef, Identifier) == 0x000008, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetWeatherDataRef::Identifier' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetWeatherDataRef, ReturnValue) == 0x000018, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetWeatherDataRef::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.GetWorld
// 0x0010 (0x0010 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_GetWorld final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWorld*                                 ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_GetWorld) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_GetWorld");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_GetWorld) == 0x000010, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_GetWorld");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetWorld, WorldContextObject) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetWorld::WorldContextObject' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetWorld, ReturnValue) == 0x000008, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetWorld::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.GetWorldFeatureLevel
// 0x0010 (0x0010 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_GetWorldFeatureLevel final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EKuroFeatureLevel                             ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_GetWorldFeatureLevel) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_GetWorldFeatureLevel");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_GetWorldFeatureLevel) == 0x000010, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_GetWorldFeatureLevel");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetWorldFeatureLevel, WorldContextObject) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetWorldFeatureLevel::WorldContextObject' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetWorldFeatureLevel, ReturnValue) == 0x000008, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetWorldFeatureLevel::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.GetWorldPartition
// 0x0010 (0x0010 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_GetWorldPartition final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWorldPartition*                        ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_GetWorldPartition) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_GetWorldPartition");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_GetWorldPartition) == 0x000010, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_GetWorldPartition");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetWorldPartition, WorldContextObject) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetWorldPartition::WorldContextObject' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetWorldPartition, ReturnValue) == 0x000008, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetWorldPartition::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.GetWorldPartitionAllDataLayerNames
// 0x0018 (0x0018 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_GetWorldPartitionAllDataLayerNames final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FString>                         ReturnValue;                                       // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_GetWorldPartitionAllDataLayerNames) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_GetWorldPartitionAllDataLayerNames");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_GetWorldPartitionAllDataLayerNames) == 0x000018, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_GetWorldPartitionAllDataLayerNames");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetWorldPartitionAllDataLayerNames, WorldContextObject) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetWorldPartitionAllDataLayerNames::WorldContextObject' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetWorldPartitionAllDataLayerNames, ReturnValue) == 0x000008, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetWorldPartitionAllDataLayerNames::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.GetWorldPartitionDataLayerNameByLabel
// 0x0020 (0x0020 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_GetWorldPartitionDataLayerNameByLabel final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   InDataLayerLabel;                                  // 0x0008(0x000C)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   OutDataLayerNamme;                                 // 0x0014(0x000C)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_GetWorldPartitionDataLayerNameByLabel) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_GetWorldPartitionDataLayerNameByLabel");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_GetWorldPartitionDataLayerNameByLabel) == 0x000020, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_GetWorldPartitionDataLayerNameByLabel");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetWorldPartitionDataLayerNameByLabel, WorldContextObject) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetWorldPartitionDataLayerNameByLabel::WorldContextObject' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetWorldPartitionDataLayerNameByLabel, InDataLayerLabel) == 0x000008, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetWorldPartitionDataLayerNameByLabel::InDataLayerLabel' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetWorldPartitionDataLayerNameByLabel, OutDataLayerNamme) == 0x000014, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetWorldPartitionDataLayerNameByLabel::OutDataLayerNamme' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.GetWorldRebaseAbsoluePos
// 0x0020 (0x0020 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_GetWorldRebaseAbsoluePos final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                InCurPos;                                          // 0x0008(0x000C)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ReturnValue;                                       // 0x0014(0x000C)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_GetWorldRebaseAbsoluePos) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_GetWorldRebaseAbsoluePos");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_GetWorldRebaseAbsoluePos) == 0x000020, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_GetWorldRebaseAbsoluePos");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetWorldRebaseAbsoluePos, WorldContextObject) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetWorldRebaseAbsoluePos::WorldContextObject' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetWorldRebaseAbsoluePos, InCurPos) == 0x000008, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetWorldRebaseAbsoluePos::InCurPos' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetWorldRebaseAbsoluePos, ReturnValue) == 0x000014, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetWorldRebaseAbsoluePos::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.GetWorldRebaseRelativePos
// 0x0020 (0x0020 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_GetWorldRebaseRelativePos final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                InCurPos;                                          // 0x0008(0x000C)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ReturnValue;                                       // 0x0014(0x000C)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_GetWorldRebaseRelativePos) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_GetWorldRebaseRelativePos");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_GetWorldRebaseRelativePos) == 0x000020, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_GetWorldRebaseRelativePos");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetWorldRebaseRelativePos, WorldContextObject) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetWorldRebaseRelativePos::WorldContextObject' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetWorldRebaseRelativePos, InCurPos) == 0x000008, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetWorldRebaseRelativePos::InCurPos' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetWorldRebaseRelativePos, ReturnValue) == 0x000014, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetWorldRebaseRelativePos::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.GetWorldSetting
// 0x0010 (0x0010 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_GetWorldSetting final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AWorldSettings*                         ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_GetWorldSetting) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_GetWorldSetting");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_GetWorldSetting) == 0x000010, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_GetWorldSetting");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetWorldSetting, WorldContextObject) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetWorldSetting::WorldContextObject' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetWorldSetting, ReturnValue) == 0x000008, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetWorldSetting::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.GetWorldType
// 0x0010 (0x0010 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_GetWorldType final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBP_EWorldType                                ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_GetWorldType) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_GetWorldType");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_GetWorldType) == 0x000010, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_GetWorldType");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetWorldType, WorldContextObject) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetWorldType::WorldContextObject' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetWorldType, ReturnValue) == 0x000008, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetWorldType::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.GetWpWorldBound
// 0x0020 (0x0020 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_GetWpWorldBound final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                BoundMin;                                          // 0x0008(0x000C)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                BoundMax;                                          // 0x0014(0x000C)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_GetWpWorldBound) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_GetWpWorldBound");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_GetWpWorldBound) == 0x000020, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_GetWpWorldBound");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetWpWorldBound, WorldContextObject) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetWpWorldBound::WorldContextObject' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetWpWorldBound, BoundMin) == 0x000008, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetWpWorldBound::BoundMin' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetWpWorldBound, BoundMax) == 0x000014, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetWpWorldBound::BoundMax' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.HasAllObjectFlags
// 0x0010 (0x0010 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_HasAllObjectFlags final
{
public:
	class UObject*                                Object;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         flags;                                             // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_HasAllObjectFlags) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_HasAllObjectFlags");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_HasAllObjectFlags) == 0x000010, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_HasAllObjectFlags");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_HasAllObjectFlags, Object) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_HasAllObjectFlags::Object' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_HasAllObjectFlags, flags) == 0x000008, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_HasAllObjectFlags::flags' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.HasAnyObjectFlags
// 0x0010 (0x0010 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_HasAnyObjectFlags final
{
public:
	class UObject*                                Object;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         flags;                                             // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_HasAnyObjectFlags) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_HasAnyObjectFlags");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_HasAnyObjectFlags) == 0x000010, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_HasAnyObjectFlags");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_HasAnyObjectFlags, Object) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_HasAnyObjectFlags::Object' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_HasAnyObjectFlags, flags) == 0x000008, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_HasAnyObjectFlags::flags' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.HasKey
// 0x0020 (0x0020 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_HasKey final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Key;                                               // 0x0008(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0018(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_HasKey) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_HasKey");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_HasKey) == 0x000020, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_HasKey");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_HasKey, WorldContextObject) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_HasKey::WorldContextObject' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_HasKey, Key) == 0x000008, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_HasKey::Key' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_HasKey, ReturnValue) == 0x000018, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_HasKey::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.HSP2RGB
// 0x0020 (0x0020 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_HSP2RGB final
{
public:
	struct FLinearColor                           hsp;                                               // 0x0000(0x0010)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           ReturnValue;                                       // 0x0010(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_HSP2RGB) == 0x000004, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_HSP2RGB");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_HSP2RGB) == 0x000020, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_HSP2RGB");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_HSP2RGB, hsp) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_HSP2RGB::hsp' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_HSP2RGB, ReturnValue) == 0x000010, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_HSP2RGB::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.IsCurrentPlatformPC
// 0x0010 (0x0010 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_IsCurrentPlatformPC final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_IsCurrentPlatformPC) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_IsCurrentPlatformPC");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_IsCurrentPlatformPC) == 0x000010, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_IsCurrentPlatformPC");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_IsCurrentPlatformPC, Actor) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_IsCurrentPlatformPC::Actor' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_IsCurrentPlatformPC, ReturnValue) == 0x000008, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_IsCurrentPlatformPC::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.IsDistanceCull
// 0x0020 (0x0020 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_IsDistanceCull final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraEffectType*                     EffectType;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Location;                                          // 0x0010(0x000C)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x001C(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_IsDistanceCull) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_IsDistanceCull");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_IsDistanceCull) == 0x000020, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_IsDistanceCull");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_IsDistanceCull, WorldContextObject) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_IsDistanceCull::WorldContextObject' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_IsDistanceCull, EffectType) == 0x000008, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_IsDistanceCull::EffectType' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_IsDistanceCull, Location) == 0x000010, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_IsDistanceCull::Location' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_IsDistanceCull, ReturnValue) == 0x00001C, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_IsDistanceCull::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.IsEditorOnlyActor
// 0x0010 (0x0010 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_IsEditorOnlyActor final
{
public:
	const class AActor*                           Actor;                                             // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_IsEditorOnlyActor) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_IsEditorOnlyActor");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_IsEditorOnlyActor) == 0x000010, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_IsEditorOnlyActor");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_IsEditorOnlyActor, Actor) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_IsEditorOnlyActor::Actor' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_IsEditorOnlyActor, ReturnValue) == 0x000008, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_IsEditorOnlyActor::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.IsNiagaraComplete
// 0x0010 (0x0010 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_IsNiagaraComplete final
{
public:
	class UNiagaraComponent*                      NiagaraComponent;                                  // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_IsNiagaraComplete) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_IsNiagaraComplete");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_IsNiagaraComplete) == 0x000010, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_IsNiagaraComplete");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_IsNiagaraComplete, NiagaraComponent) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_IsNiagaraComplete::NiagaraComponent' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_IsNiagaraComplete, ReturnValue) == 0x000008, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_IsNiagaraComplete::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.IsParticleComplete
// 0x0010 (0x0010 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_IsParticleComplete final
{
public:
	class UParticleSystemComponent*               ParticleSystemComponent;                           // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_IsParticleComplete) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_IsParticleComplete");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_IsParticleComplete) == 0x000010, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_IsParticleComplete");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_IsParticleComplete, ParticleSystemComponent) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_IsParticleComplete::ParticleSystemComponent' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_IsParticleComplete, ReturnValue) == 0x000008, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_IsParticleComplete::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.IsPositionInCaveOrRoom
// 0x0018 (0x0018 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_IsPositionInCaveOrRoom final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                InPoisition;                                       // 0x0008(0x000C)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0014(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_IsPositionInCaveOrRoom) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_IsPositionInCaveOrRoom");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_IsPositionInCaveOrRoom) == 0x000018, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_IsPositionInCaveOrRoom");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_IsPositionInCaveOrRoom, WorldContextObject) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_IsPositionInCaveOrRoom::WorldContextObject' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_IsPositionInCaveOrRoom, InPoisition) == 0x000008, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_IsPositionInCaveOrRoom::InPoisition' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_IsPositionInCaveOrRoom, ReturnValue) == 0x000014, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_IsPositionInCaveOrRoom::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.IsPostprocessMaterialActive
// 0x0010 (0x0010 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_IsPostprocessMaterialActive final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Handle;                                            // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x000C(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_IsPostprocessMaterialActive) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_IsPostprocessMaterialActive");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_IsPostprocessMaterialActive) == 0x000010, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_IsPostprocessMaterialActive");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_IsPostprocessMaterialActive, WorldContextObject) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_IsPostprocessMaterialActive::WorldContextObject' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_IsPostprocessMaterialActive, Handle) == 0x000008, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_IsPostprocessMaterialActive::Handle' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_IsPostprocessMaterialActive, ReturnValue) == 0x00000C, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_IsPostprocessMaterialActive::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.IsStreamingSourceInSide
// 0x0028 (0x0028 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_IsStreamingSourceInSide final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EStreamingSourcePriority                      StreamingSourcePriority;                           // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                Origin;                                            // 0x000C(0x000C)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Extent;                                            // 0x0018(0x000C)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0024(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_25[0x3];                                       // 0x0025(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_IsStreamingSourceInSide) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_IsStreamingSourceInSide");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_IsStreamingSourceInSide) == 0x000028, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_IsStreamingSourceInSide");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_IsStreamingSourceInSide, WorldContextObject) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_IsStreamingSourceInSide::WorldContextObject' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_IsStreamingSourceInSide, StreamingSourcePriority) == 0x000008, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_IsStreamingSourceInSide::StreamingSourcePriority' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_IsStreamingSourceInSide, Origin) == 0x00000C, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_IsStreamingSourceInSide::Origin' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_IsStreamingSourceInSide, Extent) == 0x000018, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_IsStreamingSourceInSide::Extent' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_IsStreamingSourceInSide, ReturnValue) == 0x000024, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_IsStreamingSourceInSide::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.IsSupportsMetalFx
// 0x0001 (0x0001 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_IsSupportsMetalFx final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_IsSupportsMetalFx) == 0x000001, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_IsSupportsMetalFx");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_IsSupportsMetalFx) == 0x000001, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_IsSupportsMetalFx");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_IsSupportsMetalFx, ReturnValue) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_IsSupportsMetalFx::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.IsUsingNotSeparateCache
// 0x0001 (0x0001 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_IsUsingNotSeparateCache final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_IsUsingNotSeparateCache) == 0x000001, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_IsUsingNotSeparateCache");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_IsUsingNotSeparateCache) == 0x000001, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_IsUsingNotSeparateCache");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_IsUsingNotSeparateCache, ReturnValue) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_IsUsingNotSeparateCache::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.IsUsingParallaxCorrect
// 0x0001 (0x0001 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_IsUsingParallaxCorrect final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_IsUsingParallaxCorrect) == 0x000001, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_IsUsingParallaxCorrect");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_IsUsingParallaxCorrect) == 0x000001, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_IsUsingParallaxCorrect");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_IsUsingParallaxCorrect, ReturnValue) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_IsUsingParallaxCorrect::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.IsWorldOriginFinish
// 0x0010 (0x0010 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_IsWorldOriginFinish final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_IsWorldOriginFinish) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_IsWorldOriginFinish");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_IsWorldOriginFinish) == 0x000010, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_IsWorldOriginFinish");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_IsWorldOriginFinish, WorldContextObject) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_IsWorldOriginFinish::WorldContextObject' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_IsWorldOriginFinish, ReturnValue) == 0x000008, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_IsWorldOriginFinish::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.IsWorldOriginVisibilityRequestPending
// 0x0010 (0x0010 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_IsWorldOriginVisibilityRequestPending final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_IsWorldOriginVisibilityRequestPending) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_IsWorldOriginVisibilityRequestPending");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_IsWorldOriginVisibilityRequestPending) == 0x000010, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_IsWorldOriginVisibilityRequestPending");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_IsWorldOriginVisibilityRequestPending, WorldContextObject) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_IsWorldOriginVisibilityRequestPending::WorldContextObject' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_IsWorldOriginVisibilityRequestPending, ReturnValue) == 0x000008, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_IsWorldOriginVisibilityRequestPending::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.IsWorldPartitionDataLayerEnable
// 0x0018 (0x0018 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_IsWorldPartitionDataLayerEnable final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   DataLayerName;                                     // 0x0008(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0014(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_IsWorldPartitionDataLayerEnable) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_IsWorldPartitionDataLayerEnable");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_IsWorldPartitionDataLayerEnable) == 0x000018, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_IsWorldPartitionDataLayerEnable");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_IsWorldPartitionDataLayerEnable, WorldContextObject) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_IsWorldPartitionDataLayerEnable::WorldContextObject' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_IsWorldPartitionDataLayerEnable, DataLayerName) == 0x000008, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_IsWorldPartitionDataLayerEnable::DataLayerName' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_IsWorldPartitionDataLayerEnable, ReturnValue) == 0x000014, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_IsWorldPartitionDataLayerEnable::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.IsWorldPartitionWorld
// 0x0010 (0x0010 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_IsWorldPartitionWorld final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_IsWorldPartitionWorld) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_IsWorldPartitionWorld");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_IsWorldPartitionWorld) == 0x000010, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_IsWorldPartitionWorld");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_IsWorldPartitionWorld, WorldContextObject) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_IsWorldPartitionWorld::WorldContextObject' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_IsWorldPartitionWorld, ReturnValue) == 0x000008, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_IsWorldPartitionWorld::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.IsWpPlayerInCaveOrRoom
// 0x0010 (0x0010 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_IsWpPlayerInCaveOrRoom final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_IsWpPlayerInCaveOrRoom) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_IsWpPlayerInCaveOrRoom");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_IsWpPlayerInCaveOrRoom) == 0x000010, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_IsWpPlayerInCaveOrRoom");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_IsWpPlayerInCaveOrRoom, WorldContextObject) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_IsWpPlayerInCaveOrRoom::WorldContextObject' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_IsWpPlayerInCaveOrRoom, ReturnValue) == 0x000008, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_IsWpPlayerInCaveOrRoom::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.KuroBuoyancyCalculation
// 0x0030 (0x0030 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_KuroBuoyancyCalculation final
{
public:
	class UStaticMeshComponent*                   MeshComponent;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FVector4>                       SphereList;                                        // 0x0008(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	float                                         WaterHeight;                                       // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                BuoyancyMagnitude;                                 // 0x001C(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              ReturnValue;                                       // 0x0028(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_KuroBuoyancyCalculation) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_KuroBuoyancyCalculation");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_KuroBuoyancyCalculation) == 0x000030, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_KuroBuoyancyCalculation");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_KuroBuoyancyCalculation, MeshComponent) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_KuroBuoyancyCalculation::MeshComponent' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_KuroBuoyancyCalculation, SphereList) == 0x000008, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_KuroBuoyancyCalculation::SphereList' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_KuroBuoyancyCalculation, WaterHeight) == 0x000018, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_KuroBuoyancyCalculation::WaterHeight' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_KuroBuoyancyCalculation, BuoyancyMagnitude) == 0x00001C, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_KuroBuoyancyCalculation::BuoyancyMagnitude' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_KuroBuoyancyCalculation, ReturnValue) == 0x000028, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_KuroBuoyancyCalculation::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.KuroMarkPackageDirty
// 0x0008 (0x0008 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_KuroMarkPackageDirty final
{
public:
	class UObject*                                Object;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_KuroMarkPackageDirty) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_KuroMarkPackageDirty");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_KuroMarkPackageDirty) == 0x000008, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_KuroMarkPackageDirty");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_KuroMarkPackageDirty, Object) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_KuroMarkPackageDirty::Object' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.MakeSequencePlayer
// 0x0028 (0x0028 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_MakeSequencePlayer final
{
public:
	class UActorSequenceComponent*                SequenceComponent;                                 // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FMovieSceneSequencePlaybackSettings    PlaybackSettings;                                  // 0x0008(0x0014)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UActorSequencePlayer*                   ReturnValue;                                       // 0x0020(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_MakeSequencePlayer) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_MakeSequencePlayer");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_MakeSequencePlayer) == 0x000028, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_MakeSequencePlayer");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_MakeSequencePlayer, SequenceComponent) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_MakeSequencePlayer::SequenceComponent' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_MakeSequencePlayer, PlaybackSettings) == 0x000008, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_MakeSequencePlayer::PlaybackSettings' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_MakeSequencePlayer, ReturnValue) == 0x000020, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_MakeSequencePlayer::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.MarkWorldPostProcessPriorityDirty
// 0x0008 (0x0008 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_MarkWorldPostProcessPriorityDirty final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_MarkWorldPostProcessPriorityDirty) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_MarkWorldPostProcessPriorityDirty");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_MarkWorldPostProcessPriorityDirty) == 0x000008, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_MarkWorldPostProcessPriorityDirty");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_MarkWorldPostProcessPriorityDirty, WorldContextObject) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_MarkWorldPostProcessPriorityDirty::WorldContextObject' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.MaterialHasParameter_EditorOnly
// 0x0020 (0x0020 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_MaterialHasParameter_EditorOnly final
{
public:
	class UMaterialInterface*                     MaterialInterface;                                 // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ParameterName;                                     // 0x0008(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0018(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_MaterialHasParameter_EditorOnly) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_MaterialHasParameter_EditorOnly");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_MaterialHasParameter_EditorOnly) == 0x000020, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_MaterialHasParameter_EditorOnly");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_MaterialHasParameter_EditorOnly, MaterialInterface) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_MaterialHasParameter_EditorOnly::MaterialInterface' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_MaterialHasParameter_EditorOnly, ParameterName) == 0x000008, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_MaterialHasParameter_EditorOnly::ParameterName' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_MaterialHasParameter_EditorOnly, ReturnValue) == 0x000018, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_MaterialHasParameter_EditorOnly::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.MessageNotify_EditorOnly
// 0x0028 (0x0028 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_MessageNotify_EditorOnly final
{
public:
	class FText                                   Message;                                           // 0x0000(0x0018)(ConstParm, Parm, NativeAccessSpecifierPublic)
	class FName                                   Tile;                                              // 0x0018(0x000C)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_MessageNotify_EditorOnly) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_MessageNotify_EditorOnly");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_MessageNotify_EditorOnly) == 0x000028, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_MessageNotify_EditorOnly");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_MessageNotify_EditorOnly, Message) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_MessageNotify_EditorOnly::Message' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_MessageNotify_EditorOnly, Tile) == 0x000018, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_MessageNotify_EditorOnly::Tile' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.MoveCurveColorValueToOtherTime
// 0x0010 (0x0010 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_MoveCurveColorValueToOtherTime final
{
public:
	class UCurveLinearColor*                      Curve;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SrcTime;                                           // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TargetTime;                                        // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_MoveCurveColorValueToOtherTime) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_MoveCurveColorValueToOtherTime");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_MoveCurveColorValueToOtherTime) == 0x000010, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_MoveCurveColorValueToOtherTime");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_MoveCurveColorValueToOtherTime, Curve) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_MoveCurveColorValueToOtherTime::Curve' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_MoveCurveColorValueToOtherTime, SrcTime) == 0x000008, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_MoveCurveColorValueToOtherTime::SrcTime' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_MoveCurveColorValueToOtherTime, TargetTime) == 0x00000C, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_MoveCurveColorValueToOtherTime::TargetTime' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.MoveCurveFloatValueToOtherTime
// 0x0010 (0x0010 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_MoveCurveFloatValueToOtherTime final
{
public:
	class UCurveFloat*                            Curve;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SrcTime;                                           // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TargetTime;                                        // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_MoveCurveFloatValueToOtherTime) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_MoveCurveFloatValueToOtherTime");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_MoveCurveFloatValueToOtherTime) == 0x000010, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_MoveCurveFloatValueToOtherTime");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_MoveCurveFloatValueToOtherTime, Curve) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_MoveCurveFloatValueToOtherTime::Curve' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_MoveCurveFloatValueToOtherTime, SrcTime) == 0x000008, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_MoveCurveFloatValueToOtherTime::SrcTime' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_MoveCurveFloatValueToOtherTime, TargetTime) == 0x00000C, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_MoveCurveFloatValueToOtherTime::TargetTime' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.PackLinearColorRGBToVector2D
// 0x0018 (0x0018 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_PackLinearColorRGBToVector2D final
{
public:
	struct FLinearColor                           Color;                                             // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_PackLinearColorRGBToVector2D) == 0x000004, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_PackLinearColorRGBToVector2D");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_PackLinearColorRGBToVector2D) == 0x000018, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_PackLinearColorRGBToVector2D");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_PackLinearColorRGBToVector2D, Color) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_PackLinearColorRGBToVector2D::Color' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_PackLinearColorRGBToVector2D, ReturnValue) == 0x000010, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_PackLinearColorRGBToVector2D::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.PBDChain_MY
// 0x0068 (0x0068 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_PBDChain_MY final
{
public:
	TArray<struct FVector>                        posArr;                                            // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	TArray<struct FVector>                        volArr;                                            // 0x0010(0x0010)(Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	TArray<struct FVector>                        posArrFoe;                                         // 0x0020(0x0010)(Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	float                                         linkDis;                                           // 0x0030(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                emitterOriginPos;                                  // 0x0034(0x000C)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                accel_ext;                                         // 0x0040(0x000C)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         collisionR;                                        // 0x004C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          isFirstFrame;                                      // 0x0050(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_51[0x3];                                       // 0x0051(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         volDamping;                                        // 0x0054(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         dt;                                                // 0x0058(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                playerPos;                                         // 0x005C(0x000C)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_PBDChain_MY) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_PBDChain_MY");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_PBDChain_MY) == 0x000068, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_PBDChain_MY");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_PBDChain_MY, posArr) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_PBDChain_MY::posArr' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_PBDChain_MY, volArr) == 0x000010, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_PBDChain_MY::volArr' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_PBDChain_MY, posArrFoe) == 0x000020, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_PBDChain_MY::posArrFoe' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_PBDChain_MY, linkDis) == 0x000030, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_PBDChain_MY::linkDis' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_PBDChain_MY, emitterOriginPos) == 0x000034, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_PBDChain_MY::emitterOriginPos' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_PBDChain_MY, accel_ext) == 0x000040, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_PBDChain_MY::accel_ext' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_PBDChain_MY, collisionR) == 0x00004C, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_PBDChain_MY::collisionR' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_PBDChain_MY, isFirstFrame) == 0x000050, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_PBDChain_MY::isFirstFrame' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_PBDChain_MY, volDamping) == 0x000054, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_PBDChain_MY::volDamping' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_PBDChain_MY, dt) == 0x000058, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_PBDChain_MY::dt' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_PBDChain_MY, playerPos) == 0x00005C, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_PBDChain_MY::playerPos' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.PBDChainParallel_MY
// 0x0070 (0x0070 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_PBDChainParallel_MY final
{
public:
	TArray<struct FVector>                        posArr;                                            // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	TArray<struct FVector>                        volArr;                                            // 0x0010(0x0010)(Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	TArray<struct FVector>                        posArrFoe;                                         // 0x0020(0x0010)(Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	float                                         linkDis;                                           // 0x0030(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                emitterOriginPos;                                  // 0x0034(0x000C)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                accel_ext;                                         // 0x0040(0x000C)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         collisionR;                                        // 0x004C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          isFirstFrame;                                      // 0x0050(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_51[0x3];                                       // 0x0051(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         volDamping;                                        // 0x0054(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         dt;                                                // 0x0058(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                playerPos;                                         // 0x005C(0x000C)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          doParallel;                                        // 0x0068(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_69[0x7];                                       // 0x0069(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_PBDChainParallel_MY) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_PBDChainParallel_MY");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_PBDChainParallel_MY) == 0x000070, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_PBDChainParallel_MY");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_PBDChainParallel_MY, posArr) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_PBDChainParallel_MY::posArr' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_PBDChainParallel_MY, volArr) == 0x000010, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_PBDChainParallel_MY::volArr' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_PBDChainParallel_MY, posArrFoe) == 0x000020, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_PBDChainParallel_MY::posArrFoe' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_PBDChainParallel_MY, linkDis) == 0x000030, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_PBDChainParallel_MY::linkDis' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_PBDChainParallel_MY, emitterOriginPos) == 0x000034, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_PBDChainParallel_MY::emitterOriginPos' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_PBDChainParallel_MY, accel_ext) == 0x000040, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_PBDChainParallel_MY::accel_ext' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_PBDChainParallel_MY, collisionR) == 0x00004C, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_PBDChainParallel_MY::collisionR' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_PBDChainParallel_MY, isFirstFrame) == 0x000050, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_PBDChainParallel_MY::isFirstFrame' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_PBDChainParallel_MY, volDamping) == 0x000054, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_PBDChainParallel_MY::volDamping' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_PBDChainParallel_MY, dt) == 0x000058, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_PBDChainParallel_MY::dt' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_PBDChainParallel_MY, playerPos) == 0x00005C, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_PBDChainParallel_MY::playerPos' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_PBDChainParallel_MY, doParallel) == 0x000068, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_PBDChainParallel_MY::doParallel' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.ProjectWorldToScreenWithLevelEditorViewPort
// 0x0040 (0x0040 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_ProjectWorldToScreenWithLevelEditorViewPort final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                worldPosition;                                     // 0x0008(0x000C)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0xC];                                       // 0x0014(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector4                               result;                                            // 0x0020(0x0010)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0030(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0xF];                                       // 0x0031(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_ProjectWorldToScreenWithLevelEditorViewPort) == 0x000010, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_ProjectWorldToScreenWithLevelEditorViewPort");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_ProjectWorldToScreenWithLevelEditorViewPort) == 0x000040, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_ProjectWorldToScreenWithLevelEditorViewPort");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_ProjectWorldToScreenWithLevelEditorViewPort, WorldContextObject) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_ProjectWorldToScreenWithLevelEditorViewPort::WorldContextObject' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_ProjectWorldToScreenWithLevelEditorViewPort, worldPosition) == 0x000008, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_ProjectWorldToScreenWithLevelEditorViewPort::worldPosition' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_ProjectWorldToScreenWithLevelEditorViewPort, result) == 0x000020, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_ProjectWorldToScreenWithLevelEditorViewPort::result' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_ProjectWorldToScreenWithLevelEditorViewPort, ReturnValue) == 0x000030, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_ProjectWorldToScreenWithLevelEditorViewPort::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.ProjectWorldToScreenWithLevelEditorViewPortFloatRef
// 0x0028 (0x0028 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_ProjectWorldToScreenWithLevelEditorViewPortFloatRef final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                WorldPosition;                                     // 0x0008(0x000C)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ResultX;                                           // 0x0014(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ResultY;                                           // 0x0018(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ResultZ;                                           // 0x001C(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ResultW;                                           // 0x0020(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0024(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_25[0x3];                                       // 0x0025(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_ProjectWorldToScreenWithLevelEditorViewPortFloatRef) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_ProjectWorldToScreenWithLevelEditorViewPortFloatRef");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_ProjectWorldToScreenWithLevelEditorViewPortFloatRef) == 0x000028, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_ProjectWorldToScreenWithLevelEditorViewPortFloatRef");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_ProjectWorldToScreenWithLevelEditorViewPortFloatRef, WorldContextObject) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_ProjectWorldToScreenWithLevelEditorViewPortFloatRef::WorldContextObject' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_ProjectWorldToScreenWithLevelEditorViewPortFloatRef, WorldPosition) == 0x000008, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_ProjectWorldToScreenWithLevelEditorViewPortFloatRef::WorldPosition' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_ProjectWorldToScreenWithLevelEditorViewPortFloatRef, ResultX) == 0x000014, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_ProjectWorldToScreenWithLevelEditorViewPortFloatRef::ResultX' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_ProjectWorldToScreenWithLevelEditorViewPortFloatRef, ResultY) == 0x000018, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_ProjectWorldToScreenWithLevelEditorViewPortFloatRef::ResultY' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_ProjectWorldToScreenWithLevelEditorViewPortFloatRef, ResultZ) == 0x00001C, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_ProjectWorldToScreenWithLevelEditorViewPortFloatRef::ResultZ' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_ProjectWorldToScreenWithLevelEditorViewPortFloatRef, ResultW) == 0x000020, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_ProjectWorldToScreenWithLevelEditorViewPortFloatRef::ResultW' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_ProjectWorldToScreenWithLevelEditorViewPortFloatRef, ReturnValue) == 0x000024, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_ProjectWorldToScreenWithLevelEditorViewPortFloatRef::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.RemoveAdditionalClusteredStuff
// 0x0010 (0x0010 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_RemoveAdditionalClusteredStuff final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UClusteredStuffDataAsset*               Asset;                                             // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_RemoveAdditionalClusteredStuff) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_RemoveAdditionalClusteredStuff");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_RemoveAdditionalClusteredStuff) == 0x000010, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_RemoveAdditionalClusteredStuff");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_RemoveAdditionalClusteredStuff, WorldContextObject) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_RemoveAdditionalClusteredStuff::WorldContextObject' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_RemoveAdditionalClusteredStuff, Asset) == 0x000008, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_RemoveAdditionalClusteredStuff::Asset' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.RemovePostprocessMaterial
// 0x0010 (0x0010 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_RemovePostprocessMaterial final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Handle;                                            // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_RemovePostprocessMaterial) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_RemovePostprocessMaterial");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_RemovePostprocessMaterial) == 0x000010, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_RemovePostprocessMaterial");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_RemovePostprocessMaterial, WorldContextObject) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_RemovePostprocessMaterial::WorldContextObject' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_RemovePostprocessMaterial, Handle) == 0x000008, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_RemovePostprocessMaterial::Handle' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.RerunConstructionScripts
// 0x0008 (0x0008 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_RerunConstructionScripts final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_RerunConstructionScripts) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_RerunConstructionScripts");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_RerunConstructionScripts) == 0x000008, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_RerunConstructionScripts");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_RerunConstructionScripts, Actor) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_RerunConstructionScripts::Actor' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.ResetParticleSystem
// 0x0008 (0x0008 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_ResetParticleSystem final
{
public:
	class UParticleSystemComponent*               ParticleSystemComponent;                           // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_ResetParticleSystem) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_ResetParticleSystem");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_ResetParticleSystem) == 0x000008, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_ResetParticleSystem");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_ResetParticleSystem, ParticleSystemComponent) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_ResetParticleSystem::ParticleSystemComponent' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.ResumeSomeWeatherAfterTeleport
// 0x0008 (0x0008 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_ResumeSomeWeatherAfterTeleport final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_ResumeSomeWeatherAfterTeleport) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_ResumeSomeWeatherAfterTeleport");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_ResumeSomeWeatherAfterTeleport) == 0x000008, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_ResumeSomeWeatherAfterTeleport");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_ResumeSomeWeatherAfterTeleport, WorldContextObject) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_ResumeSomeWeatherAfterTeleport::WorldContextObject' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.RGB2HSP
// 0x0020 (0x0020 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_RGB2HSP final
{
public:
	struct FLinearColor                           rgb;                                               // 0x0000(0x0010)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           ReturnValue;                                       // 0x0010(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_RGB2HSP) == 0x000004, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_RGB2HSP");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_RGB2HSP) == 0x000020, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_RGB2HSP");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_RGB2HSP, rgb) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_RGB2HSP::rgb' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_RGB2HSP, ReturnValue) == 0x000010, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_RGB2HSP::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.Save
// 0x0008 (0x0008 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_Save final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_Save) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_Save");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_Save) == 0x000008, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_Save");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_Save, WorldContextObject) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_Save::WorldContextObject' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.SetActorUISceneRendering
// 0x0010 (0x0010 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_SetActorUISceneRendering final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsUISceneRendering;                                // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_SetActorUISceneRendering) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_SetActorUISceneRendering");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_SetActorUISceneRendering) == 0x000010, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_SetActorUISceneRendering");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_SetActorUISceneRendering, Actor) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_SetActorUISceneRendering::Actor' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_SetActorUISceneRendering, IsUISceneRendering) == 0x000008, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_SetActorUISceneRendering::IsUISceneRendering' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.SetClusteredStuffVisible
// 0x0010 (0x0010 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_SetClusteredStuffVisible final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Visible;                                           // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_SetClusteredStuffVisible) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_SetClusteredStuffVisible");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_SetClusteredStuffVisible) == 0x000010, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_SetClusteredStuffVisible");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_SetClusteredStuffVisible, WorldContextObject) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_SetClusteredStuffVisible::WorldContextObject' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_SetClusteredStuffVisible, Visible) == 0x000008, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_SetClusteredStuffVisible::Visible' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.SetCVarFloat
// 0x0018 (0x0018 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_SetCVarFloat final
{
public:
	class FString                                 CVarKey;                                           // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Value;                                             // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_SetCVarFloat) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_SetCVarFloat");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_SetCVarFloat) == 0x000018, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_SetCVarFloat");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_SetCVarFloat, CVarKey) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_SetCVarFloat::CVarKey' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_SetCVarFloat, Value) == 0x000010, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_SetCVarFloat::Value' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.SetCVarInt32
// 0x0018 (0x0018 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_SetCVarInt32 final
{
public:
	class FString                                 CVarKey;                                           // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Value;                                             // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_SetCVarInt32) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_SetCVarInt32");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_SetCVarInt32) == 0x000018, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_SetCVarInt32");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_SetCVarInt32, CVarKey) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_SetCVarInt32::CVarKey' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_SetCVarInt32, Value) == 0x000010, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_SetCVarInt32::Value' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.SetDisableEffectPostProcessVolume
// 0x0010 (0x0010 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_SetDisableEffectPostProcessVolume final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDisable;                                          // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ChangeSpeed;                                       // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_SetDisableEffectPostProcessVolume) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_SetDisableEffectPostProcessVolume");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_SetDisableEffectPostProcessVolume) == 0x000010, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_SetDisableEffectPostProcessVolume");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_SetDisableEffectPostProcessVolume, WorldContextObject) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_SetDisableEffectPostProcessVolume::WorldContextObject' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_SetDisableEffectPostProcessVolume, bDisable) == 0x000008, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_SetDisableEffectPostProcessVolume::bDisable' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_SetDisableEffectPostProcessVolume, ChangeSpeed) == 0x00000C, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_SetDisableEffectPostProcessVolume::ChangeSpeed' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.SetFloat
// 0x0020 (0x0020 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_SetFloat final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Key;                                               // 0x0008(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Value;                                             // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_SetFloat) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_SetFloat");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_SetFloat) == 0x000020, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_SetFloat");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_SetFloat, WorldContextObject) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_SetFloat::WorldContextObject' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_SetFloat, Key) == 0x000008, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_SetFloat::Key' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_SetFloat, Value) == 0x000018, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_SetFloat::Value' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.SetGITransientActorAttachment
// 0x0018 (0x0018 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_SetGITransientActorAttachment final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   IdName;                                            // 0x0008(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAttachToPlayer;                                   // 0x0014(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAttachToEditorCamera;                             // 0x0015(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_16[0x2];                                       // 0x0016(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_SetGITransientActorAttachment) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_SetGITransientActorAttachment");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_SetGITransientActorAttachment) == 0x000018, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_SetGITransientActorAttachment");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_SetGITransientActorAttachment, WorldContextObject) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_SetGITransientActorAttachment::WorldContextObject' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_SetGITransientActorAttachment, IdName) == 0x000008, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_SetGITransientActorAttachment::IdName' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_SetGITransientActorAttachment, bAttachToPlayer) == 0x000014, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_SetGITransientActorAttachment::bAttachToPlayer' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_SetGITransientActorAttachment, bAttachToEditorCamera) == 0x000015, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_SetGITransientActorAttachment::bAttachToEditorCamera' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.SetGlobalGITime
// 0x0010 (0x0010 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_SetGlobalGITime final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Time;                                              // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x000C(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_SetGlobalGITime) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_SetGlobalGITime");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_SetGlobalGITime) == 0x000010, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_SetGlobalGITime");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_SetGlobalGITime, WorldContextObject) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_SetGlobalGITime::WorldContextObject' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_SetGlobalGITime, Time) == 0x000008, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_SetGlobalGITime::Time' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_SetGlobalGITime, ReturnValue) == 0x00000C, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_SetGlobalGITime::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.SetInt
// 0x0020 (0x0020 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_SetInt final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Key;                                               // 0x0008(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Value;                                             // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_SetInt) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_SetInt");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_SetInt) == 0x000020, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_SetInt");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_SetInt, WorldContextObject) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_SetInt::WorldContextObject' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_SetInt, Key) == 0x000008, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_SetInt::Key' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_SetInt, Value) == 0x000018, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_SetInt::Value' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.SetIntsDataToRenderTarget
// 0x0018 (0x0018 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_SetIntsDataToRenderTarget final
{
public:
	class UTextureRenderTarget2D*                 TextureRenderTarget;                               // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<int32>                                 WriteData;                                         // 0x0008(0x0010)(Parm, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_SetIntsDataToRenderTarget) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_SetIntsDataToRenderTarget");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_SetIntsDataToRenderTarget) == 0x000018, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_SetIntsDataToRenderTarget");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_SetIntsDataToRenderTarget, TextureRenderTarget) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_SetIntsDataToRenderTarget::TextureRenderTarget' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_SetIntsDataToRenderTarget, WriteData) == 0x000008, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_SetIntsDataToRenderTarget::WriteData' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.SetIsUsingInCaveOrIndoorShadow
// 0x0018 (0x0018 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_SetIsUsingInCaveOrIndoorShadow final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsUsing;                                           // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MobileCSMDistanceInCave;                           // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MobileCSMDistanceOutCave;                          // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_SetIsUsingInCaveOrIndoorShadow) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_SetIsUsingInCaveOrIndoorShadow");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_SetIsUsingInCaveOrIndoorShadow) == 0x000018, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_SetIsUsingInCaveOrIndoorShadow");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_SetIsUsingInCaveOrIndoorShadow, WorldContextObject) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_SetIsUsingInCaveOrIndoorShadow::WorldContextObject' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_SetIsUsingInCaveOrIndoorShadow, IsUsing) == 0x000008, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_SetIsUsingInCaveOrIndoorShadow::IsUsing' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_SetIsUsingInCaveOrIndoorShadow, MobileCSMDistanceInCave) == 0x00000C, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_SetIsUsingInCaveOrIndoorShadow::MobileCSMDistanceInCave' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_SetIsUsingInCaveOrIndoorShadow, MobileCSMDistanceOutCave) == 0x000010, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_SetIsUsingInCaveOrIndoorShadow::MobileCSMDistanceOutCave' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.SetLevelEditorCameraLocation
// 0x0018 (0x0018 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_SetLevelEditorCameraLocation final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Position;                                          // 0x0008(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0014(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_SetLevelEditorCameraLocation) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_SetLevelEditorCameraLocation");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_SetLevelEditorCameraLocation) == 0x000018, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_SetLevelEditorCameraLocation");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_SetLevelEditorCameraLocation, WorldContextObject) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_SetLevelEditorCameraLocation::WorldContextObject' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_SetLevelEditorCameraLocation, Position) == 0x000008, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_SetLevelEditorCameraLocation::Position' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_SetLevelEditorCameraLocation, ReturnValue) == 0x000014, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_SetLevelEditorCameraLocation::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.SetNiagaraSkeletalMeshComponentWithoutWarning
// 0x0020 (0x0020 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_SetNiagaraSkeletalMeshComponentWithoutWarning final
{
public:
	class UNiagaraComponent*                      NiagaraSystem;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 OverrideName;                                      // 0x0008(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USkeletalMeshComponent*                 SkeletalMeshComponent;                             // 0x0018(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_SetNiagaraSkeletalMeshComponentWithoutWarning) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_SetNiagaraSkeletalMeshComponentWithoutWarning");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_SetNiagaraSkeletalMeshComponentWithoutWarning) == 0x000020, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_SetNiagaraSkeletalMeshComponentWithoutWarning");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_SetNiagaraSkeletalMeshComponentWithoutWarning, NiagaraSystem) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_SetNiagaraSkeletalMeshComponentWithoutWarning::NiagaraSystem' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_SetNiagaraSkeletalMeshComponentWithoutWarning, OverrideName) == 0x000008, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_SetNiagaraSkeletalMeshComponentWithoutWarning::OverrideName' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_SetNiagaraSkeletalMeshComponentWithoutWarning, SkeletalMeshComponent) == 0x000018, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_SetNiagaraSkeletalMeshComponentWithoutWarning::SkeletalMeshComponent' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.SetNiagaraSplineComponent
// 0x0020 (0x0020 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_SetNiagaraSplineComponent final
{
public:
	class UNiagaraComponent*                      NiagaraSystem;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 OverrideName;                                      // 0x0008(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USplineComponent*                       SplineComponent;                                   // 0x0018(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_SetNiagaraSplineComponent) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_SetNiagaraSplineComponent");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_SetNiagaraSplineComponent) == 0x000020, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_SetNiagaraSplineComponent");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_SetNiagaraSplineComponent, NiagaraSystem) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_SetNiagaraSplineComponent::NiagaraSystem' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_SetNiagaraSplineComponent, OverrideName) == 0x000008, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_SetNiagaraSplineComponent::OverrideName' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_SetNiagaraSplineComponent, SplineComponent) == 0x000018, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_SetNiagaraSplineComponent::SplineComponent' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.SetObjectFlags
// 0x0010 (0x0010 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_SetObjectFlags final
{
public:
	class UObject*                                Object;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         flags;                                             // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_SetObjectFlags) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_SetObjectFlags");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_SetObjectFlags) == 0x000010, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_SetObjectFlags");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_SetObjectFlags, Object) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_SetObjectFlags::Object' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_SetObjectFlags, flags) == 0x000008, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_SetObjectFlags::flags' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.SetRayTracingEnable
// 0x0001 (0x0001 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_SetRayTracingEnable final
{
public:
	bool                                          bEnable;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_SetRayTracingEnable) == 0x000001, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_SetRayTracingEnable");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_SetRayTracingEnable) == 0x000001, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_SetRayTracingEnable");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_SetRayTracingEnable, bEnable) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_SetRayTracingEnable::bEnable' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.SetSceneKuroMainPlayerLocation
// 0x0010 (0x0010 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_SetSceneKuroMainPlayerLocation final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PlayerIndex;                                       // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_SetSceneKuroMainPlayerLocation) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_SetSceneKuroMainPlayerLocation");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_SetSceneKuroMainPlayerLocation) == 0x000010, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_SetSceneKuroMainPlayerLocation");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_SetSceneKuroMainPlayerLocation, WorldContextObject) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_SetSceneKuroMainPlayerLocation::WorldContextObject' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_SetSceneKuroMainPlayerLocation, PlayerIndex) == 0x000008, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_SetSceneKuroMainPlayerLocation::PlayerIndex' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.SetSceneKuroViewCenter
// 0x0018 (0x0018 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_SetSceneKuroViewCenter final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Location;                                          // 0x0008(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_SetSceneKuroViewCenter) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_SetSceneKuroViewCenter");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_SetSceneKuroViewCenter) == 0x000018, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_SetSceneKuroViewCenter");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_SetSceneKuroViewCenter, WorldContextObject) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_SetSceneKuroViewCenter::WorldContextObject' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_SetSceneKuroViewCenter, Location) == 0x000008, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_SetSceneKuroViewCenter::Location' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.SetSceneRenderingState
// 0x0010 (0x0010 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_SetSceneRenderingState final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSceneVisible;                                     // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_SetSceneRenderingState) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_SetSceneRenderingState");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_SetSceneRenderingState) == 0x000010, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_SetSceneRenderingState");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_SetSceneRenderingState, WorldContextObject) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_SetSceneRenderingState::WorldContextObject' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_SetSceneRenderingState, bSceneVisible) == 0x000008, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_SetSceneRenderingState::bSceneVisible' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.SetString
// 0x0028 (0x0028 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_SetString final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Key;                                               // 0x0008(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Value;                                             // 0x0018(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_SetString) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_SetString");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_SetString) == 0x000028, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_SetString");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_SetString, WorldContextObject) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_SetString::WorldContextObject' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_SetString, Key) == 0x000008, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_SetString::Key' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_SetString, Value) == 0x000018, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_SetString::Value' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.SetSunLensflareEnabled
// 0x0010 (0x0010 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_SetSunLensflareEnabled final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnabled;                                          // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_SetSunLensflareEnabled) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_SetSunLensflareEnabled");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_SetSunLensflareEnabled) == 0x000010, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_SetSunLensflareEnabled");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_SetSunLensflareEnabled, WorldContextObject) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_SetSunLensflareEnabled::WorldContextObject' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_SetSunLensflareEnabled, bEnabled) == 0x000008, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_SetSunLensflareEnabled::bEnabled' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.SetTransformLocationInArray
// 0x0020 (0x0020 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_SetTransformLocationInArray final
{
public:
	TArray<struct FTransform>                     TransformArray;                                    // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         index;                                             // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Location;                                          // 0x0014(0x000C)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_SetTransformLocationInArray) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_SetTransformLocationInArray");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_SetTransformLocationInArray) == 0x000020, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_SetTransformLocationInArray");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_SetTransformLocationInArray, TransformArray) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_SetTransformLocationInArray::TransformArray' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_SetTransformLocationInArray, index) == 0x000010, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_SetTransformLocationInArray::index' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_SetTransformLocationInArray, Location) == 0x000014, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_SetTransformLocationInArray::Location' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.SetupVolumeSize
// 0x0028 (0x0028 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_SetupVolumeSize final
{
public:
	class AVolume*                                Volume;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBox                                   Bounds;                                            // 0x0008(0x001C)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_SetupVolumeSize) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_SetupVolumeSize");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_SetupVolumeSize) == 0x000028, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_SetupVolumeSize");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_SetupVolumeSize, Volume) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_SetupVolumeSize::Volume' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_SetupVolumeSize, Bounds) == 0x000008, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_SetupVolumeSize::Bounds' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.SetUsingInCaveOrIndoorShadow
// 0x0018 (0x0018 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_SetUsingInCaveOrIndoorShadow final
{
public:
	class UDirectionalLightComponent*             LightComp;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsUsing;                                           // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MobileCSMDistanceOld;                              // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MobileCSMDistanceNew;                              // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_SetUsingInCaveOrIndoorShadow) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_SetUsingInCaveOrIndoorShadow");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_SetUsingInCaveOrIndoorShadow) == 0x000018, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_SetUsingInCaveOrIndoorShadow");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_SetUsingInCaveOrIndoorShadow, LightComp) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_SetUsingInCaveOrIndoorShadow::LightComp' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_SetUsingInCaveOrIndoorShadow, IsUsing) == 0x000008, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_SetUsingInCaveOrIndoorShadow::IsUsing' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_SetUsingInCaveOrIndoorShadow, MobileCSMDistanceOld) == 0x00000C, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_SetUsingInCaveOrIndoorShadow::MobileCSMDistanceOld' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_SetUsingInCaveOrIndoorShadow, MobileCSMDistanceNew) == 0x000010, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_SetUsingInCaveOrIndoorShadow::MobileCSMDistanceNew' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.SetVectorParameterValueRef
// 0x0030 (0x0030 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_SetVectorParameterValueRef final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialParameterCollection*           Collection;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ParameterName;                                     // 0x0010(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           RefLinearColor;                                    // 0x001C(0x0010)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_SetVectorParameterValueRef) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_SetVectorParameterValueRef");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_SetVectorParameterValueRef) == 0x000030, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_SetVectorParameterValueRef");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_SetVectorParameterValueRef, WorldContextObject) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_SetVectorParameterValueRef::WorldContextObject' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_SetVectorParameterValueRef, Collection) == 0x000008, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_SetVectorParameterValueRef::Collection' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_SetVectorParameterValueRef, ParameterName) == 0x000010, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_SetVectorParameterValueRef::ParameterName' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_SetVectorParameterValueRef, RefLinearColor) == 0x00001C, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_SetVectorParameterValueRef::RefLinearColor' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.SetVulkanPromotion
// 0x0001 (0x0001 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_SetVulkanPromotion final
{
public:
	bool                                          promot;                                            // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_SetVulkanPromotion) == 0x000001, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_SetVulkanPromotion");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_SetVulkanPromotion) == 0x000001, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_SetVulkanPromotion");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_SetVulkanPromotion, promot) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_SetVulkanPromotion::promot' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.SetWorldOrigin
// 0x0020 (0x0020 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_SetWorldOrigin final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVectorDouble                          InNewOrigin;                                       // 0x0008(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_SetWorldOrigin) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_SetWorldOrigin");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_SetWorldOrigin) == 0x000020, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_SetWorldOrigin");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_SetWorldOrigin, WorldContextObject) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_SetWorldOrigin::WorldContextObject' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_SetWorldOrigin, InNewOrigin) == 0x000008, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_SetWorldOrigin::InNewOrigin' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.SetWorldPartitionDataLayerState
// 0x0018 (0x0018 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_SetWorldPartitionDataLayerState final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   DataLayerName;                                     // 0x0008(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsActivate;                                        // 0x0014(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_SetWorldPartitionDataLayerState) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_SetWorldPartitionDataLayerState");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_SetWorldPartitionDataLayerState) == 0x000018, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_SetWorldPartitionDataLayerState");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_SetWorldPartitionDataLayerState, WorldContextObject) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_SetWorldPartitionDataLayerState::WorldContextObject' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_SetWorldPartitionDataLayerState, DataLayerName) == 0x000008, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_SetWorldPartitionDataLayerState::DataLayerName' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_SetWorldPartitionDataLayerState, IsActivate) == 0x000014, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_SetWorldPartitionDataLayerState::IsActivate' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.SetWorldPartitionStreamingEnable
// 0x0010 (0x0010 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_SetWorldPartitionStreamingEnable final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStreamingEnable;                                  // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_SetWorldPartitionStreamingEnable) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_SetWorldPartitionStreamingEnable");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_SetWorldPartitionStreamingEnable) == 0x000010, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_SetWorldPartitionStreamingEnable");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_SetWorldPartitionStreamingEnable, WorldContextObject) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_SetWorldPartitionStreamingEnable::WorldContextObject' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_SetWorldPartitionStreamingEnable, bStreamingEnable) == 0x000008, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_SetWorldPartitionStreamingEnable::bStreamingEnable' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.solve
// 0x0038 (0x0038 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_solve final
{
public:
	struct FVector                                pos;                                               // 0x0000(0x000C)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                linkPos;                                           // 0x000C(0x000C)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         targetLen;                                         // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                emiterOriginPos;                                   // 0x001C(0x000C)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          isPinned;                                          // 0x0028(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x3];                                       // 0x0029(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                ReturnValue;                                       // 0x002C(0x000C)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_solve) == 0x000004, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_solve");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_solve) == 0x000038, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_solve");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_solve, pos) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_solve::pos' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_solve, linkPos) == 0x00000C, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_solve::linkPos' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_solve, targetLen) == 0x000018, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_solve::targetLen' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_solve, emiterOriginPos) == 0x00001C, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_solve::emiterOriginPos' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_solve, isPinned) == 0x000028, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_solve::isPinned' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_solve, ReturnValue) == 0x00002C, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_solve::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.SortStringArray
// 0x0018 (0x0018 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_SortStringArray final
{
public:
	TArray<class FString>                         InStringArray;                                     // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	ESearchCase                                   SearchCase;                                        // 0x0010(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Descending;                                        // 0x0011(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12[0x6];                                       // 0x0012(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_SortStringArray) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_SortStringArray");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_SortStringArray) == 0x000018, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_SortStringArray");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_SortStringArray, InStringArray) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_SortStringArray::InStringArray' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_SortStringArray, SearchCase) == 0x000010, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_SortStringArray::SearchCase' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_SortStringArray, Descending) == 0x000011, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_SortStringArray::Descending' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.SpawnActorFromClass
// 0x0070 (0x0070 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_SpawnActorFromClass final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AActor>                     ActorClass;                                        // 0x0008(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTransform                             SpawnTransform;                                    // 0x0010(0x0030)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	ESpawnActorCollisionHandlingMethod            CollisionHandlingOverride;                         // 0x0040(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 Owner;                                             // 0x0048(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class APawn*                                  Instigator;                                        // 0x0050(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTemporaryEditorActor;                             // 0x0058(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_59[0x7];                                       // 0x0059(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 ReturnValue;                                       // 0x0060(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_68[0x8];                                       // 0x0068(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_SpawnActorFromClass) == 0x000010, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_SpawnActorFromClass");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_SpawnActorFromClass) == 0x000070, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_SpawnActorFromClass");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_SpawnActorFromClass, WorldContextObject) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_SpawnActorFromClass::WorldContextObject' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_SpawnActorFromClass, ActorClass) == 0x000008, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_SpawnActorFromClass::ActorClass' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_SpawnActorFromClass, SpawnTransform) == 0x000010, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_SpawnActorFromClass::SpawnTransform' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_SpawnActorFromClass, CollisionHandlingOverride) == 0x000040, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_SpawnActorFromClass::CollisionHandlingOverride' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_SpawnActorFromClass, Owner) == 0x000048, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_SpawnActorFromClass::Owner' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_SpawnActorFromClass, Instigator) == 0x000050, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_SpawnActorFromClass::Instigator' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_SpawnActorFromClass, bTemporaryEditorActor) == 0x000058, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_SpawnActorFromClass::bTemporaryEditorActor' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_SpawnActorFromClass, ReturnValue) == 0x000060, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_SpawnActorFromClass::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.SpawnTransientActor
// 0x0028 (0x0028 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_SpawnTransientActor final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Name_0;                                            // 0x0008(0x000C)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   FolderPath;                                        // 0x0014(0x000C)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 ReturnValue;                                       // 0x0020(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_SpawnTransientActor) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_SpawnTransientActor");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_SpawnTransientActor) == 0x000028, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_SpawnTransientActor");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_SpawnTransientActor, WorldContextObject) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_SpawnTransientActor::WorldContextObject' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_SpawnTransientActor, Name_0) == 0x000008, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_SpawnTransientActor::Name_0' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_SpawnTransientActor, FolderPath) == 0x000014, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_SpawnTransientActor::FolderPath' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_SpawnTransientActor, ReturnValue) == 0x000020, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_SpawnTransientActor::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.StartSceneColorShotBeforeTonemap
// 0x0001 (0x0001 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_StartSceneColorShotBeforeTonemap final
{
public:
	EKuroCaptureSceneColorType                    Type;                                              // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_StartSceneColorShotBeforeTonemap) == 0x000001, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_StartSceneColorShotBeforeTonemap");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_StartSceneColorShotBeforeTonemap) == 0x000001, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_StartSceneColorShotBeforeTonemap");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_StartSceneColorShotBeforeTonemap, Type) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_StartSceneColorShotBeforeTonemap::Type' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.StopSceneColorShotBeforeTonemap
// 0x0008 (0x0008 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_StopSceneColorShotBeforeTonemap final
{
public:
	EKuroCaptureSceneColorType                    Type;                                              // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         HoldSeconds;                                       // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_StopSceneColorShotBeforeTonemap) == 0x000004, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_StopSceneColorShotBeforeTonemap");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_StopSceneColorShotBeforeTonemap) == 0x000008, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_StopSceneColorShotBeforeTonemap");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_StopSceneColorShotBeforeTonemap, Type) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_StopSceneColorShotBeforeTonemap::Type' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_StopSceneColorShotBeforeTonemap, HoldSeconds) == 0x000004, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_StopSceneColorShotBeforeTonemap::HoldSeconds' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.StopSomeWeatherBeforeTeleport
// 0x0008 (0x0008 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_StopSomeWeatherBeforeTeleport final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_StopSomeWeatherBeforeTeleport) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_StopSomeWeatherBeforeTeleport");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_StopSomeWeatherBeforeTeleport) == 0x000008, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_StopSomeWeatherBeforeTeleport");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_StopSomeWeatherBeforeTeleport, WorldContextObject) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_StopSomeWeatherBeforeTeleport::WorldContextObject' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.SupportVulkan
// 0x0001 (0x0001 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_SupportVulkan final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_SupportVulkan) == 0x000001, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_SupportVulkan");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_SupportVulkan) == 0x000001, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_SupportVulkan");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_SupportVulkan, ReturnValue) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_SupportVulkan::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.UnFreezeWorldLevelStreaming
// 0x0008 (0x0008 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_UnFreezeWorldLevelStreaming final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_UnFreezeWorldLevelStreaming) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_UnFreezeWorldLevelStreaming");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_UnFreezeWorldLevelStreaming) == 0x000008, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_UnFreezeWorldLevelStreaming");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_UnFreezeWorldLevelStreaming, WorldContextObject) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_UnFreezeWorldLevelStreaming::WorldContextObject' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.UnpackVector2DToLinearColorRGB
// 0x0018 (0x0018 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_UnpackVector2DToLinearColorRGB final
{
public:
	struct FVector2D                              Vector2D;                                          // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           ReturnValue;                                       // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_UnpackVector2DToLinearColorRGB) == 0x000004, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_UnpackVector2DToLinearColorRGB");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_UnpackVector2DToLinearColorRGB) == 0x000018, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_UnpackVector2DToLinearColorRGB");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_UnpackVector2DToLinearColorRGB, Vector2D) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_UnpackVector2DToLinearColorRGB::Vector2D' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_UnpackVector2DToLinearColorRGB, ReturnValue) == 0x000008, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_UnpackVector2DToLinearColorRGB::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.UpdateEffectTransform
// 0x0510 (0x0510 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_UpdateEffectTransform final
{
public:
	bool                                          ForceUpdate;                                       // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class USceneComponent*                        SceneComponent;                                    // 0x0008(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FKuroCurveVector                       LocationCurve;                                     // 0x0010(0x01A8)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FKuroCurveVector                       RotationCurve;                                     // 0x01B8(0x01A8)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FKuroCurveVector                       ScaleCurve;                                        // 0x0360(0x01A8)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	float                                         Time;                                              // 0x0508(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_50C[0x4];                                      // 0x050C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_UpdateEffectTransform) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_UpdateEffectTransform");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_UpdateEffectTransform) == 0x000510, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_UpdateEffectTransform");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_UpdateEffectTransform, ForceUpdate) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_UpdateEffectTransform::ForceUpdate' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_UpdateEffectTransform, SceneComponent) == 0x000008, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_UpdateEffectTransform::SceneComponent' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_UpdateEffectTransform, LocationCurve) == 0x000010, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_UpdateEffectTransform::LocationCurve' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_UpdateEffectTransform, RotationCurve) == 0x0001B8, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_UpdateEffectTransform::RotationCurve' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_UpdateEffectTransform, ScaleCurve) == 0x000360, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_UpdateEffectTransform::ScaleCurve' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_UpdateEffectTransform, Time) == 0x000508, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_UpdateEffectTransform::Time' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.UpdateEffectTransformLocation
// 0x01C0 (0x01C0 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_UpdateEffectTransformLocation final
{
public:
	bool                                          ForceUpdate;                                       // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class USceneComponent*                        SceneComponent;                                    // 0x0008(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FKuroCurveVector                       LocationCurve;                                     // 0x0010(0x01A8)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	float                                         Time;                                              // 0x01B8(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1BC[0x4];                                      // 0x01BC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_UpdateEffectTransformLocation) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_UpdateEffectTransformLocation");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_UpdateEffectTransformLocation) == 0x0001C0, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_UpdateEffectTransformLocation");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_UpdateEffectTransformLocation, ForceUpdate) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_UpdateEffectTransformLocation::ForceUpdate' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_UpdateEffectTransformLocation, SceneComponent) == 0x000008, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_UpdateEffectTransformLocation::SceneComponent' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_UpdateEffectTransformLocation, LocationCurve) == 0x000010, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_UpdateEffectTransformLocation::LocationCurve' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_UpdateEffectTransformLocation, Time) == 0x0001B8, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_UpdateEffectTransformLocation::Time' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.UpdateFoliageDataLayer
// 0x0010 (0x0010 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_UpdateFoliageDataLayer final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InMobileLevel;                                     // 0x0008(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_UpdateFoliageDataLayer) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_UpdateFoliageDataLayer");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_UpdateFoliageDataLayer) == 0x000010, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_UpdateFoliageDataLayer");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_UpdateFoliageDataLayer, WorldContextObject) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_UpdateFoliageDataLayer::WorldContextObject' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_UpdateFoliageDataLayer, InMobileLevel) == 0x000008, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_UpdateFoliageDataLayer::InMobileLevel' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.UpdateOrAddCurveColorValue
// 0x0020 (0x0020 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_UpdateOrAddCurveColorValue final
{
public:
	class UCurveLinearColor*                      Curve;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InTime;                                            // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           InValue;                                           // 0x000C(0x0010)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_UpdateOrAddCurveColorValue) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_UpdateOrAddCurveColorValue");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_UpdateOrAddCurveColorValue) == 0x000020, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_UpdateOrAddCurveColorValue");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_UpdateOrAddCurveColorValue, Curve) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_UpdateOrAddCurveColorValue::Curve' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_UpdateOrAddCurveColorValue, InTime) == 0x000008, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_UpdateOrAddCurveColorValue::InTime' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_UpdateOrAddCurveColorValue, InValue) == 0x00000C, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_UpdateOrAddCurveColorValue::InValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.UpdateOrAddCurveFloatValue
// 0x0010 (0x0010 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_UpdateOrAddCurveFloatValue final
{
public:
	class UCurveFloat*                            Curve;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InTime;                                            // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InValue;                                           // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_UpdateOrAddCurveFloatValue) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_UpdateOrAddCurveFloatValue");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_UpdateOrAddCurveFloatValue) == 0x000010, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_UpdateOrAddCurveFloatValue");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_UpdateOrAddCurveFloatValue, Curve) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_UpdateOrAddCurveFloatValue::Curve' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_UpdateOrAddCurveFloatValue, InTime) == 0x000008, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_UpdateOrAddCurveFloatValue::InTime' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_UpdateOrAddCurveFloatValue, InValue) == 0x00000C, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_UpdateOrAddCurveFloatValue::InValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.VolumeSphereInWater
// 0x001C (0x001C - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_VolumeSphereInWater final
{
public:
	struct FVector                                Pos;                                               // 0x0000(0x000C)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Radius;                                            // 0x000C(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WaterHeight;                                       // 0x0010(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              ReturnValue;                                       // 0x0014(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_VolumeSphereInWater) == 0x000004, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_VolumeSphereInWater");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_VolumeSphereInWater) == 0x00001C, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_VolumeSphereInWater");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_VolumeSphereInWater, Pos) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_VolumeSphereInWater::Pos' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_VolumeSphereInWater, Radius) == 0x00000C, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_VolumeSphereInWater::Radius' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_VolumeSphereInWater, WaterHeight) == 0x000010, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_VolumeSphereInWater::WaterHeight' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_VolumeSphereInWater, ReturnValue) == 0x000014, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_VolumeSphereInWater::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.WpBeginAdjustLoadRange
// 0x0010 (0x0010 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_WpBeginAdjustLoadRange final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InAdjustValue;                                     // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECaveOrRoomLoadType                           InLoadType;                                        // 0x000C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseCustomCoef;                                    // 0x000D(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E[0x2];                                        // 0x000E(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_WpBeginAdjustLoadRange) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_WpBeginAdjustLoadRange");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_WpBeginAdjustLoadRange) == 0x000010, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_WpBeginAdjustLoadRange");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_WpBeginAdjustLoadRange, WorldContextObject) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_WpBeginAdjustLoadRange::WorldContextObject' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_WpBeginAdjustLoadRange, InAdjustValue) == 0x000008, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_WpBeginAdjustLoadRange::InAdjustValue' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_WpBeginAdjustLoadRange, InLoadType) == 0x00000C, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_WpBeginAdjustLoadRange::InLoadType' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_WpBeginAdjustLoadRange, bUseCustomCoef) == 0x00000D, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_WpBeginAdjustLoadRange::bUseCustomCoef' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.WpBeginEnterCaveOrRoom
// 0x0020 (0x0020 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_WpBeginEnterCaveOrRoom final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   EncloseDataLayer;                                  // 0x0008(0x000C)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   EncloseSubDataLayer;                               // 0x0014(0x000C)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_WpBeginEnterCaveOrRoom) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_WpBeginEnterCaveOrRoom");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_WpBeginEnterCaveOrRoom) == 0x000020, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_WpBeginEnterCaveOrRoom");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_WpBeginEnterCaveOrRoom, WorldContextObject) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_WpBeginEnterCaveOrRoom::WorldContextObject' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_WpBeginEnterCaveOrRoom, EncloseDataLayer) == 0x000008, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_WpBeginEnterCaveOrRoom::EncloseDataLayer' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_WpBeginEnterCaveOrRoom, EncloseSubDataLayer) == 0x000014, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_WpBeginEnterCaveOrRoom::EncloseSubDataLayer' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.WpBeginLeaveCaveOrRoom
// 0x0020 (0x0020 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_WpBeginLeaveCaveOrRoom final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   EncloseDataLayer;                                  // 0x0008(0x000C)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   EncloseSubDataLayer;                               // 0x0014(0x000C)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_WpBeginLeaveCaveOrRoom) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_WpBeginLeaveCaveOrRoom");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_WpBeginLeaveCaveOrRoom) == 0x000020, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_WpBeginLeaveCaveOrRoom");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_WpBeginLeaveCaveOrRoom, WorldContextObject) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_WpBeginLeaveCaveOrRoom::WorldContextObject' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_WpBeginLeaveCaveOrRoom, EncloseDataLayer) == 0x000008, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_WpBeginLeaveCaveOrRoom::EncloseDataLayer' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_WpBeginLeaveCaveOrRoom, EncloseSubDataLayer) == 0x000014, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_WpBeginLeaveCaveOrRoom::EncloseSubDataLayer' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.WpCancelAdjustLoadRange
// 0x0008 (0x0008 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_WpCancelAdjustLoadRange final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_WpCancelAdjustLoadRange) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_WpCancelAdjustLoadRange");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_WpCancelAdjustLoadRange) == 0x000008, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_WpCancelAdjustLoadRange");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_WpCancelAdjustLoadRange, WorldContextObject) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_WpCancelAdjustLoadRange::WorldContextObject' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.WpEnterCaveOrRoom
// 0x0028 (0x0028 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_WpEnterCaveOrRoom final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   EncloseDataLayer;                                  // 0x0008(0x000C)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   EncloseSubDataLayer;                               // 0x0014(0x000C)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InAdjustValue;                                     // 0x0020(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECaveOrRoomLoadType                           LoadType;                                          // 0x0024(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseCustomCoef;                                    // 0x0025(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_26[0x2];                                       // 0x0026(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_WpEnterCaveOrRoom) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_WpEnterCaveOrRoom");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_WpEnterCaveOrRoom) == 0x000028, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_WpEnterCaveOrRoom");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_WpEnterCaveOrRoom, WorldContextObject) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_WpEnterCaveOrRoom::WorldContextObject' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_WpEnterCaveOrRoom, EncloseDataLayer) == 0x000008, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_WpEnterCaveOrRoom::EncloseDataLayer' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_WpEnterCaveOrRoom, EncloseSubDataLayer) == 0x000014, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_WpEnterCaveOrRoom::EncloseSubDataLayer' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_WpEnterCaveOrRoom, InAdjustValue) == 0x000020, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_WpEnterCaveOrRoom::InAdjustValue' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_WpEnterCaveOrRoom, LoadType) == 0x000024, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_WpEnterCaveOrRoom::LoadType' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_WpEnterCaveOrRoom, bUseCustomCoef) == 0x000025, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_WpEnterCaveOrRoom::bUseCustomCoef' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.WpLeaveCaveOrRoom
// 0x0020 (0x0020 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_WpLeaveCaveOrRoom final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   EncloseDataLayer;                                  // 0x0008(0x000C)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   EncloseSubDataLayer;                               // 0x0014(0x000C)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_WpLeaveCaveOrRoom) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_WpLeaveCaveOrRoom");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_WpLeaveCaveOrRoom) == 0x000020, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_WpLeaveCaveOrRoom");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_WpLeaveCaveOrRoom, WorldContextObject) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_WpLeaveCaveOrRoom::WorldContextObject' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_WpLeaveCaveOrRoom, EncloseDataLayer) == 0x000008, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_WpLeaveCaveOrRoom::EncloseDataLayer' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_WpLeaveCaveOrRoom, EncloseSubDataLayer) == 0x000014, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_WpLeaveCaveOrRoom::EncloseSubDataLayer' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.WpPEnterCaveOrRoom
// 0x0020 (0x0020 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_WpPEnterCaveOrRoom final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   EncloseDataLayer;                                  // 0x0008(0x000C)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   EncloseSubDataLayer;                               // 0x0014(0x000C)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_WpPEnterCaveOrRoom) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_WpPEnterCaveOrRoom");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_WpPEnterCaveOrRoom) == 0x000020, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_WpPEnterCaveOrRoom");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_WpPEnterCaveOrRoom, WorldContextObject) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_WpPEnterCaveOrRoom::WorldContextObject' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_WpPEnterCaveOrRoom, EncloseDataLayer) == 0x000008, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_WpPEnterCaveOrRoom::EncloseDataLayer' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_WpPEnterCaveOrRoom, EncloseSubDataLayer) == 0x000014, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_WpPEnterCaveOrRoom::EncloseSubDataLayer' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroSceneEffectActor.GetIsWorldPartitionActor
// 0x0001 (0x0001 - 0x0000)
struct KuroSceneEffectActor_GetIsWorldPartitionActor final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroSceneEffectActor_GetIsWorldPartitionActor) == 0x000001, "Wrong alignment on KuroSceneEffectActor_GetIsWorldPartitionActor");
static_assert(sizeof(KuroSceneEffectActor_GetIsWorldPartitionActor) == 0x000001, "Wrong size on KuroSceneEffectActor_GetIsWorldPartitionActor");
static_assert(offsetof(KuroSceneEffectActor_GetIsWorldPartitionActor, ReturnValue) == 0x000000, "Member 'KuroSceneEffectActor_GetIsWorldPartitionActor::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroSceneInteractionActor.OnSetState
// 0x0002 (0x0002 - 0x0000)
struct KuroSceneInteractionActor_OnSetState final
{
public:
	EKuroSceneInteractionState                    TargetState;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          NeedTransition;                                    // 0x0001(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroSceneInteractionActor_OnSetState) == 0x000001, "Wrong alignment on KuroSceneInteractionActor_OnSetState");
static_assert(sizeof(KuroSceneInteractionActor_OnSetState) == 0x000002, "Wrong size on KuroSceneInteractionActor_OnSetState");
static_assert(offsetof(KuroSceneInteractionActor_OnSetState, TargetState) == 0x000000, "Member 'KuroSceneInteractionActor_OnSetState::TargetState' has a wrong offset!");
static_assert(offsetof(KuroSceneInteractionActor_OnSetState, NeedTransition) == 0x000001, "Member 'KuroSceneInteractionActor_OnSetState::NeedTransition' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroSceneInteractionMatConManager.RemoveMatConData
// 0x0004 (0x0004 - 0x0000)
struct KuroSceneInteractionMatConManager_RemoveMatConData final
{
public:
	int32                                         Uid;                                               // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroSceneInteractionMatConManager_RemoveMatConData) == 0x000004, "Wrong alignment on KuroSceneInteractionMatConManager_RemoveMatConData");
static_assert(sizeof(KuroSceneInteractionMatConManager_RemoveMatConData) == 0x000004, "Wrong size on KuroSceneInteractionMatConManager_RemoveMatConData");
static_assert(offsetof(KuroSceneInteractionMatConManager_RemoveMatConData, Uid) == 0x000000, "Member 'KuroSceneInteractionMatConManager_RemoveMatConData::Uid' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroSceneInteractionMatConManager.RemoveMatConDataWithStaticMesh
// 0x0008 (0x0008 - 0x0000)
struct KuroSceneInteractionMatConManager_RemoveMatConDataWithStaticMesh final
{
public:
	class UStaticMeshComponent*                   StaticMeshComponent;                               // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroSceneInteractionMatConManager_RemoveMatConDataWithStaticMesh) == 0x000008, "Wrong alignment on KuroSceneInteractionMatConManager_RemoveMatConDataWithStaticMesh");
static_assert(sizeof(KuroSceneInteractionMatConManager_RemoveMatConDataWithStaticMesh) == 0x000008, "Wrong size on KuroSceneInteractionMatConManager_RemoveMatConDataWithStaticMesh");
static_assert(offsetof(KuroSceneInteractionMatConManager_RemoveMatConDataWithStaticMesh, StaticMeshComponent) == 0x000000, "Member 'KuroSceneInteractionMatConManager_RemoveMatConDataWithStaticMesh::StaticMeshComponent' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroSceneInteractionMatConManager.SetMatConData
// 0x0010 (0x0010 - 0x0000)
struct KuroSceneInteractionMatConManager_SetMatConData final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UKuroSceneInteractionMatConDataCache*   DataCache;                                         // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroSceneInteractionMatConManager_SetMatConData) == 0x000008, "Wrong alignment on KuroSceneInteractionMatConManager_SetMatConData");
static_assert(sizeof(KuroSceneInteractionMatConManager_SetMatConData) == 0x000010, "Wrong size on KuroSceneInteractionMatConManager_SetMatConData");
static_assert(offsetof(KuroSceneInteractionMatConManager_SetMatConData, Actor) == 0x000000, "Member 'KuroSceneInteractionMatConManager_SetMatConData::Actor' has a wrong offset!");
static_assert(offsetof(KuroSceneInteractionMatConManager_SetMatConData, DataCache) == 0x000008, "Member 'KuroSceneInteractionMatConManager_SetMatConData::DataCache' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroSceneInteractionActorSystem.BindActorToLevelSequenceActor
// 0x0020 (0x0020 - 0x0000)
struct KuroSceneInteractionActorSystem_BindActorToLevelSequenceActor final
{
public:
	class AActor*                                 ActorToBind;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ALevelSequenceActor*                    LevelSequenceActor;                                // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 BindingName;                                       // 0x0010(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroSceneInteractionActorSystem_BindActorToLevelSequenceActor) == 0x000008, "Wrong alignment on KuroSceneInteractionActorSystem_BindActorToLevelSequenceActor");
static_assert(sizeof(KuroSceneInteractionActorSystem_BindActorToLevelSequenceActor) == 0x000020, "Wrong size on KuroSceneInteractionActorSystem_BindActorToLevelSequenceActor");
static_assert(offsetof(KuroSceneInteractionActorSystem_BindActorToLevelSequenceActor, ActorToBind) == 0x000000, "Member 'KuroSceneInteractionActorSystem_BindActorToLevelSequenceActor::ActorToBind' has a wrong offset!");
static_assert(offsetof(KuroSceneInteractionActorSystem_BindActorToLevelSequenceActor, LevelSequenceActor) == 0x000008, "Member 'KuroSceneInteractionActorSystem_BindActorToLevelSequenceActor::LevelSequenceActor' has a wrong offset!");
static_assert(offsetof(KuroSceneInteractionActorSystem_BindActorToLevelSequenceActor, BindingName) == 0x000010, "Member 'KuroSceneInteractionActorSystem_BindActorToLevelSequenceActor::BindingName' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroSceneInteractionActorSystem.CreateSceneInteractionLevel
// 0x0030 (0x0030 - 0x0000)
struct KuroSceneInteractionActorSystem_CreateSceneInteractionLevel final
{
public:
	class FString                                 InLevelName;                                       // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EKuroSceneInteractionState                    InitState;                                         // 0x0010(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                Location;                                          // 0x0014(0x000C)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               Rotation;                                          // 0x0020(0x000C)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x002C(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroSceneInteractionActorSystem_CreateSceneInteractionLevel) == 0x000008, "Wrong alignment on KuroSceneInteractionActorSystem_CreateSceneInteractionLevel");
static_assert(sizeof(KuroSceneInteractionActorSystem_CreateSceneInteractionLevel) == 0x000030, "Wrong size on KuroSceneInteractionActorSystem_CreateSceneInteractionLevel");
static_assert(offsetof(KuroSceneInteractionActorSystem_CreateSceneInteractionLevel, InLevelName) == 0x000000, "Member 'KuroSceneInteractionActorSystem_CreateSceneInteractionLevel::InLevelName' has a wrong offset!");
static_assert(offsetof(KuroSceneInteractionActorSystem_CreateSceneInteractionLevel, InitState) == 0x000010, "Member 'KuroSceneInteractionActorSystem_CreateSceneInteractionLevel::InitState' has a wrong offset!");
static_assert(offsetof(KuroSceneInteractionActorSystem_CreateSceneInteractionLevel, Location) == 0x000014, "Member 'KuroSceneInteractionActorSystem_CreateSceneInteractionLevel::Location' has a wrong offset!");
static_assert(offsetof(KuroSceneInteractionActorSystem_CreateSceneInteractionLevel, Rotation) == 0x000020, "Member 'KuroSceneInteractionActorSystem_CreateSceneInteractionLevel::Rotation' has a wrong offset!");
static_assert(offsetof(KuroSceneInteractionActorSystem_CreateSceneInteractionLevel, ReturnValue) == 0x00002C, "Member 'KuroSceneInteractionActorSystem_CreateSceneInteractionLevel::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroSceneInteractionActorSystem.DestroySceneInteractionLevel
// 0x0008 (0x0008 - 0x0000)
struct KuroSceneInteractionActorSystem_DestroySceneInteractionLevel final
{
public:
	int32                                         HandleId;                                          // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0004(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroSceneInteractionActorSystem_DestroySceneInteractionLevel) == 0x000004, "Wrong alignment on KuroSceneInteractionActorSystem_DestroySceneInteractionLevel");
static_assert(sizeof(KuroSceneInteractionActorSystem_DestroySceneInteractionLevel) == 0x000008, "Wrong size on KuroSceneInteractionActorSystem_DestroySceneInteractionLevel");
static_assert(offsetof(KuroSceneInteractionActorSystem_DestroySceneInteractionLevel, HandleId) == 0x000000, "Member 'KuroSceneInteractionActorSystem_DestroySceneInteractionLevel::HandleId' has a wrong offset!");
static_assert(offsetof(KuroSceneInteractionActorSystem_DestroySceneInteractionLevel, ReturnValue) == 0x000004, "Member 'KuroSceneInteractionActorSystem_DestroySceneInteractionLevel::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroSceneInteractionActorSystem.GetCurrentState
// 0x0008 (0x0008 - 0x0000)
struct KuroSceneInteractionActorSystem_GetCurrentState final
{
public:
	int32                                         HandleId;                                          // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EKuroSceneInteractionState                    ReturnValue;                                       // 0x0004(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroSceneInteractionActorSystem_GetCurrentState) == 0x000004, "Wrong alignment on KuroSceneInteractionActorSystem_GetCurrentState");
static_assert(sizeof(KuroSceneInteractionActorSystem_GetCurrentState) == 0x000008, "Wrong size on KuroSceneInteractionActorSystem_GetCurrentState");
static_assert(offsetof(KuroSceneInteractionActorSystem_GetCurrentState, HandleId) == 0x000000, "Member 'KuroSceneInteractionActorSystem_GetCurrentState::HandleId' has a wrong offset!");
static_assert(offsetof(KuroSceneInteractionActorSystem_GetCurrentState, ReturnValue) == 0x000004, "Member 'KuroSceneInteractionActorSystem_GetCurrentState::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroSceneInteractionActorSystem.SetSequenceWithTargetLevelActor
// 0x0018 (0x0018 - 0x0000)
struct KuroSceneInteractionActorSystem_SetSequenceWithTargetLevelActor final
{
public:
	class ALevelSequenceActor*                    LevelSequenceActor;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ULevelSequence*                         InSequence;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 TargetLevelActor;                                  // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroSceneInteractionActorSystem_SetSequenceWithTargetLevelActor) == 0x000008, "Wrong alignment on KuroSceneInteractionActorSystem_SetSequenceWithTargetLevelActor");
static_assert(sizeof(KuroSceneInteractionActorSystem_SetSequenceWithTargetLevelActor) == 0x000018, "Wrong size on KuroSceneInteractionActorSystem_SetSequenceWithTargetLevelActor");
static_assert(offsetof(KuroSceneInteractionActorSystem_SetSequenceWithTargetLevelActor, LevelSequenceActor) == 0x000000, "Member 'KuroSceneInteractionActorSystem_SetSequenceWithTargetLevelActor::LevelSequenceActor' has a wrong offset!");
static_assert(offsetof(KuroSceneInteractionActorSystem_SetSequenceWithTargetLevelActor, InSequence) == 0x000008, "Member 'KuroSceneInteractionActorSystem_SetSequenceWithTargetLevelActor::InSequence' has a wrong offset!");
static_assert(offsetof(KuroSceneInteractionActorSystem_SetSequenceWithTargetLevelActor, TargetLevelActor) == 0x000010, "Member 'KuroSceneInteractionActorSystem_SetSequenceWithTargetLevelActor::TargetLevelActor' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroSceneInteractionActorSystem.SwitchToState
// 0x0008 (0x0008 - 0x0000)
struct KuroSceneInteractionActorSystem_SwitchToState final
{
public:
	int32                                         HandleId;                                          // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EKuroSceneInteractionState                    TargetState;                                       // 0x0004(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          NeedTransition;                                    // 0x0005(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0006(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7[0x1];                                        // 0x0007(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroSceneInteractionActorSystem_SwitchToState) == 0x000004, "Wrong alignment on KuroSceneInteractionActorSystem_SwitchToState");
static_assert(sizeof(KuroSceneInteractionActorSystem_SwitchToState) == 0x000008, "Wrong size on KuroSceneInteractionActorSystem_SwitchToState");
static_assert(offsetof(KuroSceneInteractionActorSystem_SwitchToState, HandleId) == 0x000000, "Member 'KuroSceneInteractionActorSystem_SwitchToState::HandleId' has a wrong offset!");
static_assert(offsetof(KuroSceneInteractionActorSystem_SwitchToState, TargetState) == 0x000004, "Member 'KuroSceneInteractionActorSystem_SwitchToState::TargetState' has a wrong offset!");
static_assert(offsetof(KuroSceneInteractionActorSystem_SwitchToState, NeedTransition) == 0x000005, "Member 'KuroSceneInteractionActorSystem_SwitchToState::NeedTransition' has a wrong offset!");
static_assert(offsetof(KuroSceneInteractionActorSystem_SwitchToState, ReturnValue) == 0x000006, "Member 'KuroSceneInteractionActorSystem_SwitchToState::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroSceneRainActor.SetCurrentRain
// 0x0014 (0x0014 - 0x0000)
struct KuroSceneRainActor_SetCurrentRain final
{
public:
	float                                         InDensity;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InGravity;                                         // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                InWindSpeed;                                       // 0x0008(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroSceneRainActor_SetCurrentRain) == 0x000004, "Wrong alignment on KuroSceneRainActor_SetCurrentRain");
static_assert(sizeof(KuroSceneRainActor_SetCurrentRain) == 0x000014, "Wrong size on KuroSceneRainActor_SetCurrentRain");
static_assert(offsetof(KuroSceneRainActor_SetCurrentRain, InDensity) == 0x000000, "Member 'KuroSceneRainActor_SetCurrentRain::InDensity' has a wrong offset!");
static_assert(offsetof(KuroSceneRainActor_SetCurrentRain, InGravity) == 0x000004, "Member 'KuroSceneRainActor_SetCurrentRain::InGravity' has a wrong offset!");
static_assert(offsetof(KuroSceneRainActor_SetCurrentRain, InWindSpeed) == 0x000008, "Member 'KuroSceneRainActor_SetCurrentRain::InWindSpeed' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroSequencePerformanceManager.ApplyVolumetricFogHighQualityMode
// 0x0010 (0x0010 - 0x0000)
struct KuroSequencePerformanceManager_ApplyVolumetricFogHighQualityMode final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UExponentialHeightFogComponent*         HeightFog;                                         // 0x0008(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroSequencePerformanceManager_ApplyVolumetricFogHighQualityMode) == 0x000008, "Wrong alignment on KuroSequencePerformanceManager_ApplyVolumetricFogHighQualityMode");
static_assert(sizeof(KuroSequencePerformanceManager_ApplyVolumetricFogHighQualityMode) == 0x000010, "Wrong size on KuroSequencePerformanceManager_ApplyVolumetricFogHighQualityMode");
static_assert(offsetof(KuroSequencePerformanceManager_ApplyVolumetricFogHighQualityMode, WorldContextObject) == 0x000000, "Member 'KuroSequencePerformanceManager_ApplyVolumetricFogHighQualityMode::WorldContextObject' has a wrong offset!");
static_assert(offsetof(KuroSequencePerformanceManager_ApplyVolumetricFogHighQualityMode, HeightFog) == 0x000008, "Member 'KuroSequencePerformanceManager_ApplyVolumetricFogHighQualityMode::HeightFog' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroSequencePerformanceManager.EditPerformanceConfiguration
// 0x0010 (0x0010 - 0x0000)
struct KuroSequencePerformanceManager_EditPerformanceConfiguration final
{
public:
	TArray<class FString>                         CmdArray;                                          // 0x0000(0x0010)(Parm, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroSequencePerformanceManager_EditPerformanceConfiguration) == 0x000008, "Wrong alignment on KuroSequencePerformanceManager_EditPerformanceConfiguration");
static_assert(sizeof(KuroSequencePerformanceManager_EditPerformanceConfiguration) == 0x000010, "Wrong size on KuroSequencePerformanceManager_EditPerformanceConfiguration");
static_assert(offsetof(KuroSequencePerformanceManager_EditPerformanceConfiguration, CmdArray) == 0x000000, "Member 'KuroSequencePerformanceManager_EditPerformanceConfiguration::CmdArray' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroSequencePerformanceManager.ExecuteCommandInPerformance
// 0x0010 (0x0010 - 0x0000)
struct KuroSequencePerformanceManager_ExecuteCommandInPerformance final
{
public:
	class FString                                 Command;                                           // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroSequencePerformanceManager_ExecuteCommandInPerformance) == 0x000008, "Wrong alignment on KuroSequencePerformanceManager_ExecuteCommandInPerformance");
static_assert(sizeof(KuroSequencePerformanceManager_ExecuteCommandInPerformance) == 0x000010, "Wrong size on KuroSequencePerformanceManager_ExecuteCommandInPerformance");
static_assert(offsetof(KuroSequencePerformanceManager_ExecuteCommandInPerformance, Command) == 0x000000, "Member 'KuroSequencePerformanceManager_ExecuteCommandInPerformance::Command' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroSequencePerformanceManager.GetPerformanceMode
// 0x0001 (0x0001 - 0x0000)
struct KuroSequencePerformanceManager_GetPerformanceMode final
{
public:
	EKuroPerformanceMode                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroSequencePerformanceManager_GetPerformanceMode) == 0x000001, "Wrong alignment on KuroSequencePerformanceManager_GetPerformanceMode");
static_assert(sizeof(KuroSequencePerformanceManager_GetPerformanceMode) == 0x000001, "Wrong size on KuroSequencePerformanceManager_GetPerformanceMode");
static_assert(offsetof(KuroSequencePerformanceManager_GetPerformanceMode, ReturnValue) == 0x000000, "Member 'KuroSequencePerformanceManager_GetPerformanceMode::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroSequencePerformanceManager.GetTotalPhysicalMemoryInPerformance
// 0x0008 (0x0008 - 0x0000)
struct KuroSequencePerformanceManager_GetTotalPhysicalMemoryInPerformance final
{
public:
	int64                                         ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroSequencePerformanceManager_GetTotalPhysicalMemoryInPerformance) == 0x000008, "Wrong alignment on KuroSequencePerformanceManager_GetTotalPhysicalMemoryInPerformance");
static_assert(sizeof(KuroSequencePerformanceManager_GetTotalPhysicalMemoryInPerformance) == 0x000008, "Wrong size on KuroSequencePerformanceManager_GetTotalPhysicalMemoryInPerformance");
static_assert(offsetof(KuroSequencePerformanceManager_GetTotalPhysicalMemoryInPerformance, ReturnValue) == 0x000000, "Member 'KuroSequencePerformanceManager_GetTotalPhysicalMemoryInPerformance::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroSequencePerformanceManager.IsLowMemoryDeviceInPerformance
// 0x0001 (0x0001 - 0x0000)
struct KuroSequencePerformanceManager_IsLowMemoryDeviceInPerformance final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroSequencePerformanceManager_IsLowMemoryDeviceInPerformance) == 0x000001, "Wrong alignment on KuroSequencePerformanceManager_IsLowMemoryDeviceInPerformance");
static_assert(sizeof(KuroSequencePerformanceManager_IsLowMemoryDeviceInPerformance) == 0x000001, "Wrong size on KuroSequencePerformanceManager_IsLowMemoryDeviceInPerformance");
static_assert(offsetof(KuroSequencePerformanceManager_IsLowMemoryDeviceInPerformance, ReturnValue) == 0x000000, "Member 'KuroSequencePerformanceManager_IsLowMemoryDeviceInPerformance::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroSequencePerformanceManager.OpenKuroPerformanceMode
// 0x0008 (0x0008 - 0x0000)
struct KuroSequencePerformanceManager_OpenKuroPerformanceMode final
{
public:
	class ULevelSequence*                         Sequence;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroSequencePerformanceManager_OpenKuroPerformanceMode) == 0x000008, "Wrong alignment on KuroSequencePerformanceManager_OpenKuroPerformanceMode");
static_assert(sizeof(KuroSequencePerformanceManager_OpenKuroPerformanceMode) == 0x000008, "Wrong size on KuroSequencePerformanceManager_OpenKuroPerformanceMode");
static_assert(offsetof(KuroSequencePerformanceManager_OpenKuroPerformanceMode, Sequence) == 0x000000, "Member 'KuroSequencePerformanceManager_OpenKuroPerformanceMode::Sequence' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroSequencePerformanceManager.OpenKuroPerformanceModeInPhotographModel
// 0x0008 (0x0008 - 0x0000)
struct KuroSequencePerformanceManager_OpenKuroPerformanceModeInPhotographModel final
{
public:
	class UKuroSequenceConsoleCommandDataAsset*   PhotographModelDA;                                 // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroSequencePerformanceManager_OpenKuroPerformanceModeInPhotographModel) == 0x000008, "Wrong alignment on KuroSequencePerformanceManager_OpenKuroPerformanceModeInPhotographModel");
static_assert(sizeof(KuroSequencePerformanceManager_OpenKuroPerformanceModeInPhotographModel) == 0x000008, "Wrong size on KuroSequencePerformanceManager_OpenKuroPerformanceModeInPhotographModel");
static_assert(offsetof(KuroSequencePerformanceManager_OpenKuroPerformanceModeInPhotographModel, PhotographModelDA) == 0x000000, "Member 'KuroSequencePerformanceManager_OpenKuroPerformanceModeInPhotographModel::PhotographModelDA' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroSequencePerformanceManager.SetPerformanceMode
// 0x0001 (0x0001 - 0x0000)
struct KuroSequencePerformanceManager_SetPerformanceMode final
{
public:
	EKuroPerformanceMode                          CurrentPerformanceMode;                            // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroSequencePerformanceManager_SetPerformanceMode) == 0x000001, "Wrong alignment on KuroSequencePerformanceManager_SetPerformanceMode");
static_assert(sizeof(KuroSequencePerformanceManager_SetPerformanceMode) == 0x000001, "Wrong size on KuroSequencePerformanceManager_SetPerformanceMode");
static_assert(offsetof(KuroSequencePerformanceManager_SetPerformanceMode, CurrentPerformanceMode) == 0x000000, "Member 'KuroSequencePerformanceManager_SetPerformanceMode::CurrentPerformanceMode' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroSequencePerformanceManager.SimpleExecuteCommand
// 0x0010 (0x0010 - 0x0000)
struct KuroSequencePerformanceManager_SimpleExecuteCommand final
{
public:
	class FString                                 Command;                                           // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroSequencePerformanceManager_SimpleExecuteCommand) == 0x000008, "Wrong alignment on KuroSequencePerformanceManager_SimpleExecuteCommand");
static_assert(sizeof(KuroSequencePerformanceManager_SimpleExecuteCommand) == 0x000010, "Wrong size on KuroSequencePerformanceManager_SimpleExecuteCommand");
static_assert(offsetof(KuroSequencePerformanceManager_SimpleExecuteCommand, Command) == 0x000000, "Member 'KuroSequencePerformanceManager_SimpleExecuteCommand::Command' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroSequencePoseComponent.AddSkeletalMeshComponent
// 0x0008 (0x0008 - 0x0000)
struct KuroSequencePoseComponent_AddSkeletalMeshComponent final
{
public:
	class USkeletalMeshComponent*                 InSkeletalMeshComponent;                           // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroSequencePoseComponent_AddSkeletalMeshComponent) == 0x000008, "Wrong alignment on KuroSequencePoseComponent_AddSkeletalMeshComponent");
static_assert(sizeof(KuroSequencePoseComponent_AddSkeletalMeshComponent) == 0x000008, "Wrong size on KuroSequencePoseComponent_AddSkeletalMeshComponent");
static_assert(offsetof(KuroSequencePoseComponent_AddSkeletalMeshComponent, InSkeletalMeshComponent) == 0x000000, "Member 'KuroSequencePoseComponent_AddSkeletalMeshComponent::InSkeletalMeshComponent' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroSequencePoseComponent.GetCurrentPoseNum
// 0x0004 (0x0004 - 0x0000)
struct KuroSequencePoseComponent_GetCurrentPoseNum final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroSequencePoseComponent_GetCurrentPoseNum) == 0x000004, "Wrong alignment on KuroSequencePoseComponent_GetCurrentPoseNum");
static_assert(sizeof(KuroSequencePoseComponent_GetCurrentPoseNum) == 0x000004, "Wrong size on KuroSequencePoseComponent_GetCurrentPoseNum");
static_assert(offsetof(KuroSequencePoseComponent_GetCurrentPoseNum, ReturnValue) == 0x000000, "Member 'KuroSequencePoseComponent_GetCurrentPoseNum::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroSmartLightActor.ApplyLightParametersToStaticMeshComponent
// 0x0008 (0x0008 - 0x0000)
struct KuroSmartLightActor_ApplyLightParametersToStaticMeshComponent final
{
public:
	class UStaticMeshComponent*                   Component;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroSmartLightActor_ApplyLightParametersToStaticMeshComponent) == 0x000008, "Wrong alignment on KuroSmartLightActor_ApplyLightParametersToStaticMeshComponent");
static_assert(sizeof(KuroSmartLightActor_ApplyLightParametersToStaticMeshComponent) == 0x000008, "Wrong size on KuroSmartLightActor_ApplyLightParametersToStaticMeshComponent");
static_assert(offsetof(KuroSmartLightActor_ApplyLightParametersToStaticMeshComponent, Component) == 0x000000, "Member 'KuroSmartLightActor_ApplyLightParametersToStaticMeshComponent::Component' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroSmartLightActor.OnUpdateLightOff
// 0x0004 (0x0004 - 0x0000)
struct KuroSmartLightActor_OnUpdateLightOff final
{
public:
	float                                         Time;                                              // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroSmartLightActor_OnUpdateLightOff) == 0x000004, "Wrong alignment on KuroSmartLightActor_OnUpdateLightOff");
static_assert(sizeof(KuroSmartLightActor_OnUpdateLightOff) == 0x000004, "Wrong size on KuroSmartLightActor_OnUpdateLightOff");
static_assert(offsetof(KuroSmartLightActor_OnUpdateLightOff, Time) == 0x000000, "Member 'KuroSmartLightActor_OnUpdateLightOff::Time' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroSmartLightActor.OnUpdateLightOn
// 0x0004 (0x0004 - 0x0000)
struct KuroSmartLightActor_OnUpdateLightOn final
{
public:
	float                                         Time;                                              // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroSmartLightActor_OnUpdateLightOn) == 0x000004, "Wrong alignment on KuroSmartLightActor_OnUpdateLightOn");
static_assert(sizeof(KuroSmartLightActor_OnUpdateLightOn) == 0x000004, "Wrong size on KuroSmartLightActor_OnUpdateLightOn");
static_assert(offsetof(KuroSmartLightActor_OnUpdateLightOn, Time) == 0x000000, "Member 'KuroSmartLightActor_OnUpdateLightOn::Time' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroSuperFarFog.Update
// 0x0004 (0x0004 - 0x0000)
struct KuroSuperFarFog_Update final
{
public:
	float                                         DeltaSeconds;                                      // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroSuperFarFog_Update) == 0x000004, "Wrong alignment on KuroSuperFarFog_Update");
static_assert(sizeof(KuroSuperFarFog_Update) == 0x000004, "Wrong size on KuroSuperFarFog_Update");
static_assert(offsetof(KuroSuperFarFog_Update, DeltaSeconds) == 0x000000, "Member 'KuroSuperFarFog_Update::DeltaSeconds' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroUiSceneInfo.Init
// 0x0040 (0x0040 - 0x0000)
struct KuroUiSceneInfo_Init final
{
public:
	class ULevelStreamingDynamic*                 InLevelStreaming;                                  // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 InLevelName;                                       // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 OptionalName;                                      // 0x0018(0x0010)(Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                InLocation;                                        // 0x0028(0x000C)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UWorld*                                 InWorld;                                           // 0x0038(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroUiSceneInfo_Init) == 0x000008, "Wrong alignment on KuroUiSceneInfo_Init");
static_assert(sizeof(KuroUiSceneInfo_Init) == 0x000040, "Wrong size on KuroUiSceneInfo_Init");
static_assert(offsetof(KuroUiSceneInfo_Init, InLevelStreaming) == 0x000000, "Member 'KuroUiSceneInfo_Init::InLevelStreaming' has a wrong offset!");
static_assert(offsetof(KuroUiSceneInfo_Init, InLevelName) == 0x000008, "Member 'KuroUiSceneInfo_Init::InLevelName' has a wrong offset!");
static_assert(offsetof(KuroUiSceneInfo_Init, OptionalName) == 0x000018, "Member 'KuroUiSceneInfo_Init::OptionalName' has a wrong offset!");
static_assert(offsetof(KuroUiSceneInfo_Init, InLocation) == 0x000028, "Member 'KuroUiSceneInfo_Init::InLocation' has a wrong offset!");
static_assert(offsetof(KuroUiSceneInfo_Init, InWorld) == 0x000038, "Member 'KuroUiSceneInfo_Init::InWorld' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroUiSceneInfo.SetLevelVisible
// 0x0001 (0x0001 - 0x0000)
struct KuroUiSceneInfo_SetLevelVisible final
{
public:
	bool                                          InIsVisible;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroUiSceneInfo_SetLevelVisible) == 0x000001, "Wrong alignment on KuroUiSceneInfo_SetLevelVisible");
static_assert(sizeof(KuroUiSceneInfo_SetLevelVisible) == 0x000001, "Wrong size on KuroUiSceneInfo_SetLevelVisible");
static_assert(offsetof(KuroUiSceneInfo_SetLevelVisible, InIsVisible) == 0x000000, "Member 'KuroUiSceneInfo_SetLevelVisible::InIsVisible' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroUiSceneSystem.GetKuroUiSceneSystem
// 0x0010 (0x0010 - 0x0000)
struct KuroUiSceneSystem_GetKuroUiSceneSystem final
{
public:
	class UWorld*                                 InWorld;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UKuroUiSceneSystem*                     ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroUiSceneSystem_GetKuroUiSceneSystem) == 0x000008, "Wrong alignment on KuroUiSceneSystem_GetKuroUiSceneSystem");
static_assert(sizeof(KuroUiSceneSystem_GetKuroUiSceneSystem) == 0x000010, "Wrong size on KuroUiSceneSystem_GetKuroUiSceneSystem");
static_assert(offsetof(KuroUiSceneSystem_GetKuroUiSceneSystem, InWorld) == 0x000000, "Member 'KuroUiSceneSystem_GetKuroUiSceneSystem::InWorld' has a wrong offset!");
static_assert(offsetof(KuroUiSceneSystem_GetKuroUiSceneSystem, ReturnValue) == 0x000008, "Member 'KuroUiSceneSystem_GetKuroUiSceneSystem::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroUiSceneSystem.D_PreloadUiScene
// 0x0028 (0x0028 - 0x0000)
struct KuroUiSceneSystem_D_PreloadUiScene final
{
public:
	class FString                                 ScenePath;                                         // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVectorDouble                          WorldPositionOffset;                               // 0x0010(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroUiSceneSystem_D_PreloadUiScene) == 0x000008, "Wrong alignment on KuroUiSceneSystem_D_PreloadUiScene");
static_assert(sizeof(KuroUiSceneSystem_D_PreloadUiScene) == 0x000028, "Wrong size on KuroUiSceneSystem_D_PreloadUiScene");
static_assert(offsetof(KuroUiSceneSystem_D_PreloadUiScene, ScenePath) == 0x000000, "Member 'KuroUiSceneSystem_D_PreloadUiScene::ScenePath' has a wrong offset!");
static_assert(offsetof(KuroUiSceneSystem_D_PreloadUiScene, WorldPositionOffset) == 0x000010, "Member 'KuroUiSceneSystem_D_PreloadUiScene::WorldPositionOffset' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroUiSceneSystem.EndUiSceneRendering
// 0x0001 (0x0001 - 0x0000)
struct KuroUiSceneSystem_EndUiSceneRendering final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroUiSceneSystem_EndUiSceneRendering) == 0x000001, "Wrong alignment on KuroUiSceneSystem_EndUiSceneRendering");
static_assert(sizeof(KuroUiSceneSystem_EndUiSceneRendering) == 0x000001, "Wrong size on KuroUiSceneSystem_EndUiSceneRendering");
static_assert(offsetof(KuroUiSceneSystem_EndUiSceneRendering, ReturnValue) == 0x000000, "Member 'KuroUiSceneSystem_EndUiSceneRendering::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroUiSceneSystem.GetCurrentUiSceneRenderingSceneName
// 0x0010 (0x0010 - 0x0000)
struct KuroUiSceneSystem_GetCurrentUiSceneRenderingSceneName final
{
public:
	class FString                                 ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroUiSceneSystem_GetCurrentUiSceneRenderingSceneName) == 0x000008, "Wrong alignment on KuroUiSceneSystem_GetCurrentUiSceneRenderingSceneName");
static_assert(sizeof(KuroUiSceneSystem_GetCurrentUiSceneRenderingSceneName) == 0x000010, "Wrong size on KuroUiSceneSystem_GetCurrentUiSceneRenderingSceneName");
static_assert(offsetof(KuroUiSceneSystem_GetCurrentUiSceneRenderingSceneName, ReturnValue) == 0x000000, "Member 'KuroUiSceneSystem_GetCurrentUiSceneRenderingSceneName::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroUiSceneSystem.GetUiSceneLoadingState
// 0x0018 (0x0018 - 0x0000)
struct KuroUiSceneSystem_GetUiSceneLoadingState final
{
public:
	class FString                                 ScenePath;                                         // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EKuroUiSceneLoadingState                      ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroUiSceneSystem_GetUiSceneLoadingState) == 0x000008, "Wrong alignment on KuroUiSceneSystem_GetUiSceneLoadingState");
static_assert(sizeof(KuroUiSceneSystem_GetUiSceneLoadingState) == 0x000018, "Wrong size on KuroUiSceneSystem_GetUiSceneLoadingState");
static_assert(offsetof(KuroUiSceneSystem_GetUiSceneLoadingState, ScenePath) == 0x000000, "Member 'KuroUiSceneSystem_GetUiSceneLoadingState::ScenePath' has a wrong offset!");
static_assert(offsetof(KuroUiSceneSystem_GetUiSceneLoadingState, ReturnValue) == 0x000010, "Member 'KuroUiSceneSystem_GetUiSceneLoadingState::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroUiSceneSystem.GetUiSceneRootActor
// 0x0018 (0x0018 - 0x0000)
struct KuroUiSceneSystem_GetUiSceneRootActor final
{
public:
	class FString                                 ScenePath;                                         // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AKuroUiSceneRootActor*                  ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroUiSceneSystem_GetUiSceneRootActor) == 0x000008, "Wrong alignment on KuroUiSceneSystem_GetUiSceneRootActor");
static_assert(sizeof(KuroUiSceneSystem_GetUiSceneRootActor) == 0x000018, "Wrong size on KuroUiSceneSystem_GetUiSceneRootActor");
static_assert(offsetof(KuroUiSceneSystem_GetUiSceneRootActor, ScenePath) == 0x000000, "Member 'KuroUiSceneSystem_GetUiSceneRootActor::ScenePath' has a wrong offset!");
static_assert(offsetof(KuroUiSceneSystem_GetUiSceneRootActor, ReturnValue) == 0x000010, "Member 'KuroUiSceneSystem_GetUiSceneRootActor::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroUiSceneSystem.GetUiSceneStates
// 0x0050 (0x0050 - 0x0000)
struct KuroUiSceneSystem_GetUiSceneStates final
{
public:
	TMap<class FString, EKuroUiSceneLoadingState> ReturnValue;                                       // 0x0000(0x0050)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroUiSceneSystem_GetUiSceneStates) == 0x000008, "Wrong alignment on KuroUiSceneSystem_GetUiSceneStates");
static_assert(sizeof(KuroUiSceneSystem_GetUiSceneStates) == 0x000050, "Wrong size on KuroUiSceneSystem_GetUiSceneStates");
static_assert(offsetof(KuroUiSceneSystem_GetUiSceneStates, ReturnValue) == 0x000000, "Member 'KuroUiSceneSystem_GetUiSceneStates::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroUiSceneSystem.GetUiSceneWorldPositionOffset
// 0x0020 (0x0020 - 0x0000)
struct KuroUiSceneSystem_GetUiSceneWorldPositionOffset final
{
public:
	class FString                                 ScenePath;                                         // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ReturnValue;                                       // 0x0010(0x000C)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroUiSceneSystem_GetUiSceneWorldPositionOffset) == 0x000008, "Wrong alignment on KuroUiSceneSystem_GetUiSceneWorldPositionOffset");
static_assert(sizeof(KuroUiSceneSystem_GetUiSceneWorldPositionOffset) == 0x000020, "Wrong size on KuroUiSceneSystem_GetUiSceneWorldPositionOffset");
static_assert(offsetof(KuroUiSceneSystem_GetUiSceneWorldPositionOffset, ScenePath) == 0x000000, "Member 'KuroUiSceneSystem_GetUiSceneWorldPositionOffset::ScenePath' has a wrong offset!");
static_assert(offsetof(KuroUiSceneSystem_GetUiSceneWorldPositionOffset, ReturnValue) == 0x000010, "Member 'KuroUiSceneSystem_GetUiSceneWorldPositionOffset::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroUiSceneSystem.InvokeSceneVisible
// 0x0010 (0x0010 - 0x0000)
struct KuroUiSceneSystem_InvokeSceneVisible final
{
public:
	class FString                                 ScenePath;                                         // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroUiSceneSystem_InvokeSceneVisible) == 0x000008, "Wrong alignment on KuroUiSceneSystem_InvokeSceneVisible");
static_assert(sizeof(KuroUiSceneSystem_InvokeSceneVisible) == 0x000010, "Wrong size on KuroUiSceneSystem_InvokeSceneVisible");
static_assert(offsetof(KuroUiSceneSystem_InvokeSceneVisible, ScenePath) == 0x000000, "Member 'KuroUiSceneSystem_InvokeSceneVisible::ScenePath' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroUiSceneSystem.PreloadUiScene
// 0x0020 (0x0020 - 0x0000)
struct KuroUiSceneSystem_PreloadUiScene final
{
public:
	class FString                                 ScenePath;                                         // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                WorldPositionOffset;                               // 0x0010(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroUiSceneSystem_PreloadUiScene) == 0x000008, "Wrong alignment on KuroUiSceneSystem_PreloadUiScene");
static_assert(sizeof(KuroUiSceneSystem_PreloadUiScene) == 0x000020, "Wrong size on KuroUiSceneSystem_PreloadUiScene");
static_assert(offsetof(KuroUiSceneSystem_PreloadUiScene, ScenePath) == 0x000000, "Member 'KuroUiSceneSystem_PreloadUiScene::ScenePath' has a wrong offset!");
static_assert(offsetof(KuroUiSceneSystem_PreloadUiScene, WorldPositionOffset) == 0x000010, "Member 'KuroUiSceneSystem_PreloadUiScene::WorldPositionOffset' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroUiSceneSystem.StartUiSceneRendering
// 0x0018 (0x0018 - 0x0000)
struct KuroUiSceneSystem_StartUiSceneRendering final
{
public:
	class FString                                 ScenePath;                                         // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroUiSceneSystem_StartUiSceneRendering) == 0x000008, "Wrong alignment on KuroUiSceneSystem_StartUiSceneRendering");
static_assert(sizeof(KuroUiSceneSystem_StartUiSceneRendering) == 0x000018, "Wrong size on KuroUiSceneSystem_StartUiSceneRendering");
static_assert(offsetof(KuroUiSceneSystem_StartUiSceneRendering, ScenePath) == 0x000000, "Member 'KuroUiSceneSystem_StartUiSceneRendering::ScenePath' has a wrong offset!");
static_assert(offsetof(KuroUiSceneSystem_StartUiSceneRendering, ReturnValue) == 0x000010, "Member 'KuroUiSceneSystem_StartUiSceneRendering::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroUiSceneSystem.UnloadUiScene
// 0x0018 (0x0018 - 0x0000)
struct KuroUiSceneSystem_UnloadUiScene final
{
public:
	class FString                                 ScenePath;                                         // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroUiSceneSystem_UnloadUiScene) == 0x000008, "Wrong alignment on KuroUiSceneSystem_UnloadUiScene");
static_assert(sizeof(KuroUiSceneSystem_UnloadUiScene) == 0x000018, "Wrong size on KuroUiSceneSystem_UnloadUiScene");
static_assert(offsetof(KuroUiSceneSystem_UnloadUiScene, ScenePath) == 0x000000, "Member 'KuroUiSceneSystem_UnloadUiScene::ScenePath' has a wrong offset!");
static_assert(offsetof(KuroUiSceneSystem_UnloadUiScene, ReturnValue) == 0x000010, "Member 'KuroUiSceneSystem_UnloadUiScene::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroVirtualAttachmentWorldSubsystem.GetRegisteredChildComponents
// 0x0020 (0x0020 - 0x0000)
struct KuroVirtualAttachmentWorldSubsystem_GetRegisteredChildComponents final
{
public:
	struct FGuid                                  Uid;                                               // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UKuroVirtualAttachmentChildComponent*> ReturnValue;                                 // 0x0010(0x0010)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroVirtualAttachmentWorldSubsystem_GetRegisteredChildComponents) == 0x000008, "Wrong alignment on KuroVirtualAttachmentWorldSubsystem_GetRegisteredChildComponents");
static_assert(sizeof(KuroVirtualAttachmentWorldSubsystem_GetRegisteredChildComponents) == 0x000020, "Wrong size on KuroVirtualAttachmentWorldSubsystem_GetRegisteredChildComponents");
static_assert(offsetof(KuroVirtualAttachmentWorldSubsystem_GetRegisteredChildComponents, Uid) == 0x000000, "Member 'KuroVirtualAttachmentWorldSubsystem_GetRegisteredChildComponents::Uid' has a wrong offset!");
static_assert(offsetof(KuroVirtualAttachmentWorldSubsystem_GetRegisteredChildComponents, ReturnValue) == 0x000010, "Member 'KuroVirtualAttachmentWorldSubsystem_GetRegisteredChildComponents::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroVirtualAttachmentWorldSubsystem.GetRegisteredParentComponent
// 0x0018 (0x0018 - 0x0000)
struct KuroVirtualAttachmentWorldSubsystem_GetRegisteredParentComponent final
{
public:
	struct FGuid                                  Uid;                                               // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UKuroVirtualAttachmentParentComponent*  ReturnValue;                                       // 0x0010(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroVirtualAttachmentWorldSubsystem_GetRegisteredParentComponent) == 0x000008, "Wrong alignment on KuroVirtualAttachmentWorldSubsystem_GetRegisteredParentComponent");
static_assert(sizeof(KuroVirtualAttachmentWorldSubsystem_GetRegisteredParentComponent) == 0x000018, "Wrong size on KuroVirtualAttachmentWorldSubsystem_GetRegisteredParentComponent");
static_assert(offsetof(KuroVirtualAttachmentWorldSubsystem_GetRegisteredParentComponent, Uid) == 0x000000, "Member 'KuroVirtualAttachmentWorldSubsystem_GetRegisteredParentComponent::Uid' has a wrong offset!");
static_assert(offsetof(KuroVirtualAttachmentWorldSubsystem_GetRegisteredParentComponent, ReturnValue) == 0x000010, "Member 'KuroVirtualAttachmentWorldSubsystem_GetRegisteredParentComponent::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroWorldInfo.BP_GetInstance
// 0x0018 (0x0018 - 0x0000)
struct KuroWorldInfo_BP_GetInstance final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          AutoCreate;                                        // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AKuroWorldInfo*                         ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroWorldInfo_BP_GetInstance) == 0x000008, "Wrong alignment on KuroWorldInfo_BP_GetInstance");
static_assert(sizeof(KuroWorldInfo_BP_GetInstance) == 0x000018, "Wrong size on KuroWorldInfo_BP_GetInstance");
static_assert(offsetof(KuroWorldInfo_BP_GetInstance, WorldContextObject) == 0x000000, "Member 'KuroWorldInfo_BP_GetInstance::WorldContextObject' has a wrong offset!");
static_assert(offsetof(KuroWorldInfo_BP_GetInstance, AutoCreate) == 0x000008, "Member 'KuroWorldInfo_BP_GetInstance::AutoCreate' has a wrong offset!");
static_assert(offsetof(KuroWorldInfo_BP_GetInstance, ReturnValue) == 0x000010, "Member 'KuroWorldInfo_BP_GetInstance::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroWorldInfo.GetSLInfo
// 0x0040 (0x0040 - 0x0000)
struct KuroWorldInfo_GetSLInfo final
{
public:
	class FName                                   PackageName;                                       // 0x0000(0x000C)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FKuroStreamingLevelInfo                LandscapeInfo;                                     // 0x000C(0x0030)(Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x003C(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroWorldInfo_GetSLInfo) == 0x000004, "Wrong alignment on KuroWorldInfo_GetSLInfo");
static_assert(sizeof(KuroWorldInfo_GetSLInfo) == 0x000040, "Wrong size on KuroWorldInfo_GetSLInfo");
static_assert(offsetof(KuroWorldInfo_GetSLInfo, PackageName) == 0x000000, "Member 'KuroWorldInfo_GetSLInfo::PackageName' has a wrong offset!");
static_assert(offsetof(KuroWorldInfo_GetSLInfo, LandscapeInfo) == 0x00000C, "Member 'KuroWorldInfo_GetSLInfo::LandscapeInfo' has a wrong offset!");
static_assert(offsetof(KuroWorldInfo_GetSLInfo, ReturnValue) == 0x00003C, "Member 'KuroWorldInfo_GetSLInfo::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroWorldInfo.GetLandscapeInfo
// 0x0058 (0x0058 - 0x0000)
struct KuroWorldInfo_GetLandscapeInfo final
{
public:
	struct FKuroLandscapeInfo                     LandscapeInfo;                                     // 0x0000(0x0058)(Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroWorldInfo_GetLandscapeInfo) == 0x000004, "Wrong alignment on KuroWorldInfo_GetLandscapeInfo");
static_assert(sizeof(KuroWorldInfo_GetLandscapeInfo) == 0x000058, "Wrong size on KuroWorldInfo_GetLandscapeInfo");
static_assert(offsetof(KuroWorldInfo_GetLandscapeInfo, LandscapeInfo) == 0x000000, "Member 'KuroWorldInfo_GetLandscapeInfo::LandscapeInfo' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.LensflareSamplerActor.ApplyDynamicMaterialGhost
// 0x0008 (0x0008 - 0x0000)
struct LensflareSamplerActor_ApplyDynamicMaterialGhost final
{
public:
	class UMaterialInstanceDynamic*               DynMaterial;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LensflareSamplerActor_ApplyDynamicMaterialGhost) == 0x000008, "Wrong alignment on LensflareSamplerActor_ApplyDynamicMaterialGhost");
static_assert(sizeof(LensflareSamplerActor_ApplyDynamicMaterialGhost) == 0x000008, "Wrong size on LensflareSamplerActor_ApplyDynamicMaterialGhost");
static_assert(offsetof(LensflareSamplerActor_ApplyDynamicMaterialGhost, DynMaterial) == 0x000000, "Member 'LensflareSamplerActor_ApplyDynamicMaterialGhost::DynMaterial' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.LensflareSamplerActor.ApplyDynamicMaterialGlare
// 0x0008 (0x0008 - 0x0000)
struct LensflareSamplerActor_ApplyDynamicMaterialGlare final
{
public:
	class UMaterialInstanceDynamic*               DynMaterial;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LensflareSamplerActor_ApplyDynamicMaterialGlare) == 0x000008, "Wrong alignment on LensflareSamplerActor_ApplyDynamicMaterialGlare");
static_assert(sizeof(LensflareSamplerActor_ApplyDynamicMaterialGlare) == 0x000008, "Wrong size on LensflareSamplerActor_ApplyDynamicMaterialGlare");
static_assert(offsetof(LensflareSamplerActor_ApplyDynamicMaterialGlare, DynMaterial) == 0x000000, "Member 'LensflareSamplerActor_ApplyDynamicMaterialGlare::DynMaterial' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.LensflareSamplerActor.ApplyDynamicMaterialHalo
// 0x0008 (0x0008 - 0x0000)
struct LensflareSamplerActor_ApplyDynamicMaterialHalo final
{
public:
	class UMaterialInstanceDynamic*               DynMaterial;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LensflareSamplerActor_ApplyDynamicMaterialHalo) == 0x000008, "Wrong alignment on LensflareSamplerActor_ApplyDynamicMaterialHalo");
static_assert(sizeof(LensflareSamplerActor_ApplyDynamicMaterialHalo) == 0x000008, "Wrong size on LensflareSamplerActor_ApplyDynamicMaterialHalo");
static_assert(offsetof(LensflareSamplerActor_ApplyDynamicMaterialHalo, DynMaterial) == 0x000000, "Member 'LensflareSamplerActor_ApplyDynamicMaterialHalo::DynMaterial' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.LensflareSamplerActor.GetCustomGhostParameter
// 0x0040 (0x0040 - 0x0000)
struct LensflareSamplerActor_GetCustomGhostParameter final
{
public:
	struct FLensflareSamplerActorGhostParameter   ReturnValue;                                       // 0x0000(0x0040)(Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(LensflareSamplerActor_GetCustomGhostParameter) == 0x000008, "Wrong alignment on LensflareSamplerActor_GetCustomGhostParameter");
static_assert(sizeof(LensflareSamplerActor_GetCustomGhostParameter) == 0x000040, "Wrong size on LensflareSamplerActor_GetCustomGhostParameter");
static_assert(offsetof(LensflareSamplerActor_GetCustomGhostParameter, ReturnValue) == 0x000000, "Member 'LensflareSamplerActor_GetCustomGhostParameter::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.LensflareSamplerActor.GetCustomGlareParameter
// 0x0050 (0x0050 - 0x0000)
struct LensflareSamplerActor_GetCustomGlareParameter final
{
public:
	struct FLensflareSamplerActorGlareParameter   ReturnValue;                                       // 0x0000(0x0050)(Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(LensflareSamplerActor_GetCustomGlareParameter) == 0x000008, "Wrong alignment on LensflareSamplerActor_GetCustomGlareParameter");
static_assert(sizeof(LensflareSamplerActor_GetCustomGlareParameter) == 0x000050, "Wrong size on LensflareSamplerActor_GetCustomGlareParameter");
static_assert(offsetof(LensflareSamplerActor_GetCustomGlareParameter, ReturnValue) == 0x000000, "Member 'LensflareSamplerActor_GetCustomGlareParameter::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.LensflareSamplerActor.GetCustomHaloParameter
// 0x0048 (0x0048 - 0x0000)
struct LensflareSamplerActor_GetCustomHaloParameter final
{
public:
	struct FLensflareSamplerActorHaloParameter    ReturnValue;                                       // 0x0000(0x0048)(Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(LensflareSamplerActor_GetCustomHaloParameter) == 0x000008, "Wrong alignment on LensflareSamplerActor_GetCustomHaloParameter");
static_assert(sizeof(LensflareSamplerActor_GetCustomHaloParameter) == 0x000048, "Wrong size on LensflareSamplerActor_GetCustomHaloParameter");
static_assert(offsetof(LensflareSamplerActor_GetCustomHaloParameter, ReturnValue) == 0x000000, "Member 'LensflareSamplerActor_GetCustomHaloParameter::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.LensflareSamplerActor.GetLensflareParameter
// 0x0008 (0x0008 - 0x0000)
struct LensflareSamplerActor_GetLensflareParameter final
{
public:
	struct FLensflareSamplerActorParameter        ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(LensflareSamplerActor_GetLensflareParameter) == 0x000004, "Wrong alignment on LensflareSamplerActor_GetLensflareParameter");
static_assert(sizeof(LensflareSamplerActor_GetLensflareParameter) == 0x000008, "Wrong size on LensflareSamplerActor_GetLensflareParameter");
static_assert(offsetof(LensflareSamplerActor_GetLensflareParameter, ReturnValue) == 0x000000, "Member 'LensflareSamplerActor_GetLensflareParameter::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.NiagaraKuroParameterSystem.GetParameterFloat
// 0x0020 (0x0020 - 0x0000)
struct NiagaraKuroParameterSystem_GetParameterFloat final
{
public:
	class FName                                   Collection;                                        // 0x0000(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Name_0;                                            // 0x000C(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Default;                                           // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x001C(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(NiagaraKuroParameterSystem_GetParameterFloat) == 0x000004, "Wrong alignment on NiagaraKuroParameterSystem_GetParameterFloat");
static_assert(sizeof(NiagaraKuroParameterSystem_GetParameterFloat) == 0x000020, "Wrong size on NiagaraKuroParameterSystem_GetParameterFloat");
static_assert(offsetof(NiagaraKuroParameterSystem_GetParameterFloat, Collection) == 0x000000, "Member 'NiagaraKuroParameterSystem_GetParameterFloat::Collection' has a wrong offset!");
static_assert(offsetof(NiagaraKuroParameterSystem_GetParameterFloat, Name_0) == 0x00000C, "Member 'NiagaraKuroParameterSystem_GetParameterFloat::Name_0' has a wrong offset!");
static_assert(offsetof(NiagaraKuroParameterSystem_GetParameterFloat, Default) == 0x000018, "Member 'NiagaraKuroParameterSystem_GetParameterFloat::Default' has a wrong offset!");
static_assert(offsetof(NiagaraKuroParameterSystem_GetParameterFloat, ReturnValue) == 0x00001C, "Member 'NiagaraKuroParameterSystem_GetParameterFloat::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.NiagaraKuroParameterSystem.GetParameterLinearColor
// 0x0038 (0x0038 - 0x0000)
struct NiagaraKuroParameterSystem_GetParameterLinearColor final
{
public:
	class FName                                   Collection;                                        // 0x0000(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Name_0;                                            // 0x000C(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           Default;                                           // 0x0018(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           ReturnValue;                                       // 0x0028(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(NiagaraKuroParameterSystem_GetParameterLinearColor) == 0x000004, "Wrong alignment on NiagaraKuroParameterSystem_GetParameterLinearColor");
static_assert(sizeof(NiagaraKuroParameterSystem_GetParameterLinearColor) == 0x000038, "Wrong size on NiagaraKuroParameterSystem_GetParameterLinearColor");
static_assert(offsetof(NiagaraKuroParameterSystem_GetParameterLinearColor, Collection) == 0x000000, "Member 'NiagaraKuroParameterSystem_GetParameterLinearColor::Collection' has a wrong offset!");
static_assert(offsetof(NiagaraKuroParameterSystem_GetParameterLinearColor, Name_0) == 0x00000C, "Member 'NiagaraKuroParameterSystem_GetParameterLinearColor::Name_0' has a wrong offset!");
static_assert(offsetof(NiagaraKuroParameterSystem_GetParameterLinearColor, Default) == 0x000018, "Member 'NiagaraKuroParameterSystem_GetParameterLinearColor::Default' has a wrong offset!");
static_assert(offsetof(NiagaraKuroParameterSystem_GetParameterLinearColor, ReturnValue) == 0x000028, "Member 'NiagaraKuroParameterSystem_GetParameterLinearColor::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.NiagaraKuroParameterSystem.GetParameterVector
// 0x0030 (0x0030 - 0x0000)
struct NiagaraKuroParameterSystem_GetParameterVector final
{
public:
	class FName                                   Collection;                                        // 0x0000(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Name_0;                                            // 0x000C(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Default;                                           // 0x0018(0x000C)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ReturnValue;                                       // 0x0024(0x000C)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(NiagaraKuroParameterSystem_GetParameterVector) == 0x000004, "Wrong alignment on NiagaraKuroParameterSystem_GetParameterVector");
static_assert(sizeof(NiagaraKuroParameterSystem_GetParameterVector) == 0x000030, "Wrong size on NiagaraKuroParameterSystem_GetParameterVector");
static_assert(offsetof(NiagaraKuroParameterSystem_GetParameterVector, Collection) == 0x000000, "Member 'NiagaraKuroParameterSystem_GetParameterVector::Collection' has a wrong offset!");
static_assert(offsetof(NiagaraKuroParameterSystem_GetParameterVector, Name_0) == 0x00000C, "Member 'NiagaraKuroParameterSystem_GetParameterVector::Name_0' has a wrong offset!");
static_assert(offsetof(NiagaraKuroParameterSystem_GetParameterVector, Default) == 0x000018, "Member 'NiagaraKuroParameterSystem_GetParameterVector::Default' has a wrong offset!");
static_assert(offsetof(NiagaraKuroParameterSystem_GetParameterVector, ReturnValue) == 0x000024, "Member 'NiagaraKuroParameterSystem_GetParameterVector::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.NiagaraKuroParameterSystem.RemoveCollection
// 0x000C (0x000C - 0x0000)
struct NiagaraKuroParameterSystem_RemoveCollection final
{
public:
	class FName                                   Collection;                                        // 0x0000(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(NiagaraKuroParameterSystem_RemoveCollection) == 0x000004, "Wrong alignment on NiagaraKuroParameterSystem_RemoveCollection");
static_assert(sizeof(NiagaraKuroParameterSystem_RemoveCollection) == 0x00000C, "Wrong size on NiagaraKuroParameterSystem_RemoveCollection");
static_assert(offsetof(NiagaraKuroParameterSystem_RemoveCollection, Collection) == 0x000000, "Member 'NiagaraKuroParameterSystem_RemoveCollection::Collection' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.NiagaraKuroParameterSystem.RemoveParameterFloat
// 0x0018 (0x0018 - 0x0000)
struct NiagaraKuroParameterSystem_RemoveParameterFloat final
{
public:
	class FName                                   Collection;                                        // 0x0000(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Name_0;                                            // 0x000C(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(NiagaraKuroParameterSystem_RemoveParameterFloat) == 0x000004, "Wrong alignment on NiagaraKuroParameterSystem_RemoveParameterFloat");
static_assert(sizeof(NiagaraKuroParameterSystem_RemoveParameterFloat) == 0x000018, "Wrong size on NiagaraKuroParameterSystem_RemoveParameterFloat");
static_assert(offsetof(NiagaraKuroParameterSystem_RemoveParameterFloat, Collection) == 0x000000, "Member 'NiagaraKuroParameterSystem_RemoveParameterFloat::Collection' has a wrong offset!");
static_assert(offsetof(NiagaraKuroParameterSystem_RemoveParameterFloat, Name_0) == 0x00000C, "Member 'NiagaraKuroParameterSystem_RemoveParameterFloat::Name_0' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.NiagaraKuroParameterSystem.RemoveParameterLinearColor
// 0x0018 (0x0018 - 0x0000)
struct NiagaraKuroParameterSystem_RemoveParameterLinearColor final
{
public:
	class FName                                   Collection;                                        // 0x0000(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Name_0;                                            // 0x000C(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(NiagaraKuroParameterSystem_RemoveParameterLinearColor) == 0x000004, "Wrong alignment on NiagaraKuroParameterSystem_RemoveParameterLinearColor");
static_assert(sizeof(NiagaraKuroParameterSystem_RemoveParameterLinearColor) == 0x000018, "Wrong size on NiagaraKuroParameterSystem_RemoveParameterLinearColor");
static_assert(offsetof(NiagaraKuroParameterSystem_RemoveParameterLinearColor, Collection) == 0x000000, "Member 'NiagaraKuroParameterSystem_RemoveParameterLinearColor::Collection' has a wrong offset!");
static_assert(offsetof(NiagaraKuroParameterSystem_RemoveParameterLinearColor, Name_0) == 0x00000C, "Member 'NiagaraKuroParameterSystem_RemoveParameterLinearColor::Name_0' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.NiagaraKuroParameterSystem.RemoveParameterVector
// 0x0018 (0x0018 - 0x0000)
struct NiagaraKuroParameterSystem_RemoveParameterVector final
{
public:
	class FName                                   Collection;                                        // 0x0000(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Name_0;                                            // 0x000C(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(NiagaraKuroParameterSystem_RemoveParameterVector) == 0x000004, "Wrong alignment on NiagaraKuroParameterSystem_RemoveParameterVector");
static_assert(sizeof(NiagaraKuroParameterSystem_RemoveParameterVector) == 0x000018, "Wrong size on NiagaraKuroParameterSystem_RemoveParameterVector");
static_assert(offsetof(NiagaraKuroParameterSystem_RemoveParameterVector, Collection) == 0x000000, "Member 'NiagaraKuroParameterSystem_RemoveParameterVector::Collection' has a wrong offset!");
static_assert(offsetof(NiagaraKuroParameterSystem_RemoveParameterVector, Name_0) == 0x00000C, "Member 'NiagaraKuroParameterSystem_RemoveParameterVector::Name_0' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.NiagaraKuroParameterSystem.SetParameterFloat
// 0x001C (0x001C - 0x0000)
struct NiagaraKuroParameterSystem_SetParameterFloat final
{
public:
	class FName                                   Collection;                                        // 0x0000(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Name_0;                                            // 0x000C(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Val;                                               // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(NiagaraKuroParameterSystem_SetParameterFloat) == 0x000004, "Wrong alignment on NiagaraKuroParameterSystem_SetParameterFloat");
static_assert(sizeof(NiagaraKuroParameterSystem_SetParameterFloat) == 0x00001C, "Wrong size on NiagaraKuroParameterSystem_SetParameterFloat");
static_assert(offsetof(NiagaraKuroParameterSystem_SetParameterFloat, Collection) == 0x000000, "Member 'NiagaraKuroParameterSystem_SetParameterFloat::Collection' has a wrong offset!");
static_assert(offsetof(NiagaraKuroParameterSystem_SetParameterFloat, Name_0) == 0x00000C, "Member 'NiagaraKuroParameterSystem_SetParameterFloat::Name_0' has a wrong offset!");
static_assert(offsetof(NiagaraKuroParameterSystem_SetParameterFloat, Val) == 0x000018, "Member 'NiagaraKuroParameterSystem_SetParameterFloat::Val' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.NiagaraKuroParameterSystem.SetParameterLinearColor
// 0x0028 (0x0028 - 0x0000)
struct NiagaraKuroParameterSystem_SetParameterLinearColor final
{
public:
	class FName                                   Collection;                                        // 0x0000(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Name_0;                                            // 0x000C(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           Val;                                               // 0x0018(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(NiagaraKuroParameterSystem_SetParameterLinearColor) == 0x000004, "Wrong alignment on NiagaraKuroParameterSystem_SetParameterLinearColor");
static_assert(sizeof(NiagaraKuroParameterSystem_SetParameterLinearColor) == 0x000028, "Wrong size on NiagaraKuroParameterSystem_SetParameterLinearColor");
static_assert(offsetof(NiagaraKuroParameterSystem_SetParameterLinearColor, Collection) == 0x000000, "Member 'NiagaraKuroParameterSystem_SetParameterLinearColor::Collection' has a wrong offset!");
static_assert(offsetof(NiagaraKuroParameterSystem_SetParameterLinearColor, Name_0) == 0x00000C, "Member 'NiagaraKuroParameterSystem_SetParameterLinearColor::Name_0' has a wrong offset!");
static_assert(offsetof(NiagaraKuroParameterSystem_SetParameterLinearColor, Val) == 0x000018, "Member 'NiagaraKuroParameterSystem_SetParameterLinearColor::Val' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.NiagaraKuroParameterSystem.SetParameterVector
// 0x0024 (0x0024 - 0x0000)
struct NiagaraKuroParameterSystem_SetParameterVector final
{
public:
	class FName                                   Collection;                                        // 0x0000(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Name_0;                                            // 0x000C(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Val;                                               // 0x0018(0x000C)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(NiagaraKuroParameterSystem_SetParameterVector) == 0x000004, "Wrong alignment on NiagaraKuroParameterSystem_SetParameterVector");
static_assert(sizeof(NiagaraKuroParameterSystem_SetParameterVector) == 0x000024, "Wrong size on NiagaraKuroParameterSystem_SetParameterVector");
static_assert(offsetof(NiagaraKuroParameterSystem_SetParameterVector, Collection) == 0x000000, "Member 'NiagaraKuroParameterSystem_SetParameterVector::Collection' has a wrong offset!");
static_assert(offsetof(NiagaraKuroParameterSystem_SetParameterVector, Name_0) == 0x00000C, "Member 'NiagaraKuroParameterSystem_SetParameterVector::Name_0' has a wrong offset!");
static_assert(offsetof(NiagaraKuroParameterSystem_SetParameterVector, Val) == 0x000018, "Member 'NiagaraKuroParameterSystem_SetParameterVector::Val' has a wrong offset!");

}

