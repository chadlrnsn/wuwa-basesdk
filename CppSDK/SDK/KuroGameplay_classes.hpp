#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: KuroGameplay

#include "Basic.hpp"

#include "KuroRenderingRuntimeBPPlugin_structs.hpp"
#include "Engine_structs.hpp"
#include "Engine_classes.hpp"
#include "CoreUObject_structs.hpp"
#include "CoreUObject_classes.hpp"
#include "Niagara_structs.hpp"
#include "KuroAudio_structs.hpp"
#include "KuroCurve_structs.hpp"
#include "KuroGameplay_structs.hpp"
#include "AIModule_classes.hpp"
#include "InputCore_structs.hpp"
#include "SlateCore_structs.hpp"
#include "Slate_structs.hpp"
#include "UMG_classes.hpp"


namespace SDK
{

// Class KuroGameplay.EffectModelBase
// 0x0028 (0x0060 - 0x0038)
class UEffectModelBase : public UPrimaryDataAsset
{
public:
	float                                         StartTime;                                         // 0x0038(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LoopTime;                                          // 0x003C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EndTime;                                           // 0x0040(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          AutoPlay;                                          // 0x0044(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          AutoDestroy;                                       // 0x0045(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IgnoreTimeDilation;                                // 0x0046(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IgnoreGlobalTimeDilation;                          // 0x0047(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UiScenePrimitive;                                  // 0x0048(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49[0x3];                                       // 0x0049(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ImportanceLevel;                                   // 0x004C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DefaultManualTime;                                 // 0x0050(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DefaultManualSpeed;                                // 0x0054(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IgnoreDisable;                                     // 0x0058(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          DisableOnMobile;                                   // 0x0059(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          HideOnBurstSkill;                                  // 0x005A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          NeedDisableWithActor;                              // 0x005B(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          SuperFarProgramFlag;                               // 0x005C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5D[0x3];                                       // 0x005D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EffectModelBase">();
	}
	static class UEffectModelBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEffectModelBase>();
	}
};
static_assert(alignof(UEffectModelBase) == 0x000008, "Wrong alignment on UEffectModelBase");
static_assert(sizeof(UEffectModelBase) == 0x000060, "Wrong size on UEffectModelBase");
static_assert(offsetof(UEffectModelBase, StartTime) == 0x000038, "Member 'UEffectModelBase::StartTime' has a wrong offset!");
static_assert(offsetof(UEffectModelBase, LoopTime) == 0x00003C, "Member 'UEffectModelBase::LoopTime' has a wrong offset!");
static_assert(offsetof(UEffectModelBase, EndTime) == 0x000040, "Member 'UEffectModelBase::EndTime' has a wrong offset!");
static_assert(offsetof(UEffectModelBase, AutoPlay) == 0x000044, "Member 'UEffectModelBase::AutoPlay' has a wrong offset!");
static_assert(offsetof(UEffectModelBase, AutoDestroy) == 0x000045, "Member 'UEffectModelBase::AutoDestroy' has a wrong offset!");
static_assert(offsetof(UEffectModelBase, IgnoreTimeDilation) == 0x000046, "Member 'UEffectModelBase::IgnoreTimeDilation' has a wrong offset!");
static_assert(offsetof(UEffectModelBase, IgnoreGlobalTimeDilation) == 0x000047, "Member 'UEffectModelBase::IgnoreGlobalTimeDilation' has a wrong offset!");
static_assert(offsetof(UEffectModelBase, UiScenePrimitive) == 0x000048, "Member 'UEffectModelBase::UiScenePrimitive' has a wrong offset!");
static_assert(offsetof(UEffectModelBase, ImportanceLevel) == 0x00004C, "Member 'UEffectModelBase::ImportanceLevel' has a wrong offset!");
static_assert(offsetof(UEffectModelBase, DefaultManualTime) == 0x000050, "Member 'UEffectModelBase::DefaultManualTime' has a wrong offset!");
static_assert(offsetof(UEffectModelBase, DefaultManualSpeed) == 0x000054, "Member 'UEffectModelBase::DefaultManualSpeed' has a wrong offset!");
static_assert(offsetof(UEffectModelBase, IgnoreDisable) == 0x000058, "Member 'UEffectModelBase::IgnoreDisable' has a wrong offset!");
static_assert(offsetof(UEffectModelBase, DisableOnMobile) == 0x000059, "Member 'UEffectModelBase::DisableOnMobile' has a wrong offset!");
static_assert(offsetof(UEffectModelBase, HideOnBurstSkill) == 0x00005A, "Member 'UEffectModelBase::HideOnBurstSkill' has a wrong offset!");
static_assert(offsetof(UEffectModelBase, NeedDisableWithActor) == 0x00005B, "Member 'UEffectModelBase::NeedDisableWithActor' has a wrong offset!");
static_assert(offsetof(UEffectModelBase, SuperFarProgramFlag) == 0x00005C, "Member 'UEffectModelBase::SuperFarProgramFlag' has a wrong offset!");

// Class KuroGameplay.EffectModelAudio
// 0x0028 (0x0088 - 0x0060)
class UEffectModelAudio : public UEffectModelBase
{
public:
	class UAkAudioEvent*                          AudioEvent;                                        // 0x0060(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FVector>                        LocationOffsets;                                   // 0x0068(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         FadeOutTime;                                       // 0x0078(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAudioFadeCurve                               FadeOutCurve;                                      // 0x007C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          KeepAlive;                                         // 0x007D(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7E[0x2];                                       // 0x007E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class UAkAudioEvent*                          TrailingAudioEvent;                                // 0x0080(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EffectModelAudio">();
	}
	static class UEffectModelAudio* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEffectModelAudio>();
	}
};
static_assert(alignof(UEffectModelAudio) == 0x000008, "Wrong alignment on UEffectModelAudio");
static_assert(sizeof(UEffectModelAudio) == 0x000088, "Wrong size on UEffectModelAudio");
static_assert(offsetof(UEffectModelAudio, AudioEvent) == 0x000060, "Member 'UEffectModelAudio::AudioEvent' has a wrong offset!");
static_assert(offsetof(UEffectModelAudio, LocationOffsets) == 0x000068, "Member 'UEffectModelAudio::LocationOffsets' has a wrong offset!");
static_assert(offsetof(UEffectModelAudio, FadeOutTime) == 0x000078, "Member 'UEffectModelAudio::FadeOutTime' has a wrong offset!");
static_assert(offsetof(UEffectModelAudio, FadeOutCurve) == 0x00007C, "Member 'UEffectModelAudio::FadeOutCurve' has a wrong offset!");
static_assert(offsetof(UEffectModelAudio, KeepAlive) == 0x00007D, "Member 'UEffectModelAudio::KeepAlive' has a wrong offset!");
static_assert(offsetof(UEffectModelAudio, TrailingAudioEvent) == 0x000080, "Member 'UEffectModelAudio::TrailingAudioEvent' has a wrong offset!");

// Class KuroGameplay.EffectModelBillboard
// 0x0010 (0x0070 - 0x0060)
class UEffectModelBillboard : public UEffectModelBase
{
public:
	bool                                          IsUpdateEveryFrame;                                // 0x0060(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBillboardMode                                OrientAxis;                                        // 0x0061(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsFixSize;                                         // 0x0062(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_63[0x1];                                       // 0x0063(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ScaleSize;                                         // 0x0064(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxDistance;                                       // 0x0068(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinSize;                                           // 0x006C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EffectModelBillboard">();
	}
	static class UEffectModelBillboard* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEffectModelBillboard>();
	}
};
static_assert(alignof(UEffectModelBillboard) == 0x000008, "Wrong alignment on UEffectModelBillboard");
static_assert(sizeof(UEffectModelBillboard) == 0x000070, "Wrong size on UEffectModelBillboard");
static_assert(offsetof(UEffectModelBillboard, IsUpdateEveryFrame) == 0x000060, "Member 'UEffectModelBillboard::IsUpdateEveryFrame' has a wrong offset!");
static_assert(offsetof(UEffectModelBillboard, OrientAxis) == 0x000061, "Member 'UEffectModelBillboard::OrientAxis' has a wrong offset!");
static_assert(offsetof(UEffectModelBillboard, IsFixSize) == 0x000062, "Member 'UEffectModelBillboard::IsFixSize' has a wrong offset!");
static_assert(offsetof(UEffectModelBillboard, ScaleSize) == 0x000064, "Member 'UEffectModelBillboard::ScaleSize' has a wrong offset!");
static_assert(offsetof(UEffectModelBillboard, MaxDistance) == 0x000068, "Member 'UEffectModelBillboard::MaxDistance' has a wrong offset!");
static_assert(offsetof(UEffectModelBillboard, MinSize) == 0x00006C, "Member 'UEffectModelBillboard::MinSize' has a wrong offset!");

// Class KuroGameplay.EffectModelDecal
// 0x05A8 (0x0608 - 0x0060)
class UEffectModelDecal : public UEffectModelBase
{
public:
	class UMaterialInterface*                     DecalMaterialRef;                                  // 0x0060(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FKuroCurveVector                       Location;                                          // 0x0068(0x01A8)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FKuroCurveVector                       Rotation;                                          // 0x0210(0x01A8)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FKuroCurveVector                       Scale;                                             // 0x03B8(0x01A8)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	float                                         ZfadingFactor;                                     // 0x0560(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ZfadingPower;                                      // 0x0564(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class FName, struct FKuroCurveFloat>     MaterialFloatParameters;                           // 0x0568(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<class FName, struct FKuroCurveLinearColor> MaterialColorParameters;                           // 0x05B8(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EffectModelDecal">();
	}
	static class UEffectModelDecal* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEffectModelDecal>();
	}
};
static_assert(alignof(UEffectModelDecal) == 0x000008, "Wrong alignment on UEffectModelDecal");
static_assert(sizeof(UEffectModelDecal) == 0x000608, "Wrong size on UEffectModelDecal");
static_assert(offsetof(UEffectModelDecal, DecalMaterialRef) == 0x000060, "Member 'UEffectModelDecal::DecalMaterialRef' has a wrong offset!");
static_assert(offsetof(UEffectModelDecal, Location) == 0x000068, "Member 'UEffectModelDecal::Location' has a wrong offset!");
static_assert(offsetof(UEffectModelDecal, Rotation) == 0x000210, "Member 'UEffectModelDecal::Rotation' has a wrong offset!");
static_assert(offsetof(UEffectModelDecal, Scale) == 0x0003B8, "Member 'UEffectModelDecal::Scale' has a wrong offset!");
static_assert(offsetof(UEffectModelDecal, ZfadingFactor) == 0x000560, "Member 'UEffectModelDecal::ZfadingFactor' has a wrong offset!");
static_assert(offsetof(UEffectModelDecal, ZfadingPower) == 0x000564, "Member 'UEffectModelDecal::ZfadingPower' has a wrong offset!");
static_assert(offsetof(UEffectModelDecal, MaterialFloatParameters) == 0x000568, "Member 'UEffectModelDecal::MaterialFloatParameters' has a wrong offset!");
static_assert(offsetof(UEffectModelDecal, MaterialColorParameters) == 0x0005B8, "Member 'UEffectModelDecal::MaterialColorParameters' has a wrong offset!");

// Class KuroGameplay.EffectModelGhost
// 0x0160 (0x01C0 - 0x0060)
class UEffectModelGhost : public UEffectModelBase
{
public:
	class UMaterialInstance*                      MaterialRef;                                       // 0x0060(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USkeletalMesh*                          Mesh;                                              // 0x0068(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<EEffectModelGhostCppComponent>         MeshComponentsToUse;                               // 0x0070(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FName>                           CustomComponentNames;                              // 0x0080(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FKuroCurveFloat                        AlphaCurve;                                        // 0x0090(0x0090)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<class FName, struct FKuroCurveFloat>     FloatParameters;                                   // 0x0120(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TMap<class FName, struct FKuroCurveLinearColor> ColorParameters;                                   // 0x0170(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EffectModelGhost">();
	}
	static class UEffectModelGhost* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEffectModelGhost>();
	}
};
static_assert(alignof(UEffectModelGhost) == 0x000008, "Wrong alignment on UEffectModelGhost");
static_assert(sizeof(UEffectModelGhost) == 0x0001C0, "Wrong size on UEffectModelGhost");
static_assert(offsetof(UEffectModelGhost, MaterialRef) == 0x000060, "Member 'UEffectModelGhost::MaterialRef' has a wrong offset!");
static_assert(offsetof(UEffectModelGhost, Mesh) == 0x000068, "Member 'UEffectModelGhost::Mesh' has a wrong offset!");
static_assert(offsetof(UEffectModelGhost, MeshComponentsToUse) == 0x000070, "Member 'UEffectModelGhost::MeshComponentsToUse' has a wrong offset!");
static_assert(offsetof(UEffectModelGhost, CustomComponentNames) == 0x000080, "Member 'UEffectModelGhost::CustomComponentNames' has a wrong offset!");
static_assert(offsetof(UEffectModelGhost, AlphaCurve) == 0x000090, "Member 'UEffectModelGhost::AlphaCurve' has a wrong offset!");
static_assert(offsetof(UEffectModelGhost, FloatParameters) == 0x000120, "Member 'UEffectModelGhost::FloatParameters' has a wrong offset!");
static_assert(offsetof(UEffectModelGhost, ColorParameters) == 0x000170, "Member 'UEffectModelGhost::ColorParameters' has a wrong offset!");

// Class KuroGameplay.EffectModelGpuParticle
// 0x05A0 (0x0600 - 0x0060)
class UEffectModelGpuParticle final : public UEffectModelBase
{
public:
	struct FKuroCurveVector                       Location;                                          // 0x0060(0x01A8)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FKuroCurveVector                       Rotation;                                          // 0x0208(0x01A8)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FKuroCurveVector                       Scale;                                             // 0x03B0(0x01A8)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class UKuroGPUParticleDA*                     Data;                                              // 0x0558(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FKuroCurveFloat                        TimeScaler;                                        // 0x0560(0x0090)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	bool                                          Loop;                                              // 0x05F0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          EnablePingPong;                                    // 0x05F1(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5F2[0x2];                                      // 0x05F2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PingPongTime;                                      // 0x05F4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReversePlay;                                       // 0x05F8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5F9[0x7];                                      // 0x05F9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EffectModelGpuParticle">();
	}
	static class UEffectModelGpuParticle* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEffectModelGpuParticle>();
	}
};
static_assert(alignof(UEffectModelGpuParticle) == 0x000008, "Wrong alignment on UEffectModelGpuParticle");
static_assert(sizeof(UEffectModelGpuParticle) == 0x000600, "Wrong size on UEffectModelGpuParticle");
static_assert(offsetof(UEffectModelGpuParticle, Location) == 0x000060, "Member 'UEffectModelGpuParticle::Location' has a wrong offset!");
static_assert(offsetof(UEffectModelGpuParticle, Rotation) == 0x000208, "Member 'UEffectModelGpuParticle::Rotation' has a wrong offset!");
static_assert(offsetof(UEffectModelGpuParticle, Scale) == 0x0003B0, "Member 'UEffectModelGpuParticle::Scale' has a wrong offset!");
static_assert(offsetof(UEffectModelGpuParticle, Data) == 0x000558, "Member 'UEffectModelGpuParticle::Data' has a wrong offset!");
static_assert(offsetof(UEffectModelGpuParticle, TimeScaler) == 0x000560, "Member 'UEffectModelGpuParticle::TimeScaler' has a wrong offset!");
static_assert(offsetof(UEffectModelGpuParticle, Loop) == 0x0005F0, "Member 'UEffectModelGpuParticle::Loop' has a wrong offset!");
static_assert(offsetof(UEffectModelGpuParticle, EnablePingPong) == 0x0005F1, "Member 'UEffectModelGpuParticle::EnablePingPong' has a wrong offset!");
static_assert(offsetof(UEffectModelGpuParticle, PingPongTime) == 0x0005F4, "Member 'UEffectModelGpuParticle::PingPongTime' has a wrong offset!");
static_assert(offsetof(UEffectModelGpuParticle, ReversePlay) == 0x0005F8, "Member 'UEffectModelGpuParticle::ReversePlay' has a wrong offset!");

// Class KuroGameplay.KuroInputManager
// 0x0060 (0x0090 - 0x0030)
class UKuroInputManager final : public UObject
{
public:
	uint8                                         Pad_30[0x50];                                      // 0x0030(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UKuroInputEvent*>                HoldEvents;                                        // 0x0080(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	void OnActorDestroy(class AActor* Actor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroInputManager">();
	}
	static class UKuroInputManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroInputManager>();
	}
};
static_assert(alignof(UKuroInputManager) == 0x000008, "Wrong alignment on UKuroInputManager");
static_assert(sizeof(UKuroInputManager) == 0x000090, "Wrong size on UKuroInputManager");
static_assert(offsetof(UKuroInputManager, HoldEvents) == 0x000080, "Member 'UKuroInputManager::HoldEvents' has a wrong offset!");

// Class KuroGameplay.EffectModelGroup
// 0x0548 (0x05A8 - 0x0060)
class UEffectModelGroup : public UEffectModelBase
{
public:
	struct FKuroCurveVector                       Location;                                          // 0x0060(0x01A8)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FKuroCurveVector                       Rotation;                                          // 0x0208(0x01A8)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FKuroCurveVector                       Scale;                                             // 0x03B0(0x01A8)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<class UEffectModelBase*, float>          EffectData;                                        // 0x0558(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EffectModelGroup">();
	}
	static class UEffectModelGroup* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEffectModelGroup>();
	}
};
static_assert(alignof(UEffectModelGroup) == 0x000008, "Wrong alignment on UEffectModelGroup");
static_assert(sizeof(UEffectModelGroup) == 0x0005A8, "Wrong size on UEffectModelGroup");
static_assert(offsetof(UEffectModelGroup, Location) == 0x000060, "Member 'UEffectModelGroup::Location' has a wrong offset!");
static_assert(offsetof(UEffectModelGroup, Rotation) == 0x000208, "Member 'UEffectModelGroup::Rotation' has a wrong offset!");
static_assert(offsetof(UEffectModelGroup, Scale) == 0x0003B0, "Member 'UEffectModelGroup::Scale' has a wrong offset!");
static_assert(offsetof(UEffectModelGroup, EffectData) == 0x000558, "Member 'UEffectModelGroup::EffectData' has a wrong offset!");

// Class KuroGameplay.EffectModelLight
// 0x0678 (0x06D8 - 0x0060)
class UEffectModelLight : public UEffectModelBase
{
public:
	struct FKuroCurveVector                       Location;                                          // 0x0060(0x01A8)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FKuroCurveFloat                        Intensity;                                         // 0x0208(0x0090)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FKuroCurveLinearColor                  Color;                                             // 0x0298(0x0220)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FKuroCurveFloat                        Radius;                                            // 0x04B8(0x0090)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FKuroCurveFloat                        FalloffExponent;                                   // 0x0548(0x0090)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	ELightQualityType                             LightQualityType;                                  // 0x05D8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5D9[0x3];                                      // 0x05D9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SourceRadius;                                      // 0x05DC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SoftSourceRadius;                                  // 0x05E0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SourceLength;                                      // 0x05E4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FKuroCurveFloat                        CharacterLightAlpha;                               // 0x05E8(0x0090)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	float                                         CharacterFalloffExponent;                          // 0x0678(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CharacterBlendAtten;                               // 0x067C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CharacterBlendIntensity;                           // 0x0680(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EToonLightType                                ToonLightType;                                     // 0x0684(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_685[0x3];                                      // 0x0685(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         CharacterPriority;                                 // 0x0688(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CharacterIntensity;                                // 0x068C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           CharacterColor;                                    // 0x0690(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CharacterShadowIntensity;                          // 0x06A0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CharacterRealTimeShadowIntensity;                  // 0x06A4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CharacterDesaturationIntensity;                    // 0x06A8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CharacterHardIntensity;                            // 0x06AC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           CharacterHardColor;                                // 0x06B0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           CharacterHardShadowColor;                          // 0x06C0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CharacterHardBlend;                                // 0x06D0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6D4[0x4];                                      // 0x06D4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EffectModelLight">();
	}
	static class UEffectModelLight* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEffectModelLight>();
	}
};
static_assert(alignof(UEffectModelLight) == 0x000008, "Wrong alignment on UEffectModelLight");
static_assert(sizeof(UEffectModelLight) == 0x0006D8, "Wrong size on UEffectModelLight");
static_assert(offsetof(UEffectModelLight, Location) == 0x000060, "Member 'UEffectModelLight::Location' has a wrong offset!");
static_assert(offsetof(UEffectModelLight, Intensity) == 0x000208, "Member 'UEffectModelLight::Intensity' has a wrong offset!");
static_assert(offsetof(UEffectModelLight, Color) == 0x000298, "Member 'UEffectModelLight::Color' has a wrong offset!");
static_assert(offsetof(UEffectModelLight, Radius) == 0x0004B8, "Member 'UEffectModelLight::Radius' has a wrong offset!");
static_assert(offsetof(UEffectModelLight, FalloffExponent) == 0x000548, "Member 'UEffectModelLight::FalloffExponent' has a wrong offset!");
static_assert(offsetof(UEffectModelLight, LightQualityType) == 0x0005D8, "Member 'UEffectModelLight::LightQualityType' has a wrong offset!");
static_assert(offsetof(UEffectModelLight, SourceRadius) == 0x0005DC, "Member 'UEffectModelLight::SourceRadius' has a wrong offset!");
static_assert(offsetof(UEffectModelLight, SoftSourceRadius) == 0x0005E0, "Member 'UEffectModelLight::SoftSourceRadius' has a wrong offset!");
static_assert(offsetof(UEffectModelLight, SourceLength) == 0x0005E4, "Member 'UEffectModelLight::SourceLength' has a wrong offset!");
static_assert(offsetof(UEffectModelLight, CharacterLightAlpha) == 0x0005E8, "Member 'UEffectModelLight::CharacterLightAlpha' has a wrong offset!");
static_assert(offsetof(UEffectModelLight, CharacterFalloffExponent) == 0x000678, "Member 'UEffectModelLight::CharacterFalloffExponent' has a wrong offset!");
static_assert(offsetof(UEffectModelLight, CharacterBlendAtten) == 0x00067C, "Member 'UEffectModelLight::CharacterBlendAtten' has a wrong offset!");
static_assert(offsetof(UEffectModelLight, CharacterBlendIntensity) == 0x000680, "Member 'UEffectModelLight::CharacterBlendIntensity' has a wrong offset!");
static_assert(offsetof(UEffectModelLight, ToonLightType) == 0x000684, "Member 'UEffectModelLight::ToonLightType' has a wrong offset!");
static_assert(offsetof(UEffectModelLight, CharacterPriority) == 0x000688, "Member 'UEffectModelLight::CharacterPriority' has a wrong offset!");
static_assert(offsetof(UEffectModelLight, CharacterIntensity) == 0x00068C, "Member 'UEffectModelLight::CharacterIntensity' has a wrong offset!");
static_assert(offsetof(UEffectModelLight, CharacterColor) == 0x000690, "Member 'UEffectModelLight::CharacterColor' has a wrong offset!");
static_assert(offsetof(UEffectModelLight, CharacterShadowIntensity) == 0x0006A0, "Member 'UEffectModelLight::CharacterShadowIntensity' has a wrong offset!");
static_assert(offsetof(UEffectModelLight, CharacterRealTimeShadowIntensity) == 0x0006A4, "Member 'UEffectModelLight::CharacterRealTimeShadowIntensity' has a wrong offset!");
static_assert(offsetof(UEffectModelLight, CharacterDesaturationIntensity) == 0x0006A8, "Member 'UEffectModelLight::CharacterDesaturationIntensity' has a wrong offset!");
static_assert(offsetof(UEffectModelLight, CharacterHardIntensity) == 0x0006AC, "Member 'UEffectModelLight::CharacterHardIntensity' has a wrong offset!");
static_assert(offsetof(UEffectModelLight, CharacterHardColor) == 0x0006B0, "Member 'UEffectModelLight::CharacterHardColor' has a wrong offset!");
static_assert(offsetof(UEffectModelLight, CharacterHardShadowColor) == 0x0006C0, "Member 'UEffectModelLight::CharacterHardShadowColor' has a wrong offset!");
static_assert(offsetof(UEffectModelLight, CharacterHardBlend) == 0x0006D0, "Member 'UEffectModelLight::CharacterHardBlend' has a wrong offset!");

// Class KuroGameplay.EffectModelMaterialController
// 0x0010 (0x0070 - 0x0060)
class UEffectModelMaterialController final : public UEffectModelBase
{
public:
	class UKuroMaterialControllerDataAsset*       MaterialControllerData;                            // 0x0060(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UKuroMaterialControllerDataAsset*       MaterialControllerGroupData;                       // 0x0068(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EffectModelMaterialController">();
	}
	static class UEffectModelMaterialController* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEffectModelMaterialController>();
	}
};
static_assert(alignof(UEffectModelMaterialController) == 0x000008, "Wrong alignment on UEffectModelMaterialController");
static_assert(sizeof(UEffectModelMaterialController) == 0x000070, "Wrong size on UEffectModelMaterialController");
static_assert(offsetof(UEffectModelMaterialController, MaterialControllerData) == 0x000060, "Member 'UEffectModelMaterialController::MaterialControllerData' has a wrong offset!");
static_assert(offsetof(UEffectModelMaterialController, MaterialControllerGroupData) == 0x000068, "Member 'UEffectModelMaterialController::MaterialControllerGroupData' has a wrong offset!");

// Class KuroGameplay.EffectModelMultiEffect
// 0x0018 (0x0078 - 0x0060)
class UEffectModelMultiEffect final : public UEffectModelBase
{
public:
	class UEffectModelBase*                       EffectData;                                        // 0x0060(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMultiEffectType                              Type;                                              // 0x0068(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_69[0x3];                                       // 0x0069(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         BaseNum;                                           // 0x006C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpinSpeed;                                         // 0x0070(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Radius;                                            // 0x0074(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EffectModelMultiEffect">();
	}
	static class UEffectModelMultiEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEffectModelMultiEffect>();
	}
};
static_assert(alignof(UEffectModelMultiEffect) == 0x000008, "Wrong alignment on UEffectModelMultiEffect");
static_assert(sizeof(UEffectModelMultiEffect) == 0x000078, "Wrong size on UEffectModelMultiEffect");
static_assert(offsetof(UEffectModelMultiEffect, EffectData) == 0x000060, "Member 'UEffectModelMultiEffect::EffectData' has a wrong offset!");
static_assert(offsetof(UEffectModelMultiEffect, Type) == 0x000068, "Member 'UEffectModelMultiEffect::Type' has a wrong offset!");
static_assert(offsetof(UEffectModelMultiEffect, BaseNum) == 0x00006C, "Member 'UEffectModelMultiEffect::BaseNum' has a wrong offset!");
static_assert(offsetof(UEffectModelMultiEffect, SpinSpeed) == 0x000070, "Member 'UEffectModelMultiEffect::SpinSpeed' has a wrong offset!");
static_assert(offsetof(UEffectModelMultiEffect, Radius) == 0x000074, "Member 'UEffectModelMultiEffect::Radius' has a wrong offset!");

// Class KuroGameplay.EffectModelNiagara
// 0x0610 (0x0670 - 0x0060)
class UEffectModelNiagara : public UEffectModelBase
{
public:
	struct FKuroCurveVector                       Location;                                          // 0x0060(0x01A8)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FKuroCurveVector                       Rotation;                                          // 0x0208(0x01A8)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FKuroCurveVector                       Scale;                                             // 0x03B0(0x01A8)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class UNiagaraSystem*                         NiagaraRef;                                        // 0x0558(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class FName, struct FKuroCurveFloat>     FloatParameters;                                   // 0x0560(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TMap<class FName, struct FKuroCurveLinearColor> ColorParameters;                                   // 0x05B0(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TMap<class FName, struct FKuroCurveVector>    VectorParameters;                                  // 0x0600(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	bool                                          DeactivateOnStop;                                  // 0x0650(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReceiveDecal;                                      // 0x0651(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_652[0x2];                                      // 0x0652(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         TranslucencySortPriority;                          // 0x0654(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FEffectModelNiagaraExtraState>  ExtraStates;                                       // 0x0658(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          HideForProtoPlayer;                                // 0x0668(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCastShadow;                                       // 0x0669(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IgnoreMobileSimulationOptimize;                    // 0x066A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_66B[0x5];                                      // 0x066B(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EffectModelNiagara">();
	}
	static class UEffectModelNiagara* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEffectModelNiagara>();
	}
};
static_assert(alignof(UEffectModelNiagara) == 0x000008, "Wrong alignment on UEffectModelNiagara");
static_assert(sizeof(UEffectModelNiagara) == 0x000670, "Wrong size on UEffectModelNiagara");
static_assert(offsetof(UEffectModelNiagara, Location) == 0x000060, "Member 'UEffectModelNiagara::Location' has a wrong offset!");
static_assert(offsetof(UEffectModelNiagara, Rotation) == 0x000208, "Member 'UEffectModelNiagara::Rotation' has a wrong offset!");
static_assert(offsetof(UEffectModelNiagara, Scale) == 0x0003B0, "Member 'UEffectModelNiagara::Scale' has a wrong offset!");
static_assert(offsetof(UEffectModelNiagara, NiagaraRef) == 0x000558, "Member 'UEffectModelNiagara::NiagaraRef' has a wrong offset!");
static_assert(offsetof(UEffectModelNiagara, FloatParameters) == 0x000560, "Member 'UEffectModelNiagara::FloatParameters' has a wrong offset!");
static_assert(offsetof(UEffectModelNiagara, ColorParameters) == 0x0005B0, "Member 'UEffectModelNiagara::ColorParameters' has a wrong offset!");
static_assert(offsetof(UEffectModelNiagara, VectorParameters) == 0x000600, "Member 'UEffectModelNiagara::VectorParameters' has a wrong offset!");
static_assert(offsetof(UEffectModelNiagara, DeactivateOnStop) == 0x000650, "Member 'UEffectModelNiagara::DeactivateOnStop' has a wrong offset!");
static_assert(offsetof(UEffectModelNiagara, ReceiveDecal) == 0x000651, "Member 'UEffectModelNiagara::ReceiveDecal' has a wrong offset!");
static_assert(offsetof(UEffectModelNiagara, TranslucencySortPriority) == 0x000654, "Member 'UEffectModelNiagara::TranslucencySortPriority' has a wrong offset!");
static_assert(offsetof(UEffectModelNiagara, ExtraStates) == 0x000658, "Member 'UEffectModelNiagara::ExtraStates' has a wrong offset!");
static_assert(offsetof(UEffectModelNiagara, HideForProtoPlayer) == 0x000668, "Member 'UEffectModelNiagara::HideForProtoPlayer' has a wrong offset!");
static_assert(offsetof(UEffectModelNiagara, bCastShadow) == 0x000669, "Member 'UEffectModelNiagara::bCastShadow' has a wrong offset!");
static_assert(offsetof(UEffectModelNiagara, IgnoreMobileSimulationOptimize) == 0x00066A, "Member 'UEffectModelNiagara::IgnoreMobileSimulationOptimize' has a wrong offset!");

// Class KuroGameplay.EffectModelPostProcess
// 0x48E0 (0x4940 - 0x0060)
class UEffectModelPostProcess : public UEffectModelBase
{
public:
	struct FKuroCurveVector                       Location;                                          // 0x0060(0x01A8)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	bool                                          EnableVolume;                                      // 0x0208(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_209[0x3];                                      // 0x0209(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         VolumeRadius;                                      // 0x020C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VolumeHardness;                                    // 0x0210(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UseVolumeHardnessCurve;                            // 0x0214(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_215[0x3];                                      // 0x0215(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FKuroCurveFloat                        VolumeHardnessCurve;                               // 0x0218(0x0090)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	float                                         WeatherPriority;                                   // 0x02A8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          VisibleForProtoPlayer;                             // 0x02AC(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          OverrideTOD;                                       // 0x02AD(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnablePostprocessMaterial;                        // 0x02AE(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2AF[0x1];                                      // 0x02AF(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialInterface*                     PostprocessMaterial;                               // 0x02B0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class FName, struct FKuroCurveFloat>     PostprocessMaterialFloatParameters;                // 0x02B8(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<class FName, struct FKuroCurveLinearColor> PostprocessMaterialColorParameters;                // 0x0308(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	bool                                          BlurIntensityOverride;                             // 0x0358(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_359[0x7];                                      // 0x0359(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FKuroCurveFloat                        BlurIntensity;                                     // 0x0360(0x0090)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	bool                                          UseWorldPosition;                                  // 0x03F0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3F1[0x3];                                      // 0x03F1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              ScreenPosition;                                    // 0x03F4(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3FC[0x4];                                      // 0x03FC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FKuroCurveFloat                        RadialBlurRadius;                                  // 0x0400(0x0090)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FKuroCurveFloat                        RadialBlurHardness;                                // 0x0490(0x0090)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class UTexture*                               RadialBlurMask;                                    // 0x0520(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              RadialBlurMaskScale;                               // 0x0528(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FKuroCurveLinearColor                  RadialBlurMaskScaleOffset;                         // 0x0530(0x0220)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	bool                                          MainLightIntensityOverride;                        // 0x0750(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_751[0x7];                                      // 0x0751(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FKuroCurveFloat                        MainLightIntensity;                                // 0x0758(0x0090)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	bool                                          MainLightColorOverride;                            // 0x07E8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7E9[0x7];                                      // 0x07E9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FKuroCurveLinearColor                  MainLightColor;                                    // 0x07F0(0x0220)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	bool                                          SkyLightIntensityOverride;                         // 0x0A10(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A11[0x7];                                      // 0x0A11(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FKuroCurveFloat                        SkyLightIntensity;                                 // 0x0A18(0x0090)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	bool                                          SkyLightColorOverride;                             // 0x0AA8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_AA9[0x7];                                      // 0x0AA9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FKuroCurveLinearColor                  SkyLightColor;                                     // 0x0AB0(0x0220)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	bool                                          EnableEffectFog;                                   // 0x0CD0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_CD1[0x7];                                      // 0x0CD1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FKuroCurveFloat                        EffectFogSwitch;                                   // 0x0CD8(0x0090)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	bool                                          FogDensityOverride;                                // 0x0D68(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D69[0x7];                                      // 0x0D69(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FKuroCurveFloat                        FogDensity;                                        // 0x0D70(0x0090)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FKuroCurveFloat                        FogStartDistance;                                  // 0x0E00(0x0090)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	float                                         FogFalloff;                                        // 0x0E90(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E94[0x4];                                      // 0x0E94(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FKuroCurveFloat                        FogMaxOpacity;                                     // 0x0E98(0x0090)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	bool                                          FogColorOverride;                                  // 0x0F28(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F29[0x7];                                      // 0x0F29(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FKuroCurveLinearColor                  FogNearColor;                                      // 0x0F30(0x0220)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FKuroCurveLinearColor                  FogFarColor;                                       // 0x1150(0x0220)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FKuroCurveFloat                        FogNearColorDistance;                              // 0x1370(0x0090)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FKuroCurveFloat                        FogFarColorDistance;                               // 0x1400(0x0090)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	float                                         FogColorRatio;                                     // 0x1490(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          FogDistanceViewOverride;                           // 0x1494(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1495[0x3];                                     // 0x1495(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FogFalloffFarSky;                                  // 0x1498(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FogMixDistance;                                    // 0x149C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FogMixWidth;                                       // 0x14A0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          KuroBloomIntensityOverride;                        // 0x14A4(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14A5[0x3];                                     // 0x14A5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FKuroCurveFloat                        KuroBloomIntensity;                                // 0x14A8(0x0090)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	bool                                          KuroThresholdOverride;                             // 0x1538(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1539[0x7];                                     // 0x1539(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FKuroCurveFloat                        KuroThreshold;                                     // 0x1540(0x0090)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	bool                                          SceneFringeIntensityOverride;                      // 0x15D0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15D1[0x7];                                     // 0x15D1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FKuroCurveFloat                        SceneFringeIntensity;                              // 0x15D8(0x0090)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	bool                                          StartOffsetOverride;                               // 0x1668(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1669[0x7];                                     // 0x1669(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FKuroCurveFloat                        StartOffset;                                       // 0x1670(0x0090)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	bool                                          VignetteIntensityOverride;                         // 0x1700(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1701[0x7];                                     // 0x1701(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FKuroCurveFloat                        VignetteIntensity;                                 // 0x1708(0x0090)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	bool                                          VignetteAdvanceOverride;                           // 0x1798(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1799[0x7];                                     // 0x1799(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FKuroCurveFloat                        VignetteHardness;                                  // 0x17A0(0x0090)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FKuroCurveFloat                        VignetteXScale;                                    // 0x1830(0x0090)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FKuroCurveFloat                        VignetteYScale;                                    // 0x18C0(0x0090)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FKuroCurveFloat                        VignetteXPos;                                      // 0x1950(0x0090)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FKuroCurveFloat                        VignetteYPos;                                      // 0x19E0(0x0090)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FKuroCurveLinearColor                  VignetteColor;                                     // 0x1A70(0x0220)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	bool                                          GrainJitterOverride;                               // 0x1C90(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C91[0x7];                                     // 0x1C91(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FKuroCurveFloat                        GrainJitter;                                       // 0x1C98(0x0090)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	bool                                          GrainIntensityOverride;                            // 0x1D28(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D29[0x7];                                     // 0x1D29(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FKuroCurveFloat                        GrainIntensity;                                    // 0x1D30(0x0090)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	bool                                          LutIntensityOverride;                              // 0x1DC0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1DC1[0x7];                                     // 0x1DC1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FKuroCurveFloat                        LutIntensity;                                      // 0x1DC8(0x0090)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	bool                                          LutTextureOverride;                                // 0x1E58(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1E59[0x7];                                     // 0x1E59(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UTexture2D*                             LutTexture;                                        // 0x1E60(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          SceneColorTintOverride;                            // 0x1E68(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1E69[0x7];                                     // 0x1E69(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FKuroCurveLinearColor                  SceneColorTint;                                    // 0x1E70(0x0220)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	bool                                          SceneColorDesaturateOverride;                      // 0x2090(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2091[0x7];                                     // 0x2091(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FKuroCurveFloat                        SceneColorDesaturate;                              // 0x2098(0x0090)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	bool                                          BlackWhiteFlashIntensityOverride;                  // 0x2128(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2129[0x7];                                     // 0x2129(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FKuroCurveFloat                        BlackWhiteFlashIntensity;                          // 0x2130(0x0090)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	bool                                          BlackWhiteFlashFactorOverride;                     // 0x21C0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21C1[0x7];                                     // 0x21C1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FKuroCurveFloat                        BlackWhiteFlashFactor;                             // 0x21C8(0x0090)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	bool                                          BlackWhiteFlashThresholdOverride;                  // 0x2258(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2259[0x7];                                     // 0x2259(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FKuroCurveFloat                        BlackWhiteFlashThreshold;                          // 0x2260(0x0090)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	bool                                          BlackWhiteFlashBlackAreaColorOverride;             // 0x22F0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22F1[0x7];                                     // 0x22F1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FKuroCurveLinearColor                  BlackWhiteFlashBlackAreaColor;                     // 0x22F8(0x0220)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	bool                                          BlackWhiteFlashWhiteAreaColorOverride;             // 0x2518(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2519[0x7];                                     // 0x2519(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FKuroCurveLinearColor                  BlackWhiteFlashWhiteAreaColor;                     // 0x2520(0x0220)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	bool                                          GrayGradationOverride;                             // 0x2740(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          GrayGradationCullTranslucency;                     // 0x2741(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          GrayGradationUsePlayerLocation;                    // 0x2742(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2743[0x5];                                     // 0x2743(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	struct FKuroCurveFloat                        GrayGradationDegree;                               // 0x2748(0x0090)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FKuroCurveFloat                        GrayGradationLerpWidth;                            // 0x27D8(0x0090)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class UTexture2D*                             GrayGradationRampTexture;                          // 0x2868(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FKuroCurveLinearColor                  GrayGradationColorTint;                            // 0x2870(0x0220)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FKuroCurveFloat                        GrayGradationBlendWeight;                          // 0x2A90(0x0090)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	bool                                          RetroFuturisticOverride;                           // 0x2B20(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B21[0x7];                                     // 0x2B21(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FKuroCurveFloat                        MainCenterMask;                                    // 0x2B28(0x0090)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FKuroCurveFloat                        MainCenterMaskRadius;                              // 0x2BB8(0x0090)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FKuroCurveFloat                        MainCenterMaskHardness;                            // 0x2C48(0x0090)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FKuroCurveFloat                        MainStartDistance;                                 // 0x2CD8(0x0090)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FKuroCurveFloat                        MainCharacterIntensity;                            // 0x2D68(0x0090)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FKuroCurveFloat                        VintageColorIntensity;                             // 0x2DF8(0x0090)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FKuroCurveFloat                        VintageColorBlackPoint;                            // 0x2E88(0x0090)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FKuroCurveFloat                        VintageColorWhitePoint;                            // 0x2F18(0x0090)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FKuroCurveFloat                        VHSLinesColorIntensity;                            // 0x2FA8(0x0090)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FKuroCurveFloat                        VHSLinesDistortIntensity;                          // 0x3038(0x0090)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FKuroCurveFloat                        VHSEffectIntensity;                                // 0x30C8(0x0090)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FKuroCurveFloat                        VHSSpecklesIntensity;                              // 0x3158(0x0090)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FKuroCurveFloat                        VHSSpecklesAmount;                                 // 0x31E8(0x0090)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FKuroCurveFloat                        VHSSpecklesSize;                                   // 0x3278(0x0090)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FKuroCurveFloat                        CRTDistortion;                                     // 0x3308(0x0090)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	bool                                          RetroFuturisticAdvancedOverride;                   // 0x3398(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3399[0x7];                                     // 0x3399(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FKuroCurveFloat                        VintageColorCenterMask;                            // 0x33A0(0x0090)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FKuroCurveFloat                        VintageColorStartDistance;                         // 0x3430(0x0090)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FKuroCurveFloat                        VintageColorCharacterIntensity;                    // 0x34C0(0x0090)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FKuroCurveFloat                        VHSLinesCenterMask;                                // 0x3550(0x0090)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FKuroCurveFloat                        VHSLinesStartDistance;                             // 0x35E0(0x0090)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FKuroCurveFloat                        VHSLinesCharacterIntensity;                        // 0x3670(0x0090)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FKuroCurveFloat                        VHSEffectCenterMask;                               // 0x3700(0x0090)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FKuroCurveFloat                        VHSEffectStartDistance;                            // 0x3790(0x0090)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FKuroCurveFloat                        VHSEffectCharacterIntensity;                       // 0x3820(0x0090)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FKuroCurveFloat                        VHSSpecklesCenterMask;                             // 0x38B0(0x0090)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FKuroCurveFloat                        VHSSpecklesStartDistance;                          // 0x3940(0x0090)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FKuroCurveFloat                        VHSSpecklesCharacterIntensity;                     // 0x39D0(0x0090)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	bool                                          ScreenWaveOverride;                                // 0x3A60(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UsePolarWavePattern;                               // 0x3A61(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3A62[0x6];                                     // 0x3A62(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UTexture2D*                             WavePatternTexture;                                // 0x3A68(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FKuroCurveLinearColor                  WavePatternScaleBias;                              // 0x3A70(0x0220)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FKuroCurveFloat                        WaveRadius;                                        // 0x3C90(0x0090)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FKuroCurveFloat                        WaveRadiusSmooth;                                  // 0x3D20(0x0090)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FKuroCurveFloat                        WaveHeight;                                        // 0x3DB0(0x0090)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FKuroCurveFloat                        WaveHeightSmooth;                                  // 0x3E40(0x0090)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FKuroCurveFloat                        WaveNormalSize;                                    // 0x3ED0(0x0090)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FKuroCurveFloat                        WaveRoughness;                                     // 0x3F60(0x0090)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class UTexture2D*                             WaveDissolveTexture;                               // 0x3FF0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FKuroCurveLinearColor                  WaveDissolveScaleBias;                             // 0x3FF8(0x0220)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FKuroCurveFloat                        WaveDissolveProgress;                              // 0x4218(0x0090)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FKuroCurveFloat                        WaveDissolveSmooth;                                // 0x42A8(0x0090)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class UTexture2D*                             WaveColorTexture;                                  // 0x4338(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FKuroCurveLinearColor                  WaveColorScaleBias;                                // 0x4340(0x0220)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FKuroCurveLinearColor                  WaveColorTextureTint;                              // 0x4560(0x0220)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FKuroCurveFloat                        WaveAmplitude;                                     // 0x4780(0x0090)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	bool                                          AutoExposureOverride;                              // 0x4810(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4811[0x7];                                     // 0x4811(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FKuroCurveFloat                        AutoExposureMinBrightness;                         // 0x4818(0x0090)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FKuroCurveFloat                        AutoExposureMaxBrightness;                         // 0x48A8(0x0090)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class UKuroWeatherDataAsset*                  WeatherDataAsset;                                  // 0x4938(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EffectModelPostProcess">();
	}
	static class UEffectModelPostProcess* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEffectModelPostProcess>();
	}
};
static_assert(alignof(UEffectModelPostProcess) == 0x000008, "Wrong alignment on UEffectModelPostProcess");
static_assert(sizeof(UEffectModelPostProcess) == 0x004940, "Wrong size on UEffectModelPostProcess");
static_assert(offsetof(UEffectModelPostProcess, Location) == 0x000060, "Member 'UEffectModelPostProcess::Location' has a wrong offset!");
static_assert(offsetof(UEffectModelPostProcess, EnableVolume) == 0x000208, "Member 'UEffectModelPostProcess::EnableVolume' has a wrong offset!");
static_assert(offsetof(UEffectModelPostProcess, VolumeRadius) == 0x00020C, "Member 'UEffectModelPostProcess::VolumeRadius' has a wrong offset!");
static_assert(offsetof(UEffectModelPostProcess, VolumeHardness) == 0x000210, "Member 'UEffectModelPostProcess::VolumeHardness' has a wrong offset!");
static_assert(offsetof(UEffectModelPostProcess, UseVolumeHardnessCurve) == 0x000214, "Member 'UEffectModelPostProcess::UseVolumeHardnessCurve' has a wrong offset!");
static_assert(offsetof(UEffectModelPostProcess, VolumeHardnessCurve) == 0x000218, "Member 'UEffectModelPostProcess::VolumeHardnessCurve' has a wrong offset!");
static_assert(offsetof(UEffectModelPostProcess, WeatherPriority) == 0x0002A8, "Member 'UEffectModelPostProcess::WeatherPriority' has a wrong offset!");
static_assert(offsetof(UEffectModelPostProcess, VisibleForProtoPlayer) == 0x0002AC, "Member 'UEffectModelPostProcess::VisibleForProtoPlayer' has a wrong offset!");
static_assert(offsetof(UEffectModelPostProcess, OverrideTOD) == 0x0002AD, "Member 'UEffectModelPostProcess::OverrideTOD' has a wrong offset!");
static_assert(offsetof(UEffectModelPostProcess, bEnablePostprocessMaterial) == 0x0002AE, "Member 'UEffectModelPostProcess::bEnablePostprocessMaterial' has a wrong offset!");
static_assert(offsetof(UEffectModelPostProcess, PostprocessMaterial) == 0x0002B0, "Member 'UEffectModelPostProcess::PostprocessMaterial' has a wrong offset!");
static_assert(offsetof(UEffectModelPostProcess, PostprocessMaterialFloatParameters) == 0x0002B8, "Member 'UEffectModelPostProcess::PostprocessMaterialFloatParameters' has a wrong offset!");
static_assert(offsetof(UEffectModelPostProcess, PostprocessMaterialColorParameters) == 0x000308, "Member 'UEffectModelPostProcess::PostprocessMaterialColorParameters' has a wrong offset!");
static_assert(offsetof(UEffectModelPostProcess, BlurIntensityOverride) == 0x000358, "Member 'UEffectModelPostProcess::BlurIntensityOverride' has a wrong offset!");
static_assert(offsetof(UEffectModelPostProcess, BlurIntensity) == 0x000360, "Member 'UEffectModelPostProcess::BlurIntensity' has a wrong offset!");
static_assert(offsetof(UEffectModelPostProcess, UseWorldPosition) == 0x0003F0, "Member 'UEffectModelPostProcess::UseWorldPosition' has a wrong offset!");
static_assert(offsetof(UEffectModelPostProcess, ScreenPosition) == 0x0003F4, "Member 'UEffectModelPostProcess::ScreenPosition' has a wrong offset!");
static_assert(offsetof(UEffectModelPostProcess, RadialBlurRadius) == 0x000400, "Member 'UEffectModelPostProcess::RadialBlurRadius' has a wrong offset!");
static_assert(offsetof(UEffectModelPostProcess, RadialBlurHardness) == 0x000490, "Member 'UEffectModelPostProcess::RadialBlurHardness' has a wrong offset!");
static_assert(offsetof(UEffectModelPostProcess, RadialBlurMask) == 0x000520, "Member 'UEffectModelPostProcess::RadialBlurMask' has a wrong offset!");
static_assert(offsetof(UEffectModelPostProcess, RadialBlurMaskScale) == 0x000528, "Member 'UEffectModelPostProcess::RadialBlurMaskScale' has a wrong offset!");
static_assert(offsetof(UEffectModelPostProcess, RadialBlurMaskScaleOffset) == 0x000530, "Member 'UEffectModelPostProcess::RadialBlurMaskScaleOffset' has a wrong offset!");
static_assert(offsetof(UEffectModelPostProcess, MainLightIntensityOverride) == 0x000750, "Member 'UEffectModelPostProcess::MainLightIntensityOverride' has a wrong offset!");
static_assert(offsetof(UEffectModelPostProcess, MainLightIntensity) == 0x000758, "Member 'UEffectModelPostProcess::MainLightIntensity' has a wrong offset!");
static_assert(offsetof(UEffectModelPostProcess, MainLightColorOverride) == 0x0007E8, "Member 'UEffectModelPostProcess::MainLightColorOverride' has a wrong offset!");
static_assert(offsetof(UEffectModelPostProcess, MainLightColor) == 0x0007F0, "Member 'UEffectModelPostProcess::MainLightColor' has a wrong offset!");
static_assert(offsetof(UEffectModelPostProcess, SkyLightIntensityOverride) == 0x000A10, "Member 'UEffectModelPostProcess::SkyLightIntensityOverride' has a wrong offset!");
static_assert(offsetof(UEffectModelPostProcess, SkyLightIntensity) == 0x000A18, "Member 'UEffectModelPostProcess::SkyLightIntensity' has a wrong offset!");
static_assert(offsetof(UEffectModelPostProcess, SkyLightColorOverride) == 0x000AA8, "Member 'UEffectModelPostProcess::SkyLightColorOverride' has a wrong offset!");
static_assert(offsetof(UEffectModelPostProcess, SkyLightColor) == 0x000AB0, "Member 'UEffectModelPostProcess::SkyLightColor' has a wrong offset!");
static_assert(offsetof(UEffectModelPostProcess, EnableEffectFog) == 0x000CD0, "Member 'UEffectModelPostProcess::EnableEffectFog' has a wrong offset!");
static_assert(offsetof(UEffectModelPostProcess, EffectFogSwitch) == 0x000CD8, "Member 'UEffectModelPostProcess::EffectFogSwitch' has a wrong offset!");
static_assert(offsetof(UEffectModelPostProcess, FogDensityOverride) == 0x000D68, "Member 'UEffectModelPostProcess::FogDensityOverride' has a wrong offset!");
static_assert(offsetof(UEffectModelPostProcess, FogDensity) == 0x000D70, "Member 'UEffectModelPostProcess::FogDensity' has a wrong offset!");
static_assert(offsetof(UEffectModelPostProcess, FogStartDistance) == 0x000E00, "Member 'UEffectModelPostProcess::FogStartDistance' has a wrong offset!");
static_assert(offsetof(UEffectModelPostProcess, FogFalloff) == 0x000E90, "Member 'UEffectModelPostProcess::FogFalloff' has a wrong offset!");
static_assert(offsetof(UEffectModelPostProcess, FogMaxOpacity) == 0x000E98, "Member 'UEffectModelPostProcess::FogMaxOpacity' has a wrong offset!");
static_assert(offsetof(UEffectModelPostProcess, FogColorOverride) == 0x000F28, "Member 'UEffectModelPostProcess::FogColorOverride' has a wrong offset!");
static_assert(offsetof(UEffectModelPostProcess, FogNearColor) == 0x000F30, "Member 'UEffectModelPostProcess::FogNearColor' has a wrong offset!");
static_assert(offsetof(UEffectModelPostProcess, FogFarColor) == 0x001150, "Member 'UEffectModelPostProcess::FogFarColor' has a wrong offset!");
static_assert(offsetof(UEffectModelPostProcess, FogNearColorDistance) == 0x001370, "Member 'UEffectModelPostProcess::FogNearColorDistance' has a wrong offset!");
static_assert(offsetof(UEffectModelPostProcess, FogFarColorDistance) == 0x001400, "Member 'UEffectModelPostProcess::FogFarColorDistance' has a wrong offset!");
static_assert(offsetof(UEffectModelPostProcess, FogColorRatio) == 0x001490, "Member 'UEffectModelPostProcess::FogColorRatio' has a wrong offset!");
static_assert(offsetof(UEffectModelPostProcess, FogDistanceViewOverride) == 0x001494, "Member 'UEffectModelPostProcess::FogDistanceViewOverride' has a wrong offset!");
static_assert(offsetof(UEffectModelPostProcess, FogFalloffFarSky) == 0x001498, "Member 'UEffectModelPostProcess::FogFalloffFarSky' has a wrong offset!");
static_assert(offsetof(UEffectModelPostProcess, FogMixDistance) == 0x00149C, "Member 'UEffectModelPostProcess::FogMixDistance' has a wrong offset!");
static_assert(offsetof(UEffectModelPostProcess, FogMixWidth) == 0x0014A0, "Member 'UEffectModelPostProcess::FogMixWidth' has a wrong offset!");
static_assert(offsetof(UEffectModelPostProcess, KuroBloomIntensityOverride) == 0x0014A4, "Member 'UEffectModelPostProcess::KuroBloomIntensityOverride' has a wrong offset!");
static_assert(offsetof(UEffectModelPostProcess, KuroBloomIntensity) == 0x0014A8, "Member 'UEffectModelPostProcess::KuroBloomIntensity' has a wrong offset!");
static_assert(offsetof(UEffectModelPostProcess, KuroThresholdOverride) == 0x001538, "Member 'UEffectModelPostProcess::KuroThresholdOverride' has a wrong offset!");
static_assert(offsetof(UEffectModelPostProcess, KuroThreshold) == 0x001540, "Member 'UEffectModelPostProcess::KuroThreshold' has a wrong offset!");
static_assert(offsetof(UEffectModelPostProcess, SceneFringeIntensityOverride) == 0x0015D0, "Member 'UEffectModelPostProcess::SceneFringeIntensityOverride' has a wrong offset!");
static_assert(offsetof(UEffectModelPostProcess, SceneFringeIntensity) == 0x0015D8, "Member 'UEffectModelPostProcess::SceneFringeIntensity' has a wrong offset!");
static_assert(offsetof(UEffectModelPostProcess, StartOffsetOverride) == 0x001668, "Member 'UEffectModelPostProcess::StartOffsetOverride' has a wrong offset!");
static_assert(offsetof(UEffectModelPostProcess, StartOffset) == 0x001670, "Member 'UEffectModelPostProcess::StartOffset' has a wrong offset!");
static_assert(offsetof(UEffectModelPostProcess, VignetteIntensityOverride) == 0x001700, "Member 'UEffectModelPostProcess::VignetteIntensityOverride' has a wrong offset!");
static_assert(offsetof(UEffectModelPostProcess, VignetteIntensity) == 0x001708, "Member 'UEffectModelPostProcess::VignetteIntensity' has a wrong offset!");
static_assert(offsetof(UEffectModelPostProcess, VignetteAdvanceOverride) == 0x001798, "Member 'UEffectModelPostProcess::VignetteAdvanceOverride' has a wrong offset!");
static_assert(offsetof(UEffectModelPostProcess, VignetteHardness) == 0x0017A0, "Member 'UEffectModelPostProcess::VignetteHardness' has a wrong offset!");
static_assert(offsetof(UEffectModelPostProcess, VignetteXScale) == 0x001830, "Member 'UEffectModelPostProcess::VignetteXScale' has a wrong offset!");
static_assert(offsetof(UEffectModelPostProcess, VignetteYScale) == 0x0018C0, "Member 'UEffectModelPostProcess::VignetteYScale' has a wrong offset!");
static_assert(offsetof(UEffectModelPostProcess, VignetteXPos) == 0x001950, "Member 'UEffectModelPostProcess::VignetteXPos' has a wrong offset!");
static_assert(offsetof(UEffectModelPostProcess, VignetteYPos) == 0x0019E0, "Member 'UEffectModelPostProcess::VignetteYPos' has a wrong offset!");
static_assert(offsetof(UEffectModelPostProcess, VignetteColor) == 0x001A70, "Member 'UEffectModelPostProcess::VignetteColor' has a wrong offset!");
static_assert(offsetof(UEffectModelPostProcess, GrainJitterOverride) == 0x001C90, "Member 'UEffectModelPostProcess::GrainJitterOverride' has a wrong offset!");
static_assert(offsetof(UEffectModelPostProcess, GrainJitter) == 0x001C98, "Member 'UEffectModelPostProcess::GrainJitter' has a wrong offset!");
static_assert(offsetof(UEffectModelPostProcess, GrainIntensityOverride) == 0x001D28, "Member 'UEffectModelPostProcess::GrainIntensityOverride' has a wrong offset!");
static_assert(offsetof(UEffectModelPostProcess, GrainIntensity) == 0x001D30, "Member 'UEffectModelPostProcess::GrainIntensity' has a wrong offset!");
static_assert(offsetof(UEffectModelPostProcess, LutIntensityOverride) == 0x001DC0, "Member 'UEffectModelPostProcess::LutIntensityOverride' has a wrong offset!");
static_assert(offsetof(UEffectModelPostProcess, LutIntensity) == 0x001DC8, "Member 'UEffectModelPostProcess::LutIntensity' has a wrong offset!");
static_assert(offsetof(UEffectModelPostProcess, LutTextureOverride) == 0x001E58, "Member 'UEffectModelPostProcess::LutTextureOverride' has a wrong offset!");
static_assert(offsetof(UEffectModelPostProcess, LutTexture) == 0x001E60, "Member 'UEffectModelPostProcess::LutTexture' has a wrong offset!");
static_assert(offsetof(UEffectModelPostProcess, SceneColorTintOverride) == 0x001E68, "Member 'UEffectModelPostProcess::SceneColorTintOverride' has a wrong offset!");
static_assert(offsetof(UEffectModelPostProcess, SceneColorTint) == 0x001E70, "Member 'UEffectModelPostProcess::SceneColorTint' has a wrong offset!");
static_assert(offsetof(UEffectModelPostProcess, SceneColorDesaturateOverride) == 0x002090, "Member 'UEffectModelPostProcess::SceneColorDesaturateOverride' has a wrong offset!");
static_assert(offsetof(UEffectModelPostProcess, SceneColorDesaturate) == 0x002098, "Member 'UEffectModelPostProcess::SceneColorDesaturate' has a wrong offset!");
static_assert(offsetof(UEffectModelPostProcess, BlackWhiteFlashIntensityOverride) == 0x002128, "Member 'UEffectModelPostProcess::BlackWhiteFlashIntensityOverride' has a wrong offset!");
static_assert(offsetof(UEffectModelPostProcess, BlackWhiteFlashIntensity) == 0x002130, "Member 'UEffectModelPostProcess::BlackWhiteFlashIntensity' has a wrong offset!");
static_assert(offsetof(UEffectModelPostProcess, BlackWhiteFlashFactorOverride) == 0x0021C0, "Member 'UEffectModelPostProcess::BlackWhiteFlashFactorOverride' has a wrong offset!");
static_assert(offsetof(UEffectModelPostProcess, BlackWhiteFlashFactor) == 0x0021C8, "Member 'UEffectModelPostProcess::BlackWhiteFlashFactor' has a wrong offset!");
static_assert(offsetof(UEffectModelPostProcess, BlackWhiteFlashThresholdOverride) == 0x002258, "Member 'UEffectModelPostProcess::BlackWhiteFlashThresholdOverride' has a wrong offset!");
static_assert(offsetof(UEffectModelPostProcess, BlackWhiteFlashThreshold) == 0x002260, "Member 'UEffectModelPostProcess::BlackWhiteFlashThreshold' has a wrong offset!");
static_assert(offsetof(UEffectModelPostProcess, BlackWhiteFlashBlackAreaColorOverride) == 0x0022F0, "Member 'UEffectModelPostProcess::BlackWhiteFlashBlackAreaColorOverride' has a wrong offset!");
static_assert(offsetof(UEffectModelPostProcess, BlackWhiteFlashBlackAreaColor) == 0x0022F8, "Member 'UEffectModelPostProcess::BlackWhiteFlashBlackAreaColor' has a wrong offset!");
static_assert(offsetof(UEffectModelPostProcess, BlackWhiteFlashWhiteAreaColorOverride) == 0x002518, "Member 'UEffectModelPostProcess::BlackWhiteFlashWhiteAreaColorOverride' has a wrong offset!");
static_assert(offsetof(UEffectModelPostProcess, BlackWhiteFlashWhiteAreaColor) == 0x002520, "Member 'UEffectModelPostProcess::BlackWhiteFlashWhiteAreaColor' has a wrong offset!");
static_assert(offsetof(UEffectModelPostProcess, GrayGradationOverride) == 0x002740, "Member 'UEffectModelPostProcess::GrayGradationOverride' has a wrong offset!");
static_assert(offsetof(UEffectModelPostProcess, GrayGradationCullTranslucency) == 0x002741, "Member 'UEffectModelPostProcess::GrayGradationCullTranslucency' has a wrong offset!");
static_assert(offsetof(UEffectModelPostProcess, GrayGradationUsePlayerLocation) == 0x002742, "Member 'UEffectModelPostProcess::GrayGradationUsePlayerLocation' has a wrong offset!");
static_assert(offsetof(UEffectModelPostProcess, GrayGradationDegree) == 0x002748, "Member 'UEffectModelPostProcess::GrayGradationDegree' has a wrong offset!");
static_assert(offsetof(UEffectModelPostProcess, GrayGradationLerpWidth) == 0x0027D8, "Member 'UEffectModelPostProcess::GrayGradationLerpWidth' has a wrong offset!");
static_assert(offsetof(UEffectModelPostProcess, GrayGradationRampTexture) == 0x002868, "Member 'UEffectModelPostProcess::GrayGradationRampTexture' has a wrong offset!");
static_assert(offsetof(UEffectModelPostProcess, GrayGradationColorTint) == 0x002870, "Member 'UEffectModelPostProcess::GrayGradationColorTint' has a wrong offset!");
static_assert(offsetof(UEffectModelPostProcess, GrayGradationBlendWeight) == 0x002A90, "Member 'UEffectModelPostProcess::GrayGradationBlendWeight' has a wrong offset!");
static_assert(offsetof(UEffectModelPostProcess, RetroFuturisticOverride) == 0x002B20, "Member 'UEffectModelPostProcess::RetroFuturisticOverride' has a wrong offset!");
static_assert(offsetof(UEffectModelPostProcess, MainCenterMask) == 0x002B28, "Member 'UEffectModelPostProcess::MainCenterMask' has a wrong offset!");
static_assert(offsetof(UEffectModelPostProcess, MainCenterMaskRadius) == 0x002BB8, "Member 'UEffectModelPostProcess::MainCenterMaskRadius' has a wrong offset!");
static_assert(offsetof(UEffectModelPostProcess, MainCenterMaskHardness) == 0x002C48, "Member 'UEffectModelPostProcess::MainCenterMaskHardness' has a wrong offset!");
static_assert(offsetof(UEffectModelPostProcess, MainStartDistance) == 0x002CD8, "Member 'UEffectModelPostProcess::MainStartDistance' has a wrong offset!");
static_assert(offsetof(UEffectModelPostProcess, MainCharacterIntensity) == 0x002D68, "Member 'UEffectModelPostProcess::MainCharacterIntensity' has a wrong offset!");
static_assert(offsetof(UEffectModelPostProcess, VintageColorIntensity) == 0x002DF8, "Member 'UEffectModelPostProcess::VintageColorIntensity' has a wrong offset!");
static_assert(offsetof(UEffectModelPostProcess, VintageColorBlackPoint) == 0x002E88, "Member 'UEffectModelPostProcess::VintageColorBlackPoint' has a wrong offset!");
static_assert(offsetof(UEffectModelPostProcess, VintageColorWhitePoint) == 0x002F18, "Member 'UEffectModelPostProcess::VintageColorWhitePoint' has a wrong offset!");
static_assert(offsetof(UEffectModelPostProcess, VHSLinesColorIntensity) == 0x002FA8, "Member 'UEffectModelPostProcess::VHSLinesColorIntensity' has a wrong offset!");
static_assert(offsetof(UEffectModelPostProcess, VHSLinesDistortIntensity) == 0x003038, "Member 'UEffectModelPostProcess::VHSLinesDistortIntensity' has a wrong offset!");
static_assert(offsetof(UEffectModelPostProcess, VHSEffectIntensity) == 0x0030C8, "Member 'UEffectModelPostProcess::VHSEffectIntensity' has a wrong offset!");
static_assert(offsetof(UEffectModelPostProcess, VHSSpecklesIntensity) == 0x003158, "Member 'UEffectModelPostProcess::VHSSpecklesIntensity' has a wrong offset!");
static_assert(offsetof(UEffectModelPostProcess, VHSSpecklesAmount) == 0x0031E8, "Member 'UEffectModelPostProcess::VHSSpecklesAmount' has a wrong offset!");
static_assert(offsetof(UEffectModelPostProcess, VHSSpecklesSize) == 0x003278, "Member 'UEffectModelPostProcess::VHSSpecklesSize' has a wrong offset!");
static_assert(offsetof(UEffectModelPostProcess, CRTDistortion) == 0x003308, "Member 'UEffectModelPostProcess::CRTDistortion' has a wrong offset!");
static_assert(offsetof(UEffectModelPostProcess, RetroFuturisticAdvancedOverride) == 0x003398, "Member 'UEffectModelPostProcess::RetroFuturisticAdvancedOverride' has a wrong offset!");
static_assert(offsetof(UEffectModelPostProcess, VintageColorCenterMask) == 0x0033A0, "Member 'UEffectModelPostProcess::VintageColorCenterMask' has a wrong offset!");
static_assert(offsetof(UEffectModelPostProcess, VintageColorStartDistance) == 0x003430, "Member 'UEffectModelPostProcess::VintageColorStartDistance' has a wrong offset!");
static_assert(offsetof(UEffectModelPostProcess, VintageColorCharacterIntensity) == 0x0034C0, "Member 'UEffectModelPostProcess::VintageColorCharacterIntensity' has a wrong offset!");
static_assert(offsetof(UEffectModelPostProcess, VHSLinesCenterMask) == 0x003550, "Member 'UEffectModelPostProcess::VHSLinesCenterMask' has a wrong offset!");
static_assert(offsetof(UEffectModelPostProcess, VHSLinesStartDistance) == 0x0035E0, "Member 'UEffectModelPostProcess::VHSLinesStartDistance' has a wrong offset!");
static_assert(offsetof(UEffectModelPostProcess, VHSLinesCharacterIntensity) == 0x003670, "Member 'UEffectModelPostProcess::VHSLinesCharacterIntensity' has a wrong offset!");
static_assert(offsetof(UEffectModelPostProcess, VHSEffectCenterMask) == 0x003700, "Member 'UEffectModelPostProcess::VHSEffectCenterMask' has a wrong offset!");
static_assert(offsetof(UEffectModelPostProcess, VHSEffectStartDistance) == 0x003790, "Member 'UEffectModelPostProcess::VHSEffectStartDistance' has a wrong offset!");
static_assert(offsetof(UEffectModelPostProcess, VHSEffectCharacterIntensity) == 0x003820, "Member 'UEffectModelPostProcess::VHSEffectCharacterIntensity' has a wrong offset!");
static_assert(offsetof(UEffectModelPostProcess, VHSSpecklesCenterMask) == 0x0038B0, "Member 'UEffectModelPostProcess::VHSSpecklesCenterMask' has a wrong offset!");
static_assert(offsetof(UEffectModelPostProcess, VHSSpecklesStartDistance) == 0x003940, "Member 'UEffectModelPostProcess::VHSSpecklesStartDistance' has a wrong offset!");
static_assert(offsetof(UEffectModelPostProcess, VHSSpecklesCharacterIntensity) == 0x0039D0, "Member 'UEffectModelPostProcess::VHSSpecklesCharacterIntensity' has a wrong offset!");
static_assert(offsetof(UEffectModelPostProcess, ScreenWaveOverride) == 0x003A60, "Member 'UEffectModelPostProcess::ScreenWaveOverride' has a wrong offset!");
static_assert(offsetof(UEffectModelPostProcess, UsePolarWavePattern) == 0x003A61, "Member 'UEffectModelPostProcess::UsePolarWavePattern' has a wrong offset!");
static_assert(offsetof(UEffectModelPostProcess, WavePatternTexture) == 0x003A68, "Member 'UEffectModelPostProcess::WavePatternTexture' has a wrong offset!");
static_assert(offsetof(UEffectModelPostProcess, WavePatternScaleBias) == 0x003A70, "Member 'UEffectModelPostProcess::WavePatternScaleBias' has a wrong offset!");
static_assert(offsetof(UEffectModelPostProcess, WaveRadius) == 0x003C90, "Member 'UEffectModelPostProcess::WaveRadius' has a wrong offset!");
static_assert(offsetof(UEffectModelPostProcess, WaveRadiusSmooth) == 0x003D20, "Member 'UEffectModelPostProcess::WaveRadiusSmooth' has a wrong offset!");
static_assert(offsetof(UEffectModelPostProcess, WaveHeight) == 0x003DB0, "Member 'UEffectModelPostProcess::WaveHeight' has a wrong offset!");
static_assert(offsetof(UEffectModelPostProcess, WaveHeightSmooth) == 0x003E40, "Member 'UEffectModelPostProcess::WaveHeightSmooth' has a wrong offset!");
static_assert(offsetof(UEffectModelPostProcess, WaveNormalSize) == 0x003ED0, "Member 'UEffectModelPostProcess::WaveNormalSize' has a wrong offset!");
static_assert(offsetof(UEffectModelPostProcess, WaveRoughness) == 0x003F60, "Member 'UEffectModelPostProcess::WaveRoughness' has a wrong offset!");
static_assert(offsetof(UEffectModelPostProcess, WaveDissolveTexture) == 0x003FF0, "Member 'UEffectModelPostProcess::WaveDissolveTexture' has a wrong offset!");
static_assert(offsetof(UEffectModelPostProcess, WaveDissolveScaleBias) == 0x003FF8, "Member 'UEffectModelPostProcess::WaveDissolveScaleBias' has a wrong offset!");
static_assert(offsetof(UEffectModelPostProcess, WaveDissolveProgress) == 0x004218, "Member 'UEffectModelPostProcess::WaveDissolveProgress' has a wrong offset!");
static_assert(offsetof(UEffectModelPostProcess, WaveDissolveSmooth) == 0x0042A8, "Member 'UEffectModelPostProcess::WaveDissolveSmooth' has a wrong offset!");
static_assert(offsetof(UEffectModelPostProcess, WaveColorTexture) == 0x004338, "Member 'UEffectModelPostProcess::WaveColorTexture' has a wrong offset!");
static_assert(offsetof(UEffectModelPostProcess, WaveColorScaleBias) == 0x004340, "Member 'UEffectModelPostProcess::WaveColorScaleBias' has a wrong offset!");
static_assert(offsetof(UEffectModelPostProcess, WaveColorTextureTint) == 0x004560, "Member 'UEffectModelPostProcess::WaveColorTextureTint' has a wrong offset!");
static_assert(offsetof(UEffectModelPostProcess, WaveAmplitude) == 0x004780, "Member 'UEffectModelPostProcess::WaveAmplitude' has a wrong offset!");
static_assert(offsetof(UEffectModelPostProcess, AutoExposureOverride) == 0x004810, "Member 'UEffectModelPostProcess::AutoExposureOverride' has a wrong offset!");
static_assert(offsetof(UEffectModelPostProcess, AutoExposureMinBrightness) == 0x004818, "Member 'UEffectModelPostProcess::AutoExposureMinBrightness' has a wrong offset!");
static_assert(offsetof(UEffectModelPostProcess, AutoExposureMaxBrightness) == 0x0048A8, "Member 'UEffectModelPostProcess::AutoExposureMaxBrightness' has a wrong offset!");
static_assert(offsetof(UEffectModelPostProcess, WeatherDataAsset) == 0x004938, "Member 'UEffectModelPostProcess::WeatherDataAsset' has a wrong offset!");

// Class KuroGameplay.EffectModelSkeletalMesh
// 0x0520 (0x0580 - 0x0060)
class UEffectModelSkeletalMesh : public UEffectModelBase
{
public:
	class USkeletalMesh*                          SkeletalMeshRef;                                   // 0x0060(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimationAsset*                        AnimationRef;                                      // 0x0068(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Looping;                                           // 0x0070(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Playing;                                           // 0x0071(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_72[0x6];                                       // 0x0072(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FKuroCurveVector                       Location;                                          // 0x0078(0x01A8)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FKuroCurveVector                       Rotation;                                          // 0x0220(0x01A8)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FKuroCurveVector                       Scale;                                             // 0x03C8(0x01A8)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	bool                                          EnableCollision;                                   // 0x0570(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_571[0x3];                                      // 0x0571(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         HideFrames;                                        // 0x0574(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          CastShadow;                                        // 0x0578(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ForbidCastToonShadow;                              // 0x0579(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_57A[0x6];                                      // 0x057A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EffectModelSkeletalMesh">();
	}
	static class UEffectModelSkeletalMesh* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEffectModelSkeletalMesh>();
	}
};
static_assert(alignof(UEffectModelSkeletalMesh) == 0x000008, "Wrong alignment on UEffectModelSkeletalMesh");
static_assert(sizeof(UEffectModelSkeletalMesh) == 0x000580, "Wrong size on UEffectModelSkeletalMesh");
static_assert(offsetof(UEffectModelSkeletalMesh, SkeletalMeshRef) == 0x000060, "Member 'UEffectModelSkeletalMesh::SkeletalMeshRef' has a wrong offset!");
static_assert(offsetof(UEffectModelSkeletalMesh, AnimationRef) == 0x000068, "Member 'UEffectModelSkeletalMesh::AnimationRef' has a wrong offset!");
static_assert(offsetof(UEffectModelSkeletalMesh, Looping) == 0x000070, "Member 'UEffectModelSkeletalMesh::Looping' has a wrong offset!");
static_assert(offsetof(UEffectModelSkeletalMesh, Playing) == 0x000071, "Member 'UEffectModelSkeletalMesh::Playing' has a wrong offset!");
static_assert(offsetof(UEffectModelSkeletalMesh, Location) == 0x000078, "Member 'UEffectModelSkeletalMesh::Location' has a wrong offset!");
static_assert(offsetof(UEffectModelSkeletalMesh, Rotation) == 0x000220, "Member 'UEffectModelSkeletalMesh::Rotation' has a wrong offset!");
static_assert(offsetof(UEffectModelSkeletalMesh, Scale) == 0x0003C8, "Member 'UEffectModelSkeletalMesh::Scale' has a wrong offset!");
static_assert(offsetof(UEffectModelSkeletalMesh, EnableCollision) == 0x000570, "Member 'UEffectModelSkeletalMesh::EnableCollision' has a wrong offset!");
static_assert(offsetof(UEffectModelSkeletalMesh, HideFrames) == 0x000574, "Member 'UEffectModelSkeletalMesh::HideFrames' has a wrong offset!");
static_assert(offsetof(UEffectModelSkeletalMesh, CastShadow) == 0x000578, "Member 'UEffectModelSkeletalMesh::CastShadow' has a wrong offset!");
static_assert(offsetof(UEffectModelSkeletalMesh, ForbidCastToonShadow) == 0x000579, "Member 'UEffectModelSkeletalMesh::ForbidCastToonShadow' has a wrong offset!");

// Class KuroGameplay.EffectModelStaticMesh
// 0x05D8 (0x0638 - 0x0060)
class UEffectModelStaticMesh : public UEffectModelBase
{
public:
	struct FKuroCurveVector                       Location;                                          // 0x0060(0x01A8)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FKuroCurveVector                       Rotation;                                          // 0x0208(0x01A8)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FKuroCurveVector                       Scale;                                             // 0x03B0(0x01A8)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class UStaticMesh*                            StaticMeshRef;                                     // 0x0558(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UseMultipleMaterialSlots;                          // 0x0560(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_561[0x7];                                      // 0x0561(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialInstance*                      MaterialOverrideRef;                               // 0x0568(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UMaterialInstance*>              MaterialOverrideArrayRef;                          // 0x0570(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TMap<class FName, struct FKuroCurveFloat>     MaterialFloatParameters;                           // 0x0580(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<class FName, struct FKuroCurveLinearColor> MaterialColorParameters;                           // 0x05D0(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	bool                                          ReceiveDecal;                                      // 0x0620(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          EnableCollision;                                   // 0x0621(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          CastShadow;                                        // 0x0622(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_623[0x1];                                      // 0x0623(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TranslucencySortPriority;                          // 0x0624(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          EnableScreenSizeCullRatioOverride;                 // 0x0628(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_629[0x3];                                      // 0x0629(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ScreenSizeCullRatio;                               // 0x062C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          AcceptExternalNiagaraParameter;                    // 0x0630(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_631[0x7];                                      // 0x0631(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EffectModelStaticMesh">();
	}
	static class UEffectModelStaticMesh* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEffectModelStaticMesh>();
	}
};
static_assert(alignof(UEffectModelStaticMesh) == 0x000008, "Wrong alignment on UEffectModelStaticMesh");
static_assert(sizeof(UEffectModelStaticMesh) == 0x000638, "Wrong size on UEffectModelStaticMesh");
static_assert(offsetof(UEffectModelStaticMesh, Location) == 0x000060, "Member 'UEffectModelStaticMesh::Location' has a wrong offset!");
static_assert(offsetof(UEffectModelStaticMesh, Rotation) == 0x000208, "Member 'UEffectModelStaticMesh::Rotation' has a wrong offset!");
static_assert(offsetof(UEffectModelStaticMesh, Scale) == 0x0003B0, "Member 'UEffectModelStaticMesh::Scale' has a wrong offset!");
static_assert(offsetof(UEffectModelStaticMesh, StaticMeshRef) == 0x000558, "Member 'UEffectModelStaticMesh::StaticMeshRef' has a wrong offset!");
static_assert(offsetof(UEffectModelStaticMesh, UseMultipleMaterialSlots) == 0x000560, "Member 'UEffectModelStaticMesh::UseMultipleMaterialSlots' has a wrong offset!");
static_assert(offsetof(UEffectModelStaticMesh, MaterialOverrideRef) == 0x000568, "Member 'UEffectModelStaticMesh::MaterialOverrideRef' has a wrong offset!");
static_assert(offsetof(UEffectModelStaticMesh, MaterialOverrideArrayRef) == 0x000570, "Member 'UEffectModelStaticMesh::MaterialOverrideArrayRef' has a wrong offset!");
static_assert(offsetof(UEffectModelStaticMesh, MaterialFloatParameters) == 0x000580, "Member 'UEffectModelStaticMesh::MaterialFloatParameters' has a wrong offset!");
static_assert(offsetof(UEffectModelStaticMesh, MaterialColorParameters) == 0x0005D0, "Member 'UEffectModelStaticMesh::MaterialColorParameters' has a wrong offset!");
static_assert(offsetof(UEffectModelStaticMesh, ReceiveDecal) == 0x000620, "Member 'UEffectModelStaticMesh::ReceiveDecal' has a wrong offset!");
static_assert(offsetof(UEffectModelStaticMesh, EnableCollision) == 0x000621, "Member 'UEffectModelStaticMesh::EnableCollision' has a wrong offset!");
static_assert(offsetof(UEffectModelStaticMesh, CastShadow) == 0x000622, "Member 'UEffectModelStaticMesh::CastShadow' has a wrong offset!");
static_assert(offsetof(UEffectModelStaticMesh, TranslucencySortPriority) == 0x000624, "Member 'UEffectModelStaticMesh::TranslucencySortPriority' has a wrong offset!");
static_assert(offsetof(UEffectModelStaticMesh, EnableScreenSizeCullRatioOverride) == 0x000628, "Member 'UEffectModelStaticMesh::EnableScreenSizeCullRatioOverride' has a wrong offset!");
static_assert(offsetof(UEffectModelStaticMesh, ScreenSizeCullRatio) == 0x00062C, "Member 'UEffectModelStaticMesh::ScreenSizeCullRatio' has a wrong offset!");
static_assert(offsetof(UEffectModelStaticMesh, AcceptExternalNiagaraParameter) == 0x000630, "Member 'UEffectModelStaticMesh::AcceptExternalNiagaraParameter' has a wrong offset!");

// Class KuroGameplay.EffectModelTrail
// 0x0250 (0x02B0 - 0x0060)
class UEffectModelTrail final : public UEffectModelBase
{
public:
	bool                                          AttachToBones;                                     // 0x0060(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_61[0x7];                                       // 0x0061(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           AttachBoneNames;                                   // 0x0068(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FVector>                        RelativeLocations;                                 // 0x0078(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TMap<int32, struct FKuroCurveVector>          LocationsCurve;                                    // 0x0088(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class UMaterialInstance*                      Material;                                          // 0x00D8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UnitLength;                                        // 0x00E0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E4[0x4];                                       // 0x00E4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FKuroCurveFloat                        DissipateSpeed;                                    // 0x00E8(0x0090)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FKuroCurveFloat                        Alpha;                                             // 0x0178(0x0090)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<class FName, struct FKuroCurveFloat>     FloatParameters;                                   // 0x0208(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<class FName, struct FKuroCurveLinearColor> ColorParameters;                                   // 0x0258(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	bool                                          DestroyAtOnce;                                     // 0x02A8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A9[0x3];                                      // 0x02A9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DissipateSpeedAfterDead;                           // 0x02AC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EffectModelTrail">();
	}
	static class UEffectModelTrail* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEffectModelTrail>();
	}
};
static_assert(alignof(UEffectModelTrail) == 0x000008, "Wrong alignment on UEffectModelTrail");
static_assert(sizeof(UEffectModelTrail) == 0x0002B0, "Wrong size on UEffectModelTrail");
static_assert(offsetof(UEffectModelTrail, AttachToBones) == 0x000060, "Member 'UEffectModelTrail::AttachToBones' has a wrong offset!");
static_assert(offsetof(UEffectModelTrail, AttachBoneNames) == 0x000068, "Member 'UEffectModelTrail::AttachBoneNames' has a wrong offset!");
static_assert(offsetof(UEffectModelTrail, RelativeLocations) == 0x000078, "Member 'UEffectModelTrail::RelativeLocations' has a wrong offset!");
static_assert(offsetof(UEffectModelTrail, LocationsCurve) == 0x000088, "Member 'UEffectModelTrail::LocationsCurve' has a wrong offset!");
static_assert(offsetof(UEffectModelTrail, Material) == 0x0000D8, "Member 'UEffectModelTrail::Material' has a wrong offset!");
static_assert(offsetof(UEffectModelTrail, UnitLength) == 0x0000E0, "Member 'UEffectModelTrail::UnitLength' has a wrong offset!");
static_assert(offsetof(UEffectModelTrail, DissipateSpeed) == 0x0000E8, "Member 'UEffectModelTrail::DissipateSpeed' has a wrong offset!");
static_assert(offsetof(UEffectModelTrail, Alpha) == 0x000178, "Member 'UEffectModelTrail::Alpha' has a wrong offset!");
static_assert(offsetof(UEffectModelTrail, FloatParameters) == 0x000208, "Member 'UEffectModelTrail::FloatParameters' has a wrong offset!");
static_assert(offsetof(UEffectModelTrail, ColorParameters) == 0x000258, "Member 'UEffectModelTrail::ColorParameters' has a wrong offset!");
static_assert(offsetof(UEffectModelTrail, DestroyAtOnce) == 0x0002A8, "Member 'UEffectModelTrail::DestroyAtOnce' has a wrong offset!");
static_assert(offsetof(UEffectModelTrail, DissipateSpeedAfterDead) == 0x0002AC, "Member 'UEffectModelTrail::DissipateSpeedAfterDead' has a wrong offset!");

// Class KuroGameplay.EffectSystemActor
// 0x0028 (0x02D8 - 0x02B0)
class AEffectSystemActor final : public AActor
{
public:
	uint8                                         Pad_2B0[0x28];                                     // 0x02B0(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetOwnerEntityId(int32 EntityId);

	int32 GetEffectType() const;
	int32 GetHandle() const;
	int32 GetOwnerEntityId() const;
	float GetTimeScale() const;
	void StopEffect(const class FName& Reason, bool Immediately, bool DestroyActor) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EffectSystemActor">();
	}
	static class AEffectSystemActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEffectSystemActor>();
	}
};
static_assert(alignof(AEffectSystemActor) == 0x000008, "Wrong alignment on AEffectSystemActor");
static_assert(sizeof(AEffectSystemActor) == 0x0002D8, "Wrong size on AEffectSystemActor");

// Class KuroGameplay.GameBudgetAllocator
// 0x05C0 (0x05F0 - 0x0030)
class UGameBudgetAllocator final : public UObject
{
public:
	uint8                                         Pad_30[0x5C0];                                     // 0x0030(0x05C0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AfterTickOutside(float DeltaSeconds);
	void SetCenterActor(class AActor* CenterActor);
	void SetDefaultTickIntervalDetailConfig(struct FGameBudgetAllocatorGroupConfig* Config, uint32 MaxTickInterval, uint16 TickReductionStartSize, uint16 TickReductionIntervalSize);
	void SetGlobalMode(EGameBudgetAllocatorGlobalMode Mode);
	void SetGroupConfig(class FName GroupName, const struct FGameBudgetAllocatorGroupConfig& Config);
	void SetMaximumFrameRate(uint32 MaxFPS);
	void SetTickIntervalDetailConfig(struct FGameBudgetAllocatorGroupConfig* Config, EGameBudgetAllocatorGlobalMode GlobalMode, EGameBudgetAllocatorActorMode ActorMode, uint32 MaxTickInterval, uint16 TickReductionStartSize, uint16 TickReductionIntervalSize);
	void TickOutside(float DeltaSeconds);
	void UpdateMinUpdateFIFOBudgetTime(float Time);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameBudgetAllocator">();
	}
	static class UGameBudgetAllocator* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameBudgetAllocator>();
	}
};
static_assert(alignof(UGameBudgetAllocator) == 0x000008, "Wrong alignment on UGameBudgetAllocator");
static_assert(sizeof(UGameBudgetAllocator) == 0x0005F0, "Wrong size on UGameBudgetAllocator");

// Class KuroGameplay.KuroAIController
// 0x0000 (0x03C0 - 0x03C0)
class AKuroAIController : public AAIController
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroAIController">();
	}
	static class AKuroAIController* GetDefaultObj()
	{
		return GetDefaultObjImpl<AKuroAIController>();
	}
};
static_assert(alignof(AKuroAIController) == 0x000008, "Wrong alignment on AKuroAIController");
static_assert(sizeof(AKuroAIController) == 0x0003C0, "Wrong size on AKuroAIController");

// Class KuroGameplay.KuroEffectLibrary
// 0x0000 (0x0030 - 0x0030)
class UKuroEffectLibrary final : public UBlueprintFunctionLibrary
{
public:
	static class USceneComponent* AddSceneComponent(class AActor* Actor, class UClass* Class_0, class USceneComponent* Parent, bool bDeferredFinish);
	static class USceneComponent* AddSceneComponentWithTransform(class AActor* Actor, class UClass* Class_0, class USceneComponent* Parent, bool bDeferredFinish, const struct FTransform& Transform);
	static void DeactivateImmediateNiagaraComponent(class UNiagaraComponent* NiagaraComponent);
	static bool EqualWorld(class UWorld* World, class UWorld* Other);
	static class USceneComponent* GetActorDefaultAttachComponent(class AActor* Actor);
	static float GetNiagaraEffectRegularTypeScalabilitySettingsMaxDistance(EKuroNiagaraEffectRegularType EffectRegularType);
	static int32 GetNiagaraQualityLevel();
	static EKuroNiagaraEffectRegularType GetNiagaraSystemEffectRegularType(class UNiagaraSystem* NiagaraSystem);
	static float GetNpcDisappearDistance();
	static void InitModelNiagaraSpec(class UNiagaraComponent* NiagaraComponent, bool bUIScene, bool bReceivesDecals, int32 TranslucencySortPriority);
	static bool IsEffectSystemInEditorNoPIE();
	static bool IsNiagaraComponentHasBound(class UNiagaraComponent* NiagaraComponent, float Threshold);
	static void RegisterOnSystemFinished(class UNiagaraComponent* NiagaraComponent);
	static void RegisterOnSystemPaused(class UNiagaraComponent* NiagaraComponent);
	static void SetEffectActorSpawnInUIScene(class AActor* Actor, bool Value, bool Immediately);
	static bool SetNiagaraFrameDeltaTime(class UNiagaraComponent* NiagaraComponent, float DeltaTime);
	static void SetNiagaraSimulationMinDeltaTime(class UNiagaraComponent* NiagaraComponent, float MinDeltaTime);
	static void SetOnSystemFinishedDelegate(const TDelegate<void(class UNiagaraComponent* NiagaraComponent)>& Delegate);
	static void SetOnSystemPausedDelegate(const TDelegate<void(class UNiagaraComponent* NiagaraComponent, bool IsPaused)>& Delegate);
	static void UpdateEffectModelLightSpec(class UEffectModelLight* EffectModelLight, class UPointLightComponent* LightComponent, bool bForceUpdate, float Time, float DefaultMaxLightRadius);
	static void UpdateEffectModelNiagaraSpec(class UEffectModelNiagara* EffectModelNiagara, class UNiagaraComponent* NiagaraComponent, bool bForceUpdate, float Time, int32 ExtraState);
	static void UpdateEffectModelPostProcessMaterial(class UEffectModelPostProcess* EffectModelPostProcess, class UMaterialInstanceDynamic* DynMaterial, bool bForceUpdate, float Time);
	static struct FVector2D UpdateEffectModelPostProcessSpec(class UEffectModelPostProcess* EffectModelPostProcess, class UKuroPostProcessComponent* PostProcessComponent, bool bForceUpdate, float Time, class APlayerController* Controller, class ACharacter* Character, class AActor* EffectActor, const struct FVector2D& LastScreenUV);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroEffectLibrary">();
	}
	static class UKuroEffectLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroEffectLibrary>();
	}
};
static_assert(alignof(UKuroEffectLibrary) == 0x000008, "Wrong alignment on UKuroEffectLibrary");
static_assert(sizeof(UKuroEffectLibrary) == 0x000030, "Wrong size on UKuroEffectLibrary");

// Class KuroGameplay.KuroInputEvent
// 0x0028 (0x0058 - 0x0030)
class UKuroInputEvent final : public UObject
{
public:
	uint8                                         Pad_30[0x28];                                      // 0x0030(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DoActionCallback(const struct FKey& Key);
	void DoAxisCallback(float value);
	void DoKeyCallback(const struct FKey& Key);
	void DoTouchCallback(const ETouchIndex touchIndex, const struct FVector& position);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroInputEvent">();
	}
	static class UKuroInputEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroInputEvent>();
	}
};
static_assert(alignof(UKuroInputEvent) == 0x000008, "Wrong alignment on UKuroInputEvent");
static_assert(sizeof(UKuroInputEvent) == 0x000058, "Wrong size on UKuroInputEvent");

// Class KuroGameplay.KuroLevelPlayCustomCollisionComponent
// 0x0040 (0x0540 - 0x0500)
class UKuroLevelPlayCustomCollisionComponent final : public UPrimitiveComponent
{
public:
	uint8                                         Pad_500[0x8];                                      // 0x0500(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCollisionProfileName                  CollisionProfileName;                              // 0x0508(0x000C)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                WaterStaticMeshNormal;                             // 0x0514(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                WaterNormal;                                       // 0x0520(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_52C[0x4];                                      // 0x052C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UBodySetup*                             BodySetup;                                         // 0x0530(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, DuplicateTransient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_538[0x8];                                      // 0x0538(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool CanEnableCollision() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroLevelPlayCustomCollisionComponent">();
	}
	static class UKuroLevelPlayCustomCollisionComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroLevelPlayCustomCollisionComponent>();
	}
};
static_assert(alignof(UKuroLevelPlayCustomCollisionComponent) == 0x000010, "Wrong alignment on UKuroLevelPlayCustomCollisionComponent");
static_assert(sizeof(UKuroLevelPlayCustomCollisionComponent) == 0x000540, "Wrong size on UKuroLevelPlayCustomCollisionComponent");
static_assert(offsetof(UKuroLevelPlayCustomCollisionComponent, CollisionProfileName) == 0x000508, "Member 'UKuroLevelPlayCustomCollisionComponent::CollisionProfileName' has a wrong offset!");
static_assert(offsetof(UKuroLevelPlayCustomCollisionComponent, WaterStaticMeshNormal) == 0x000514, "Member 'UKuroLevelPlayCustomCollisionComponent::WaterStaticMeshNormal' has a wrong offset!");
static_assert(offsetof(UKuroLevelPlayCustomCollisionComponent, WaterNormal) == 0x000520, "Member 'UKuroLevelPlayCustomCollisionComponent::WaterNormal' has a wrong offset!");
static_assert(offsetof(UKuroLevelPlayCustomCollisionComponent, BodySetup) == 0x000530, "Member 'UKuroLevelPlayCustomCollisionComponent::BodySetup' has a wrong offset!");

// Class KuroGameplay.KuroLevelPlayInterface
// 0x0000 (0x0030 - 0x0030)
class IKuroLevelPlayInterface final : public IInterface
{
public:
	bool ProcessPhysics();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroLevelPlayInterface">();
	}
	static class IKuroLevelPlayInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IKuroLevelPlayInterface>();
	}
};
static_assert(alignof(IKuroLevelPlayInterface) == 0x000008, "Wrong alignment on IKuroLevelPlayInterface");
static_assert(sizeof(IKuroLevelPlayInterface) == 0x000030, "Wrong size on IKuroLevelPlayInterface");

// Class KuroGameplay.KuroLevelPlayLibrary
// 0x0000 (0x0030 - 0x0030)
class UKuroLevelPlayLibrary final : public UBlueprintFunctionLibrary
{
public:
	static struct FBox GetActorComponentsBoundingBox(class AActor* Actor, bool bNonColliding, bool bIncludeFromChildActors);
	static bool GetActorScreenBoundingBox(class APlayerController* PlayerController, class AActor* Actor, struct FVector2D* ScreenMin, struct FVector2D* ScreenMax);
	static class FString GetCurrentLevelRefPath(const class UObject* WorldContextObject);
	static int32 GetEntityIdByBaseItem(class AActor* Actor);
	static void RegisterBaseItemInfo(class UClass* BaseItemClass, const class FString& EntityIdName);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroLevelPlayLibrary">();
	}
	static class UKuroLevelPlayLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroLevelPlayLibrary>();
	}
};
static_assert(alignof(UKuroLevelPlayLibrary) == 0x000008, "Wrong alignment on UKuroLevelPlayLibrary");
static_assert(sizeof(UKuroLevelPlayLibrary) == 0x000030, "Wrong size on UKuroLevelPlayLibrary");

// Class KuroGameplay.KuroLevelPlaySubsystem
// 0x0050 (0x0088 - 0x0038)
class UKuroLevelPlaySubsystem final : public UWorldSubsystem
{
public:
	TSet<TWeakObjectPtr<class UObject>>           ManagedObjects;                                    // 0x0038(0x0050)(Edit, EditConst, UObjectWrapper, NativeAccessSpecifierPrivate)

public:
	void ProcessAllItems();
	void RegisterObject(class UObject* InKuroLevelPlayObject);
	void UnregisterObject(class UObject* InKuroLevelPlayObject);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroLevelPlaySubsystem">();
	}
	static class UKuroLevelPlaySubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroLevelPlaySubsystem>();
	}
};
static_assert(alignof(UKuroLevelPlaySubsystem) == 0x000008, "Wrong alignment on UKuroLevelPlaySubsystem");
static_assert(sizeof(UKuroLevelPlaySubsystem) == 0x000088, "Wrong size on UKuroLevelPlaySubsystem");
static_assert(offsetof(UKuroLevelPlaySubsystem, ManagedObjects) == 0x000038, "Member 'UKuroLevelPlaySubsystem::ManagedObjects' has a wrong offset!");

// Class KuroGameplay.KuroMultilBgProgressBar
// 0x0320 (0x0490 - 0x0170)
class UKuroMultilBgProgressBar final : public UWidget
{
public:
	struct FProgressBarStyle                      WidgetStyle;                                       // 0x0170(0x0248)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class USlateWidgetStyleAsset*                 Style;                                             // 0x03B8(0x0008)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USlateBrushAsset*                       BackgroundImage;                                   // 0x03C0(0x0008)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USlateBrushAsset*                       FillImageMiddle;                                   // 0x03C8(0x0008)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USlateBrushAsset*                       FillImage;                                         // 0x03D0(0x0008)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USlateBrushAsset*                       MarqueeImage;                                      // 0x03D8(0x0008)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MiddlePercent;                                     // 0x03E0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Percent;                                           // 0x03E4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EProgressBarFillType                          BarFillType;                                       // 0x03E8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsMarquee;                                        // 0x03E9(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3EA[0x2];                                      // 0x03EA(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              BorderPadding;                                     // 0x03EC(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3F4[0x4];                                      // 0x03F4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TDelegate<void()>                             PercentDelegate;                                   // 0x03F8(0x0028)(ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
	TDelegate<void()>                             MiddlePercentDelegate;                             // 0x0420(0x0028)(ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
	struct FLinearColor                           FillColorAndOpacity;                               // 0x0448(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TDelegate<void()>                             FillColorAndOpacityDelegate;                       // 0x0458(0x0028)(ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
	uint8                                         Pad_480[0x10];                                     // 0x0480(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetFillColorAndOpacity(const struct FLinearColor& InColor);
	void SetIsMarquee(bool InbIsMarquee);
	void SetMiddlePercent(float InPercent);
	void SetPercent(float InPercent);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroMultilBgProgressBar">();
	}
	static class UKuroMultilBgProgressBar* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroMultilBgProgressBar>();
	}
};
static_assert(alignof(UKuroMultilBgProgressBar) == 0x000008, "Wrong alignment on UKuroMultilBgProgressBar");
static_assert(sizeof(UKuroMultilBgProgressBar) == 0x000490, "Wrong size on UKuroMultilBgProgressBar");
static_assert(offsetof(UKuroMultilBgProgressBar, WidgetStyle) == 0x000170, "Member 'UKuroMultilBgProgressBar::WidgetStyle' has a wrong offset!");
static_assert(offsetof(UKuroMultilBgProgressBar, Style) == 0x0003B8, "Member 'UKuroMultilBgProgressBar::Style' has a wrong offset!");
static_assert(offsetof(UKuroMultilBgProgressBar, BackgroundImage) == 0x0003C0, "Member 'UKuroMultilBgProgressBar::BackgroundImage' has a wrong offset!");
static_assert(offsetof(UKuroMultilBgProgressBar, FillImageMiddle) == 0x0003C8, "Member 'UKuroMultilBgProgressBar::FillImageMiddle' has a wrong offset!");
static_assert(offsetof(UKuroMultilBgProgressBar, FillImage) == 0x0003D0, "Member 'UKuroMultilBgProgressBar::FillImage' has a wrong offset!");
static_assert(offsetof(UKuroMultilBgProgressBar, MarqueeImage) == 0x0003D8, "Member 'UKuroMultilBgProgressBar::MarqueeImage' has a wrong offset!");
static_assert(offsetof(UKuroMultilBgProgressBar, MiddlePercent) == 0x0003E0, "Member 'UKuroMultilBgProgressBar::MiddlePercent' has a wrong offset!");
static_assert(offsetof(UKuroMultilBgProgressBar, Percent) == 0x0003E4, "Member 'UKuroMultilBgProgressBar::Percent' has a wrong offset!");
static_assert(offsetof(UKuroMultilBgProgressBar, BarFillType) == 0x0003E8, "Member 'UKuroMultilBgProgressBar::BarFillType' has a wrong offset!");
static_assert(offsetof(UKuroMultilBgProgressBar, bIsMarquee) == 0x0003E9, "Member 'UKuroMultilBgProgressBar::bIsMarquee' has a wrong offset!");
static_assert(offsetof(UKuroMultilBgProgressBar, BorderPadding) == 0x0003EC, "Member 'UKuroMultilBgProgressBar::BorderPadding' has a wrong offset!");
static_assert(offsetof(UKuroMultilBgProgressBar, PercentDelegate) == 0x0003F8, "Member 'UKuroMultilBgProgressBar::PercentDelegate' has a wrong offset!");
static_assert(offsetof(UKuroMultilBgProgressBar, MiddlePercentDelegate) == 0x000420, "Member 'UKuroMultilBgProgressBar::MiddlePercentDelegate' has a wrong offset!");
static_assert(offsetof(UKuroMultilBgProgressBar, FillColorAndOpacity) == 0x000448, "Member 'UKuroMultilBgProgressBar::FillColorAndOpacity' has a wrong offset!");
static_assert(offsetof(UKuroMultilBgProgressBar, FillColorAndOpacityDelegate) == 0x000458, "Member 'UKuroMultilBgProgressBar::FillColorAndOpacityDelegate' has a wrong offset!");

// Class KuroGameplay.KuroResourceManager
// 0x0170 (0x01A0 - 0x0030)
class UKuroResourceManager final : public UObject
{
public:
	TDelegate<void(int32 HandleId)>               LoadResourceDelegate;                              // 0x0030(0x0028)(ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
	uint8                                         Pad_58[0x148];                                     // 0x0058(0x0148)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class UObject* GetAsset(const int32 HandleId);
	int32 LoadAsyncWithId(const class FString& Path, const int32 HandleId, const int32 Priority);
	int32 LoadWithId(const class FString& Path, const int32 HandleId);
	void Release(const int32 HandleId);
	bool WaitComplete(const int32 HandleId, const float Timeout);

	void DebugDumpLoadingAssets() const;
	class UObject* GetLoadedAsset(const class FString& Path) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroResourceManager">();
	}
	static class UKuroResourceManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroResourceManager>();
	}
};
static_assert(alignof(UKuroResourceManager) == 0x000008, "Wrong alignment on UKuroResourceManager");
static_assert(sizeof(UKuroResourceManager) == 0x0001A0, "Wrong size on UKuroResourceManager");
static_assert(offsetof(UKuroResourceManager, LoadResourceDelegate) == 0x000030, "Member 'UKuroResourceManager::LoadResourceDelegate' has a wrong offset!");

// Class KuroGameplay.KuroSequenceEaseExecutor
// 0x0008 (0x0038 - 0x0030)
class UKuroSequenceEaseExecutor : public UObject
{
public:
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void StopEase();
	bool UpdateEase(float DeltaTime);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroSequenceEaseExecutor">();
	}
	static class UKuroSequenceEaseExecutor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroSequenceEaseExecutor>();
	}
};
static_assert(alignof(UKuroSequenceEaseExecutor) == 0x000008, "Wrong alignment on UKuroSequenceEaseExecutor");
static_assert(sizeof(UKuroSequenceEaseExecutor) == 0x000038, "Wrong size on UKuroSequenceEaseExecutor");

// Class KuroGameplay.KuroSequenceEaseFloatExecutor
// 0x0010 (0x0048 - 0x0038)
class UKuroSequenceEaseFloatExecutor final : public UKuroSequenceEaseExecutor
{
public:
	uint8                                         Pad_38[0x8];                                       // 0x0038(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            EaseCurve;                                         // 0x0040(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	float GetDuration() const;
	float GetStartValue() const;
	float GetTargetValue() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroSequenceEaseFloatExecutor">();
	}
	static class UKuroSequenceEaseFloatExecutor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroSequenceEaseFloatExecutor>();
	}
};
static_assert(alignof(UKuroSequenceEaseFloatExecutor) == 0x000008, "Wrong alignment on UKuroSequenceEaseFloatExecutor");
static_assert(sizeof(UKuroSequenceEaseFloatExecutor) == 0x000048, "Wrong size on UKuroSequenceEaseFloatExecutor");
static_assert(offsetof(UKuroSequenceEaseFloatExecutor, EaseCurve) == 0x000040, "Member 'UKuroSequenceEaseFloatExecutor::EaseCurve' has a wrong offset!");

// Class KuroGameplay.KuroSequenceRuntimeEaseComponent
// 0x00A8 (0x0168 - 0x00C0)
class UKuroSequenceRuntimeEaseComponent final : public UActorComponent
{
public:
	TMap<int32, class UKuroSequenceEaseExecutor*> EaseExecutors;                                     // 0x00C0(0x0050)(BlueprintVisible, BlueprintReadOnly, Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_110[0x58];                                     // 0x0110(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroSequenceRuntimeEaseComponent">();
	}
	static class UKuroSequenceRuntimeEaseComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroSequenceRuntimeEaseComponent>();
	}
};
static_assert(alignof(UKuroSequenceRuntimeEaseComponent) == 0x000008, "Wrong alignment on UKuroSequenceRuntimeEaseComponent");
static_assert(sizeof(UKuroSequenceRuntimeEaseComponent) == 0x000168, "Wrong size on UKuroSequenceRuntimeEaseComponent");
static_assert(offsetof(UKuroSequenceRuntimeEaseComponent, EaseExecutors) == 0x0000C0, "Member 'UKuroSequenceRuntimeEaseComponent::EaseExecutors' has a wrong offset!");

// Class KuroGameplay.KuroSequenceRuntimeFunctionLibrary
// 0x0000 (0x0030 - 0x0030)
class UKuroSequenceRuntimeFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static int32 EasePlayRateTo(class ALevelSequenceActor* SequenceActor, float TargetPlayRate, EKuroEasingFuncType EaseType, float Duration, float Exp);
	static struct FSequencerBindingRuntimeProxy FindBindingById(class UMovieSceneSequence* Sequence, const struct FGuid& BindingId);
	static TArray<class UMovieSceneTrack*> FindMasterTracksByType(class UMovieSceneSequence* Sequence, TSubclassOf<class UMovieSceneTrack> TrackType);
	static TArray<class UMovieSceneTrack*> FindTracksByType(const struct FSequencerBindingRuntimeProxy& InBinding, TSubclassOf<class UMovieSceneTrack> TrackType);
	static int32 GetEndFrame(class UMovieSceneSection* Section);
	static float GetFadeAmountAt(class UMovieSceneFadeSection* Section, const struct FFrameTime& Frame);
	static struct FTransform GetFrameTransform(class UMovieSceneTrack* Track, const struct FFrameTime& Frame);
	static bool GetFrameTransformByTag(class UMovieSceneSequence* Sequence, class FName Tag, int32 OutsideFrame, struct FTransform* OutTransfom);
	static TArray<class UMovieSceneTrack*> GetMasterTracks(class UMovieSceneSequence* Sequence);
	static class UObject* GetObjectTemplate(const struct FSequencerBindingRuntimeProxy& InBinding);
	static int32 GetPlaybackEnd(class UMovieSceneSequence* Sequence);
	static int32 GetPlaybackStart(class UMovieSceneSequence* Sequence);
	static TArray<class UMovieSceneSection*> GetSections(class UMovieSceneTrack* Track);
	static TArray<struct FSequencerBindingRuntimeProxy> GetSpawnables(class UMovieSceneSequence* Sequence);
	static int32 GetStartFrame(class UMovieSceneSection* Section);
	static TArray<class UMovieSceneTrack*> GetTracks(const struct FSequencerBindingRuntimeProxy& InBinding);
	static bool HandleSeqTexStreaming(const class ULevelSequence* LevelSequences, const bool bStartForceStreamIn);
	static void MuteTrackByName(class UMovieSceneSequence* Sequence, class FName Name_0, bool bIsMuted);
	static void MuteTrackByTag(class UMovieSceneSequence* Sequence, class FName Tag, bool bIsMuted);
	static void ResetMovieSceneCompiledData(class UMovieSceneSequence* Sequence);
	static bool SectionContains(class UMovieSceneSection* Section, const struct FFrameTime& Frame);
	static bool SetSequenceInUiScene(class UMovieSceneSequence* Sequence, bool IsEnable);
	static bool StopEasingPlayRate(class ALevelSequenceActor* SequenceActor, int32 HandleId, bool JumpToTarget);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroSequenceRuntimeFunctionLibrary">();
	}
	static class UKuroSequenceRuntimeFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroSequenceRuntimeFunctionLibrary>();
	}
};
static_assert(alignof(UKuroSequenceRuntimeFunctionLibrary) == 0x000008, "Wrong alignment on UKuroSequenceRuntimeFunctionLibrary");
static_assert(sizeof(UKuroSequenceRuntimeFunctionLibrary) == 0x000030, "Wrong size on UKuroSequenceRuntimeFunctionLibrary");

// Class KuroGameplay.KuroSplineCylinderTriggerActor
// 0x0038 (0x02E8 - 0x02B0)
class AKuroSplineCylinderTriggerActor final : public AActor
{
public:
	class UStaticMeshComponent*                   MeshComponent;                                     // 0x02B0(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B8[0x30];                                     // 0x02B8(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void GenerateMesh(class USplineComponent* Spline, float CircleRadius);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroSplineCylinderTriggerActor">();
	}
	static class AKuroSplineCylinderTriggerActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AKuroSplineCylinderTriggerActor>();
	}
};
static_assert(alignof(AKuroSplineCylinderTriggerActor) == 0x000008, "Wrong alignment on AKuroSplineCylinderTriggerActor");
static_assert(sizeof(AKuroSplineCylinderTriggerActor) == 0x0002E8, "Wrong size on AKuroSplineCylinderTriggerActor");
static_assert(offsetof(AKuroSplineCylinderTriggerActor, MeshComponent) == 0x0002B0, "Member 'AKuroSplineCylinderTriggerActor::MeshComponent' has a wrong offset!");

// Class KuroGameplay.KuroStaticMeshLibrary
// 0x0000 (0x0030 - 0x0030)
class UKuroStaticMeshLibrary final : public UBlueprintFunctionLibrary
{
public:
	static void MergeSimpleCollisions(class UStaticMeshComponent* TemplateComponent, const TArray<struct FTransform>& LocalTransforms);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroStaticMeshLibrary">();
	}
	static class UKuroStaticMeshLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroStaticMeshLibrary>();
	}
};
static_assert(alignof(UKuroStaticMeshLibrary) == 0x000008, "Wrong alignment on UKuroStaticMeshLibrary");
static_assert(sizeof(UKuroStaticMeshLibrary) == 0x000030, "Wrong size on UKuroStaticMeshLibrary");

// Class KuroGameplay.PerformanceStatisticsLibrary
// 0x0000 (0x0030 - 0x0030)
class UPerformanceStatisticsLibrary final : public UBlueprintFunctionLibrary
{
public:
	static void AddStatistics(class FName SectionName, int32 FrameCount, const class FString& Tag, int32 MeasureMode, float Time, const class FString& UserDefineMessage);
	static void Clear();
	static void Export();
	static void ReadAllSectionsFromDirectory();
	static void ReadSectionFromFile(class FString* FilePath);
	static void StatisticsFromRawDataFiles();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PerformanceStatisticsLibrary">();
	}
	static class UPerformanceStatisticsLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPerformanceStatisticsLibrary>();
	}
};
static_assert(alignof(UPerformanceStatisticsLibrary) == 0x000008, "Wrong alignment on UPerformanceStatisticsLibrary");
static_assert(sizeof(UPerformanceStatisticsLibrary) == 0x000030, "Wrong size on UPerformanceStatisticsLibrary");

}

