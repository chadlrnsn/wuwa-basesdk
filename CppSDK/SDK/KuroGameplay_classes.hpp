#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: KuroGameplay

#include "Basic.hpp"

#include "KuroGameplay_structs.hpp"
#include "Engine_structs.hpp"
#include "Engine_classes.hpp"
#include "KuroCurve_structs.hpp"
#include "CoreUObject_structs.hpp"
#include "CoreUObject_classes.hpp"
#include "AIModule_classes.hpp"
#include "Niagara_structs.hpp"
#include "InputCore_structs.hpp"
#include "SlateCore_structs.hpp"
#include "Slate_structs.hpp"
#include "UMG_classes.hpp"


namespace SDK
{

// Class KuroGameplay.EffectModelBase
// 0x0028 (0x0060 - 0x0038)
class UEffectModelBase : public UPrimaryDataAsset
{
public:
	float                                         StartTime;                                         // 0x0038(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LoopTime;                                          // 0x003C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EndTime;                                           // 0x0040(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          AutoPlay;                                          // 0x0044(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          AutoDestroy;                                       // 0x0045(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IgnoreTimeDilation;                                // 0x0046(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IgnoreGlobalTimeDilation;                          // 0x0047(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UiScenePrimitive;                                  // 0x0048(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49[0x3];                                       // 0x0049(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ImportanceLevel;                                   // 0x004C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DefaultManualTime;                                 // 0x0050(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DefaultManualSpeed;                                // 0x0054(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IgnoreDisable;                                     // 0x0058(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          DisableOnMobile;                                   // 0x0059(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          HideOnBurstSkill;                                  // 0x005A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          NeedDisableWithActor;                              // 0x005B(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          SuperFarProgramFlag;                               // 0x005C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5D[0x3];                                       // 0x005D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EffectModelBase">();
	}
	static class UEffectModelBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEffectModelBase>();
	}
};
static_assert(alignof(UEffectModelBase) == 0x000008, "Wrong alignment on UEffectModelBase");
static_assert(sizeof(UEffectModelBase) == 0x000060, "Wrong size on UEffectModelBase");
static_assert(offsetof(UEffectModelBase, StartTime) == 0x000038, "Member 'UEffectModelBase::StartTime' has a wrong offset!");
static_assert(offsetof(UEffectModelBase, LoopTime) == 0x00003C, "Member 'UEffectModelBase::LoopTime' has a wrong offset!");
static_assert(offsetof(UEffectModelBase, EndTime) == 0x000040, "Member 'UEffectModelBase::EndTime' has a wrong offset!");
static_assert(offsetof(UEffectModelBase, AutoPlay) == 0x000044, "Member 'UEffectModelBase::AutoPlay' has a wrong offset!");
static_assert(offsetof(UEffectModelBase, AutoDestroy) == 0x000045, "Member 'UEffectModelBase::AutoDestroy' has a wrong offset!");
static_assert(offsetof(UEffectModelBase, IgnoreTimeDilation) == 0x000046, "Member 'UEffectModelBase::IgnoreTimeDilation' has a wrong offset!");
static_assert(offsetof(UEffectModelBase, IgnoreGlobalTimeDilation) == 0x000047, "Member 'UEffectModelBase::IgnoreGlobalTimeDilation' has a wrong offset!");
static_assert(offsetof(UEffectModelBase, UiScenePrimitive) == 0x000048, "Member 'UEffectModelBase::UiScenePrimitive' has a wrong offset!");
static_assert(offsetof(UEffectModelBase, ImportanceLevel) == 0x00004C, "Member 'UEffectModelBase::ImportanceLevel' has a wrong offset!");
static_assert(offsetof(UEffectModelBase, DefaultManualTime) == 0x000050, "Member 'UEffectModelBase::DefaultManualTime' has a wrong offset!");
static_assert(offsetof(UEffectModelBase, DefaultManualSpeed) == 0x000054, "Member 'UEffectModelBase::DefaultManualSpeed' has a wrong offset!");
static_assert(offsetof(UEffectModelBase, IgnoreDisable) == 0x000058, "Member 'UEffectModelBase::IgnoreDisable' has a wrong offset!");
static_assert(offsetof(UEffectModelBase, DisableOnMobile) == 0x000059, "Member 'UEffectModelBase::DisableOnMobile' has a wrong offset!");
static_assert(offsetof(UEffectModelBase, HideOnBurstSkill) == 0x00005A, "Member 'UEffectModelBase::HideOnBurstSkill' has a wrong offset!");
static_assert(offsetof(UEffectModelBase, NeedDisableWithActor) == 0x00005B, "Member 'UEffectModelBase::NeedDisableWithActor' has a wrong offset!");
static_assert(offsetof(UEffectModelBase, SuperFarProgramFlag) == 0x00005C, "Member 'UEffectModelBase::SuperFarProgramFlag' has a wrong offset!");

// Class KuroGameplay.EffectModelDecal
// 0x05A8 (0x0608 - 0x0060)
class UEffectModelDecal : public UEffectModelBase
{
public:
	class UMaterialInterface*                     DecalMaterialRef;                                  // 0x0060(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FKuroCurveVector                       Location;                                          // 0x0068(0x01A8)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FKuroCurveVector                       Rotation;                                          // 0x0210(0x01A8)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FKuroCurveVector                       Scale;                                             // 0x03B8(0x01A8)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	float                                         ZfadingFactor;                                     // 0x0560(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ZfadingPower;                                      // 0x0564(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class FName, struct FKuroCurveFloat>     MaterialFloatParameters;                           // 0x0568(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<class FName, struct FKuroCurveLinearColor> MaterialColorParameters;                           // 0x05B8(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EffectModelDecal">();
	}
	static class UEffectModelDecal* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEffectModelDecal>();
	}
};
static_assert(alignof(UEffectModelDecal) == 0x000008, "Wrong alignment on UEffectModelDecal");
static_assert(sizeof(UEffectModelDecal) == 0x000608, "Wrong size on UEffectModelDecal");
static_assert(offsetof(UEffectModelDecal, DecalMaterialRef) == 0x000060, "Member 'UEffectModelDecal::DecalMaterialRef' has a wrong offset!");
static_assert(offsetof(UEffectModelDecal, Location) == 0x000068, "Member 'UEffectModelDecal::Location' has a wrong offset!");
static_assert(offsetof(UEffectModelDecal, Rotation) == 0x000210, "Member 'UEffectModelDecal::Rotation' has a wrong offset!");
static_assert(offsetof(UEffectModelDecal, Scale) == 0x0003B8, "Member 'UEffectModelDecal::Scale' has a wrong offset!");
static_assert(offsetof(UEffectModelDecal, ZfadingFactor) == 0x000560, "Member 'UEffectModelDecal::ZfadingFactor' has a wrong offset!");
static_assert(offsetof(UEffectModelDecal, ZfadingPower) == 0x000564, "Member 'UEffectModelDecal::ZfadingPower' has a wrong offset!");
static_assert(offsetof(UEffectModelDecal, MaterialFloatParameters) == 0x000568, "Member 'UEffectModelDecal::MaterialFloatParameters' has a wrong offset!");
static_assert(offsetof(UEffectModelDecal, MaterialColorParameters) == 0x0005B8, "Member 'UEffectModelDecal::MaterialColorParameters' has a wrong offset!");

// Class KuroGameplay.EffectModelGhost
// 0x00C0 (0x0120 - 0x0060)
class UEffectModelGhost : public UEffectModelBase
{
public:
	class UMaterialInstance*                      MaterialRef;                                       // 0x0060(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USkeletalMesh*                          Mesh;                                              // 0x0068(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<EEffectModelGhostCppComponent>         MeshComponentsToUse;                               // 0x0070(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FName>                           CustomComponentNames;                              // 0x0080(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FKuroCurveFloat                        AlphaCurve;                                        // 0x0090(0x0090)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EffectModelGhost">();
	}
	static class UEffectModelGhost* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEffectModelGhost>();
	}
};
static_assert(alignof(UEffectModelGhost) == 0x000008, "Wrong alignment on UEffectModelGhost");
static_assert(sizeof(UEffectModelGhost) == 0x000120, "Wrong size on UEffectModelGhost");
static_assert(offsetof(UEffectModelGhost, MaterialRef) == 0x000060, "Member 'UEffectModelGhost::MaterialRef' has a wrong offset!");
static_assert(offsetof(UEffectModelGhost, Mesh) == 0x000068, "Member 'UEffectModelGhost::Mesh' has a wrong offset!");
static_assert(offsetof(UEffectModelGhost, MeshComponentsToUse) == 0x000070, "Member 'UEffectModelGhost::MeshComponentsToUse' has a wrong offset!");
static_assert(offsetof(UEffectModelGhost, CustomComponentNames) == 0x000080, "Member 'UEffectModelGhost::CustomComponentNames' has a wrong offset!");
static_assert(offsetof(UEffectModelGhost, AlphaCurve) == 0x000090, "Member 'UEffectModelGhost::AlphaCurve' has a wrong offset!");

// Class KuroGameplay.EffectModelGpuParticle
// 0x05A0 (0x0600 - 0x0060)
class UEffectModelGpuParticle : public UEffectModelBase
{
public:
	struct FKuroCurveVector                       Location;                                          // 0x0060(0x01A8)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FKuroCurveVector                       Rotation;                                          // 0x0208(0x01A8)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FKuroCurveVector                       Scale;                                             // 0x03B0(0x01A8)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class UKuroGPUParticleDA*                     Data;                                              // 0x0558(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FKuroCurveFloat                        TimeScaler;                                        // 0x0560(0x0090)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	bool                                          Loop;                                              // 0x05F0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          EnablePingPong;                                    // 0x05F1(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5F2[0x2];                                      // 0x05F2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PingPongTime;                                      // 0x05F4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReversePlay;                                       // 0x05F8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5F9[0x7];                                      // 0x05F9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EffectModelGpuParticle">();
	}
	static class UEffectModelGpuParticle* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEffectModelGpuParticle>();
	}
};
static_assert(alignof(UEffectModelGpuParticle) == 0x000008, "Wrong alignment on UEffectModelGpuParticle");
static_assert(sizeof(UEffectModelGpuParticle) == 0x000600, "Wrong size on UEffectModelGpuParticle");
static_assert(offsetof(UEffectModelGpuParticle, Location) == 0x000060, "Member 'UEffectModelGpuParticle::Location' has a wrong offset!");
static_assert(offsetof(UEffectModelGpuParticle, Rotation) == 0x000208, "Member 'UEffectModelGpuParticle::Rotation' has a wrong offset!");
static_assert(offsetof(UEffectModelGpuParticle, Scale) == 0x0003B0, "Member 'UEffectModelGpuParticle::Scale' has a wrong offset!");
static_assert(offsetof(UEffectModelGpuParticle, Data) == 0x000558, "Member 'UEffectModelGpuParticle::Data' has a wrong offset!");
static_assert(offsetof(UEffectModelGpuParticle, TimeScaler) == 0x000560, "Member 'UEffectModelGpuParticle::TimeScaler' has a wrong offset!");
static_assert(offsetof(UEffectModelGpuParticle, Loop) == 0x0005F0, "Member 'UEffectModelGpuParticle::Loop' has a wrong offset!");
static_assert(offsetof(UEffectModelGpuParticle, EnablePingPong) == 0x0005F1, "Member 'UEffectModelGpuParticle::EnablePingPong' has a wrong offset!");
static_assert(offsetof(UEffectModelGpuParticle, PingPongTime) == 0x0005F4, "Member 'UEffectModelGpuParticle::PingPongTime' has a wrong offset!");
static_assert(offsetof(UEffectModelGpuParticle, ReversePlay) == 0x0005F8, "Member 'UEffectModelGpuParticle::ReversePlay' has a wrong offset!");

// Class KuroGameplay.EffectModelGroup
// 0x0548 (0x05A8 - 0x0060)
class UEffectModelGroup : public UEffectModelBase
{
public:
	struct FKuroCurveVector                       Location;                                          // 0x0060(0x01A8)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FKuroCurveVector                       Rotation;                                          // 0x0208(0x01A8)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FKuroCurveVector                       Scale;                                             // 0x03B0(0x01A8)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<class UEffectModelBase*, float>          EffectData;                                        // 0x0558(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EffectModelGroup">();
	}
	static class UEffectModelGroup* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEffectModelGroup>();
	}
};
static_assert(alignof(UEffectModelGroup) == 0x000008, "Wrong alignment on UEffectModelGroup");
static_assert(sizeof(UEffectModelGroup) == 0x0005A8, "Wrong size on UEffectModelGroup");
static_assert(offsetof(UEffectModelGroup, Location) == 0x000060, "Member 'UEffectModelGroup::Location' has a wrong offset!");
static_assert(offsetof(UEffectModelGroup, Rotation) == 0x000208, "Member 'UEffectModelGroup::Rotation' has a wrong offset!");
static_assert(offsetof(UEffectModelGroup, Scale) == 0x0003B0, "Member 'UEffectModelGroup::Scale' has a wrong offset!");
static_assert(offsetof(UEffectModelGroup, EffectData) == 0x000558, "Member 'UEffectModelGroup::EffectData' has a wrong offset!");

// Class KuroGameplay.EffectModelLight
// 0x0678 (0x06D8 - 0x0060)
class UEffectModelLight : public UEffectModelBase
{
public:
	struct FKuroCurveVector                       Location;                                          // 0x0060(0x01A8)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FKuroCurveFloat                        Intensity;                                         // 0x0208(0x0090)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FKuroCurveLinearColor                  Color;                                             // 0x0298(0x0220)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FKuroCurveFloat                        Radius;                                            // 0x04B8(0x0090)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FKuroCurveFloat                        FalloffExponent;                                   // 0x0548(0x0090)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	ELightQualityType                             LightQualityType;                                  // 0x05D8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5D9[0x3];                                      // 0x05D9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SourceRadius;                                      // 0x05DC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SoftSourceRadius;                                  // 0x05E0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SourceLength;                                      // 0x05E4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FKuroCurveFloat                        CharacterLightAlpha;                               // 0x05E8(0x0090)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	float                                         CharacterFalloffExponent;                          // 0x0678(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CharacterBlendAtten;                               // 0x067C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CharacterBlendIntensity;                           // 0x0680(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EToonLightType                                ToonLightType;                                     // 0x0684(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_685[0x3];                                      // 0x0685(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         CharacterPriority;                                 // 0x0688(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CharacterIntensity;                                // 0x068C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           CharacterColor;                                    // 0x0690(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CharacterShadowIntensity;                          // 0x06A0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CharacterRealTimeShadowIntensity;                  // 0x06A4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CharacterDesaturationIntensity;                    // 0x06A8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CharacterHardIntensity;                            // 0x06AC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           CharacterHardColor;                                // 0x06B0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           CharacterHardShadowColor;                          // 0x06C0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CharacterHardBlend;                                // 0x06D0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6D4[0x4];                                      // 0x06D4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EffectModelLight">();
	}
	static class UEffectModelLight* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEffectModelLight>();
	}
};
static_assert(alignof(UEffectModelLight) == 0x000008, "Wrong alignment on UEffectModelLight");
static_assert(sizeof(UEffectModelLight) == 0x0006D8, "Wrong size on UEffectModelLight");
static_assert(offsetof(UEffectModelLight, Location) == 0x000060, "Member 'UEffectModelLight::Location' has a wrong offset!");
static_assert(offsetof(UEffectModelLight, Intensity) == 0x000208, "Member 'UEffectModelLight::Intensity' has a wrong offset!");
static_assert(offsetof(UEffectModelLight, Color) == 0x000298, "Member 'UEffectModelLight::Color' has a wrong offset!");
static_assert(offsetof(UEffectModelLight, Radius) == 0x0004B8, "Member 'UEffectModelLight::Radius' has a wrong offset!");
static_assert(offsetof(UEffectModelLight, FalloffExponent) == 0x000548, "Member 'UEffectModelLight::FalloffExponent' has a wrong offset!");
static_assert(offsetof(UEffectModelLight, LightQualityType) == 0x0005D8, "Member 'UEffectModelLight::LightQualityType' has a wrong offset!");
static_assert(offsetof(UEffectModelLight, SourceRadius) == 0x0005DC, "Member 'UEffectModelLight::SourceRadius' has a wrong offset!");
static_assert(offsetof(UEffectModelLight, SoftSourceRadius) == 0x0005E0, "Member 'UEffectModelLight::SoftSourceRadius' has a wrong offset!");
static_assert(offsetof(UEffectModelLight, SourceLength) == 0x0005E4, "Member 'UEffectModelLight::SourceLength' has a wrong offset!");
static_assert(offsetof(UEffectModelLight, CharacterLightAlpha) == 0x0005E8, "Member 'UEffectModelLight::CharacterLightAlpha' has a wrong offset!");
static_assert(offsetof(UEffectModelLight, CharacterFalloffExponent) == 0x000678, "Member 'UEffectModelLight::CharacterFalloffExponent' has a wrong offset!");
static_assert(offsetof(UEffectModelLight, CharacterBlendAtten) == 0x00067C, "Member 'UEffectModelLight::CharacterBlendAtten' has a wrong offset!");
static_assert(offsetof(UEffectModelLight, CharacterBlendIntensity) == 0x000680, "Member 'UEffectModelLight::CharacterBlendIntensity' has a wrong offset!");
static_assert(offsetof(UEffectModelLight, ToonLightType) == 0x000684, "Member 'UEffectModelLight::ToonLightType' has a wrong offset!");
static_assert(offsetof(UEffectModelLight, CharacterPriority) == 0x000688, "Member 'UEffectModelLight::CharacterPriority' has a wrong offset!");
static_assert(offsetof(UEffectModelLight, CharacterIntensity) == 0x00068C, "Member 'UEffectModelLight::CharacterIntensity' has a wrong offset!");
static_assert(offsetof(UEffectModelLight, CharacterColor) == 0x000690, "Member 'UEffectModelLight::CharacterColor' has a wrong offset!");
static_assert(offsetof(UEffectModelLight, CharacterShadowIntensity) == 0x0006A0, "Member 'UEffectModelLight::CharacterShadowIntensity' has a wrong offset!");
static_assert(offsetof(UEffectModelLight, CharacterRealTimeShadowIntensity) == 0x0006A4, "Member 'UEffectModelLight::CharacterRealTimeShadowIntensity' has a wrong offset!");
static_assert(offsetof(UEffectModelLight, CharacterDesaturationIntensity) == 0x0006A8, "Member 'UEffectModelLight::CharacterDesaturationIntensity' has a wrong offset!");
static_assert(offsetof(UEffectModelLight, CharacterHardIntensity) == 0x0006AC, "Member 'UEffectModelLight::CharacterHardIntensity' has a wrong offset!");
static_assert(offsetof(UEffectModelLight, CharacterHardColor) == 0x0006B0, "Member 'UEffectModelLight::CharacterHardColor' has a wrong offset!");
static_assert(offsetof(UEffectModelLight, CharacterHardShadowColor) == 0x0006C0, "Member 'UEffectModelLight::CharacterHardShadowColor' has a wrong offset!");
static_assert(offsetof(UEffectModelLight, CharacterHardBlend) == 0x0006D0, "Member 'UEffectModelLight::CharacterHardBlend' has a wrong offset!");

// Class KuroGameplay.EffectModelMultiEffect
// 0x0018 (0x0078 - 0x0060)
class UEffectModelMultiEffect final : public UEffectModelBase
{
public:
	class UEffectModelBase*                       EffectData;                                        // 0x0060(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	KuroGameplay::EMultiEffectType                Type;                                              // 0x0068(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_69[0x3];                                       // 0x0069(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         BaseNum;                                           // 0x006C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpinSpeed;                                         // 0x0070(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Radius;                                            // 0x0074(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EffectModelMultiEffect">();
	}
	static class UEffectModelMultiEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEffectModelMultiEffect>();
	}
};
static_assert(alignof(UEffectModelMultiEffect) == 0x000008, "Wrong alignment on UEffectModelMultiEffect");
static_assert(sizeof(UEffectModelMultiEffect) == 0x000078, "Wrong size on UEffectModelMultiEffect");
static_assert(offsetof(UEffectModelMultiEffect, EffectData) == 0x000060, "Member 'UEffectModelMultiEffect::EffectData' has a wrong offset!");
static_assert(offsetof(UEffectModelMultiEffect, Type) == 0x000068, "Member 'UEffectModelMultiEffect::Type' has a wrong offset!");
static_assert(offsetof(UEffectModelMultiEffect, BaseNum) == 0x00006C, "Member 'UEffectModelMultiEffect::BaseNum' has a wrong offset!");
static_assert(offsetof(UEffectModelMultiEffect, SpinSpeed) == 0x000070, "Member 'UEffectModelMultiEffect::SpinSpeed' has a wrong offset!");
static_assert(offsetof(UEffectModelMultiEffect, Radius) == 0x000074, "Member 'UEffectModelMultiEffect::Radius' has a wrong offset!");

// Class KuroGameplay.EffectModelNiagara
// 0x0610 (0x0670 - 0x0060)
class UEffectModelNiagara : public UEffectModelBase
{
public:
	struct FKuroCurveVector                       Location;                                          // 0x0060(0x01A8)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FKuroCurveVector                       Rotation;                                          // 0x0208(0x01A8)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FKuroCurveVector                       Scale;                                             // 0x03B0(0x01A8)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class UNiagaraSystem*                         NiagaraRef;                                        // 0x0558(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class FName, struct FKuroCurveFloat>     FloatParameters;                                   // 0x0560(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TMap<class FName, struct FKuroCurveLinearColor> ColorParameters;                                   // 0x05B0(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TMap<class FName, struct FKuroCurveVector>    VectorParameters;                                  // 0x0600(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	bool                                          DeactivateOnStop;                                  // 0x0650(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReceiveDecal;                                      // 0x0651(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_652[0x2];                                      // 0x0652(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         TranslucencySortPriority;                          // 0x0654(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FEffectModelNiagaraExtraState>  ExtraStates;                                       // 0x0658(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          IgnoreMobileSimulationOptimize;                    // 0x0668(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_669[0x7];                                      // 0x0669(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EffectModelNiagara">();
	}
	static class UEffectModelNiagara* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEffectModelNiagara>();
	}
};
static_assert(alignof(UEffectModelNiagara) == 0x000008, "Wrong alignment on UEffectModelNiagara");
static_assert(sizeof(UEffectModelNiagara) == 0x000670, "Wrong size on UEffectModelNiagara");
static_assert(offsetof(UEffectModelNiagara, Location) == 0x000060, "Member 'UEffectModelNiagara::Location' has a wrong offset!");
static_assert(offsetof(UEffectModelNiagara, Rotation) == 0x000208, "Member 'UEffectModelNiagara::Rotation' has a wrong offset!");
static_assert(offsetof(UEffectModelNiagara, Scale) == 0x0003B0, "Member 'UEffectModelNiagara::Scale' has a wrong offset!");
static_assert(offsetof(UEffectModelNiagara, NiagaraRef) == 0x000558, "Member 'UEffectModelNiagara::NiagaraRef' has a wrong offset!");
static_assert(offsetof(UEffectModelNiagara, FloatParameters) == 0x000560, "Member 'UEffectModelNiagara::FloatParameters' has a wrong offset!");
static_assert(offsetof(UEffectModelNiagara, ColorParameters) == 0x0005B0, "Member 'UEffectModelNiagara::ColorParameters' has a wrong offset!");
static_assert(offsetof(UEffectModelNiagara, VectorParameters) == 0x000600, "Member 'UEffectModelNiagara::VectorParameters' has a wrong offset!");
static_assert(offsetof(UEffectModelNiagara, DeactivateOnStop) == 0x000650, "Member 'UEffectModelNiagara::DeactivateOnStop' has a wrong offset!");
static_assert(offsetof(UEffectModelNiagara, ReceiveDecal) == 0x000651, "Member 'UEffectModelNiagara::ReceiveDecal' has a wrong offset!");
static_assert(offsetof(UEffectModelNiagara, TranslucencySortPriority) == 0x000654, "Member 'UEffectModelNiagara::TranslucencySortPriority' has a wrong offset!");
static_assert(offsetof(UEffectModelNiagara, ExtraStates) == 0x000658, "Member 'UEffectModelNiagara::ExtraStates' has a wrong offset!");
static_assert(offsetof(UEffectModelNiagara, IgnoreMobileSimulationOptimize) == 0x000668, "Member 'UEffectModelNiagara::IgnoreMobileSimulationOptimize' has a wrong offset!");

// Class KuroGameplay.EffectModelPostProcess
// 0x2490 (0x24F0 - 0x0060)
class UEffectModelPostProcess : public UEffectModelBase
{
public:
	struct FKuroCurveVector                       Location;                                          // 0x0060(0x01A8)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	bool                                          EnableVolume;                                      // 0x0208(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_209[0x3];                                      // 0x0209(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         VolumeRadius;                                      // 0x020C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VolumeHardness;                                    // 0x0210(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UseVolumeHardnessCurve;                            // 0x0214(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_215[0x3];                                      // 0x0215(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FKuroCurveFloat                        VolumeHardnessCurve;                               // 0x0218(0x0090)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	float                                         WeatherPriority;                                   // 0x02A8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnablePostprocessMaterial;                        // 0x02AC(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2AD[0x3];                                      // 0x02AD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialInterface*                     PostprocessMaterial;                               // 0x02B0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class FName, struct FKuroCurveFloat>     PostprocessMaterialFloatParameters;                // 0x02B8(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<class FName, struct FKuroCurveLinearColor> PostprocessMaterialColorParameters;                // 0x0308(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	bool                                          BlurIntensityOverride;                             // 0x0358(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_359[0x7];                                      // 0x0359(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FKuroCurveFloat                        BlurIntensity;                                     // 0x0360(0x0090)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	bool                                          UseWorldPosition;                                  // 0x03F0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3F1[0x3];                                      // 0x03F1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              ScreenPosition;                                    // 0x03F4(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3FC[0x4];                                      // 0x03FC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FKuroCurveFloat                        RadialBlurRadius;                                  // 0x0400(0x0090)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FKuroCurveFloat                        RadialBlurHardness;                                // 0x0490(0x0090)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class UTexture*                               RadialBlurMask;                                    // 0x0520(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              RadialBlurMaskScale;                               // 0x0528(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FKuroCurveLinearColor                  RadialBlurMaskScaleOffset;                         // 0x0530(0x0220)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	bool                                          MainLightIntensityOverride;                        // 0x0750(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_751[0x7];                                      // 0x0751(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FKuroCurveFloat                        MainLightIntensity;                                // 0x0758(0x0090)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	bool                                          MainLightColorOverride;                            // 0x07E8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7E9[0x7];                                      // 0x07E9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FKuroCurveLinearColor                  MainLightColor;                                    // 0x07F0(0x0220)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	bool                                          SkyLightIntensityOverride;                         // 0x0A10(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A11[0x7];                                      // 0x0A11(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FKuroCurveFloat                        SkyLightIntensity;                                 // 0x0A18(0x0090)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	bool                                          SkyLightColorOverride;                             // 0x0AA8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_AA9[0x7];                                      // 0x0AA9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FKuroCurveLinearColor                  SkyLightColor;                                     // 0x0AB0(0x0220)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	bool                                          FogDensityOverride;                                // 0x0CD0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_CD1[0x7];                                      // 0x0CD1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FKuroCurveFloat                        FogDensity;                                        // 0x0CD8(0x0090)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FKuroCurveFloat                        FogStartDistance;                                  // 0x0D68(0x0090)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	float                                         FogFalloff;                                        // 0x0DF8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          FogColorOverride;                                  // 0x0DFC(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_DFD[0x3];                                      // 0x0DFD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FKuroCurveLinearColor                  FogNearColor;                                      // 0x0E00(0x0220)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FKuroCurveLinearColor                  FogFarColor;                                       // 0x1020(0x0220)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FKuroCurveFloat                        FogNearColorDistance;                              // 0x1240(0x0090)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FKuroCurveFloat                        FogFarColorDistance;                               // 0x12D0(0x0090)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	float                                         FogColorRatio;                                     // 0x1360(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          KuroBloomIntensityOverride;                        // 0x1364(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1365[0x3];                                     // 0x1365(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FKuroCurveFloat                        KuroBloomIntensity;                                // 0x1368(0x0090)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	bool                                          KuroThresholdOverride;                             // 0x13F8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_13F9[0x7];                                     // 0x13F9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FKuroCurveFloat                        KuroThreshold;                                     // 0x1400(0x0090)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	bool                                          SceneFringeIntensityOverride;                      // 0x1490(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1491[0x7];                                     // 0x1491(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FKuroCurveFloat                        SceneFringeIntensity;                              // 0x1498(0x0090)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	bool                                          StartOffsetOverride;                               // 0x1528(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1529[0x7];                                     // 0x1529(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FKuroCurveFloat                        StartOffset;                                       // 0x1530(0x0090)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	bool                                          VignetteIntensityOverride;                         // 0x15C0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15C1[0x7];                                     // 0x15C1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FKuroCurveFloat                        VignetteIntensity;                                 // 0x15C8(0x0090)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	bool                                          GrainJitterOverride;                               // 0x1658(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1659[0x7];                                     // 0x1659(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FKuroCurveFloat                        GrainJitter;                                       // 0x1660(0x0090)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	bool                                          GrainIntensityOverride;                            // 0x16F0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_16F1[0x7];                                     // 0x16F1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FKuroCurveFloat                        GrainIntensity;                                    // 0x16F8(0x0090)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	bool                                          LutIntensityOverride;                              // 0x1788(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1789[0x7];                                     // 0x1789(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FKuroCurveFloat                        LutIntensity;                                      // 0x1790(0x0090)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	bool                                          LutTextureOverride;                                // 0x1820(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1821[0x7];                                     // 0x1821(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UTexture2D*                             LutTexture;                                        // 0x1828(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          SceneColorTintOverride;                            // 0x1830(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1831[0x7];                                     // 0x1831(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FKuroCurveLinearColor                  SceneColorTint;                                    // 0x1838(0x0220)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	bool                                          SceneColorDesaturateOverride;                      // 0x1A58(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A59[0x7];                                     // 0x1A59(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FKuroCurveFloat                        SceneColorDesaturate;                              // 0x1A60(0x0090)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	bool                                          BlackWhiteFlashIntensityOverride;                  // 0x1AF0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1AF1[0x7];                                     // 0x1AF1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FKuroCurveFloat                        BlackWhiteFlashIntensity;                          // 0x1AF8(0x0090)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	bool                                          BlackWhiteFlashFactorOverride;                     // 0x1B88(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1B89[0x7];                                     // 0x1B89(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FKuroCurveFloat                        BlackWhiteFlashFactor;                             // 0x1B90(0x0090)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	bool                                          BlackWhiteFlashThresholdOverride;                  // 0x1C20(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C21[0x7];                                     // 0x1C21(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FKuroCurveFloat                        BlackWhiteFlashThreshold;                          // 0x1C28(0x0090)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	bool                                          BlackWhiteFlashBlackAreaColorOverride;             // 0x1CB8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1CB9[0x7];                                     // 0x1CB9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FKuroCurveLinearColor                  BlackWhiteFlashBlackAreaColor;                     // 0x1CC0(0x0220)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	bool                                          BlackWhiteFlashWhiteAreaColorOverride;             // 0x1EE0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1EE1[0x7];                                     // 0x1EE1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FKuroCurveLinearColor                  BlackWhiteFlashWhiteAreaColor;                     // 0x1EE8(0x0220)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	bool                                          GrayGradationOverride;                             // 0x2108(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          GrayGradationCullTranslucency;                     // 0x2109(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          GrayGradationUsePlayerLocation;                    // 0x210A(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_210B[0x5];                                     // 0x210B(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	struct FKuroCurveFloat                        GrayGradationDegree;                               // 0x2110(0x0090)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FKuroCurveFloat                        GrayGradationLerpWidth;                            // 0x21A0(0x0090)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class UTexture2D*                             GrayGradationRampTexture;                          // 0x2230(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FKuroCurveLinearColor                  GrayGradationColorTint;                            // 0x2238(0x0220)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FKuroCurveFloat                        GrayGradationBlendWeight;                          // 0x2458(0x0090)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class UKuroWeatherDataAsset*                  WeatherDataAsset;                                  // 0x24E8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EffectModelPostProcess">();
	}
	static class UEffectModelPostProcess* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEffectModelPostProcess>();
	}
};
static_assert(alignof(UEffectModelPostProcess) == 0x000008, "Wrong alignment on UEffectModelPostProcess");
static_assert(sizeof(UEffectModelPostProcess) == 0x0024F0, "Wrong size on UEffectModelPostProcess");
static_assert(offsetof(UEffectModelPostProcess, Location) == 0x000060, "Member 'UEffectModelPostProcess::Location' has a wrong offset!");
static_assert(offsetof(UEffectModelPostProcess, EnableVolume) == 0x000208, "Member 'UEffectModelPostProcess::EnableVolume' has a wrong offset!");
static_assert(offsetof(UEffectModelPostProcess, VolumeRadius) == 0x00020C, "Member 'UEffectModelPostProcess::VolumeRadius' has a wrong offset!");
static_assert(offsetof(UEffectModelPostProcess, VolumeHardness) == 0x000210, "Member 'UEffectModelPostProcess::VolumeHardness' has a wrong offset!");
static_assert(offsetof(UEffectModelPostProcess, UseVolumeHardnessCurve) == 0x000214, "Member 'UEffectModelPostProcess::UseVolumeHardnessCurve' has a wrong offset!");
static_assert(offsetof(UEffectModelPostProcess, VolumeHardnessCurve) == 0x000218, "Member 'UEffectModelPostProcess::VolumeHardnessCurve' has a wrong offset!");
static_assert(offsetof(UEffectModelPostProcess, WeatherPriority) == 0x0002A8, "Member 'UEffectModelPostProcess::WeatherPriority' has a wrong offset!");
static_assert(offsetof(UEffectModelPostProcess, bEnablePostprocessMaterial) == 0x0002AC, "Member 'UEffectModelPostProcess::bEnablePostprocessMaterial' has a wrong offset!");
static_assert(offsetof(UEffectModelPostProcess, PostprocessMaterial) == 0x0002B0, "Member 'UEffectModelPostProcess::PostprocessMaterial' has a wrong offset!");
static_assert(offsetof(UEffectModelPostProcess, PostprocessMaterialFloatParameters) == 0x0002B8, "Member 'UEffectModelPostProcess::PostprocessMaterialFloatParameters' has a wrong offset!");
static_assert(offsetof(UEffectModelPostProcess, PostprocessMaterialColorParameters) == 0x000308, "Member 'UEffectModelPostProcess::PostprocessMaterialColorParameters' has a wrong offset!");
static_assert(offsetof(UEffectModelPostProcess, BlurIntensityOverride) == 0x000358, "Member 'UEffectModelPostProcess::BlurIntensityOverride' has a wrong offset!");
static_assert(offsetof(UEffectModelPostProcess, BlurIntensity) == 0x000360, "Member 'UEffectModelPostProcess::BlurIntensity' has a wrong offset!");
static_assert(offsetof(UEffectModelPostProcess, UseWorldPosition) == 0x0003F0, "Member 'UEffectModelPostProcess::UseWorldPosition' has a wrong offset!");
static_assert(offsetof(UEffectModelPostProcess, ScreenPosition) == 0x0003F4, "Member 'UEffectModelPostProcess::ScreenPosition' has a wrong offset!");
static_assert(offsetof(UEffectModelPostProcess, RadialBlurRadius) == 0x000400, "Member 'UEffectModelPostProcess::RadialBlurRadius' has a wrong offset!");
static_assert(offsetof(UEffectModelPostProcess, RadialBlurHardness) == 0x000490, "Member 'UEffectModelPostProcess::RadialBlurHardness' has a wrong offset!");
static_assert(offsetof(UEffectModelPostProcess, RadialBlurMask) == 0x000520, "Member 'UEffectModelPostProcess::RadialBlurMask' has a wrong offset!");
static_assert(offsetof(UEffectModelPostProcess, RadialBlurMaskScale) == 0x000528, "Member 'UEffectModelPostProcess::RadialBlurMaskScale' has a wrong offset!");
static_assert(offsetof(UEffectModelPostProcess, RadialBlurMaskScaleOffset) == 0x000530, "Member 'UEffectModelPostProcess::RadialBlurMaskScaleOffset' has a wrong offset!");
static_assert(offsetof(UEffectModelPostProcess, MainLightIntensityOverride) == 0x000750, "Member 'UEffectModelPostProcess::MainLightIntensityOverride' has a wrong offset!");
static_assert(offsetof(UEffectModelPostProcess, MainLightIntensity) == 0x000758, "Member 'UEffectModelPostProcess::MainLightIntensity' has a wrong offset!");
static_assert(offsetof(UEffectModelPostProcess, MainLightColorOverride) == 0x0007E8, "Member 'UEffectModelPostProcess::MainLightColorOverride' has a wrong offset!");
static_assert(offsetof(UEffectModelPostProcess, MainLightColor) == 0x0007F0, "Member 'UEffectModelPostProcess::MainLightColor' has a wrong offset!");
static_assert(offsetof(UEffectModelPostProcess, SkyLightIntensityOverride) == 0x000A10, "Member 'UEffectModelPostProcess::SkyLightIntensityOverride' has a wrong offset!");
static_assert(offsetof(UEffectModelPostProcess, SkyLightIntensity) == 0x000A18, "Member 'UEffectModelPostProcess::SkyLightIntensity' has a wrong offset!");
static_assert(offsetof(UEffectModelPostProcess, SkyLightColorOverride) == 0x000AA8, "Member 'UEffectModelPostProcess::SkyLightColorOverride' has a wrong offset!");
static_assert(offsetof(UEffectModelPostProcess, SkyLightColor) == 0x000AB0, "Member 'UEffectModelPostProcess::SkyLightColor' has a wrong offset!");
static_assert(offsetof(UEffectModelPostProcess, FogDensityOverride) == 0x000CD0, "Member 'UEffectModelPostProcess::FogDensityOverride' has a wrong offset!");
static_assert(offsetof(UEffectModelPostProcess, FogDensity) == 0x000CD8, "Member 'UEffectModelPostProcess::FogDensity' has a wrong offset!");
static_assert(offsetof(UEffectModelPostProcess, FogStartDistance) == 0x000D68, "Member 'UEffectModelPostProcess::FogStartDistance' has a wrong offset!");
static_assert(offsetof(UEffectModelPostProcess, FogFalloff) == 0x000DF8, "Member 'UEffectModelPostProcess::FogFalloff' has a wrong offset!");
static_assert(offsetof(UEffectModelPostProcess, FogColorOverride) == 0x000DFC, "Member 'UEffectModelPostProcess::FogColorOverride' has a wrong offset!");
static_assert(offsetof(UEffectModelPostProcess, FogNearColor) == 0x000E00, "Member 'UEffectModelPostProcess::FogNearColor' has a wrong offset!");
static_assert(offsetof(UEffectModelPostProcess, FogFarColor) == 0x001020, "Member 'UEffectModelPostProcess::FogFarColor' has a wrong offset!");
static_assert(offsetof(UEffectModelPostProcess, FogNearColorDistance) == 0x001240, "Member 'UEffectModelPostProcess::FogNearColorDistance' has a wrong offset!");
static_assert(offsetof(UEffectModelPostProcess, FogFarColorDistance) == 0x0012D0, "Member 'UEffectModelPostProcess::FogFarColorDistance' has a wrong offset!");
static_assert(offsetof(UEffectModelPostProcess, FogColorRatio) == 0x001360, "Member 'UEffectModelPostProcess::FogColorRatio' has a wrong offset!");
static_assert(offsetof(UEffectModelPostProcess, KuroBloomIntensityOverride) == 0x001364, "Member 'UEffectModelPostProcess::KuroBloomIntensityOverride' has a wrong offset!");
static_assert(offsetof(UEffectModelPostProcess, KuroBloomIntensity) == 0x001368, "Member 'UEffectModelPostProcess::KuroBloomIntensity' has a wrong offset!");
static_assert(offsetof(UEffectModelPostProcess, KuroThresholdOverride) == 0x0013F8, "Member 'UEffectModelPostProcess::KuroThresholdOverride' has a wrong offset!");
static_assert(offsetof(UEffectModelPostProcess, KuroThreshold) == 0x001400, "Member 'UEffectModelPostProcess::KuroThreshold' has a wrong offset!");
static_assert(offsetof(UEffectModelPostProcess, SceneFringeIntensityOverride) == 0x001490, "Member 'UEffectModelPostProcess::SceneFringeIntensityOverride' has a wrong offset!");
static_assert(offsetof(UEffectModelPostProcess, SceneFringeIntensity) == 0x001498, "Member 'UEffectModelPostProcess::SceneFringeIntensity' has a wrong offset!");
static_assert(offsetof(UEffectModelPostProcess, StartOffsetOverride) == 0x001528, "Member 'UEffectModelPostProcess::StartOffsetOverride' has a wrong offset!");
static_assert(offsetof(UEffectModelPostProcess, StartOffset) == 0x001530, "Member 'UEffectModelPostProcess::StartOffset' has a wrong offset!");
static_assert(offsetof(UEffectModelPostProcess, VignetteIntensityOverride) == 0x0015C0, "Member 'UEffectModelPostProcess::VignetteIntensityOverride' has a wrong offset!");
static_assert(offsetof(UEffectModelPostProcess, VignetteIntensity) == 0x0015C8, "Member 'UEffectModelPostProcess::VignetteIntensity' has a wrong offset!");
static_assert(offsetof(UEffectModelPostProcess, GrainJitterOverride) == 0x001658, "Member 'UEffectModelPostProcess::GrainJitterOverride' has a wrong offset!");
static_assert(offsetof(UEffectModelPostProcess, GrainJitter) == 0x001660, "Member 'UEffectModelPostProcess::GrainJitter' has a wrong offset!");
static_assert(offsetof(UEffectModelPostProcess, GrainIntensityOverride) == 0x0016F0, "Member 'UEffectModelPostProcess::GrainIntensityOverride' has a wrong offset!");
static_assert(offsetof(UEffectModelPostProcess, GrainIntensity) == 0x0016F8, "Member 'UEffectModelPostProcess::GrainIntensity' has a wrong offset!");
static_assert(offsetof(UEffectModelPostProcess, LutIntensityOverride) == 0x001788, "Member 'UEffectModelPostProcess::LutIntensityOverride' has a wrong offset!");
static_assert(offsetof(UEffectModelPostProcess, LutIntensity) == 0x001790, "Member 'UEffectModelPostProcess::LutIntensity' has a wrong offset!");
static_assert(offsetof(UEffectModelPostProcess, LutTextureOverride) == 0x001820, "Member 'UEffectModelPostProcess::LutTextureOverride' has a wrong offset!");
static_assert(offsetof(UEffectModelPostProcess, LutTexture) == 0x001828, "Member 'UEffectModelPostProcess::LutTexture' has a wrong offset!");
static_assert(offsetof(UEffectModelPostProcess, SceneColorTintOverride) == 0x001830, "Member 'UEffectModelPostProcess::SceneColorTintOverride' has a wrong offset!");
static_assert(offsetof(UEffectModelPostProcess, SceneColorTint) == 0x001838, "Member 'UEffectModelPostProcess::SceneColorTint' has a wrong offset!");
static_assert(offsetof(UEffectModelPostProcess, SceneColorDesaturateOverride) == 0x001A58, "Member 'UEffectModelPostProcess::SceneColorDesaturateOverride' has a wrong offset!");
static_assert(offsetof(UEffectModelPostProcess, SceneColorDesaturate) == 0x001A60, "Member 'UEffectModelPostProcess::SceneColorDesaturate' has a wrong offset!");
static_assert(offsetof(UEffectModelPostProcess, BlackWhiteFlashIntensityOverride) == 0x001AF0, "Member 'UEffectModelPostProcess::BlackWhiteFlashIntensityOverride' has a wrong offset!");
static_assert(offsetof(UEffectModelPostProcess, BlackWhiteFlashIntensity) == 0x001AF8, "Member 'UEffectModelPostProcess::BlackWhiteFlashIntensity' has a wrong offset!");
static_assert(offsetof(UEffectModelPostProcess, BlackWhiteFlashFactorOverride) == 0x001B88, "Member 'UEffectModelPostProcess::BlackWhiteFlashFactorOverride' has a wrong offset!");
static_assert(offsetof(UEffectModelPostProcess, BlackWhiteFlashFactor) == 0x001B90, "Member 'UEffectModelPostProcess::BlackWhiteFlashFactor' has a wrong offset!");
static_assert(offsetof(UEffectModelPostProcess, BlackWhiteFlashThresholdOverride) == 0x001C20, "Member 'UEffectModelPostProcess::BlackWhiteFlashThresholdOverride' has a wrong offset!");
static_assert(offsetof(UEffectModelPostProcess, BlackWhiteFlashThreshold) == 0x001C28, "Member 'UEffectModelPostProcess::BlackWhiteFlashThreshold' has a wrong offset!");
static_assert(offsetof(UEffectModelPostProcess, BlackWhiteFlashBlackAreaColorOverride) == 0x001CB8, "Member 'UEffectModelPostProcess::BlackWhiteFlashBlackAreaColorOverride' has a wrong offset!");
static_assert(offsetof(UEffectModelPostProcess, BlackWhiteFlashBlackAreaColor) == 0x001CC0, "Member 'UEffectModelPostProcess::BlackWhiteFlashBlackAreaColor' has a wrong offset!");
static_assert(offsetof(UEffectModelPostProcess, BlackWhiteFlashWhiteAreaColorOverride) == 0x001EE0, "Member 'UEffectModelPostProcess::BlackWhiteFlashWhiteAreaColorOverride' has a wrong offset!");
static_assert(offsetof(UEffectModelPostProcess, BlackWhiteFlashWhiteAreaColor) == 0x001EE8, "Member 'UEffectModelPostProcess::BlackWhiteFlashWhiteAreaColor' has a wrong offset!");
static_assert(offsetof(UEffectModelPostProcess, GrayGradationOverride) == 0x002108, "Member 'UEffectModelPostProcess::GrayGradationOverride' has a wrong offset!");
static_assert(offsetof(UEffectModelPostProcess, GrayGradationCullTranslucency) == 0x002109, "Member 'UEffectModelPostProcess::GrayGradationCullTranslucency' has a wrong offset!");
static_assert(offsetof(UEffectModelPostProcess, GrayGradationUsePlayerLocation) == 0x00210A, "Member 'UEffectModelPostProcess::GrayGradationUsePlayerLocation' has a wrong offset!");
static_assert(offsetof(UEffectModelPostProcess, GrayGradationDegree) == 0x002110, "Member 'UEffectModelPostProcess::GrayGradationDegree' has a wrong offset!");
static_assert(offsetof(UEffectModelPostProcess, GrayGradationLerpWidth) == 0x0021A0, "Member 'UEffectModelPostProcess::GrayGradationLerpWidth' has a wrong offset!");
static_assert(offsetof(UEffectModelPostProcess, GrayGradationRampTexture) == 0x002230, "Member 'UEffectModelPostProcess::GrayGradationRampTexture' has a wrong offset!");
static_assert(offsetof(UEffectModelPostProcess, GrayGradationColorTint) == 0x002238, "Member 'UEffectModelPostProcess::GrayGradationColorTint' has a wrong offset!");
static_assert(offsetof(UEffectModelPostProcess, GrayGradationBlendWeight) == 0x002458, "Member 'UEffectModelPostProcess::GrayGradationBlendWeight' has a wrong offset!");
static_assert(offsetof(UEffectModelPostProcess, WeatherDataAsset) == 0x0024E8, "Member 'UEffectModelPostProcess::WeatherDataAsset' has a wrong offset!");

// Class KuroGameplay.EffectModelSkeletalMesh
// 0x0520 (0x0580 - 0x0060)
class UEffectModelSkeletalMesh : public UEffectModelBase
{
public:
	class USkeletalMesh*                          SkeletalMeshRef;                                   // 0x0060(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimationAsset*                        AnimationRef;                                      // 0x0068(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Looping;                                           // 0x0070(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Playing;                                           // 0x0071(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_72[0x6];                                       // 0x0072(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FKuroCurveVector                       Location;                                          // 0x0078(0x01A8)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FKuroCurveVector                       Rotation;                                          // 0x0220(0x01A8)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FKuroCurveVector                       Scale;                                             // 0x03C8(0x01A8)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	bool                                          EnableCollision;                                   // 0x0570(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_571[0x3];                                      // 0x0571(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         HideFrames;                                        // 0x0574(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          CastShadow;                                        // 0x0578(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_579[0x7];                                      // 0x0579(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EffectModelSkeletalMesh">();
	}
	static class UEffectModelSkeletalMesh* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEffectModelSkeletalMesh>();
	}
};
static_assert(alignof(UEffectModelSkeletalMesh) == 0x000008, "Wrong alignment on UEffectModelSkeletalMesh");
static_assert(sizeof(UEffectModelSkeletalMesh) == 0x000580, "Wrong size on UEffectModelSkeletalMesh");
static_assert(offsetof(UEffectModelSkeletalMesh, SkeletalMeshRef) == 0x000060, "Member 'UEffectModelSkeletalMesh::SkeletalMeshRef' has a wrong offset!");
static_assert(offsetof(UEffectModelSkeletalMesh, AnimationRef) == 0x000068, "Member 'UEffectModelSkeletalMesh::AnimationRef' has a wrong offset!");
static_assert(offsetof(UEffectModelSkeletalMesh, Looping) == 0x000070, "Member 'UEffectModelSkeletalMesh::Looping' has a wrong offset!");
static_assert(offsetof(UEffectModelSkeletalMesh, Playing) == 0x000071, "Member 'UEffectModelSkeletalMesh::Playing' has a wrong offset!");
static_assert(offsetof(UEffectModelSkeletalMesh, Location) == 0x000078, "Member 'UEffectModelSkeletalMesh::Location' has a wrong offset!");
static_assert(offsetof(UEffectModelSkeletalMesh, Rotation) == 0x000220, "Member 'UEffectModelSkeletalMesh::Rotation' has a wrong offset!");
static_assert(offsetof(UEffectModelSkeletalMesh, Scale) == 0x0003C8, "Member 'UEffectModelSkeletalMesh::Scale' has a wrong offset!");
static_assert(offsetof(UEffectModelSkeletalMesh, EnableCollision) == 0x000570, "Member 'UEffectModelSkeletalMesh::EnableCollision' has a wrong offset!");
static_assert(offsetof(UEffectModelSkeletalMesh, HideFrames) == 0x000574, "Member 'UEffectModelSkeletalMesh::HideFrames' has a wrong offset!");
static_assert(offsetof(UEffectModelSkeletalMesh, CastShadow) == 0x000578, "Member 'UEffectModelSkeletalMesh::CastShadow' has a wrong offset!");

// Class KuroGameplay.EffectModelStaticMesh
// 0x05D0 (0x0630 - 0x0060)
class UEffectModelStaticMesh : public UEffectModelBase
{
public:
	struct FKuroCurveVector                       Location;                                          // 0x0060(0x01A8)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FKuroCurveVector                       Rotation;                                          // 0x0208(0x01A8)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FKuroCurveVector                       Scale;                                             // 0x03B0(0x01A8)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class UStaticMesh*                            StaticMeshRef;                                     // 0x0558(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UseMultipleMaterialSlots;                          // 0x0560(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_561[0x7];                                      // 0x0561(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialInstance*                      MaterialOverrideRef;                               // 0x0568(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UMaterialInstance*>              MaterialOverrideArrayRef;                          // 0x0570(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TMap<class FName, struct FKuroCurveFloat>     MaterialFloatParameters;                           // 0x0580(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<class FName, struct FKuroCurveLinearColor> MaterialColorParameters;                           // 0x05D0(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	bool                                          ReceiveDecal;                                      // 0x0620(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          EnableCollision;                                   // 0x0621(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          CastShadow;                                        // 0x0622(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_623[0x1];                                      // 0x0623(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TranslucencySortPriority;                          // 0x0624(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          EnableScreenSizeCullRatioOverride;                 // 0x0628(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_629[0x3];                                      // 0x0629(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ScreenSizeCullRatio;                               // 0x062C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EffectModelStaticMesh">();
	}
	static class UEffectModelStaticMesh* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEffectModelStaticMesh>();
	}
};
static_assert(alignof(UEffectModelStaticMesh) == 0x000008, "Wrong alignment on UEffectModelStaticMesh");
static_assert(sizeof(UEffectModelStaticMesh) == 0x000630, "Wrong size on UEffectModelStaticMesh");
static_assert(offsetof(UEffectModelStaticMesh, Location) == 0x000060, "Member 'UEffectModelStaticMesh::Location' has a wrong offset!");
static_assert(offsetof(UEffectModelStaticMesh, Rotation) == 0x000208, "Member 'UEffectModelStaticMesh::Rotation' has a wrong offset!");
static_assert(offsetof(UEffectModelStaticMesh, Scale) == 0x0003B0, "Member 'UEffectModelStaticMesh::Scale' has a wrong offset!");
static_assert(offsetof(UEffectModelStaticMesh, StaticMeshRef) == 0x000558, "Member 'UEffectModelStaticMesh::StaticMeshRef' has a wrong offset!");
static_assert(offsetof(UEffectModelStaticMesh, UseMultipleMaterialSlots) == 0x000560, "Member 'UEffectModelStaticMesh::UseMultipleMaterialSlots' has a wrong offset!");
static_assert(offsetof(UEffectModelStaticMesh, MaterialOverrideRef) == 0x000568, "Member 'UEffectModelStaticMesh::MaterialOverrideRef' has a wrong offset!");
static_assert(offsetof(UEffectModelStaticMesh, MaterialOverrideArrayRef) == 0x000570, "Member 'UEffectModelStaticMesh::MaterialOverrideArrayRef' has a wrong offset!");
static_assert(offsetof(UEffectModelStaticMesh, MaterialFloatParameters) == 0x000580, "Member 'UEffectModelStaticMesh::MaterialFloatParameters' has a wrong offset!");
static_assert(offsetof(UEffectModelStaticMesh, MaterialColorParameters) == 0x0005D0, "Member 'UEffectModelStaticMesh::MaterialColorParameters' has a wrong offset!");
static_assert(offsetof(UEffectModelStaticMesh, ReceiveDecal) == 0x000620, "Member 'UEffectModelStaticMesh::ReceiveDecal' has a wrong offset!");
static_assert(offsetof(UEffectModelStaticMesh, EnableCollision) == 0x000621, "Member 'UEffectModelStaticMesh::EnableCollision' has a wrong offset!");
static_assert(offsetof(UEffectModelStaticMesh, CastShadow) == 0x000622, "Member 'UEffectModelStaticMesh::CastShadow' has a wrong offset!");
static_assert(offsetof(UEffectModelStaticMesh, TranslucencySortPriority) == 0x000624, "Member 'UEffectModelStaticMesh::TranslucencySortPriority' has a wrong offset!");
static_assert(offsetof(UEffectModelStaticMesh, EnableScreenSizeCullRatioOverride) == 0x000628, "Member 'UEffectModelStaticMesh::EnableScreenSizeCullRatioOverride' has a wrong offset!");
static_assert(offsetof(UEffectModelStaticMesh, ScreenSizeCullRatio) == 0x00062C, "Member 'UEffectModelStaticMesh::ScreenSizeCullRatio' has a wrong offset!");

// Class KuroGameplay.EffectModelTrail
// 0x0250 (0x02B0 - 0x0060)
class UEffectModelTrail : public UEffectModelBase
{
public:
	bool                                          AttachToBones;                                     // 0x0060(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_61[0x7];                                       // 0x0061(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           AttachBoneNames;                                   // 0x0068(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FVector>                        RelativeLocations;                                 // 0x0078(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TMap<int32, struct FKuroCurveVector>          LocationsCurve;                                    // 0x0088(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class UMaterialInstance*                      Material;                                          // 0x00D8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UnitLength;                                        // 0x00E0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E4[0x4];                                       // 0x00E4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FKuroCurveFloat                        DissipateSpeed;                                    // 0x00E8(0x0090)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FKuroCurveFloat                        Alpha;                                             // 0x0178(0x0090)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<class FName, struct FKuroCurveFloat>     FloatParameters;                                   // 0x0208(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<class FName, struct FKuroCurveLinearColor> ColorParameters;                                   // 0x0258(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	bool                                          DestroyAtOnce;                                     // 0x02A8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A9[0x3];                                      // 0x02A9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DissipateSpeedAfterDead;                           // 0x02AC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EffectModelTrail">();
	}
	static class UEffectModelTrail* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEffectModelTrail>();
	}
};
static_assert(alignof(UEffectModelTrail) == 0x000008, "Wrong alignment on UEffectModelTrail");
static_assert(sizeof(UEffectModelTrail) == 0x0002B0, "Wrong size on UEffectModelTrail");
static_assert(offsetof(UEffectModelTrail, AttachToBones) == 0x000060, "Member 'UEffectModelTrail::AttachToBones' has a wrong offset!");
static_assert(offsetof(UEffectModelTrail, AttachBoneNames) == 0x000068, "Member 'UEffectModelTrail::AttachBoneNames' has a wrong offset!");
static_assert(offsetof(UEffectModelTrail, RelativeLocations) == 0x000078, "Member 'UEffectModelTrail::RelativeLocations' has a wrong offset!");
static_assert(offsetof(UEffectModelTrail, LocationsCurve) == 0x000088, "Member 'UEffectModelTrail::LocationsCurve' has a wrong offset!");
static_assert(offsetof(UEffectModelTrail, Material) == 0x0000D8, "Member 'UEffectModelTrail::Material' has a wrong offset!");
static_assert(offsetof(UEffectModelTrail, UnitLength) == 0x0000E0, "Member 'UEffectModelTrail::UnitLength' has a wrong offset!");
static_assert(offsetof(UEffectModelTrail, DissipateSpeed) == 0x0000E8, "Member 'UEffectModelTrail::DissipateSpeed' has a wrong offset!");
static_assert(offsetof(UEffectModelTrail, Alpha) == 0x000178, "Member 'UEffectModelTrail::Alpha' has a wrong offset!");
static_assert(offsetof(UEffectModelTrail, FloatParameters) == 0x000208, "Member 'UEffectModelTrail::FloatParameters' has a wrong offset!");
static_assert(offsetof(UEffectModelTrail, ColorParameters) == 0x000258, "Member 'UEffectModelTrail::ColorParameters' has a wrong offset!");
static_assert(offsetof(UEffectModelTrail, DestroyAtOnce) == 0x0002A8, "Member 'UEffectModelTrail::DestroyAtOnce' has a wrong offset!");
static_assert(offsetof(UEffectModelTrail, DissipateSpeedAfterDead) == 0x0002AC, "Member 'UEffectModelTrail::DissipateSpeedAfterDead' has a wrong offset!");

// Class KuroGameplay.GameBudgetAllocator
// 0x0590 (0x05C0 - 0x0030)
class UGameBudgetAllocator final : public UObject
{
public:
	uint8                                         Pad_30[0x590];                                     // 0x0030(0x0590)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AfterTickOutside(float DeltaSeconds);
	void SetCenterActor(class AActor* CenterActor);
	void SetDefaultTickIntervalDetailConfig(struct FGameBudgetAllocatorGroupConfig* Config, uint32 MaxTickInterval, uint16 TickReductionStartSize, uint16 TickReductionIntervalSize);
	void SetGlobalMode(EGameBudgetAllocatorGlobalMode Mode);
	void SetGroupConfig(class FName GroupName, const struct FGameBudgetAllocatorGroupConfig& Config);
	void SetMaximumFrameRate(uint32 MaxFPS);
	void SetTickIntervalDetailConfig(struct FGameBudgetAllocatorGroupConfig* Config, EGameBudgetAllocatorGlobalMode GlobalMode, EGameBudgetAllocatorActorMode ActorMode, uint32 MaxTickInterval, uint16 TickReductionStartSize, uint16 TickReductionIntervalSize);
	void TickOutside(float DeltaSeconds);
	void UpdateMinUpdateFIFOBudgetTime(float Time);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameBudgetAllocator">();
	}
	static class UGameBudgetAllocator* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameBudgetAllocator>();
	}
};
static_assert(alignof(UGameBudgetAllocator) == 0x000008, "Wrong alignment on UGameBudgetAllocator");
static_assert(sizeof(UGameBudgetAllocator) == 0x0005C0, "Wrong size on UGameBudgetAllocator");

// Class KuroGameplay.KuroAIController
// 0x0000 (0x03C0 - 0x03C0)
class AKuroAIController : public AAIController
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroAIController">();
	}
	static class AKuroAIController* GetDefaultObj()
	{
		return GetDefaultObjImpl<AKuroAIController>();
	}
};
static_assert(alignof(AKuroAIController) == 0x000008, "Wrong alignment on AKuroAIController");
static_assert(sizeof(AKuroAIController) == 0x0003C0, "Wrong size on AKuroAIController");

// Class KuroGameplay.KuroEffectLibrary
// 0x0000 (0x0030 - 0x0030)
class UKuroEffectLibrary final : public UBlueprintFunctionLibrary
{
public:
	static class USceneComponent* AddSceneComponent(class AActor* Actor, class UClass* Class_0, class USceneComponent* Parent, bool bDeferredFinish);
	static class USceneComponent* AddSceneComponentWithTransform(class AActor* Actor, class UClass* Class_0, class USceneComponent* Parent, bool bDeferredFinish, const struct FTransform& Transform);
	static void DeactivateImmediateNiagaraComponent(class UNiagaraComponent* NiagaraComponent);
	static bool EqualWorld(class UWorld* World, class UWorld* Other);
	static class USceneComponent* GetActorDefaultAttachComponent(class AActor* Actor);
	static float GetNiagaraEffectRegularTypeScalabilitySettingsMaxDistance(EKuroNiagaraEffectRegularType EffectRegularType);
	static EKuroNiagaraEffectRegularType GetNiagaraSystemEffectRegularType(class UNiagaraSystem* NiagaraSystem);
	static float GetNpcDisappearDistance();
	static void InitModelNiagaraSpec(class UNiagaraComponent* NiagaraComponent, bool bUIScene, bool bReceivesDecals, int32 TranslucencySortPriority);
	static bool IsNiagaraComponentHasBound(class UNiagaraComponent* NiagaraComponent, float Threshold);
	static void RegisterOnSystemFinished(class UNiagaraComponent* NiagaraComponent);
	static void RegisterOnSystemPaused(class UNiagaraComponent* NiagaraComponent);
	static void SetEffectActorSpawnInUIScene(class AActor* Actor, bool Value, bool Immediately);
	static bool SetNiagaraFrameDeltaTime(class UNiagaraComponent* NiagaraComponent, float DeltaTime);
	static void SetNiagaraSimulationMinDeltaTime(class UNiagaraComponent* NiagaraComponent, float MinDeltaTime);
	static void SetOnSystemFinishedDelegate(const TDelegate<void(class UNiagaraComponent* NiagaraComponent)>& Delegate);
	static void SetOnSystemPausedDelegate(const TDelegate<void(class UNiagaraComponent* NiagaraComponent, bool IsPaused)>& Delegate);
	static void UpdateEffectModelLightSpec(class UEffectModelLight* EffectModelLight, class UPointLightComponent* LightComponent, bool bForceUpdate, float Time, float DefaultMaxLightRadius);
	static void UpdateEffectModelNiagaraSpec(class UEffectModelNiagara* EffectModelNiagara, class UNiagaraComponent* NiagaraComponent, bool bForceUpdate, float Time, int32 ExtraState);
	static void UpdateEffectModelPostProcessMaterial(class UEffectModelPostProcess* EffectModelPostProcess, class UMaterialInstanceDynamic* DynMaterial, bool bForceUpdate, float Time);
	static struct FVector2D UpdateEffectModelPostProcessSpec(class UEffectModelPostProcess* EffectModelPostProcess, class UKuroPostProcessComponent* PostProcessComponent, bool bForceUpdate, float Time, class APlayerController* Controller, class ACharacter* Character, class AActor* EffectActor, const struct FVector2D& LastScreenUV);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroEffectLibrary">();
	}
	static class UKuroEffectLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroEffectLibrary>();
	}
};
static_assert(alignof(UKuroEffectLibrary) == 0x000008, "Wrong alignment on UKuroEffectLibrary");
static_assert(sizeof(UKuroEffectLibrary) == 0x000030, "Wrong size on UKuroEffectLibrary");

// Class KuroGameplay.KuroInputEvent
// 0x0028 (0x0058 - 0x0030)
class UKuroInputEvent final : public UObject
{
public:
	uint8                                         Pad_30[0x28];                                      // 0x0030(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DoActionCallback(const struct FKey& Key);
	void DoAxisCallback(float Value);
	void DoKeyCallback(const struct FKey& Key);
	void DoTouchCallback(const ETouchIndex TouchIndex, const struct FVector& Position);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroInputEvent">();
	}
	static class UKuroInputEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroInputEvent>();
	}
};
static_assert(alignof(UKuroInputEvent) == 0x000008, "Wrong alignment on UKuroInputEvent");
static_assert(sizeof(UKuroInputEvent) == 0x000058, "Wrong size on UKuroInputEvent");

// Class KuroGameplay.KuroInputManager
// 0x0060 (0x0090 - 0x0030)
class UKuroInputManager final : public UObject
{
public:
	uint8                                         Pad_30[0x50];                                      // 0x0030(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UKuroInputEvent*>                HoldEvents;                                        // 0x0080(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	void OnActorDestroy(class AActor* Actor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroInputManager">();
	}
	static class UKuroInputManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroInputManager>();
	}
};
static_assert(alignof(UKuroInputManager) == 0x000008, "Wrong alignment on UKuroInputManager");
static_assert(sizeof(UKuroInputManager) == 0x000090, "Wrong size on UKuroInputManager");
static_assert(offsetof(UKuroInputManager, HoldEvents) == 0x000080, "Member 'UKuroInputManager::HoldEvents' has a wrong offset!");

// Class KuroGameplay.KuroLevelPlayLibrary
// 0x0000 (0x0030 - 0x0030)
class UKuroLevelPlayLibrary final : public UBlueprintFunctionLibrary
{
public:
	static struct FBox GetActorComponentsBoundingBox(class AActor* Actor, bool bNonColliding, bool bIncludeFromChildActors);
	static bool GetActorScreenBoundingBox(class APlayerController* PlayerController, class AActor* Actor, struct FVector2D* ScreenMin, struct FVector2D* ScreenMax);
	static class FString GetCurrentLevelRefPath(const class UObject* WorldContextObject);
	static int32 GetEntityIdByBaseItem(class AActor* Actor);
	static void RegisterBaseItemInfo(class UClass* BaseItemClass, const class FString& EntityIdName);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroLevelPlayLibrary">();
	}
	static class UKuroLevelPlayLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroLevelPlayLibrary>();
	}
};
static_assert(alignof(UKuroLevelPlayLibrary) == 0x000008, "Wrong alignment on UKuroLevelPlayLibrary");
static_assert(sizeof(UKuroLevelPlayLibrary) == 0x000030, "Wrong size on UKuroLevelPlayLibrary");

// Class KuroGameplay.KuroMultilBgProgressBar
// 0x0320 (0x0490 - 0x0170)
class UKuroMultilBgProgressBar final : public UWidget
{
public:
	struct FProgressBarStyle                      WidgetStyle;                                       // 0x0170(0x0248)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class USlateWidgetStyleAsset*                 Style;                                             // 0x03B8(0x0008)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USlateBrushAsset*                       BackgroundImage;                                   // 0x03C0(0x0008)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USlateBrushAsset*                       FillImageMiddle;                                   // 0x03C8(0x0008)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USlateBrushAsset*                       FillImage;                                         // 0x03D0(0x0008)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USlateBrushAsset*                       MarqueeImage;                                      // 0x03D8(0x0008)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MiddlePercent;                                     // 0x03E0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Percent;                                           // 0x03E4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EProgressBarFillType                          BarFillType;                                       // 0x03E8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsMarquee;                                        // 0x03E9(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3EA[0x2];                                      // 0x03EA(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              BorderPadding;                                     // 0x03EC(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3F4[0x4];                                      // 0x03F4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TDelegate<void()>                             PercentDelegate;                                   // 0x03F8(0x0028)(ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
	TDelegate<void()>                             MiddlePercentDelegate;                             // 0x0420(0x0028)(ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
	struct FLinearColor                           FillColorAndOpacity;                               // 0x0448(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TDelegate<void()>                             FillColorAndOpacityDelegate;                       // 0x0458(0x0028)(ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
	uint8                                         Pad_480[0x10];                                     // 0x0480(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetFillColorAndOpacity(const struct FLinearColor& InColor);
	void SetIsMarquee(bool InbIsMarquee);
	void SetMiddlePercent(float InPercent);
	void SetPercent(float InPercent);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroMultilBgProgressBar">();
	}
	static class UKuroMultilBgProgressBar* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroMultilBgProgressBar>();
	}
};
static_assert(alignof(UKuroMultilBgProgressBar) == 0x000008, "Wrong alignment on UKuroMultilBgProgressBar");
static_assert(sizeof(UKuroMultilBgProgressBar) == 0x000490, "Wrong size on UKuroMultilBgProgressBar");
static_assert(offsetof(UKuroMultilBgProgressBar, WidgetStyle) == 0x000170, "Member 'UKuroMultilBgProgressBar::WidgetStyle' has a wrong offset!");
static_assert(offsetof(UKuroMultilBgProgressBar, Style) == 0x0003B8, "Member 'UKuroMultilBgProgressBar::Style' has a wrong offset!");
static_assert(offsetof(UKuroMultilBgProgressBar, BackgroundImage) == 0x0003C0, "Member 'UKuroMultilBgProgressBar::BackgroundImage' has a wrong offset!");
static_assert(offsetof(UKuroMultilBgProgressBar, FillImageMiddle) == 0x0003C8, "Member 'UKuroMultilBgProgressBar::FillImageMiddle' has a wrong offset!");
static_assert(offsetof(UKuroMultilBgProgressBar, FillImage) == 0x0003D0, "Member 'UKuroMultilBgProgressBar::FillImage' has a wrong offset!");
static_assert(offsetof(UKuroMultilBgProgressBar, MarqueeImage) == 0x0003D8, "Member 'UKuroMultilBgProgressBar::MarqueeImage' has a wrong offset!");
static_assert(offsetof(UKuroMultilBgProgressBar, MiddlePercent) == 0x0003E0, "Member 'UKuroMultilBgProgressBar::MiddlePercent' has a wrong offset!");
static_assert(offsetof(UKuroMultilBgProgressBar, Percent) == 0x0003E4, "Member 'UKuroMultilBgProgressBar::Percent' has a wrong offset!");
static_assert(offsetof(UKuroMultilBgProgressBar, BarFillType) == 0x0003E8, "Member 'UKuroMultilBgProgressBar::BarFillType' has a wrong offset!");
static_assert(offsetof(UKuroMultilBgProgressBar, bIsMarquee) == 0x0003E9, "Member 'UKuroMultilBgProgressBar::bIsMarquee' has a wrong offset!");
static_assert(offsetof(UKuroMultilBgProgressBar, BorderPadding) == 0x0003EC, "Member 'UKuroMultilBgProgressBar::BorderPadding' has a wrong offset!");
static_assert(offsetof(UKuroMultilBgProgressBar, PercentDelegate) == 0x0003F8, "Member 'UKuroMultilBgProgressBar::PercentDelegate' has a wrong offset!");
static_assert(offsetof(UKuroMultilBgProgressBar, MiddlePercentDelegate) == 0x000420, "Member 'UKuroMultilBgProgressBar::MiddlePercentDelegate' has a wrong offset!");
static_assert(offsetof(UKuroMultilBgProgressBar, FillColorAndOpacity) == 0x000448, "Member 'UKuroMultilBgProgressBar::FillColorAndOpacity' has a wrong offset!");
static_assert(offsetof(UKuroMultilBgProgressBar, FillColorAndOpacityDelegate) == 0x000458, "Member 'UKuroMultilBgProgressBar::FillColorAndOpacityDelegate' has a wrong offset!");

// Class KuroGameplay.KuroResourceManager
// 0x0160 (0x0190 - 0x0030)
class UKuroResourceManager final : public UObject
{
public:
	TDelegate<void(int32 HandleId)>               LoadResourceDelegate;                              // 0x0030(0x0028)(ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
	uint8                                         Pad_58[0x138];                                     // 0x0058(0x0138)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class UObject* GetAsset(const int32 HandleId);
	int32 LoadAsyncWithId(const class FString& Path, const int32 HandleId, const int32 Priority);
	int32 LoadWithId(const class FString& Path, const int32 HandleId);
	void Release(const int32 HandleId);
	bool WaitComplete(const int32 HandleId, const float Timeout);

	void DebugDumpLoadingAssets() const;
	class UObject* GetLoadedAsset(const class FString& Path) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroResourceManager">();
	}
	static class UKuroResourceManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroResourceManager>();
	}
};
static_assert(alignof(UKuroResourceManager) == 0x000008, "Wrong alignment on UKuroResourceManager");
static_assert(sizeof(UKuroResourceManager) == 0x000190, "Wrong size on UKuroResourceManager");
static_assert(offsetof(UKuroResourceManager, LoadResourceDelegate) == 0x000030, "Member 'UKuroResourceManager::LoadResourceDelegate' has a wrong offset!");

// Class KuroGameplay.KuroSequenceRuntimeFunctionLibrary
// 0x0000 (0x0030 - 0x0030)
class UKuroSequenceRuntimeFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static struct FSequencerBindingRuntimeProxy FindBindingById(class UMovieSceneSequence* Sequence, const struct FGuid& BindingId);
	static TArray<class UMovieSceneTrack*> FindMasterTracksByType(class UMovieSceneSequence* Sequence, TSubclassOf<class UMovieSceneTrack> TrackType);
	static TArray<class UMovieSceneTrack*> FindTracksByType(const struct FSequencerBindingRuntimeProxy& InBinding, TSubclassOf<class UMovieSceneTrack> TrackType);
	static int32 GetEndFrame(class UMovieSceneSection* Section);
	static float GetFadeAmountAt(class UMovieSceneFadeSection* Section, const struct FFrameTime& Frame);
	static struct FTransform GetFrameTransform(class UMovieSceneTrack* Track, const struct FFrameTime& Frame);
	static bool GetFrameTransformByTag(class UMovieSceneSequence* Sequence, class FName Tag, int32 OutsideFrame, struct FTransform* OutTransfom);
	static TArray<class UMovieSceneTrack*> GetMasterTracks(class UMovieSceneSequence* Sequence);
	static class UObject* GetObjectTemplate(const struct FSequencerBindingRuntimeProxy& InBinding);
	static int32 GetPlaybackEnd(class UMovieSceneSequence* Sequence);
	static int32 GetPlaybackStart(class UMovieSceneSequence* Sequence);
	static TArray<class UMovieSceneSection*> GetSections(class UMovieSceneTrack* Track);
	static TArray<struct FSequencerBindingRuntimeProxy> GetSpawnables(class UMovieSceneSequence* Sequence);
	static int32 GetStartFrame(class UMovieSceneSection* Section);
	static TArray<class UMovieSceneTrack*> GetTracks(const struct FSequencerBindingRuntimeProxy& InBinding);
	static bool HandleSeqTexStreaming(const class ULevelSequence* LevelSequences, const bool bStartForceStreamIn);
	static void MuteTrackByTag(class UMovieSceneSequence* Sequence, class FName Tag, bool bIsMuted);
	static void ResetMovieSceneCompiledData(class UMovieSceneSequence* Sequence);
	static bool SectionContains(class UMovieSceneSection* Section, const struct FFrameTime& Frame);
	static bool SetSequenceInUiScene(class UMovieSceneSequence* Sequence, bool IsEnable);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroSequenceRuntimeFunctionLibrary">();
	}
	static class UKuroSequenceRuntimeFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroSequenceRuntimeFunctionLibrary>();
	}
};
static_assert(alignof(UKuroSequenceRuntimeFunctionLibrary) == 0x000008, "Wrong alignment on UKuroSequenceRuntimeFunctionLibrary");
static_assert(sizeof(UKuroSequenceRuntimeFunctionLibrary) == 0x000030, "Wrong size on UKuroSequenceRuntimeFunctionLibrary");

// Class KuroGameplay.KuroStaticMeshLibrary
// 0x0000 (0x0030 - 0x0030)
class UKuroStaticMeshLibrary final : public UBlueprintFunctionLibrary
{
public:
	static void MergeSimpleCollisions(class UStaticMeshComponent* TemplateComponent, const TArray<struct FTransform>& LocalTransforms);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroStaticMeshLibrary">();
	}
	static class UKuroStaticMeshLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroStaticMeshLibrary>();
	}
};
static_assert(alignof(UKuroStaticMeshLibrary) == 0x000008, "Wrong alignment on UKuroStaticMeshLibrary");
static_assert(sizeof(UKuroStaticMeshLibrary) == 0x000030, "Wrong size on UKuroStaticMeshLibrary");

// Class KuroGameplay.PerformanceStatisticsLibrary
// 0x0000 (0x0030 - 0x0030)
class UPerformanceStatisticsLibrary final : public UBlueprintFunctionLibrary
{
public:
	static void AddStatistics(class FName SectionName, int32 FrameCount, const class FString& Tag, int32 MeasureMode, float Time, const class FString& UserDefineMessage);
	static void Clear();
	static void Export();
	static void ReadAllSectionsFromDirectory();
	static void ReadSectionFromFile(class FString* FilePath);
	static void StatisticsFromRawDataFiles();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PerformanceStatisticsLibrary">();
	}
	static class UPerformanceStatisticsLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPerformanceStatisticsLibrary>();
	}
};
static_assert(alignof(UPerformanceStatisticsLibrary) == 0x000008, "Wrong alignment on UPerformanceStatisticsLibrary");
static_assert(sizeof(UPerformanceStatisticsLibrary) == 0x000030, "Wrong size on UPerformanceStatisticsLibrary");

}

