#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: HoudiniEngineRuntime

#include "Basic.hpp"

#include "CoreUObject_structs.hpp"
#include "Engine_structs.hpp"
#include "PhysicsCore_structs.hpp"


namespace SDK
{

// Enum HoudiniEngineRuntime.EHoudiniStaticMeshMethod
// NumValues: 0x0004
enum class EHoudiniStaticMeshMethod : uint8
{
	RawMesh                                  = 0,
	FMeshDescription                         = 1,
	UHoudiniStaticMesh                       = 2,
	EHoudiniStaticMeshMethod_MAX             = 3,
};

// Enum HoudiniEngineRuntime.EHoudiniAssetStateResult
// NumValues: 0x0007
enum class EHoudiniAssetStateResult : uint8
{
	None                                     = 0,
	Working                                  = 1,
	Success                                  = 2,
	FinishedWithError                        = 3,
	FinishedWithFatalError                   = 4,
	Aborted                                  = 5,
	EHoudiniAssetStateResult_MAX             = 6,
};

// Enum HoudiniEngineRuntime.EHoudiniAssetState
// NumValues: 0x000F
enum class EHoudiniAssetState : uint8
{
	NeedInstantiation                        = 0,
	NewHDA                                   = 1,
	PreInstantiation                         = 2,
	Instantiating                            = 3,
	PreCook                                  = 4,
	Cooking                                  = 5,
	PostCook                                 = 6,
	PreProcess                               = 7,
	Processing                               = 8,
	None                                     = 9,
	NeedRebuild                              = 10,
	NeedDelete                               = 11,
	Deleting                                 = 12,
	ProcessTemplate                          = 13,
	EHoudiniAssetState_MAX                   = 14,
};

// Enum HoudiniEngineRuntime.EHoudiniPCGSplineType
// NumValues: 0x0004
enum class EHoudiniPCGSplineType : uint8
{
	Default                                  = 0,
	Water                                    = 1,
	Foliage                                  = 2,
	EHoudiniPCGSplineType_MAX                = 3,
};

// Enum HoudiniEngineRuntime.EHoudiniPCGToolType
// NumValues: 0x0003
enum class EHoudiniPCGToolType : uint8
{
	Default                                  = 0,
	Customized_BoundSelectorByFolder         = 1,
	EHoudiniPCGToolType_MAX                  = 2,
};

// Enum HoudiniEngineRuntime.EHoudiniProxyRefineRequestResult
// NumValues: 0x0005
enum class EHoudiniProxyRefineRequestResult : uint8
{
	Invalid                                  = 0,
	None                                     = 1,
	PendingCooks                             = 2,
	Refined                                  = 3,
	EHoudiniProxyRefineRequestResult_MAX     = 4,
};

// Enum HoudiniEngineRuntime.EHoudiniProxyRefineResult
// NumValues: 0x0005
enum class EHoudiniProxyRefineResult : uint8
{
	Invalid                                  = 0,
	Failed                                   = 1,
	Success                                  = 2,
	Skipped                                  = 3,
	EHoudiniProxyRefineResult_MAX            = 4,
};

// Enum HoudiniEngineRuntime.EHoudiniLandscapeExportType
// NumValues: 0x0004
enum class EHoudiniLandscapeExportType : uint8
{
	Heightfield                              = 0,
	Mesh                                     = 1,
	Points                                   = 2,
	EHoudiniLandscapeExportType_MAX          = 3,
};

// Enum HoudiniEngineRuntime.EHoudiniCurveBreakpointParameterization
// NumValues: 0x0005
enum class EHoudiniCurveBreakpointParameterization : uint8
{
	Invalid                                  = 18446744073709551615,
	Uniform                                  = 0,
	Chord                                    = 1,
	Centripetal                              = 2,
	EHoudiniCurveBreakpointParameterization_MAX = 3,
};

// Enum HoudiniEngineRuntime.EHoudiniCurveMethod
// NumValues: 0x0005
enum class EHoudiniCurveMethod : uint8
{
	Invalid                                  = 18446744073709551615,
	CVs                                      = 0,
	Breakpoints                              = 1,
	Freehand                                 = 2,
	EHoudiniCurveMethod_MAX                  = 3,
};

// Enum HoudiniEngineRuntime.EHoudiniCurveType
// NumValues: 0x0006
enum class EHoudiniCurveType : uint8
{
	Invalid                                  = 18446744073709551615,
	Polygon                                  = 0,
	Nurbs                                    = 1,
	Bezier                                   = 2,
	Points                                   = 3,
	EHoudiniCurveType_MAX                    = 4,
};

// Enum HoudiniEngineRuntime.EHoudiniOutputType
// NumValues: 0x0008
enum class EHoudiniOutputType : uint8
{
	Invalid                                  = 0,
	Mesh                                     = 1,
	Instancer                                = 2,
	Landscape                                = 3,
	Curve                                    = 4,
	Skeletal                                 = 5,
	GeometryCollection                       = 6,
	EHoudiniOutputType_MAX                   = 7,
};

// Enum HoudiniEngineRuntime.EHoudiniInputType
// NumValues: 0x0009
enum class EHoudiniInputType : uint8
{
	Invalid                                  = 0,
	Geometry                                 = 1,
	Curve                                    = 2,
	Asset                                    = 3,
	Landscape                                = 4,
	World                                    = 5,
	Skeletal                                 = 6,
	GeometryCollection                       = 7,
	EHoudiniInputType_MAX                    = 8,
};

// Enum HoudiniEngineRuntime.EHoudiniLandscapeOutputBakeType
// NumValues: 0x0005
enum class EHoudiniLandscapeOutputBakeType : uint8
{
	Detachment                               = 0,
	BakeToImage                              = 1,
	BakeToWorld                              = 2,
	InValid                                  = 3,
	EHoudiniLandscapeOutputBakeType_MAX      = 4,
};

// Enum HoudiniEngineRuntime.EHoudiniRampInterpolationType
// NumValues: 0x0009
enum class EHoudiniRampInterpolationType : uint8
{
	InValid                                  = 18446744073709551615,
	CONSTANT                                 = 0,
	LINEAR                                   = 1,
	CATMULL_ROM                              = 2,
	MONOTONE_CUBIC                           = 3,
	BEZIER                                   = 4,
	BSPLINE                                  = 5,
	HERMITE                                  = 6,
	EHoudiniRampInterpolationType_MAX        = 7,
};

// Enum HoudiniEngineRuntime.EAttribOwner
// NumValues: 0x0006
enum class EAttribOwner : uint8
{
	Invalid                                  = 18446744073709551615,
	Vertex                                   = 0,
	Point                                    = 1,
	Prim                                     = 2,
	Detail                                   = 3,
	EAttribOwner_MAX                         = 4,
};

// Enum HoudiniEngineRuntime.EAttribStorageType
// NumValues: 0x0007
enum class EAttribStorageType : uint8
{
	Invalid                                  = 18446744073709551615,
	INT                                      = 0,
	INT64                                    = 1,
	FLOAT                                    = 2,
	FLOAT64                                  = 3,
	STRING                                   = 4,
	EAttribStorageType_MAX                   = 5,
};

// Enum HoudiniEngineRuntime.EHoudiniInstancerType
// NumValues: 0x0007
enum class EHoudiniInstancerType : uint8
{
	Invalid                                  = 0,
	ObjectInstancer                          = 1,
	PackedPrimitive                          = 2,
	AttributeInstancer                       = 3,
	OldSchoolAttributeInstancer              = 4,
	GeometryCollection                       = 5,
	EHoudiniInstancerType_MAX                = 6,
};

// Enum HoudiniEngineRuntime.EHoudiniPartType
// NumValues: 0x0006
enum class EHoudiniPartType : uint8
{
	Invalid                                  = 0,
	Mesh                                     = 1,
	Instancer                                = 2,
	Curve                                    = 3,
	Volume                                   = 4,
	EHoudiniPartType_MAX                     = 5,
};

// Enum HoudiniEngineRuntime.EHoudiniGeoType
// NumValues: 0x0006
enum class EHoudiniGeoType : uint8
{
	Invalid                                  = 0,
	Default                                  = 1,
	Intermediate                             = 2,
	Input                                    = 3,
	Curve                                    = 4,
	EHoudiniGeoType_MAX                      = 5,
};

// Enum HoudiniEngineRuntime.EHoudiniHandleType
// NumValues: 0x0004
enum class EHoudiniHandleType : uint8
{
	Xform                                    = 0,
	Bounder                                  = 1,
	Unsupported                              = 2,
	EHoudiniHandleType_MAX                   = 3,
};

// Enum HoudiniEngineRuntime.EXformParameter
// NumValues: 0x000B
enum class EXformParameter : uint8
{
	TX                                       = 0,
	TY                                       = 1,
	TZ                                       = 2,
	RX                                       = 3,
	RY                                       = 4,
	RZ                                       = 5,
	SX                                       = 6,
	SY                                       = 7,
	SZ                                       = 8,
	COUNT                                    = 9,
	EXformParameter_MAX                      = 10,
};

// Enum HoudiniEngineRuntime.EHoudiniInputObjectType
// NumValues: 0x0017
enum class EHoudiniInputObjectType : uint8
{
	Invalid                                  = 0,
	Object                                   = 1,
	StaticMesh                               = 2,
	SkeletalMesh                             = 3,
	SceneComponent                           = 4,
	StaticMeshComponent                      = 5,
	InstancedStaticMeshComponent             = 6,
	SplineComponent                          = 7,
	HoudiniSplineComponent                   = 8,
	HoudiniAssetComponent                    = 9,
	Actor                                    = 10,
	Landscape                                = 11,
	Brush                                    = 12,
	CameraComponent                          = 13,
	DataTable                                = 14,
	HoudiniAssetActor                        = 15,
	FoliageType_InstancedStaticMesh          = 16,
	GeometryCollection                       = 17,
	GeometryCollectionComponent              = 18,
	GeometryCollectionActor_Deprecated       = 19,
	SkeletalMeshComponent                    = 20,
	Blueprint                                = 21,
	EHoudiniInputObjectType_MAX              = 22,
};

// Enum HoudiniEngineRuntime.EHoudiniXformType
// NumValues: 0x0004
enum class EHoudiniXformType : uint8
{
	None                                     = 0,
	IntoThisObject                           = 1,
	Auto                                     = 2,
	EHoudiniXformType_MAX                    = 3,
};

// Enum HoudiniEngineRuntime.EHoudiniCurveOutputType
// NumValues: 0x0003
enum class EHoudiniCurveOutputType : uint8
{
	UnrealSpline                             = 0,
	HoudiniSpline                            = 1,
	EHoudiniCurveOutputType_MAX              = 2,
};

// Enum HoudiniEngineRuntime.EHoudiniParameterType
// NumValues: 0x0018
enum class EHoudiniParameterType : uint8
{
	Invalid                                  = 0,
	Button                                   = 1,
	ButtonStrip                              = 2,
	Color                                    = 3,
	ColorRamp                                = 4,
	File                                     = 5,
	FileDir                                  = 6,
	FileGeo                                  = 7,
	FileImage                                = 8,
	Float                                    = 9,
	FloatRamp                                = 10,
	Folder                                   = 11,
	FolderList                               = 12,
	Input                                    = 13,
	Int                                      = 14,
	IntChoice                                = 15,
	Label                                    = 16,
	MultiParm                                = 17,
	Separator                                = 18,
	String                                   = 19,
	StringChoice                             = 20,
	StringAssetRef                           = 21,
	Toggle                                   = 22,
	EHoudiniParameterType_MAX                = 23,
};

// Enum HoudiniEngineRuntime.EHoudiniFolderParameterType
// NumValues: 0x0007
enum class EHoudiniFolderParameterType : uint8
{
	Invalid                                  = 0,
	Collapsible                              = 1,
	Simple                                   = 2,
	Tabs                                     = 3,
	Radio                                    = 4,
	Other                                    = 5,
	EHoudiniFolderParameterType_MAX          = 6,
};

// Enum HoudiniEngineRuntime.EHoudiniMultiParmModificationType
// NumValues: 0x0005
enum class EHoudiniMultiParmModificationType : uint8
{
	None                                     = 0,
	Inserted                                 = 1,
	Removed                                  = 2,
	Modified                                 = 3,
	EHoudiniMultiParmModificationType_MAX    = 4,
};

// Enum HoudiniEngineRuntime.EHoudiniRampPointConstructStatus
// NumValues: 0x0006
enum class EHoudiniRampPointConstructStatus : uint8
{
	None                                     = 0,
	INITIALIZED                              = 1,
	POSITION_INSERTED                        = 2,
	VALUE_INSERTED                           = 3,
	INTERPTYPE_INSERTED                      = 4,
	EHoudiniRampPointConstructStatus_MAX     = 5,
};

// Enum HoudiniEngineRuntime.EPDGWorkResultState
// NumValues: 0x0009
enum class EPDGWorkResultState : uint8
{
	None                                     = 0,
	ToLoad                                   = 1,
	Loading                                  = 2,
	Loaded                                   = 3,
	ToDelete                                 = 4,
	Deleting                                 = 5,
	Deleted                                  = 6,
	NotLoaded                                = 7,
	EPDGWorkResultState_MAX                  = 8,
};

// Enum HoudiniEngineRuntime.EPDGNodeState
// NumValues: 0x0007
enum class EPDGNodeState : uint8
{
	None                                     = 0,
	Dirtied                                  = 1,
	Dirtying                                 = 2,
	Cooking                                  = 3,
	Cook_Complete                            = 4,
	Cook_Failed                              = 5,
	EPDGNodeState_MAX                        = 6,
};

// Enum HoudiniEngineRuntime.EPDGLinkState
// NumValues: 0x0005
enum class EPDGLinkState : uint8
{
	Inactive                                 = 0,
	Linking                                  = 1,
	Linked                                   = 2,
	Error_Not_Linked                         = 3,
	EPDGLinkState_MAX                        = 4,
};

// Enum HoudiniEngineRuntime.EHoudiniExecutableType
// NumValues: 0x0005
enum class EHoudiniExecutableType : uint8
{
	HRSHE_Houdini                            = 0,
	HRSHE_HoudiniFX                          = 1,
	HRSHE_HoudiniCore                        = 2,
	HRSHE_HoudiniIndie                       = 3,
	HRSHE_MAX                                = 4,
};

// Enum HoudiniEngineRuntime.EHoudiniRuntimeSettingsRecomputeFlag
// NumValues: 0x0004
enum class EHoudiniRuntimeSettingsRecomputeFlag : uint8
{
	HRSRF_Always                             = 0,
	HRSRF_OnlyIfMissing                      = 1,
	HRSRF_Never                              = 2,
	HRSRF_MAX                                = 3,
};

// Enum HoudiniEngineRuntime.EHoudiniRuntimeSettingsSessionType
// NumValues: 0x0005
enum class EHoudiniRuntimeSettingsSessionType : uint8
{
	HRSST_InProcess                          = 0,
	HRSST_Socket                             = 1,
	HRSST_NamedPipe                          = 2,
	HRSST_None                               = 3,
	HRSST_MAX                                = 4,
};

// ScriptStruct HoudiniEngineRuntime.HoudiniOutputObjectIdentifier
// 0x0040 (0x0040 - 0x0000)
struct FHoudiniOutputObjectIdentifier final
{
public:
	int32                                         ObjectId;                                          // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         GeoId;                                             // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PartId;                                            // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 SplitIdentifier;                                   // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 PartName;                                          // 0x0020(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PrimitiveIndex;                                    // 0x0030(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PointIndex;                                        // 0x0034(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_38[0x8];                                       // 0x0038(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FHoudiniOutputObjectIdentifier) == 0x000008, "Wrong alignment on FHoudiniOutputObjectIdentifier");
static_assert(sizeof(FHoudiniOutputObjectIdentifier) == 0x000040, "Wrong size on FHoudiniOutputObjectIdentifier");
static_assert(offsetof(FHoudiniOutputObjectIdentifier, ObjectId) == 0x000000, "Member 'FHoudiniOutputObjectIdentifier::ObjectId' has a wrong offset!");
static_assert(offsetof(FHoudiniOutputObjectIdentifier, GeoId) == 0x000004, "Member 'FHoudiniOutputObjectIdentifier::GeoId' has a wrong offset!");
static_assert(offsetof(FHoudiniOutputObjectIdentifier, PartId) == 0x000008, "Member 'FHoudiniOutputObjectIdentifier::PartId' has a wrong offset!");
static_assert(offsetof(FHoudiniOutputObjectIdentifier, SplitIdentifier) == 0x000010, "Member 'FHoudiniOutputObjectIdentifier::SplitIdentifier' has a wrong offset!");
static_assert(offsetof(FHoudiniOutputObjectIdentifier, PartName) == 0x000020, "Member 'FHoudiniOutputObjectIdentifier::PartName' has a wrong offset!");
static_assert(offsetof(FHoudiniOutputObjectIdentifier, PrimitiveIndex) == 0x000030, "Member 'FHoudiniOutputObjectIdentifier::PrimitiveIndex' has a wrong offset!");
static_assert(offsetof(FHoudiniOutputObjectIdentifier, PointIndex) == 0x000034, "Member 'FHoudiniOutputObjectIdentifier::PointIndex' has a wrong offset!");

// ScriptStruct HoudiniEngineRuntime.HoudiniCurveOutputProperties
// 0x000C (0x000C - 0x0000)
struct FHoudiniCurveOutputProperties final
{
public:
	EHoudiniCurveOutputType                       CurveOutputType;                                   // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         NumPoints;                                         // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bClosed;                                           // 0x0008(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EHoudiniCurveType                             CurveType;                                         // 0x0009(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EHoudiniCurveMethod                           CurveMethod;                                       // 0x000A(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B[0x1];                                        // 0x000B(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FHoudiniCurveOutputProperties) == 0x000004, "Wrong alignment on FHoudiniCurveOutputProperties");
static_assert(sizeof(FHoudiniCurveOutputProperties) == 0x00000C, "Wrong size on FHoudiniCurveOutputProperties");
static_assert(offsetof(FHoudiniCurveOutputProperties, CurveOutputType) == 0x000000, "Member 'FHoudiniCurveOutputProperties::CurveOutputType' has a wrong offset!");
static_assert(offsetof(FHoudiniCurveOutputProperties, NumPoints) == 0x000004, "Member 'FHoudiniCurveOutputProperties::NumPoints' has a wrong offset!");
static_assert(offsetof(FHoudiniCurveOutputProperties, bClosed) == 0x000008, "Member 'FHoudiniCurveOutputProperties::bClosed' has a wrong offset!");
static_assert(offsetof(FHoudiniCurveOutputProperties, CurveType) == 0x000009, "Member 'FHoudiniCurveOutputProperties::CurveType' has a wrong offset!");
static_assert(offsetof(FHoudiniCurveOutputProperties, CurveMethod) == 0x00000A, "Member 'FHoudiniCurveOutputProperties::CurveMethod' has a wrong offset!");

// ScriptStruct HoudiniEngineRuntime.HoudiniOutputObject
// 0x00F8 (0x00F8 - 0x0000)
struct FHoudiniOutputObject final
{
public:
	class UObject*                                OutputObject;                                      // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                OutputComponent;                                   // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                ProxyObject;                                       // 0x0010(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                ProxyComponent;                                    // 0x0018(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bProxyIsCurrent;                                   // 0x0020(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsImplicit;                                       // 0x0021(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsGeometryCollectionPiece;                        // 0x0022(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_23[0x5];                                       // 0x0023(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 GeometryCollectionPieceName;                       // 0x0028(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 BakeName;                                          // 0x0038(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FHoudiniCurveOutputProperties          CurveOutputProperty;                               // 0x0048(0x000C)(NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_54[0x4];                                       // 0x0054(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FString, class FString>            CachedAttributes;                                  // 0x0058(0x0050)(NativeAccessSpecifierPublic)
	TMap<class FString, class FString>            CachedTokens;                                      // 0x00A8(0x0050)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FHoudiniOutputObject) == 0x000008, "Wrong alignment on FHoudiniOutputObject");
static_assert(sizeof(FHoudiniOutputObject) == 0x0000F8, "Wrong size on FHoudiniOutputObject");
static_assert(offsetof(FHoudiniOutputObject, OutputObject) == 0x000000, "Member 'FHoudiniOutputObject::OutputObject' has a wrong offset!");
static_assert(offsetof(FHoudiniOutputObject, OutputComponent) == 0x000008, "Member 'FHoudiniOutputObject::OutputComponent' has a wrong offset!");
static_assert(offsetof(FHoudiniOutputObject, ProxyObject) == 0x000010, "Member 'FHoudiniOutputObject::ProxyObject' has a wrong offset!");
static_assert(offsetof(FHoudiniOutputObject, ProxyComponent) == 0x000018, "Member 'FHoudiniOutputObject::ProxyComponent' has a wrong offset!");
static_assert(offsetof(FHoudiniOutputObject, bProxyIsCurrent) == 0x000020, "Member 'FHoudiniOutputObject::bProxyIsCurrent' has a wrong offset!");
static_assert(offsetof(FHoudiniOutputObject, bIsImplicit) == 0x000021, "Member 'FHoudiniOutputObject::bIsImplicit' has a wrong offset!");
static_assert(offsetof(FHoudiniOutputObject, bIsGeometryCollectionPiece) == 0x000022, "Member 'FHoudiniOutputObject::bIsGeometryCollectionPiece' has a wrong offset!");
static_assert(offsetof(FHoudiniOutputObject, GeometryCollectionPieceName) == 0x000028, "Member 'FHoudiniOutputObject::GeometryCollectionPieceName' has a wrong offset!");
static_assert(offsetof(FHoudiniOutputObject, BakeName) == 0x000038, "Member 'FHoudiniOutputObject::BakeName' has a wrong offset!");
static_assert(offsetof(FHoudiniOutputObject, CurveOutputProperty) == 0x000048, "Member 'FHoudiniOutputObject::CurveOutputProperty' has a wrong offset!");
static_assert(offsetof(FHoudiniOutputObject, CachedAttributes) == 0x000058, "Member 'FHoudiniOutputObject::CachedAttributes' has a wrong offset!");
static_assert(offsetof(FHoudiniOutputObject, CachedTokens) == 0x0000A8, "Member 'FHoudiniOutputObject::CachedTokens' has a wrong offset!");

// ScriptStruct HoudiniEngineRuntime.HoudiniAssetBlueprintOutput
// 0x0100 (0x0100 - 0x0000)
struct FHoudiniAssetBlueprintOutput final
{
public:
	int32                                         OutputIndex;                                       // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHoudiniOutputObject                   OutputObject;                                      // 0x0008(0x00F8)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FHoudiniAssetBlueprintOutput) == 0x000008, "Wrong alignment on FHoudiniAssetBlueprintOutput");
static_assert(sizeof(FHoudiniAssetBlueprintOutput) == 0x000100, "Wrong size on FHoudiniAssetBlueprintOutput");
static_assert(offsetof(FHoudiniAssetBlueprintOutput, OutputIndex) == 0x000000, "Member 'FHoudiniAssetBlueprintOutput::OutputIndex' has a wrong offset!");
static_assert(offsetof(FHoudiniAssetBlueprintOutput, OutputObject) == 0x000008, "Member 'FHoudiniAssetBlueprintOutput::OutputObject' has a wrong offset!");

// ScriptStruct HoudiniEngineRuntime.HoudiniAssetBlueprintInstanceData
// 0x00B8 (0x0120 - 0x0068)
struct FHoudiniAssetBlueprintInstanceData final : public FActorComponentInstanceData
{
public:
	class UHoudiniAsset*                          HoudiniAsset;                                      // 0x0068(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AssetId;                                           // 0x0070(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EHoudiniAssetState                            AssetState;                                        // 0x0074(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_75[0x3];                                       // 0x0075(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	uint32                                        SubAssetIndex;                                     // 0x0078(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        AssetCookCount;                                    // 0x007C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasBeenLoaded;                                    // 0x0080(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasBeenDuplicated;                                // 0x0081(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPendingDelete;                                    // 0x0082(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRecookRequested;                                  // 0x0083(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRebuildRequested;                                 // 0x0084(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableCooking;                                    // 0x0085(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bForceNeedUpdate;                                  // 0x0086(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLastCookSuccess;                                  // 0x0087(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGuid                                  ComponentGUID;                                     // 0x0088(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGuid                                  HapiGUID;                                          // 0x0098(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRegisteredComponentTemplate;                      // 0x00A8(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A9[0x7];                                       // 0x00A9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 SourceName;                                        // 0x00B0(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<struct FHoudiniOutputObjectIdentifier, struct FHoudiniAssetBlueprintOutput> Outputs;        // 0x00C0(0x0050)(NativeAccessSpecifierPublic)
	TArray<class UHoudiniInput*>                  Inputs;                                            // 0x0110(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHoudiniAssetBlueprintInstanceData) == 0x000008, "Wrong alignment on FHoudiniAssetBlueprintInstanceData");
static_assert(sizeof(FHoudiniAssetBlueprintInstanceData) == 0x000120, "Wrong size on FHoudiniAssetBlueprintInstanceData");
static_assert(offsetof(FHoudiniAssetBlueprintInstanceData, HoudiniAsset) == 0x000068, "Member 'FHoudiniAssetBlueprintInstanceData::HoudiniAsset' has a wrong offset!");
static_assert(offsetof(FHoudiniAssetBlueprintInstanceData, AssetId) == 0x000070, "Member 'FHoudiniAssetBlueprintInstanceData::AssetId' has a wrong offset!");
static_assert(offsetof(FHoudiniAssetBlueprintInstanceData, AssetState) == 0x000074, "Member 'FHoudiniAssetBlueprintInstanceData::AssetState' has a wrong offset!");
static_assert(offsetof(FHoudiniAssetBlueprintInstanceData, SubAssetIndex) == 0x000078, "Member 'FHoudiniAssetBlueprintInstanceData::SubAssetIndex' has a wrong offset!");
static_assert(offsetof(FHoudiniAssetBlueprintInstanceData, AssetCookCount) == 0x00007C, "Member 'FHoudiniAssetBlueprintInstanceData::AssetCookCount' has a wrong offset!");
static_assert(offsetof(FHoudiniAssetBlueprintInstanceData, bHasBeenLoaded) == 0x000080, "Member 'FHoudiniAssetBlueprintInstanceData::bHasBeenLoaded' has a wrong offset!");
static_assert(offsetof(FHoudiniAssetBlueprintInstanceData, bHasBeenDuplicated) == 0x000081, "Member 'FHoudiniAssetBlueprintInstanceData::bHasBeenDuplicated' has a wrong offset!");
static_assert(offsetof(FHoudiniAssetBlueprintInstanceData, bPendingDelete) == 0x000082, "Member 'FHoudiniAssetBlueprintInstanceData::bPendingDelete' has a wrong offset!");
static_assert(offsetof(FHoudiniAssetBlueprintInstanceData, bRecookRequested) == 0x000083, "Member 'FHoudiniAssetBlueprintInstanceData::bRecookRequested' has a wrong offset!");
static_assert(offsetof(FHoudiniAssetBlueprintInstanceData, bRebuildRequested) == 0x000084, "Member 'FHoudiniAssetBlueprintInstanceData::bRebuildRequested' has a wrong offset!");
static_assert(offsetof(FHoudiniAssetBlueprintInstanceData, bEnableCooking) == 0x000085, "Member 'FHoudiniAssetBlueprintInstanceData::bEnableCooking' has a wrong offset!");
static_assert(offsetof(FHoudiniAssetBlueprintInstanceData, bForceNeedUpdate) == 0x000086, "Member 'FHoudiniAssetBlueprintInstanceData::bForceNeedUpdate' has a wrong offset!");
static_assert(offsetof(FHoudiniAssetBlueprintInstanceData, bLastCookSuccess) == 0x000087, "Member 'FHoudiniAssetBlueprintInstanceData::bLastCookSuccess' has a wrong offset!");
static_assert(offsetof(FHoudiniAssetBlueprintInstanceData, ComponentGUID) == 0x000088, "Member 'FHoudiniAssetBlueprintInstanceData::ComponentGUID' has a wrong offset!");
static_assert(offsetof(FHoudiniAssetBlueprintInstanceData, HapiGUID) == 0x000098, "Member 'FHoudiniAssetBlueprintInstanceData::HapiGUID' has a wrong offset!");
static_assert(offsetof(FHoudiniAssetBlueprintInstanceData, bRegisteredComponentTemplate) == 0x0000A8, "Member 'FHoudiniAssetBlueprintInstanceData::bRegisteredComponentTemplate' has a wrong offset!");
static_assert(offsetof(FHoudiniAssetBlueprintInstanceData, SourceName) == 0x0000B0, "Member 'FHoudiniAssetBlueprintInstanceData::SourceName' has a wrong offset!");
static_assert(offsetof(FHoudiniAssetBlueprintInstanceData, Outputs) == 0x0000C0, "Member 'FHoudiniAssetBlueprintInstanceData::Outputs' has a wrong offset!");
static_assert(offsetof(FHoudiniAssetBlueprintInstanceData, Inputs) == 0x000110, "Member 'FHoudiniAssetBlueprintInstanceData::Inputs' has a wrong offset!");

// ScriptStruct HoudiniEngineRuntime.HoudiniGenericAttribute
// 0x0050 (0x0050 - 0x0000)
struct FHoudiniGenericAttribute final
{
public:
	class FString                                 AttributeName;                                     // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAttribStorageType                            AttributeType;                                     // 0x0010(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAttribOwner                                  AttributeOwner;                                    // 0x0011(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12[0x2];                                       // 0x0012(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         AttributeCount;                                    // 0x0014(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AttributeTupleSize;                                // 0x0018(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<double>                                DoubleValues;                                      // 0x0020(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<int64>                                 IntValues;                                         // 0x0030(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FString>                         StringValues;                                      // 0x0040(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHoudiniGenericAttribute) == 0x000008, "Wrong alignment on FHoudiniGenericAttribute");
static_assert(sizeof(FHoudiniGenericAttribute) == 0x000050, "Wrong size on FHoudiniGenericAttribute");
static_assert(offsetof(FHoudiniGenericAttribute, AttributeName) == 0x000000, "Member 'FHoudiniGenericAttribute::AttributeName' has a wrong offset!");
static_assert(offsetof(FHoudiniGenericAttribute, AttributeType) == 0x000010, "Member 'FHoudiniGenericAttribute::AttributeType' has a wrong offset!");
static_assert(offsetof(FHoudiniGenericAttribute, AttributeOwner) == 0x000011, "Member 'FHoudiniGenericAttribute::AttributeOwner' has a wrong offset!");
static_assert(offsetof(FHoudiniGenericAttribute, AttributeCount) == 0x000014, "Member 'FHoudiniGenericAttribute::AttributeCount' has a wrong offset!");
static_assert(offsetof(FHoudiniGenericAttribute, AttributeTupleSize) == 0x000018, "Member 'FHoudiniGenericAttribute::AttributeTupleSize' has a wrong offset!");
static_assert(offsetof(FHoudiniGenericAttribute, DoubleValues) == 0x000020, "Member 'FHoudiniGenericAttribute::DoubleValues' has a wrong offset!");
static_assert(offsetof(FHoudiniGenericAttribute, IntValues) == 0x000030, "Member 'FHoudiniGenericAttribute::IntValues' has a wrong offset!");
static_assert(offsetof(FHoudiniGenericAttribute, StringValues) == 0x000040, "Member 'FHoudiniGenericAttribute::StringValues' has a wrong offset!");

// ScriptStruct HoudiniEngineRuntime.HoudiniGenericAttributeChangedProperty
// 0x0098 (0x0098 - 0x0000)
struct FHoudiniGenericAttributeChangedProperty final
{
public:
	class UObject*                                Object;                                            // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x90];                                       // 0x0008(0x0090)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FHoudiniGenericAttributeChangedProperty) == 0x000008, "Wrong alignment on FHoudiniGenericAttributeChangedProperty");
static_assert(sizeof(FHoudiniGenericAttributeChangedProperty) == 0x000098, "Wrong size on FHoudiniGenericAttributeChangedProperty");
static_assert(offsetof(FHoudiniGenericAttributeChangedProperty, Object) == 0x000000, "Member 'FHoudiniGenericAttributeChangedProperty::Object' has a wrong offset!");

// ScriptStruct HoudiniEngineRuntime.HoudiniMeshSocket
// 0x0060 (0x0060 - 0x0000)
struct alignas(0x10) FHoudiniMeshSocket final
{
public:
	uint8                                         Pad_0[0x60];                                       // 0x0000(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FHoudiniMeshSocket) == 0x000010, "Wrong alignment on FHoudiniMeshSocket");
static_assert(sizeof(FHoudiniMeshSocket) == 0x000060, "Wrong size on FHoudiniMeshSocket");

// ScriptStruct HoudiniEngineRuntime.HoudiniGeoPartObject
// 0x0230 (0x0230 - 0x0000)
struct FHoudiniGeoPartObject final
{
public:
	int32                                         AssetId;                                           // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 AssetName;                                         // 0x0008(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ObjectId;                                          // 0x0018(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 ObjectName;                                        // 0x0020(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         GeoId;                                             // 0x0030(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PartId;                                            // 0x0034(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 PartName;                                          // 0x0038(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasCustomPartName;                                // 0x0048(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49[0x7];                                       // 0x0049(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FString>                         SplitGroups;                                       // 0x0050(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	struct FTransform                             TransformMatrix;                                   // 0x0060(0x0030)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	class FString                                 NodePath;                                          // 0x0090(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EHoudiniPartType                              Type;                                              // 0x00A0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EHoudiniInstancerType                         InstancerType;                                     // 0x00A1(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A2[0x6];                                       // 0x00A2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 VolumeName;                                        // 0x00A8(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasEditLayers;                                    // 0x00B8(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B9[0x7];                                       // 0x00B9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 VolumeLayerName;                                   // 0x00C0(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         VolumeTileIndex;                                   // 0x00D0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsVisible;                                        // 0x00D4(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsEditable;                                       // 0x00D5(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsTemplated;                                      // 0x00D6(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsInstanced;                                      // 0x00D7(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasGeoChanged;                                    // 0x00D8(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasPartChanged;                                   // 0x00D9(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasTransformChanged;                              // 0x00DA(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasMaterialsChanged;                              // 0x00DB(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_DC[0x144];                                     // 0x00DC(0x0144)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FHoudiniMeshSocket>             AllMeshSockets;                                    // 0x0220(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHoudiniGeoPartObject) == 0x000010, "Wrong alignment on FHoudiniGeoPartObject");
static_assert(sizeof(FHoudiniGeoPartObject) == 0x000230, "Wrong size on FHoudiniGeoPartObject");
static_assert(offsetof(FHoudiniGeoPartObject, AssetId) == 0x000000, "Member 'FHoudiniGeoPartObject::AssetId' has a wrong offset!");
static_assert(offsetof(FHoudiniGeoPartObject, AssetName) == 0x000008, "Member 'FHoudiniGeoPartObject::AssetName' has a wrong offset!");
static_assert(offsetof(FHoudiniGeoPartObject, ObjectId) == 0x000018, "Member 'FHoudiniGeoPartObject::ObjectId' has a wrong offset!");
static_assert(offsetof(FHoudiniGeoPartObject, ObjectName) == 0x000020, "Member 'FHoudiniGeoPartObject::ObjectName' has a wrong offset!");
static_assert(offsetof(FHoudiniGeoPartObject, GeoId) == 0x000030, "Member 'FHoudiniGeoPartObject::GeoId' has a wrong offset!");
static_assert(offsetof(FHoudiniGeoPartObject, PartId) == 0x000034, "Member 'FHoudiniGeoPartObject::PartId' has a wrong offset!");
static_assert(offsetof(FHoudiniGeoPartObject, PartName) == 0x000038, "Member 'FHoudiniGeoPartObject::PartName' has a wrong offset!");
static_assert(offsetof(FHoudiniGeoPartObject, bHasCustomPartName) == 0x000048, "Member 'FHoudiniGeoPartObject::bHasCustomPartName' has a wrong offset!");
static_assert(offsetof(FHoudiniGeoPartObject, SplitGroups) == 0x000050, "Member 'FHoudiniGeoPartObject::SplitGroups' has a wrong offset!");
static_assert(offsetof(FHoudiniGeoPartObject, TransformMatrix) == 0x000060, "Member 'FHoudiniGeoPartObject::TransformMatrix' has a wrong offset!");
static_assert(offsetof(FHoudiniGeoPartObject, NodePath) == 0x000090, "Member 'FHoudiniGeoPartObject::NodePath' has a wrong offset!");
static_assert(offsetof(FHoudiniGeoPartObject, Type) == 0x0000A0, "Member 'FHoudiniGeoPartObject::Type' has a wrong offset!");
static_assert(offsetof(FHoudiniGeoPartObject, InstancerType) == 0x0000A1, "Member 'FHoudiniGeoPartObject::InstancerType' has a wrong offset!");
static_assert(offsetof(FHoudiniGeoPartObject, VolumeName) == 0x0000A8, "Member 'FHoudiniGeoPartObject::VolumeName' has a wrong offset!");
static_assert(offsetof(FHoudiniGeoPartObject, bHasEditLayers) == 0x0000B8, "Member 'FHoudiniGeoPartObject::bHasEditLayers' has a wrong offset!");
static_assert(offsetof(FHoudiniGeoPartObject, VolumeLayerName) == 0x0000C0, "Member 'FHoudiniGeoPartObject::VolumeLayerName' has a wrong offset!");
static_assert(offsetof(FHoudiniGeoPartObject, VolumeTileIndex) == 0x0000D0, "Member 'FHoudiniGeoPartObject::VolumeTileIndex' has a wrong offset!");
static_assert(offsetof(FHoudiniGeoPartObject, bIsVisible) == 0x0000D4, "Member 'FHoudiniGeoPartObject::bIsVisible' has a wrong offset!");
static_assert(offsetof(FHoudiniGeoPartObject, bIsEditable) == 0x0000D5, "Member 'FHoudiniGeoPartObject::bIsEditable' has a wrong offset!");
static_assert(offsetof(FHoudiniGeoPartObject, bIsTemplated) == 0x0000D6, "Member 'FHoudiniGeoPartObject::bIsTemplated' has a wrong offset!");
static_assert(offsetof(FHoudiniGeoPartObject, bIsInstanced) == 0x0000D7, "Member 'FHoudiniGeoPartObject::bIsInstanced' has a wrong offset!");
static_assert(offsetof(FHoudiniGeoPartObject, bHasGeoChanged) == 0x0000D8, "Member 'FHoudiniGeoPartObject::bHasGeoChanged' has a wrong offset!");
static_assert(offsetof(FHoudiniGeoPartObject, bHasPartChanged) == 0x0000D9, "Member 'FHoudiniGeoPartObject::bHasPartChanged' has a wrong offset!");
static_assert(offsetof(FHoudiniGeoPartObject, bHasTransformChanged) == 0x0000DA, "Member 'FHoudiniGeoPartObject::bHasTransformChanged' has a wrong offset!");
static_assert(offsetof(FHoudiniGeoPartObject, bHasMaterialsChanged) == 0x0000DB, "Member 'FHoudiniGeoPartObject::bHasMaterialsChanged' has a wrong offset!");
static_assert(offsetof(FHoudiniGeoPartObject, AllMeshSockets) == 0x000220, "Member 'FHoudiniGeoPartObject::AllMeshSockets' has a wrong offset!");

// ScriptStruct HoudiniEngineRuntime.HoudiniCurveInfo
// 0x001C (0x001C - 0x0000)
struct alignas(0x04) FHoudiniCurveInfo final
{
public:
	uint8                                         Pad_0[0x1C];                                       // 0x0000(0x001C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FHoudiniCurveInfo) == 0x000004, "Wrong alignment on FHoudiniCurveInfo");
static_assert(sizeof(FHoudiniCurveInfo) == 0x00001C, "Wrong size on FHoudiniCurveInfo");

// ScriptStruct HoudiniEngineRuntime.HoudiniVolumeInfo
// 0x0080 (0x0080 - 0x0000)
struct alignas(0x10) FHoudiniVolumeInfo final
{
public:
	uint8                                         Pad_0[0x80];                                       // 0x0000(0x0080)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FHoudiniVolumeInfo) == 0x000010, "Wrong alignment on FHoudiniVolumeInfo");
static_assert(sizeof(FHoudiniVolumeInfo) == 0x000080, "Wrong size on FHoudiniVolumeInfo");

// ScriptStruct HoudiniEngineRuntime.HoudiniPartInfo
// 0x0048 (0x0048 - 0x0000)
struct alignas(0x08) FHoudiniPartInfo final
{
public:
	uint8                                         Pad_0[0x48];                                       // 0x0000(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FHoudiniPartInfo) == 0x000008, "Wrong alignment on FHoudiniPartInfo");
static_assert(sizeof(FHoudiniPartInfo) == 0x000048, "Wrong size on FHoudiniPartInfo");

// ScriptStruct HoudiniEngineRuntime.HoudiniGeoInfo
// 0x0030 (0x0030 - 0x0000)
struct alignas(0x08) FHoudiniGeoInfo final
{
public:
	uint8                                         Pad_0[0x30];                                       // 0x0000(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FHoudiniGeoInfo) == 0x000008, "Wrong alignment on FHoudiniGeoInfo");
static_assert(sizeof(FHoudiniGeoInfo) == 0x000030, "Wrong size on FHoudiniGeoInfo");

// ScriptStruct HoudiniEngineRuntime.HoudiniObjectInfo
// 0x0028 (0x0028 - 0x0000)
struct alignas(0x08) FHoudiniObjectInfo final
{
public:
	uint8                                         Pad_0[0x28];                                       // 0x0000(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FHoudiniObjectInfo) == 0x000008, "Wrong alignment on FHoudiniObjectInfo");
static_assert(sizeof(FHoudiniObjectInfo) == 0x000028, "Wrong size on FHoudiniObjectInfo");

// ScriptStruct HoudiniEngineRuntime.KuroHDAMeshInputConfig
// 0x000E (0x000E - 0x0000)
struct FKuroHDAMeshInputConfig final
{
public:
	bool                                          CombineMesh;                                       // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UVS;                                               // 0x0001(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Normals;                                           // 0x0002(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Tangent;                                           // 0x0003(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Binomal;                                           // 0x0004(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          VertexColor;                                       // 0x0005(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          SmoothingMask;                                     // 0x0006(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Material;                                          // 0x0007(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Lightmap;                                          // 0x0008(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          MeshName;                                          // 0x0009(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          SourceFile;                                        // 0x000A(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Tags;                                              // 0x000B(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          KuroAssetTags;                                     // 0x000C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x1];                                        // 0x000D(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FKuroHDAMeshInputConfig) == 0x000001, "Wrong alignment on FKuroHDAMeshInputConfig");
static_assert(sizeof(FKuroHDAMeshInputConfig) == 0x00000E, "Wrong size on FKuroHDAMeshInputConfig");
static_assert(offsetof(FKuroHDAMeshInputConfig, CombineMesh) == 0x000000, "Member 'FKuroHDAMeshInputConfig::CombineMesh' has a wrong offset!");
static_assert(offsetof(FKuroHDAMeshInputConfig, UVS) == 0x000001, "Member 'FKuroHDAMeshInputConfig::UVS' has a wrong offset!");
static_assert(offsetof(FKuroHDAMeshInputConfig, Normals) == 0x000002, "Member 'FKuroHDAMeshInputConfig::Normals' has a wrong offset!");
static_assert(offsetof(FKuroHDAMeshInputConfig, Tangent) == 0x000003, "Member 'FKuroHDAMeshInputConfig::Tangent' has a wrong offset!");
static_assert(offsetof(FKuroHDAMeshInputConfig, Binomal) == 0x000004, "Member 'FKuroHDAMeshInputConfig::Binomal' has a wrong offset!");
static_assert(offsetof(FKuroHDAMeshInputConfig, VertexColor) == 0x000005, "Member 'FKuroHDAMeshInputConfig::VertexColor' has a wrong offset!");
static_assert(offsetof(FKuroHDAMeshInputConfig, SmoothingMask) == 0x000006, "Member 'FKuroHDAMeshInputConfig::SmoothingMask' has a wrong offset!");
static_assert(offsetof(FKuroHDAMeshInputConfig, Material) == 0x000007, "Member 'FKuroHDAMeshInputConfig::Material' has a wrong offset!");
static_assert(offsetof(FKuroHDAMeshInputConfig, Lightmap) == 0x000008, "Member 'FKuroHDAMeshInputConfig::Lightmap' has a wrong offset!");
static_assert(offsetof(FKuroHDAMeshInputConfig, MeshName) == 0x000009, "Member 'FKuroHDAMeshInputConfig::MeshName' has a wrong offset!");
static_assert(offsetof(FKuroHDAMeshInputConfig, SourceFile) == 0x00000A, "Member 'FKuroHDAMeshInputConfig::SourceFile' has a wrong offset!");
static_assert(offsetof(FKuroHDAMeshInputConfig, Tags) == 0x00000B, "Member 'FKuroHDAMeshInputConfig::Tags' has a wrong offset!");
static_assert(offsetof(FKuroHDAMeshInputConfig, KuroAssetTags) == 0x00000C, "Member 'FKuroHDAMeshInputConfig::KuroAssetTags' has a wrong offset!");

// ScriptStruct HoudiniEngineRuntime.HoudiniBrushInfo
// 0x0070 (0x0070 - 0x0000)
struct FHoudiniBrushInfo final
{
public:
	TWeakObjectPtr<class ABrush>                  BrushActor;                                        // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             CachedTransform;                                   // 0x0010(0x0030)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                CachedOrigin;                                      // 0x0040(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                CachedExtent;                                      // 0x004C(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBrushType                                    CachedBrushType;                                   // 0x0058(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_59[0x7];                                       // 0x0059(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	uint64                                        CachedSurfaceHash;                                 // 0x0060(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_68[0x8];                                       // 0x0068(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FHoudiniBrushInfo) == 0x000010, "Wrong alignment on FHoudiniBrushInfo");
static_assert(sizeof(FHoudiniBrushInfo) == 0x000070, "Wrong size on FHoudiniBrushInfo");
static_assert(offsetof(FHoudiniBrushInfo, BrushActor) == 0x000000, "Member 'FHoudiniBrushInfo::BrushActor' has a wrong offset!");
static_assert(offsetof(FHoudiniBrushInfo, CachedTransform) == 0x000010, "Member 'FHoudiniBrushInfo::CachedTransform' has a wrong offset!");
static_assert(offsetof(FHoudiniBrushInfo, CachedOrigin) == 0x000040, "Member 'FHoudiniBrushInfo::CachedOrigin' has a wrong offset!");
static_assert(offsetof(FHoudiniBrushInfo, CachedExtent) == 0x00004C, "Member 'FHoudiniBrushInfo::CachedExtent' has a wrong offset!");
static_assert(offsetof(FHoudiniBrushInfo, CachedBrushType) == 0x000058, "Member 'FHoudiniBrushInfo::CachedBrushType' has a wrong offset!");
static_assert(offsetof(FHoudiniBrushInfo, CachedSurfaceHash) == 0x000060, "Member 'FHoudiniBrushInfo::CachedSurfaceHash' has a wrong offset!");

// ScriptStruct HoudiniEngineRuntime.HoudiniBakedOutputObjectIdentifier
// 0x0018 (0x0018 - 0x0000)
struct FHoudiniBakedOutputObjectIdentifier final
{
public:
	int32                                         PartId;                                            // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 SplitIdentifier;                                   // 0x0008(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHoudiniBakedOutputObjectIdentifier) == 0x000008, "Wrong alignment on FHoudiniBakedOutputObjectIdentifier");
static_assert(sizeof(FHoudiniBakedOutputObjectIdentifier) == 0x000018, "Wrong size on FHoudiniBakedOutputObjectIdentifier");
static_assert(offsetof(FHoudiniBakedOutputObjectIdentifier, PartId) == 0x000000, "Member 'FHoudiniBakedOutputObjectIdentifier::PartId' has a wrong offset!");
static_assert(offsetof(FHoudiniBakedOutputObjectIdentifier, SplitIdentifier) == 0x000008, "Member 'FHoudiniBakedOutputObjectIdentifier::SplitIdentifier' has a wrong offset!");

// ScriptStruct HoudiniEngineRuntime.HoudiniBakedOutputObject
// 0x00C0 (0x00C0 - 0x0000)
struct FHoudiniBakedOutputObject final
{
public:
	class FString                                 Actor;                                             // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Blueprint;                                         // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ActorBakeName;                                     // 0x0020(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 BakedObject;                                       // 0x0030(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 BakedComponent;                                    // 0x0040(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FString>                         InstancedActors;                                   // 0x0050(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FString>                         InstancedComponents;                               // 0x0060(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TMap<class FName, class FString>              LandscapeLayers;                                   // 0x0070(0x0050)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FHoudiniBakedOutputObject) == 0x000008, "Wrong alignment on FHoudiniBakedOutputObject");
static_assert(sizeof(FHoudiniBakedOutputObject) == 0x0000C0, "Wrong size on FHoudiniBakedOutputObject");
static_assert(offsetof(FHoudiniBakedOutputObject, Actor) == 0x000000, "Member 'FHoudiniBakedOutputObject::Actor' has a wrong offset!");
static_assert(offsetof(FHoudiniBakedOutputObject, Blueprint) == 0x000010, "Member 'FHoudiniBakedOutputObject::Blueprint' has a wrong offset!");
static_assert(offsetof(FHoudiniBakedOutputObject, ActorBakeName) == 0x000020, "Member 'FHoudiniBakedOutputObject::ActorBakeName' has a wrong offset!");
static_assert(offsetof(FHoudiniBakedOutputObject, BakedObject) == 0x000030, "Member 'FHoudiniBakedOutputObject::BakedObject' has a wrong offset!");
static_assert(offsetof(FHoudiniBakedOutputObject, BakedComponent) == 0x000040, "Member 'FHoudiniBakedOutputObject::BakedComponent' has a wrong offset!");
static_assert(offsetof(FHoudiniBakedOutputObject, InstancedActors) == 0x000050, "Member 'FHoudiniBakedOutputObject::InstancedActors' has a wrong offset!");
static_assert(offsetof(FHoudiniBakedOutputObject, InstancedComponents) == 0x000060, "Member 'FHoudiniBakedOutputObject::InstancedComponents' has a wrong offset!");
static_assert(offsetof(FHoudiniBakedOutputObject, LandscapeLayers) == 0x000070, "Member 'FHoudiniBakedOutputObject::LandscapeLayers' has a wrong offset!");

// ScriptStruct HoudiniEngineRuntime.HoudiniBakedOutput
// 0x0050 (0x0050 - 0x0000)
struct FHoudiniBakedOutput final
{
public:
	TMap<struct FHoudiniBakedOutputObjectIdentifier, struct FHoudiniBakedOutputObject> BakedOutputObjects; // 0x0000(0x0050)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FHoudiniBakedOutput) == 0x000008, "Wrong alignment on FHoudiniBakedOutput");
static_assert(sizeof(FHoudiniBakedOutput) == 0x000050, "Wrong size on FHoudiniBakedOutput");
static_assert(offsetof(FHoudiniBakedOutput, BakedOutputObjects) == 0x000000, "Member 'FHoudiniBakedOutput::BakedOutputObjects' has a wrong offset!");

// ScriptStruct HoudiniEngineRuntime.HoudiniInstancedOutput
// 0x0090 (0x0090 - 0x0000)
struct FHoudiniInstancedOutput final
{
public:
	TSoftObjectPtr<class UObject>                 OriginalObject;                                    // 0x0000(0x0030)(UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OriginalObjectIndex;                               // 0x0030(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FTransform>                     OriginalTransforms;                                // 0x0038(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<TSoftObjectPtr<class UObject>>         VariationObjects;                                  // 0x0048(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<struct FTransform>                     VariationTransformOffsets;                         // 0x0058(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<int32>                                 TransformVariationIndices;                         // 0x0068(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<int32>                                 OriginalInstanceIndices;                           // 0x0078(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bChanged;                                          // 0x0088(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStale;                                            // 0x0089(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8A[0x6];                                       // 0x008A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FHoudiniInstancedOutput) == 0x000008, "Wrong alignment on FHoudiniInstancedOutput");
static_assert(sizeof(FHoudiniInstancedOutput) == 0x000090, "Wrong size on FHoudiniInstancedOutput");
static_assert(offsetof(FHoudiniInstancedOutput, OriginalObject) == 0x000000, "Member 'FHoudiniInstancedOutput::OriginalObject' has a wrong offset!");
static_assert(offsetof(FHoudiniInstancedOutput, OriginalObjectIndex) == 0x000030, "Member 'FHoudiniInstancedOutput::OriginalObjectIndex' has a wrong offset!");
static_assert(offsetof(FHoudiniInstancedOutput, OriginalTransforms) == 0x000038, "Member 'FHoudiniInstancedOutput::OriginalTransforms' has a wrong offset!");
static_assert(offsetof(FHoudiniInstancedOutput, VariationObjects) == 0x000048, "Member 'FHoudiniInstancedOutput::VariationObjects' has a wrong offset!");
static_assert(offsetof(FHoudiniInstancedOutput, VariationTransformOffsets) == 0x000058, "Member 'FHoudiniInstancedOutput::VariationTransformOffsets' has a wrong offset!");
static_assert(offsetof(FHoudiniInstancedOutput, TransformVariationIndices) == 0x000068, "Member 'FHoudiniInstancedOutput::TransformVariationIndices' has a wrong offset!");
static_assert(offsetof(FHoudiniInstancedOutput, OriginalInstanceIndices) == 0x000078, "Member 'FHoudiniInstancedOutput::OriginalInstanceIndices' has a wrong offset!");
static_assert(offsetof(FHoudiniInstancedOutput, bChanged) == 0x000088, "Member 'FHoudiniInstancedOutput::bChanged' has a wrong offset!");
static_assert(offsetof(FHoudiniInstancedOutput, bStale) == 0x000089, "Member 'FHoudiniInstancedOutput::bStale' has a wrong offset!");

// ScriptStruct HoudiniEngineRuntime.HoudiniPDGWorkResultObjectBakedOutput
// 0x0010 (0x0010 - 0x0000)
struct FHoudiniPDGWorkResultObjectBakedOutput final
{
public:
	TArray<struct FHoudiniBakedOutput>            BakedOutputs;                                      // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHoudiniPDGWorkResultObjectBakedOutput) == 0x000008, "Wrong alignment on FHoudiniPDGWorkResultObjectBakedOutput");
static_assert(sizeof(FHoudiniPDGWorkResultObjectBakedOutput) == 0x000010, "Wrong size on FHoudiniPDGWorkResultObjectBakedOutput");
static_assert(offsetof(FHoudiniPDGWorkResultObjectBakedOutput, BakedOutputs) == 0x000000, "Member 'FHoudiniPDGWorkResultObjectBakedOutput::BakedOutputs' has a wrong offset!");

// ScriptStruct HoudiniEngineRuntime.WorkItemTallyBase
// 0x0008 (0x0008 - 0x0000)
struct alignas(0x08) FWorkItemTallyBase
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FWorkItemTallyBase) == 0x000008, "Wrong alignment on FWorkItemTallyBase");
static_assert(sizeof(FWorkItemTallyBase) == 0x000008, "Wrong size on FWorkItemTallyBase");

// ScriptStruct HoudiniEngineRuntime.AggregatedWorkItemTally
// 0x0020 (0x0028 - 0x0008)
struct FAggregatedWorkItemTally final : public FWorkItemTallyBase
{
public:
	int32                                         TotalWorkItems;                                    // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         WaitingWorkItems;                                  // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         ScheduledWorkItems;                                // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         CookingWorkItems;                                  // 0x0014(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         CookedWorkItems;                                   // 0x0018(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         ErroredWorkItems;                                  // 0x001C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         CookCancelledWorkItems;                            // 0x0020(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAggregatedWorkItemTally) == 0x000008, "Wrong alignment on FAggregatedWorkItemTally");
static_assert(sizeof(FAggregatedWorkItemTally) == 0x000028, "Wrong size on FAggregatedWorkItemTally");
static_assert(offsetof(FAggregatedWorkItemTally, TotalWorkItems) == 0x000008, "Member 'FAggregatedWorkItemTally::TotalWorkItems' has a wrong offset!");
static_assert(offsetof(FAggregatedWorkItemTally, WaitingWorkItems) == 0x00000C, "Member 'FAggregatedWorkItemTally::WaitingWorkItems' has a wrong offset!");
static_assert(offsetof(FAggregatedWorkItemTally, ScheduledWorkItems) == 0x000010, "Member 'FAggregatedWorkItemTally::ScheduledWorkItems' has a wrong offset!");
static_assert(offsetof(FAggregatedWorkItemTally, CookingWorkItems) == 0x000014, "Member 'FAggregatedWorkItemTally::CookingWorkItems' has a wrong offset!");
static_assert(offsetof(FAggregatedWorkItemTally, CookedWorkItems) == 0x000018, "Member 'FAggregatedWorkItemTally::CookedWorkItems' has a wrong offset!");
static_assert(offsetof(FAggregatedWorkItemTally, ErroredWorkItems) == 0x00001C, "Member 'FAggregatedWorkItemTally::ErroredWorkItems' has a wrong offset!");
static_assert(offsetof(FAggregatedWorkItemTally, CookCancelledWorkItems) == 0x000020, "Member 'FAggregatedWorkItemTally::CookCancelledWorkItems' has a wrong offset!");

// ScriptStruct HoudiniEngineRuntime.WorkItemTally
// 0x0230 (0x0238 - 0x0008)
struct FWorkItemTally final : public FWorkItemTallyBase
{
public:
	TSet<int32>                                   AllWorkItems;                                      // 0x0008(0x0050)(Protected, NativeAccessSpecifierProtected)
	TSet<int32>                                   WaitingWorkItems;                                  // 0x0058(0x0050)(Protected, NativeAccessSpecifierProtected)
	TSet<int32>                                   ScheduledWorkItems;                                // 0x00A8(0x0050)(Protected, NativeAccessSpecifierProtected)
	TSet<int32>                                   CookingWorkItems;                                  // 0x00F8(0x0050)(Protected, NativeAccessSpecifierProtected)
	TSet<int32>                                   CookedWorkItems;                                   // 0x0148(0x0050)(Protected, NativeAccessSpecifierProtected)
	TSet<int32>                                   ErroredWorkItems;                                  // 0x0198(0x0050)(Protected, NativeAccessSpecifierProtected)
	TSet<int32>                                   CookCancelledWorkItems;                            // 0x01E8(0x0050)(Protected, NativeAccessSpecifierProtected)
};
static_assert(alignof(FWorkItemTally) == 0x000008, "Wrong alignment on FWorkItemTally");
static_assert(sizeof(FWorkItemTally) == 0x000238, "Wrong size on FWorkItemTally");
static_assert(offsetof(FWorkItemTally, AllWorkItems) == 0x000008, "Member 'FWorkItemTally::AllWorkItems' has a wrong offset!");
static_assert(offsetof(FWorkItemTally, WaitingWorkItems) == 0x000058, "Member 'FWorkItemTally::WaitingWorkItems' has a wrong offset!");
static_assert(offsetof(FWorkItemTally, ScheduledWorkItems) == 0x0000A8, "Member 'FWorkItemTally::ScheduledWorkItems' has a wrong offset!");
static_assert(offsetof(FWorkItemTally, CookingWorkItems) == 0x0000F8, "Member 'FWorkItemTally::CookingWorkItems' has a wrong offset!");
static_assert(offsetof(FWorkItemTally, CookedWorkItems) == 0x000148, "Member 'FWorkItemTally::CookedWorkItems' has a wrong offset!");
static_assert(offsetof(FWorkItemTally, ErroredWorkItems) == 0x000198, "Member 'FWorkItemTally::ErroredWorkItems' has a wrong offset!");
static_assert(offsetof(FWorkItemTally, CookCancelledWorkItems) == 0x0001E8, "Member 'FWorkItemTally::CookCancelledWorkItems' has a wrong offset!");

// ScriptStruct HoudiniEngineRuntime.OutputActorOwner
// 0x0010 (0x0010 - 0x0000)
struct FOutputActorOwner final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 OutputActor;                                       // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NonTransactional, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FOutputActorOwner) == 0x000008, "Wrong alignment on FOutputActorOwner");
static_assert(sizeof(FOutputActorOwner) == 0x000010, "Wrong size on FOutputActorOwner");
static_assert(offsetof(FOutputActorOwner, OutputActor) == 0x000008, "Member 'FOutputActorOwner::OutputActor' has a wrong offset!");

// ScriptStruct HoudiniEngineRuntime.TOPWorkResultObject
// 0x0058 (0x0058 - 0x0000)
struct FTOPWorkResultObject final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 Name;                                              // 0x0008(0x0010)(ZeroConstructor, NonTransactional, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 FilePath;                                          // 0x0018(0x0010)(ZeroConstructor, NonTransactional, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPDGWorkResultState                           State;                                             // 0x0028(0x0001)(ZeroConstructor, IsPlainOldData, NonTransactional, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x3];                                       // 0x0029(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         WorkItemResultInfoIndex;                           // 0x002C(0x0004)(ZeroConstructor, IsPlainOldData, NonTransactional, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UHoudiniOutput*>                 ResultOutputs;                                     // 0x0030(0x0010)(ZeroConstructor, NonTransactional, Protected, NativeAccessSpecifierProtected)
	bool                                          bAutoBakedSinceLastLoad;                           // 0x0040(0x0001)(ZeroConstructor, IsPlainOldData, NonTransactional, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FOutputActorOwner                      OutputActorOwner;                                  // 0x0048(0x0010)(NonTransactional, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FTOPWorkResultObject) == 0x000008, "Wrong alignment on FTOPWorkResultObject");
static_assert(sizeof(FTOPWorkResultObject) == 0x000058, "Wrong size on FTOPWorkResultObject");
static_assert(offsetof(FTOPWorkResultObject, Name) == 0x000008, "Member 'FTOPWorkResultObject::Name' has a wrong offset!");
static_assert(offsetof(FTOPWorkResultObject, FilePath) == 0x000018, "Member 'FTOPWorkResultObject::FilePath' has a wrong offset!");
static_assert(offsetof(FTOPWorkResultObject, State) == 0x000028, "Member 'FTOPWorkResultObject::State' has a wrong offset!");
static_assert(offsetof(FTOPWorkResultObject, WorkItemResultInfoIndex) == 0x00002C, "Member 'FTOPWorkResultObject::WorkItemResultInfoIndex' has a wrong offset!");
static_assert(offsetof(FTOPWorkResultObject, ResultOutputs) == 0x000030, "Member 'FTOPWorkResultObject::ResultOutputs' has a wrong offset!");
static_assert(offsetof(FTOPWorkResultObject, bAutoBakedSinceLastLoad) == 0x000040, "Member 'FTOPWorkResultObject::bAutoBakedSinceLastLoad' has a wrong offset!");
static_assert(offsetof(FTOPWorkResultObject, OutputActorOwner) == 0x000048, "Member 'FTOPWorkResultObject::OutputActorOwner' has a wrong offset!");

// ScriptStruct HoudiniEngineRuntime.TOPWorkResult
// 0x0018 (0x0018 - 0x0000)
struct FTOPWorkResult final
{
public:
	int32                                         WorkItemIndex;                                     // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NonTransactional, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         WorkItemID;                                        // 0x0004(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FTOPWorkResultObject>           ResultObjects;                                     // 0x0008(0x0010)(ZeroConstructor, NonTransactional, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTOPWorkResult) == 0x000008, "Wrong alignment on FTOPWorkResult");
static_assert(sizeof(FTOPWorkResult) == 0x000018, "Wrong size on FTOPWorkResult");
static_assert(offsetof(FTOPWorkResult, WorkItemIndex) == 0x000000, "Member 'FTOPWorkResult::WorkItemIndex' has a wrong offset!");
static_assert(offsetof(FTOPWorkResult, WorkItemID) == 0x000004, "Member 'FTOPWorkResult::WorkItemID' has a wrong offset!");
static_assert(offsetof(FTOPWorkResult, ResultObjects) == 0x000008, "Member 'FTOPWorkResult::ResultObjects' has a wrong offset!");

// ScriptStruct HoudiniEngineRuntime.HoudiniStaticMeshGenerationProperties
// 0x01B8 (0x01B8 - 0x0000)
struct FHoudiniStaticMeshGenerationProperties final
{
public:
	uint8                                         bGeneratedDoubleSidedGeometry : 1;                 // 0x0000(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UPhysicalMaterial*                      GeneratedPhysMaterial;                             // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBodyInstance                          DefaultBodyInstance;                               // 0x0010(0x0168)(Edit, NativeAccessSpecifierPublic)
	ECollisionTraceFlag                           GeneratedCollisionTraceFlag;                       // 0x0178(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_179[0x3];                                      // 0x0179(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         GeneratedLightMapResolution;                       // 0x017C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FWalkableSlopeOverride                 GeneratedWalkableSlopeOverride;                    // 0x0180(0x0010)(Edit, IsPlainOldData, NoDestructor, AdvancedDisplay, NativeAccessSpecifierPublic)
	int32                                         GeneratedLightMapCoordinateIndex;                  // 0x0190(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bGeneratedUseMaximumStreamingTexelRatio : 1;       // 0x0194(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_195[0x3];                                      // 0x0195(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         GeneratedStreamingDistanceMultiplier;              // 0x0198(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19C[0x4];                                      // 0x019C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UFoliageType_InstancedStaticMesh*       GeneratedFoliageDefaultSettings;                   // 0x01A0(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, AdvancedDisplay, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UAssetUserData*>                 GeneratedAssetUserData;                            // 0x01A8(0x0010)(Edit, ExportObject, ZeroConstructor, ContainsInstancedReference, AdvancedDisplay, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHoudiniStaticMeshGenerationProperties) == 0x000008, "Wrong alignment on FHoudiniStaticMeshGenerationProperties");
static_assert(sizeof(FHoudiniStaticMeshGenerationProperties) == 0x0001B8, "Wrong size on FHoudiniStaticMeshGenerationProperties");
static_assert(offsetof(FHoudiniStaticMeshGenerationProperties, GeneratedPhysMaterial) == 0x000008, "Member 'FHoudiniStaticMeshGenerationProperties::GeneratedPhysMaterial' has a wrong offset!");
static_assert(offsetof(FHoudiniStaticMeshGenerationProperties, DefaultBodyInstance) == 0x000010, "Member 'FHoudiniStaticMeshGenerationProperties::DefaultBodyInstance' has a wrong offset!");
static_assert(offsetof(FHoudiniStaticMeshGenerationProperties, GeneratedCollisionTraceFlag) == 0x000178, "Member 'FHoudiniStaticMeshGenerationProperties::GeneratedCollisionTraceFlag' has a wrong offset!");
static_assert(offsetof(FHoudiniStaticMeshGenerationProperties, GeneratedLightMapResolution) == 0x00017C, "Member 'FHoudiniStaticMeshGenerationProperties::GeneratedLightMapResolution' has a wrong offset!");
static_assert(offsetof(FHoudiniStaticMeshGenerationProperties, GeneratedWalkableSlopeOverride) == 0x000180, "Member 'FHoudiniStaticMeshGenerationProperties::GeneratedWalkableSlopeOverride' has a wrong offset!");
static_assert(offsetof(FHoudiniStaticMeshGenerationProperties, GeneratedLightMapCoordinateIndex) == 0x000190, "Member 'FHoudiniStaticMeshGenerationProperties::GeneratedLightMapCoordinateIndex' has a wrong offset!");
static_assert(offsetof(FHoudiniStaticMeshGenerationProperties, GeneratedStreamingDistanceMultiplier) == 0x000198, "Member 'FHoudiniStaticMeshGenerationProperties::GeneratedStreamingDistanceMultiplier' has a wrong offset!");
static_assert(offsetof(FHoudiniStaticMeshGenerationProperties, GeneratedFoliageDefaultSettings) == 0x0001A0, "Member 'FHoudiniStaticMeshGenerationProperties::GeneratedFoliageDefaultSettings' has a wrong offset!");
static_assert(offsetof(FHoudiniStaticMeshGenerationProperties, GeneratedAssetUserData) == 0x0001A8, "Member 'FHoudiniStaticMeshGenerationProperties::GeneratedAssetUserData' has a wrong offset!");

// ScriptStruct HoudiniEngineRuntime.HoudiniSplineComponentInstanceData
// 0x0030 (0x0098 - 0x0068)
struct FHoudiniSplineComponentInstanceData final : public FActorComponentInstanceData
{
public:
	TArray<struct FTransform>                     CurvePoints;                                       // 0x0068(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FVector>                        DisplayPoints;                                     // 0x0078(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<int32>                                 DisplayPointIndexDivider;                          // 0x0088(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHoudiniSplineComponentInstanceData) == 0x000008, "Wrong alignment on FHoudiniSplineComponentInstanceData");
static_assert(sizeof(FHoudiniSplineComponentInstanceData) == 0x000098, "Wrong size on FHoudiniSplineComponentInstanceData");
static_assert(offsetof(FHoudiniSplineComponentInstanceData, CurvePoints) == 0x000068, "Member 'FHoudiniSplineComponentInstanceData::CurvePoints' has a wrong offset!");
static_assert(offsetof(FHoudiniSplineComponentInstanceData, DisplayPoints) == 0x000078, "Member 'FHoudiniSplineComponentInstanceData::DisplayPoints' has a wrong offset!");
static_assert(offsetof(FHoudiniSplineComponentInstanceData, DisplayPointIndexDivider) == 0x000088, "Member 'FHoudiniSplineComponentInstanceData::DisplayPointIndexDivider' has a wrong offset!");

}

