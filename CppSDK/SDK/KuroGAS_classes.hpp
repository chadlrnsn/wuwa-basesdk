#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: KuroGAS

#include "Basic.hpp"

#include "KuroGAS_structs.hpp"
#include "Engine_classes.hpp"
#include "CoreUObject_structs.hpp"
#include "GameplayTags_structs.hpp"
#include "GameplayAbilities_structs.hpp"
#include "GameplayAbilities_classes.hpp"


namespace SDK
{

// Class KuroGAS.AsyncTaskAnyAttributeChanged
// 0x0018 (0x0050 - 0x0038)
class UAsyncTaskAnyAttributeChanged final : public UBlueprintAsyncActionBase
{
public:
	TMulticastInlineDelegate<void(int32 AttributeID, float NewValue, float OldValue)> OnAttributeChanged; // 0x0038(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UAbilitySystemComponent*                ASC;                                               // 0x0048(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UAsyncTaskAnyAttributeChanged* ListenForAnyAttributeChange(class UAbilitySystemComponent* AbilitySystemComponent);

	void EndTask();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AsyncTaskAnyAttributeChanged">();
	}
	static class UAsyncTaskAnyAttributeChanged* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAsyncTaskAnyAttributeChanged>();
	}
};
static_assert(alignof(UAsyncTaskAnyAttributeChanged) == 0x000008, "Wrong alignment on UAsyncTaskAnyAttributeChanged");
static_assert(sizeof(UAsyncTaskAnyAttributeChanged) == 0x000050, "Wrong size on UAsyncTaskAnyAttributeChanged");
static_assert(offsetof(UAsyncTaskAnyAttributeChanged, OnAttributeChanged) == 0x000038, "Member 'UAsyncTaskAnyAttributeChanged::OnAttributeChanged' has a wrong offset!");
static_assert(offsetof(UAsyncTaskAnyAttributeChanged, ASC) == 0x000048, "Member 'UAsyncTaskAnyAttributeChanged::ASC' has a wrong offset!");

// Class KuroGAS.AsyncTaskAnyEffectInhibitionChanged
// 0x0018 (0x0050 - 0x0038)
class UAsyncTaskAnyEffectInhibitionChanged final : public UBlueprintAsyncActionBase
{
public:
	TMulticastInlineDelegate<void(const struct FActiveGameplayEffectHandle& Handle, bool bInhibited)> OnEffectInhibitionChanged; // 0x0038(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPrivate)
	class UAbilitySystemComponent*                AbilityComp;                                       // 0x0048(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UAsyncTaskAnyEffectInhibitionChanged* ListenForAnyEffectInhibitionChanged(class UAbilitySystemComponent* AbilityComp_0);

	void EndTask();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AsyncTaskAnyEffectInhibitionChanged">();
	}
	static class UAsyncTaskAnyEffectInhibitionChanged* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAsyncTaskAnyEffectInhibitionChanged>();
	}
};
static_assert(alignof(UAsyncTaskAnyEffectInhibitionChanged) == 0x000008, "Wrong alignment on UAsyncTaskAnyEffectInhibitionChanged");
static_assert(sizeof(UAsyncTaskAnyEffectInhibitionChanged) == 0x000050, "Wrong size on UAsyncTaskAnyEffectInhibitionChanged");
static_assert(offsetof(UAsyncTaskAnyEffectInhibitionChanged, OnEffectInhibitionChanged) == 0x000038, "Member 'UAsyncTaskAnyEffectInhibitionChanged::OnEffectInhibitionChanged' has a wrong offset!");
static_assert(offsetof(UAsyncTaskAnyEffectInhibitionChanged, AbilityComp) == 0x000048, "Member 'UAsyncTaskAnyEffectInhibitionChanged::AbilityComp' has a wrong offset!");

// Class KuroGAS.AsyncTaskAnyEffectRemoved
// 0x0030 (0x0068 - 0x0038)
class UAsyncTaskAnyEffectRemoved final : public UBlueprintAsyncActionBase
{
public:
	TMulticastInlineDelegate<void(const struct FActiveGameplayEffectHandle& Handle, const struct FGameplayEffectSpec& Spec, const struct FGameplayEffectRemovalInfo& RemovalInfo)> OnEffectRemoved; // 0x0038(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPrivate)
	class UAbilitySystemComponent*                ASC;                                               // 0x0048(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_50[0x18];                                      // 0x0050(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UAsyncTaskAnyEffectRemoved* ListenForAnyEffectRemoved(class UAbilitySystemComponent* AbilitySystemComponent);

	void EndTask();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AsyncTaskAnyEffectRemoved">();
	}
	static class UAsyncTaskAnyEffectRemoved* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAsyncTaskAnyEffectRemoved>();
	}
};
static_assert(alignof(UAsyncTaskAnyEffectRemoved) == 0x000008, "Wrong alignment on UAsyncTaskAnyEffectRemoved");
static_assert(sizeof(UAsyncTaskAnyEffectRemoved) == 0x000068, "Wrong size on UAsyncTaskAnyEffectRemoved");
static_assert(offsetof(UAsyncTaskAnyEffectRemoved, OnEffectRemoved) == 0x000038, "Member 'UAsyncTaskAnyEffectRemoved::OnEffectRemoved' has a wrong offset!");
static_assert(offsetof(UAsyncTaskAnyEffectRemoved, ASC) == 0x000048, "Member 'UAsyncTaskAnyEffectRemoved::ASC' has a wrong offset!");

// Class KuroGAS.AsyncTaskAnyEffectStackChanged
// 0x0030 (0x0068 - 0x0038)
class UAsyncTaskAnyEffectStackChanged final : public UBlueprintAsyncActionBase
{
public:
	TMulticastInlineDelegate<void(const struct FActiveGameplayEffectHandle& Handle, const int32 NewStack, const int32 OldStack, bool bPremature)> OnStackChanged; // 0x0038(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPrivate)
	class UAbilitySystemComponent*                AbilityComp;                                       // 0x0048(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_50[0x18];                                      // 0x0050(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UAsyncTaskAnyEffectStackChanged* ListenForAnyEffectStackChanged(class UAbilitySystemComponent* AbilityComp_0);

	void EndTask();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AsyncTaskAnyEffectStackChanged">();
	}
	static class UAsyncTaskAnyEffectStackChanged* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAsyncTaskAnyEffectStackChanged>();
	}
};
static_assert(alignof(UAsyncTaskAnyEffectStackChanged) == 0x000008, "Wrong alignment on UAsyncTaskAnyEffectStackChanged");
static_assert(sizeof(UAsyncTaskAnyEffectStackChanged) == 0x000068, "Wrong size on UAsyncTaskAnyEffectStackChanged");
static_assert(offsetof(UAsyncTaskAnyEffectStackChanged, OnStackChanged) == 0x000038, "Member 'UAsyncTaskAnyEffectStackChanged::OnStackChanged' has a wrong offset!");
static_assert(offsetof(UAsyncTaskAnyEffectStackChanged, AbilityComp) == 0x000048, "Member 'UAsyncTaskAnyEffectStackChanged::AbilityComp' has a wrong offset!");

// Class KuroGAS.AsyncTaskEffectApplied
// 0x0030 (0x0068 - 0x0038)
class UAsyncTaskEffectApplied final : public UBlueprintAsyncActionBase
{
public:
	TMulticastInlineDelegate<void(const struct FActiveGameplayEffectHandle& ActiveHandle)> OnEffectApplied; // 0x0038(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPrivate)
	class UAbilitySystemComponent*                ASC;                                               // 0x0048(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_50[0x18];                                      // 0x0050(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UAsyncTaskEffectApplied* ListenForEffectApplied(class UAbilitySystemComponent* AbilitySystemComponent, const struct FGameplayTag& EffectGameplayTag, const struct FGameplayTag& IgnoreGameplayTag);

	void EndTask();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AsyncTaskEffectApplied">();
	}
	static class UAsyncTaskEffectApplied* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAsyncTaskEffectApplied>();
	}
};
static_assert(alignof(UAsyncTaskEffectApplied) == 0x000008, "Wrong alignment on UAsyncTaskEffectApplied");
static_assert(sizeof(UAsyncTaskEffectApplied) == 0x000068, "Wrong size on UAsyncTaskEffectApplied");
static_assert(offsetof(UAsyncTaskEffectApplied, OnEffectApplied) == 0x000038, "Member 'UAsyncTaskEffectApplied::OnEffectApplied' has a wrong offset!");
static_assert(offsetof(UAsyncTaskEffectApplied, ASC) == 0x000048, "Member 'UAsyncTaskEffectApplied::ASC' has a wrong offset!");

// Class KuroGAS.AsyncTaskEffectDebugString
// 0x0018 (0x0050 - 0x0038)
class UAsyncTaskEffectDebugString final : public UBlueprintAsyncActionBase
{
public:
	TMulticastInlineDelegate<void(const class FString& DebugInfo)> OnAnyGameplayEffectExecuted;      // 0x0038(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPrivate)
	class UAbilitySystemComponent*                ASC;                                               // 0x0048(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UAsyncTaskEffectDebugString* ListenForGameplayEffectExecutedDebugString(class UAbilitySystemComponent* AbilitySystemComponent);

	void EndTask();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AsyncTaskEffectDebugString">();
	}
	static class UAsyncTaskEffectDebugString* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAsyncTaskEffectDebugString>();
	}
};
static_assert(alignof(UAsyncTaskEffectDebugString) == 0x000008, "Wrong alignment on UAsyncTaskEffectDebugString");
static_assert(sizeof(UAsyncTaskEffectDebugString) == 0x000050, "Wrong size on UAsyncTaskEffectDebugString");
static_assert(offsetof(UAsyncTaskEffectDebugString, OnAnyGameplayEffectExecuted) == 0x000038, "Member 'UAsyncTaskEffectDebugString::OnAnyGameplayEffectExecuted' has a wrong offset!");
static_assert(offsetof(UAsyncTaskEffectDebugString, ASC) == 0x000048, "Member 'UAsyncTaskEffectDebugString::ASC' has a wrong offset!");

// Class KuroGAS.AsyncTaskEffectInhibitionChanged
// 0x0020 (0x0058 - 0x0038)
class UAsyncTaskEffectInhibitionChanged final : public UBlueprintAsyncActionBase
{
public:
	TMulticastInlineDelegate<void(bool IsInhibited)> OnInhibitionChanged;                            // 0x0038(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_48[0x10];                                      // 0x0048(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UAsyncTaskEffectInhibitionChanged* ListenForInhibitionChanged(const struct FActiveGameplayEffectHandle& Handle);

	void EndTask();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AsyncTaskEffectInhibitionChanged">();
	}
	static class UAsyncTaskEffectInhibitionChanged* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAsyncTaskEffectInhibitionChanged>();
	}
};
static_assert(alignof(UAsyncTaskEffectInhibitionChanged) == 0x000008, "Wrong alignment on UAsyncTaskEffectInhibitionChanged");
static_assert(sizeof(UAsyncTaskEffectInhibitionChanged) == 0x000058, "Wrong size on UAsyncTaskEffectInhibitionChanged");
static_assert(offsetof(UAsyncTaskEffectInhibitionChanged, OnInhibitionChanged) == 0x000038, "Member 'UAsyncTaskEffectInhibitionChanged::OnInhibitionChanged' has a wrong offset!");

// Class KuroGAS.AsyncTaskEffectStackChanged
// 0x0020 (0x0058 - 0x0038)
class UAsyncTaskEffectStackChanged final : public UBlueprintAsyncActionBase
{
public:
	TMulticastInlineDelegate<void(int32 NewStackCount, int32 PreviousStackCount, bool bPremature)> OnStackChanged; // 0x0038(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_48[0x10];                                      // 0x0048(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UAsyncTaskEffectStackChanged* ListenForStackChanged(const struct FActiveGameplayEffectHandle& Handle);

	void EndTask();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AsyncTaskEffectStackChanged">();
	}
	static class UAsyncTaskEffectStackChanged* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAsyncTaskEffectStackChanged>();
	}
};
static_assert(alignof(UAsyncTaskEffectStackChanged) == 0x000008, "Wrong alignment on UAsyncTaskEffectStackChanged");
static_assert(sizeof(UAsyncTaskEffectStackChanged) == 0x000058, "Wrong size on UAsyncTaskEffectStackChanged");
static_assert(offsetof(UAsyncTaskEffectStackChanged, OnStackChanged) == 0x000038, "Member 'UAsyncTaskEffectStackChanged::OnStackChanged' has a wrong offset!");

// Class KuroGAS.AsyncTaskGameplayCueNotify
// 0x0018 (0x0050 - 0x0038)
class UAsyncTaskGameplayCueNotify final : public UBlueprintAsyncActionBase
{
public:
	TMulticastInlineDelegate<void(const struct FActiveGameplayEffectHandle& ActiveHandle, const struct FGameplayEffectContextHandle& ContextHandle, int64 GameplayCueId, bool bIsAdd)> GameplayCueEvent; // 0x0038(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPrivate)
	class UAbilitySystemComponent*                ASC;                                               // 0x0048(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UAsyncTaskGameplayCueNotify* ListenForGameplayCueNotify(class UAbilitySystemComponent* AbilitySystemComponent);

	void EndTask();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AsyncTaskGameplayCueNotify">();
	}
	static class UAsyncTaskGameplayCueNotify* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAsyncTaskGameplayCueNotify>();
	}
};
static_assert(alignof(UAsyncTaskGameplayCueNotify) == 0x000008, "Wrong alignment on UAsyncTaskGameplayCueNotify");
static_assert(sizeof(UAsyncTaskGameplayCueNotify) == 0x000050, "Wrong size on UAsyncTaskGameplayCueNotify");
static_assert(offsetof(UAsyncTaskGameplayCueNotify, GameplayCueEvent) == 0x000038, "Member 'UAsyncTaskGameplayCueNotify::GameplayCueEvent' has a wrong offset!");
static_assert(offsetof(UAsyncTaskGameplayCueNotify, ASC) == 0x000048, "Member 'UAsyncTaskGameplayCueNotify::ASC' has a wrong offset!");

// Class KuroGAS.AsyncTaskPlayMontageAndWait
// 0x0058 (0x0090 - 0x0038)
class UAsyncTaskPlayMontageAndWait final : public UBlueprintAsyncActionBase
{
public:
	TMulticastInlineDelegate<void(bool bInterrupted)> EndCallback;                                   // 0x0038(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPrivate)
	TMulticastInlineDelegate<void(bool bInterrupted)> BlendOutCallback;                              // 0x0048(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPrivate)
	bool                                          bShouldEmitOnEndedEvent;                           // 0x0058(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_59[0x7];                                       // 0x0059(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimInstance*                          AnimInstance;                                      // 0x0060(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimMontage*                           MontageToPlay;                                     // 0x0068(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_70[0x20];                                      // 0x0070(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UAsyncTaskPlayMontageAndWait* ListenForPlayMontage(class UAnimInstance* AnimInstance_0, class UAnimMontage* MontageToPlay_0, float PlayRate, float StartingPosition, class FName StartingSection);

	void EndTask();
	void StopMontage();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AsyncTaskPlayMontageAndWait">();
	}
	static class UAsyncTaskPlayMontageAndWait* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAsyncTaskPlayMontageAndWait>();
	}
};
static_assert(alignof(UAsyncTaskPlayMontageAndWait) == 0x000008, "Wrong alignment on UAsyncTaskPlayMontageAndWait");
static_assert(sizeof(UAsyncTaskPlayMontageAndWait) == 0x000090, "Wrong size on UAsyncTaskPlayMontageAndWait");
static_assert(offsetof(UAsyncTaskPlayMontageAndWait, EndCallback) == 0x000038, "Member 'UAsyncTaskPlayMontageAndWait::EndCallback' has a wrong offset!");
static_assert(offsetof(UAsyncTaskPlayMontageAndWait, BlendOutCallback) == 0x000048, "Member 'UAsyncTaskPlayMontageAndWait::BlendOutCallback' has a wrong offset!");
static_assert(offsetof(UAsyncTaskPlayMontageAndWait, bShouldEmitOnEndedEvent) == 0x000058, "Member 'UAsyncTaskPlayMontageAndWait::bShouldEmitOnEndedEvent' has a wrong offset!");
static_assert(offsetof(UAsyncTaskPlayMontageAndWait, AnimInstance) == 0x000060, "Member 'UAsyncTaskPlayMontageAndWait::AnimInstance' has a wrong offset!");
static_assert(offsetof(UAsyncTaskPlayMontageAndWait, MontageToPlay) == 0x000068, "Member 'UAsyncTaskPlayMontageAndWait::MontageToPlay' has a wrong offset!");

// Class KuroGAS.AsyncTaskTagCountChanged
// 0x0028 (0x0060 - 0x0038)
class UAsyncTaskTagCountChanged final : public UBlueprintAsyncActionBase
{
public:
	TMulticastInlineDelegate<void(int32 NewCount)> OnTagCountChanged;                                // 0x0038(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UAbilitySystemComponent*                ASC;                                               // 0x0048(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_50[0x10];                                      // 0x0050(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UAsyncTaskTagCountChanged* ListenForTagCountChanged(class UAbilitySystemComponent* AbilitySystemComponent, const struct FGameplayTag& Tag);

	void EndTask();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AsyncTaskTagCountChanged">();
	}
	static class UAsyncTaskTagCountChanged* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAsyncTaskTagCountChanged>();
	}
};
static_assert(alignof(UAsyncTaskTagCountChanged) == 0x000008, "Wrong alignment on UAsyncTaskTagCountChanged");
static_assert(sizeof(UAsyncTaskTagCountChanged) == 0x000060, "Wrong size on UAsyncTaskTagCountChanged");
static_assert(offsetof(UAsyncTaskTagCountChanged, OnTagCountChanged) == 0x000038, "Member 'UAsyncTaskTagCountChanged::OnTagCountChanged' has a wrong offset!");
static_assert(offsetof(UAsyncTaskTagCountChanged, ASC) == 0x000048, "Member 'UAsyncTaskTagCountChanged::ASC' has a wrong offset!");

// Class KuroGAS.AsyncTaskTagSignificantChanged
// 0x0028 (0x0060 - 0x0038)
class UAsyncTaskTagSignificantChanged final : public UBlueprintAsyncActionBase
{
public:
	TMulticastInlineDelegate<void(bool bTagExists)> OnTagSignificantChanged;                         // 0x0038(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UAbilitySystemComponent*                ASC;                                               // 0x0048(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_50[0x10];                                      // 0x0050(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UAsyncTaskTagSignificantChanged* ListenForTagSignificantChanged(class UAbilitySystemComponent* AbilitySystemComponent, const struct FGameplayTag& Tag);

	void EndTask();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AsyncTaskTagSignificantChanged">();
	}
	static class UAsyncTaskTagSignificantChanged* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAsyncTaskTagSignificantChanged>();
	}
};
static_assert(alignof(UAsyncTaskTagSignificantChanged) == 0x000008, "Wrong alignment on UAsyncTaskTagSignificantChanged");
static_assert(sizeof(UAsyncTaskTagSignificantChanged) == 0x000060, "Wrong size on UAsyncTaskTagSignificantChanged");
static_assert(offsetof(UAsyncTaskTagSignificantChanged, OnTagSignificantChanged) == 0x000038, "Member 'UAsyncTaskTagSignificantChanged::OnTagSignificantChanged' has a wrong offset!");
static_assert(offsetof(UAsyncTaskTagSignificantChanged, ASC) == 0x000048, "Member 'UAsyncTaskTagSignificantChanged::ASC' has a wrong offset!");

// Class KuroGAS.AsyncTaskWaitGameplayEvent
// 0x0018 (0x0050 - 0x0038)
class UAsyncTaskWaitGameplayEvent final : public UBlueprintAsyncActionBase
{
public:
	TMulticastInlineDelegate<void(const struct FGameplayTag& EventTag, const struct FGameplayEventData& Payload)> EventReceived; // 0x0038(0x0010)(ZeroConstructor, InstancedReference, NativeAccessSpecifierPrivate)
	class UAbilitySystemComponent*                AbilitySystemComponent;                            // 0x0048(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UAsyncTaskWaitGameplayEvent* ListenForGameplayEvent(class UAbilitySystemComponent* AbilitySystemComponent_0);

	void EndTask();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AsyncTaskWaitGameplayEvent">();
	}
	static class UAsyncTaskWaitGameplayEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAsyncTaskWaitGameplayEvent>();
	}
};
static_assert(alignof(UAsyncTaskWaitGameplayEvent) == 0x000008, "Wrong alignment on UAsyncTaskWaitGameplayEvent");
static_assert(sizeof(UAsyncTaskWaitGameplayEvent) == 0x000050, "Wrong size on UAsyncTaskWaitGameplayEvent");
static_assert(offsetof(UAsyncTaskWaitGameplayEvent, EventReceived) == 0x000038, "Member 'UAsyncTaskWaitGameplayEvent::EventReceived' has a wrong offset!");
static_assert(offsetof(UAsyncTaskWaitGameplayEvent, AbilitySystemComponent) == 0x000048, "Member 'UAsyncTaskWaitGameplayEvent::AbilitySystemComponent' has a wrong offset!");

// Class KuroGAS.BaseAbilitySystemComponent
// 0x0000 (0x1388 - 0x1388)
class UBaseAbilitySystemComponent final : public UAbilitySystemComponent
{
public:
	struct FActiveGameplayEffectHandle ApplyGeToSelfById(int64 GameplayEffectId, const struct FGameplayEffectContextHandle& Context, float Level, int32 ServerId);
	void BP_InitAbilityActorInfo(class FName AnimInstanceTag);
	void DestroyDynamicGameplayEffect(class UGameplayEffect* Ge);
	struct FGameplayAbilitySpecHandle GetAbility(const TSubclassOf<class UGameplayAbility>& Ability);
	int32 GetAbilityScopeLockCount();
	TArray<struct FActiveGameplayEffectHandle> GetActiveEffectsByGrantedTags(const struct FGameplayTag& Tag);
	TArray<struct FActiveGameplayEffectHandle> GetActiveEffectsById(const int64 GeId);
	int32 GetGameplayEffectCountById(int64 GameplayEffectId, class UAbilitySystemComponent* OptionalInstigatorFilterComponent, bool bEnforceOnGoingCheck);
	void InternalApplyModToAttribute(const int32 AttributeId, EGameplayModOp ModifierOp, float ModifierMagnitude);
	class UGameplayEffect* MakeDynamicGameplayEffect(const class FName GeName, const int64 GeId);
	bool OnAnyTagChangeInternal(const struct FGameplayTag& GameplayTag, int32 NewTagCount);
	void PauseActiveGameplayEffect(const struct FActiveGameplayEffectHandle& Handle, bool bPause);
	void PauseAllActiveGameplayEffects(bool bPause);
	void RemoveAbility(const struct FGameplayAbilitySpecHandle& Handle);
	int32 RemoveActiveEffectsById(const int64 GeId, int32 StackCount);
	void RemoveActiveEffectsByUniqueServerId(const int32 GameplayEffectSpecServerId);
	void ResetDilationForActiveEffects(const float TimeDilation);
	bool UpdateActiveGameplayEffectDurationHandle(const struct FActiveGameplayEffectHandle& Handle, const float DurationModifyValue);

	void AddGeGrantGa(class UGameplayEffect* Ge, const TSubclassOf<class UGameplayAbility>& Ability, int32 level, EGameplayEffectGrantedAbilityRemovePolicy RemovalPolicy) const;
	void AddGeModifierByAttributeId(class UGameplayEffect* Ge, const int32 ModifiedAttributeId, EAttributeBasedFloatCalculationType CalculationType, const EGameplayModOp ModOp, const int32 AttributeId, const struct FGameplayTag& DataTag, const struct FGameplayTag& DataTag2, EGameplayEffectAttributeCaptureSource InSource, bool InSnapShot) const;
	void AddGeModifierByKey(class UGameplayEffect* Ge, int32 ModifiedAttributeId, const EGameplayModOp ModOp, const int32 ModifierKey) const;
	void AddGeModifierByMMC(class UGameplayEffect* Ge, int32 ModifiedAttributeId, const EGameplayModOp ModOp, const TSubclassOf<class UGameplayModMagnitudeCalculation>& CalculationClassMagnitude) const;
	void AddGeModifierByTag(class UGameplayEffect* Ge, int32 ModifiedAttributeId, const EGameplayModOp ModOp, const struct FGameplayTag& ModifierTag) const;
	bool HasAllGameplayTag(const struct FGameplayTagContainer& GameplayTagContainer) const;
	bool HasAnyGameplayTag(const struct FGameplayTagContainer& GameplayTagContainer) const;
	bool HasGameplayTag(const struct FGameplayTag& GameplayTag) const;
	struct FGameplayEffectSpecHandle MakeDynamicOutgoingSpec(class UGameplayEffect* GameplayEffect, float Level, const struct FGameplayEffectContextHandle& Context, int32 GameplayEffectServerId) const;
	struct FGameplayEffectSpecHandle MakeRemoteDynamicOutgoingSpec(class UGameplayEffect* GameplayEffect, float Level, const struct FGameplayEffectContextHandle& Context, int32 GameplayEffectServerId, int32 InGeHandleId) const;
	void SetDurationMagnitudeByAttributeId(class UGameplayEffect* Ge, EAttributeBasedFloatCalculationType CalculationType, int32 AttributeId, const struct FGameplayTag& DataTag, const struct FGameplayTag& DataTag2, EGameplayEffectAttributeCaptureSource InSource, bool InSnapShot) const;
	void SetDurationMagnitudeByTag(class UGameplayEffect* Ge, const struct FGameplayTag& ModifierTag) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BaseAbilitySystemComponent">();
	}
	static class UBaseAbilitySystemComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBaseAbilitySystemComponent>();
	}
};
static_assert(alignof(UBaseAbilitySystemComponent) == 0x000008, "Wrong alignment on UBaseAbilitySystemComponent");
static_assert(sizeof(UBaseAbilitySystemComponent) == 0x001388, "Wrong size on UBaseAbilitySystemComponent");

// Class KuroGAS.BaseAttributeSet
// 0x0CD8 (0x0D10 - 0x0038)
class UBaseAttributeSet final : public UAttributeSet
{
public:
	struct FGameplayAttributeData                 Lv;                                                // 0x0038(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 LifeMax;                                           // 0x0050(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 Life;                                              // 0x0068(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 Sheild;                                            // 0x0080(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 SheildDamageChange;                                // 0x0098(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 SheildDamageReduce;                                // 0x00B0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 Atk;                                               // 0x00C8(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 Crit;                                              // 0x00E0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 CritDamage;                                        // 0x00F8(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 Def;                                               // 0x0110(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 EnergyEfficiency;                                  // 0x0128(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 CDReduse;                                          // 0x0140(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 ReactionEfficiency;                                // 0x0158(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 DamageChangeNormalSkill;                           // 0x0170(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 DamageChange;                                      // 0x0188(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 DamageReduce;                                      // 0x01A0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 DamageChangeAuto;                                  // 0x01B8(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 DamageChangeCast;                                  // 0x01D0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 DamageChangeUltra;                                 // 0x01E8(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 DamageChangeQTE;                                   // 0x0200(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 DamageChangePhys;                                  // 0x0218(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 DamageChangeElement1;                              // 0x0230(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 DamageChangeElement2;                              // 0x0248(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 DamageChangeElement3;                              // 0x0260(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 DamageChangeElement4;                              // 0x0278(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 DamageChangeElement5;                              // 0x0290(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 DamageChangeElement6;                              // 0x02A8(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 DamageResistancePhys;                              // 0x02C0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 DamageResistanceElement1;                          // 0x02D8(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 DamageResistanceElement2;                          // 0x02F0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 DamageResistanceElement3;                          // 0x0308(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 DamageResistanceElement4;                          // 0x0320(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 DamageResistanceElement5;                          // 0x0338(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 DamageResistanceElement6;                          // 0x0350(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 HealChange;                                        // 0x0368(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 HealedChange;                                      // 0x0380(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 DamageReducePhys;                                  // 0x0398(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 DamageReduceElement1;                              // 0x03B0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 DamageReduceElement2;                              // 0x03C8(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 DamageReduceElement3;                              // 0x03E0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 DamageReduceElement4;                              // 0x03F8(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 DamageReduceElement5;                              // 0x0410(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 DamageReduceElement6;                              // 0x0428(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 ReactionChange1;                                   // 0x0440(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 ReactionChange2;                                   // 0x0458(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 ReactionChange3;                                   // 0x0470(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 ReactionChange4;                                   // 0x0488(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 ReactionChange5;                                   // 0x04A0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 ReactionChange6;                                   // 0x04B8(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 ReactionChange7;                                   // 0x04D0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 ReactionChange8;                                   // 0x04E8(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 ReactionChange9;                                   // 0x0500(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 ReactionChange10;                                  // 0x0518(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 ReactionChange11;                                  // 0x0530(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 ReactionChange12;                                  // 0x0548(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 ReactionChange13;                                  // 0x0560(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 ReactionChange14;                                  // 0x0578(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 ReactionChange15;                                  // 0x0590(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 EnergyMax;                                         // 0x05A8(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 Energy;                                            // 0x05C0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 SpecialEnergy1Max;                                 // 0x05D8(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 SpecialEnergy1;                                    // 0x05F0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 SpecialEnergy2Max;                                 // 0x0608(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 SpecialEnergy2;                                    // 0x0620(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 SpecialEnergy3Max;                                 // 0x0638(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 SpecialEnergy3;                                    // 0x0650(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 SpecialEnergy4Max;                                 // 0x0668(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 SpecialEnergy4;                                    // 0x0680(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 StrengthMax;                                       // 0x0698(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 Strength;                                          // 0x06B0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 StrengthRecover;                                   // 0x06C8(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 StrengthPunishTime;                                // 0x06E0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 StrengthRun;                                       // 0x06F8(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 StrengthSwim;                                      // 0x0710(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 StrengthFastSwim;                                  // 0x0728(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 StrengthClimb;                                     // 0x0740(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 StrengthFastClimb;                                 // 0x0758(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 HardnessMax;                                       // 0x0770(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 Hardness;                                          // 0x0788(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 HardnessRecover;                                   // 0x07A0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 HardnessPunishTime;                                // 0x07B8(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 HardnessChange;                                    // 0x07D0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 HardnessReduce;                                    // 0x07E8(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 ToughMax;                                          // 0x0800(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 Tough;                                             // 0x0818(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 ToughRecover;                                      // 0x0830(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 ToughChange;                                       // 0x0848(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 ToughReduce;                                       // 0x0860(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 ElementPower1;                                     // 0x0878(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 ElementPower2;                                     // 0x0890(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 ElementPower3;                                     // 0x08A8(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 ElementPower4;                                     // 0x08C0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 ElementPower5;                                     // 0x08D8(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 ElementPower6;                                     // 0x08F0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 SpecialDamageChange;                               // 0x0908(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 StrengthFastClimbCost;                             // 0x0920(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 ElementPropertyType;                               // 0x0938(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 WeakTime;                                          // 0x0950(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 IgnoreDefRate;                                     // 0x0968(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 IgnoreDamageResistancePhys;                        // 0x0980(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 IgnoreDamageResistanceElement1;                    // 0x0998(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 IgnoreDamageResistanceElement2;                    // 0x09B0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 IgnoreDamageResistanceElement3;                    // 0x09C8(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 IgnoreDamageResistanceElement4;                    // 0x09E0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 IgnoreDamageResistanceElement5;                    // 0x09F8(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 IgnoreDamageResistanceElement6;                    // 0x0A10(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 SkillToughRatio;                                   // 0x0A28(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 StrengthClimbJump;                                 // 0x0A40(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 StrengthGliding;                                   // 0x0A58(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 Mass;                                              // 0x0A70(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 BrakingFrictionFactor;                             // 0x0A88(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 GravityScale;                                      // 0x0AA0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 SpeedRatio;                                        // 0x0AB8(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 DamageChangePhantom;                               // 0x0AD0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 AutoAttackSpeed;                                   // 0x0AE8(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 CastAttackSpeed;                                   // 0x0B00(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 StatusBuildUp1Max;                                 // 0x0B18(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 StatusBuildUp1;                                    // 0x0B30(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 StatusBuildUp2Max;                                 // 0x0B48(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 StatusBuildUp2;                                    // 0x0B60(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 StatusBuildUp3Max;                                 // 0x0B78(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 StatusBuildUp3;                                    // 0x0B90(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 StatusBuildUp4Max;                                 // 0x0BA8(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 StatusBuildUp4;                                    // 0x0BC0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 StatusBuildUp5Max;                                 // 0x0BD8(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 StatusBuildUp5;                                    // 0x0BF0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 RageMax;                                           // 0x0C08(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 Rage;                                              // 0x0C20(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 RageRecover;                                       // 0x0C38(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 RagePunishTime;                                    // 0x0C50(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 RageChange;                                        // 0x0C68(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 RageReduce;                                        // 0x0C80(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 ToughRecoverDelayTime;                             // 0x0C98(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	uint8                                         Pad_CB0[0x60];                                     // 0x0CB0(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static void SetAttackSpeedMax(float InMaxSpeed);
	static void SetElementPowerMax(float InElementPowerMax);
	static void SetReduceMax(float InReduceMax);

	bool CopyAllAttribute(class UBaseAttributeSet* AttributeSet);
	float GetAttributeBaseValueById(int32 AttributeType);
	float GetAttributeCurrentValueById(int32 AttributeType);
	bool GetAttributeData(int32 AttributeType, struct FGameplayAttributeData* AttributeData);
	void SetAttributeIntervalLock(const int32 AttributeId, const EIntervalLockType LockType, float UpperBoundPercentage, float UpperBoundOffset, float LowerBoundPercentage, float LowerBoundOffset);
	void SetAttributeValue(int32 AttributeType, float BaseValue, float CurrentValue);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BaseAttributeSet">();
	}
	static class UBaseAttributeSet* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBaseAttributeSet>();
	}
};
static_assert(alignof(UBaseAttributeSet) == 0x000008, "Wrong alignment on UBaseAttributeSet");
static_assert(sizeof(UBaseAttributeSet) == 0x000D10, "Wrong size on UBaseAttributeSet");
static_assert(offsetof(UBaseAttributeSet, Lv) == 0x000038, "Member 'UBaseAttributeSet::Lv' has a wrong offset!");
static_assert(offsetof(UBaseAttributeSet, LifeMax) == 0x000050, "Member 'UBaseAttributeSet::LifeMax' has a wrong offset!");
static_assert(offsetof(UBaseAttributeSet, Life) == 0x000068, "Member 'UBaseAttributeSet::Life' has a wrong offset!");
static_assert(offsetof(UBaseAttributeSet, Sheild) == 0x000080, "Member 'UBaseAttributeSet::Sheild' has a wrong offset!");
static_assert(offsetof(UBaseAttributeSet, SheildDamageChange) == 0x000098, "Member 'UBaseAttributeSet::SheildDamageChange' has a wrong offset!");
static_assert(offsetof(UBaseAttributeSet, SheildDamageReduce) == 0x0000B0, "Member 'UBaseAttributeSet::SheildDamageReduce' has a wrong offset!");
static_assert(offsetof(UBaseAttributeSet, Atk) == 0x0000C8, "Member 'UBaseAttributeSet::Atk' has a wrong offset!");
static_assert(offsetof(UBaseAttributeSet, Crit) == 0x0000E0, "Member 'UBaseAttributeSet::Crit' has a wrong offset!");
static_assert(offsetof(UBaseAttributeSet, CritDamage) == 0x0000F8, "Member 'UBaseAttributeSet::CritDamage' has a wrong offset!");
static_assert(offsetof(UBaseAttributeSet, Def) == 0x000110, "Member 'UBaseAttributeSet::Def' has a wrong offset!");
static_assert(offsetof(UBaseAttributeSet, EnergyEfficiency) == 0x000128, "Member 'UBaseAttributeSet::EnergyEfficiency' has a wrong offset!");
static_assert(offsetof(UBaseAttributeSet, CDReduse) == 0x000140, "Member 'UBaseAttributeSet::CDReduse' has a wrong offset!");
static_assert(offsetof(UBaseAttributeSet, ReactionEfficiency) == 0x000158, "Member 'UBaseAttributeSet::ReactionEfficiency' has a wrong offset!");
static_assert(offsetof(UBaseAttributeSet, DamageChangeNormalSkill) == 0x000170, "Member 'UBaseAttributeSet::DamageChangeNormalSkill' has a wrong offset!");
static_assert(offsetof(UBaseAttributeSet, DamageChange) == 0x000188, "Member 'UBaseAttributeSet::DamageChange' has a wrong offset!");
static_assert(offsetof(UBaseAttributeSet, DamageReduce) == 0x0001A0, "Member 'UBaseAttributeSet::DamageReduce' has a wrong offset!");
static_assert(offsetof(UBaseAttributeSet, DamageChangeAuto) == 0x0001B8, "Member 'UBaseAttributeSet::DamageChangeAuto' has a wrong offset!");
static_assert(offsetof(UBaseAttributeSet, DamageChangeCast) == 0x0001D0, "Member 'UBaseAttributeSet::DamageChangeCast' has a wrong offset!");
static_assert(offsetof(UBaseAttributeSet, DamageChangeUltra) == 0x0001E8, "Member 'UBaseAttributeSet::DamageChangeUltra' has a wrong offset!");
static_assert(offsetof(UBaseAttributeSet, DamageChangeQTE) == 0x000200, "Member 'UBaseAttributeSet::DamageChangeQTE' has a wrong offset!");
static_assert(offsetof(UBaseAttributeSet, DamageChangePhys) == 0x000218, "Member 'UBaseAttributeSet::DamageChangePhys' has a wrong offset!");
static_assert(offsetof(UBaseAttributeSet, DamageChangeElement1) == 0x000230, "Member 'UBaseAttributeSet::DamageChangeElement1' has a wrong offset!");
static_assert(offsetof(UBaseAttributeSet, DamageChangeElement2) == 0x000248, "Member 'UBaseAttributeSet::DamageChangeElement2' has a wrong offset!");
static_assert(offsetof(UBaseAttributeSet, DamageChangeElement3) == 0x000260, "Member 'UBaseAttributeSet::DamageChangeElement3' has a wrong offset!");
static_assert(offsetof(UBaseAttributeSet, DamageChangeElement4) == 0x000278, "Member 'UBaseAttributeSet::DamageChangeElement4' has a wrong offset!");
static_assert(offsetof(UBaseAttributeSet, DamageChangeElement5) == 0x000290, "Member 'UBaseAttributeSet::DamageChangeElement5' has a wrong offset!");
static_assert(offsetof(UBaseAttributeSet, DamageChangeElement6) == 0x0002A8, "Member 'UBaseAttributeSet::DamageChangeElement6' has a wrong offset!");
static_assert(offsetof(UBaseAttributeSet, DamageResistancePhys) == 0x0002C0, "Member 'UBaseAttributeSet::DamageResistancePhys' has a wrong offset!");
static_assert(offsetof(UBaseAttributeSet, DamageResistanceElement1) == 0x0002D8, "Member 'UBaseAttributeSet::DamageResistanceElement1' has a wrong offset!");
static_assert(offsetof(UBaseAttributeSet, DamageResistanceElement2) == 0x0002F0, "Member 'UBaseAttributeSet::DamageResistanceElement2' has a wrong offset!");
static_assert(offsetof(UBaseAttributeSet, DamageResistanceElement3) == 0x000308, "Member 'UBaseAttributeSet::DamageResistanceElement3' has a wrong offset!");
static_assert(offsetof(UBaseAttributeSet, DamageResistanceElement4) == 0x000320, "Member 'UBaseAttributeSet::DamageResistanceElement4' has a wrong offset!");
static_assert(offsetof(UBaseAttributeSet, DamageResistanceElement5) == 0x000338, "Member 'UBaseAttributeSet::DamageResistanceElement5' has a wrong offset!");
static_assert(offsetof(UBaseAttributeSet, DamageResistanceElement6) == 0x000350, "Member 'UBaseAttributeSet::DamageResistanceElement6' has a wrong offset!");
static_assert(offsetof(UBaseAttributeSet, HealChange) == 0x000368, "Member 'UBaseAttributeSet::HealChange' has a wrong offset!");
static_assert(offsetof(UBaseAttributeSet, HealedChange) == 0x000380, "Member 'UBaseAttributeSet::HealedChange' has a wrong offset!");
static_assert(offsetof(UBaseAttributeSet, DamageReducePhys) == 0x000398, "Member 'UBaseAttributeSet::DamageReducePhys' has a wrong offset!");
static_assert(offsetof(UBaseAttributeSet, DamageReduceElement1) == 0x0003B0, "Member 'UBaseAttributeSet::DamageReduceElement1' has a wrong offset!");
static_assert(offsetof(UBaseAttributeSet, DamageReduceElement2) == 0x0003C8, "Member 'UBaseAttributeSet::DamageReduceElement2' has a wrong offset!");
static_assert(offsetof(UBaseAttributeSet, DamageReduceElement3) == 0x0003E0, "Member 'UBaseAttributeSet::DamageReduceElement3' has a wrong offset!");
static_assert(offsetof(UBaseAttributeSet, DamageReduceElement4) == 0x0003F8, "Member 'UBaseAttributeSet::DamageReduceElement4' has a wrong offset!");
static_assert(offsetof(UBaseAttributeSet, DamageReduceElement5) == 0x000410, "Member 'UBaseAttributeSet::DamageReduceElement5' has a wrong offset!");
static_assert(offsetof(UBaseAttributeSet, DamageReduceElement6) == 0x000428, "Member 'UBaseAttributeSet::DamageReduceElement6' has a wrong offset!");
static_assert(offsetof(UBaseAttributeSet, ReactionChange1) == 0x000440, "Member 'UBaseAttributeSet::ReactionChange1' has a wrong offset!");
static_assert(offsetof(UBaseAttributeSet, ReactionChange2) == 0x000458, "Member 'UBaseAttributeSet::ReactionChange2' has a wrong offset!");
static_assert(offsetof(UBaseAttributeSet, ReactionChange3) == 0x000470, "Member 'UBaseAttributeSet::ReactionChange3' has a wrong offset!");
static_assert(offsetof(UBaseAttributeSet, ReactionChange4) == 0x000488, "Member 'UBaseAttributeSet::ReactionChange4' has a wrong offset!");
static_assert(offsetof(UBaseAttributeSet, ReactionChange5) == 0x0004A0, "Member 'UBaseAttributeSet::ReactionChange5' has a wrong offset!");
static_assert(offsetof(UBaseAttributeSet, ReactionChange6) == 0x0004B8, "Member 'UBaseAttributeSet::ReactionChange6' has a wrong offset!");
static_assert(offsetof(UBaseAttributeSet, ReactionChange7) == 0x0004D0, "Member 'UBaseAttributeSet::ReactionChange7' has a wrong offset!");
static_assert(offsetof(UBaseAttributeSet, ReactionChange8) == 0x0004E8, "Member 'UBaseAttributeSet::ReactionChange8' has a wrong offset!");
static_assert(offsetof(UBaseAttributeSet, ReactionChange9) == 0x000500, "Member 'UBaseAttributeSet::ReactionChange9' has a wrong offset!");
static_assert(offsetof(UBaseAttributeSet, ReactionChange10) == 0x000518, "Member 'UBaseAttributeSet::ReactionChange10' has a wrong offset!");
static_assert(offsetof(UBaseAttributeSet, ReactionChange11) == 0x000530, "Member 'UBaseAttributeSet::ReactionChange11' has a wrong offset!");
static_assert(offsetof(UBaseAttributeSet, ReactionChange12) == 0x000548, "Member 'UBaseAttributeSet::ReactionChange12' has a wrong offset!");
static_assert(offsetof(UBaseAttributeSet, ReactionChange13) == 0x000560, "Member 'UBaseAttributeSet::ReactionChange13' has a wrong offset!");
static_assert(offsetof(UBaseAttributeSet, ReactionChange14) == 0x000578, "Member 'UBaseAttributeSet::ReactionChange14' has a wrong offset!");
static_assert(offsetof(UBaseAttributeSet, ReactionChange15) == 0x000590, "Member 'UBaseAttributeSet::ReactionChange15' has a wrong offset!");
static_assert(offsetof(UBaseAttributeSet, EnergyMax) == 0x0005A8, "Member 'UBaseAttributeSet::EnergyMax' has a wrong offset!");
static_assert(offsetof(UBaseAttributeSet, Energy) == 0x0005C0, "Member 'UBaseAttributeSet::Energy' has a wrong offset!");
static_assert(offsetof(UBaseAttributeSet, SpecialEnergy1Max) == 0x0005D8, "Member 'UBaseAttributeSet::SpecialEnergy1Max' has a wrong offset!");
static_assert(offsetof(UBaseAttributeSet, SpecialEnergy1) == 0x0005F0, "Member 'UBaseAttributeSet::SpecialEnergy1' has a wrong offset!");
static_assert(offsetof(UBaseAttributeSet, SpecialEnergy2Max) == 0x000608, "Member 'UBaseAttributeSet::SpecialEnergy2Max' has a wrong offset!");
static_assert(offsetof(UBaseAttributeSet, SpecialEnergy2) == 0x000620, "Member 'UBaseAttributeSet::SpecialEnergy2' has a wrong offset!");
static_assert(offsetof(UBaseAttributeSet, SpecialEnergy3Max) == 0x000638, "Member 'UBaseAttributeSet::SpecialEnergy3Max' has a wrong offset!");
static_assert(offsetof(UBaseAttributeSet, SpecialEnergy3) == 0x000650, "Member 'UBaseAttributeSet::SpecialEnergy3' has a wrong offset!");
static_assert(offsetof(UBaseAttributeSet, SpecialEnergy4Max) == 0x000668, "Member 'UBaseAttributeSet::SpecialEnergy4Max' has a wrong offset!");
static_assert(offsetof(UBaseAttributeSet, SpecialEnergy4) == 0x000680, "Member 'UBaseAttributeSet::SpecialEnergy4' has a wrong offset!");
static_assert(offsetof(UBaseAttributeSet, StrengthMax) == 0x000698, "Member 'UBaseAttributeSet::StrengthMax' has a wrong offset!");
static_assert(offsetof(UBaseAttributeSet, Strength) == 0x0006B0, "Member 'UBaseAttributeSet::Strength' has a wrong offset!");
static_assert(offsetof(UBaseAttributeSet, StrengthRecover) == 0x0006C8, "Member 'UBaseAttributeSet::StrengthRecover' has a wrong offset!");
static_assert(offsetof(UBaseAttributeSet, StrengthPunishTime) == 0x0006E0, "Member 'UBaseAttributeSet::StrengthPunishTime' has a wrong offset!");
static_assert(offsetof(UBaseAttributeSet, StrengthRun) == 0x0006F8, "Member 'UBaseAttributeSet::StrengthRun' has a wrong offset!");
static_assert(offsetof(UBaseAttributeSet, StrengthSwim) == 0x000710, "Member 'UBaseAttributeSet::StrengthSwim' has a wrong offset!");
static_assert(offsetof(UBaseAttributeSet, StrengthFastSwim) == 0x000728, "Member 'UBaseAttributeSet::StrengthFastSwim' has a wrong offset!");
static_assert(offsetof(UBaseAttributeSet, StrengthClimb) == 0x000740, "Member 'UBaseAttributeSet::StrengthClimb' has a wrong offset!");
static_assert(offsetof(UBaseAttributeSet, StrengthFastClimb) == 0x000758, "Member 'UBaseAttributeSet::StrengthFastClimb' has a wrong offset!");
static_assert(offsetof(UBaseAttributeSet, HardnessMax) == 0x000770, "Member 'UBaseAttributeSet::HardnessMax' has a wrong offset!");
static_assert(offsetof(UBaseAttributeSet, Hardness) == 0x000788, "Member 'UBaseAttributeSet::Hardness' has a wrong offset!");
static_assert(offsetof(UBaseAttributeSet, HardnessRecover) == 0x0007A0, "Member 'UBaseAttributeSet::HardnessRecover' has a wrong offset!");
static_assert(offsetof(UBaseAttributeSet, HardnessPunishTime) == 0x0007B8, "Member 'UBaseAttributeSet::HardnessPunishTime' has a wrong offset!");
static_assert(offsetof(UBaseAttributeSet, HardnessChange) == 0x0007D0, "Member 'UBaseAttributeSet::HardnessChange' has a wrong offset!");
static_assert(offsetof(UBaseAttributeSet, HardnessReduce) == 0x0007E8, "Member 'UBaseAttributeSet::HardnessReduce' has a wrong offset!");
static_assert(offsetof(UBaseAttributeSet, ToughMax) == 0x000800, "Member 'UBaseAttributeSet::ToughMax' has a wrong offset!");
static_assert(offsetof(UBaseAttributeSet, Tough) == 0x000818, "Member 'UBaseAttributeSet::Tough' has a wrong offset!");
static_assert(offsetof(UBaseAttributeSet, ToughRecover) == 0x000830, "Member 'UBaseAttributeSet::ToughRecover' has a wrong offset!");
static_assert(offsetof(UBaseAttributeSet, ToughChange) == 0x000848, "Member 'UBaseAttributeSet::ToughChange' has a wrong offset!");
static_assert(offsetof(UBaseAttributeSet, ToughReduce) == 0x000860, "Member 'UBaseAttributeSet::ToughReduce' has a wrong offset!");
static_assert(offsetof(UBaseAttributeSet, ElementPower1) == 0x000878, "Member 'UBaseAttributeSet::ElementPower1' has a wrong offset!");
static_assert(offsetof(UBaseAttributeSet, ElementPower2) == 0x000890, "Member 'UBaseAttributeSet::ElementPower2' has a wrong offset!");
static_assert(offsetof(UBaseAttributeSet, ElementPower3) == 0x0008A8, "Member 'UBaseAttributeSet::ElementPower3' has a wrong offset!");
static_assert(offsetof(UBaseAttributeSet, ElementPower4) == 0x0008C0, "Member 'UBaseAttributeSet::ElementPower4' has a wrong offset!");
static_assert(offsetof(UBaseAttributeSet, ElementPower5) == 0x0008D8, "Member 'UBaseAttributeSet::ElementPower5' has a wrong offset!");
static_assert(offsetof(UBaseAttributeSet, ElementPower6) == 0x0008F0, "Member 'UBaseAttributeSet::ElementPower6' has a wrong offset!");
static_assert(offsetof(UBaseAttributeSet, SpecialDamageChange) == 0x000908, "Member 'UBaseAttributeSet::SpecialDamageChange' has a wrong offset!");
static_assert(offsetof(UBaseAttributeSet, StrengthFastClimbCost) == 0x000920, "Member 'UBaseAttributeSet::StrengthFastClimbCost' has a wrong offset!");
static_assert(offsetof(UBaseAttributeSet, ElementPropertyType) == 0x000938, "Member 'UBaseAttributeSet::ElementPropertyType' has a wrong offset!");
static_assert(offsetof(UBaseAttributeSet, WeakTime) == 0x000950, "Member 'UBaseAttributeSet::WeakTime' has a wrong offset!");
static_assert(offsetof(UBaseAttributeSet, IgnoreDefRate) == 0x000968, "Member 'UBaseAttributeSet::IgnoreDefRate' has a wrong offset!");
static_assert(offsetof(UBaseAttributeSet, IgnoreDamageResistancePhys) == 0x000980, "Member 'UBaseAttributeSet::IgnoreDamageResistancePhys' has a wrong offset!");
static_assert(offsetof(UBaseAttributeSet, IgnoreDamageResistanceElement1) == 0x000998, "Member 'UBaseAttributeSet::IgnoreDamageResistanceElement1' has a wrong offset!");
static_assert(offsetof(UBaseAttributeSet, IgnoreDamageResistanceElement2) == 0x0009B0, "Member 'UBaseAttributeSet::IgnoreDamageResistanceElement2' has a wrong offset!");
static_assert(offsetof(UBaseAttributeSet, IgnoreDamageResistanceElement3) == 0x0009C8, "Member 'UBaseAttributeSet::IgnoreDamageResistanceElement3' has a wrong offset!");
static_assert(offsetof(UBaseAttributeSet, IgnoreDamageResistanceElement4) == 0x0009E0, "Member 'UBaseAttributeSet::IgnoreDamageResistanceElement4' has a wrong offset!");
static_assert(offsetof(UBaseAttributeSet, IgnoreDamageResistanceElement5) == 0x0009F8, "Member 'UBaseAttributeSet::IgnoreDamageResistanceElement5' has a wrong offset!");
static_assert(offsetof(UBaseAttributeSet, IgnoreDamageResistanceElement6) == 0x000A10, "Member 'UBaseAttributeSet::IgnoreDamageResistanceElement6' has a wrong offset!");
static_assert(offsetof(UBaseAttributeSet, SkillToughRatio) == 0x000A28, "Member 'UBaseAttributeSet::SkillToughRatio' has a wrong offset!");
static_assert(offsetof(UBaseAttributeSet, StrengthClimbJump) == 0x000A40, "Member 'UBaseAttributeSet::StrengthClimbJump' has a wrong offset!");
static_assert(offsetof(UBaseAttributeSet, StrengthGliding) == 0x000A58, "Member 'UBaseAttributeSet::StrengthGliding' has a wrong offset!");
static_assert(offsetof(UBaseAttributeSet, Mass) == 0x000A70, "Member 'UBaseAttributeSet::Mass' has a wrong offset!");
static_assert(offsetof(UBaseAttributeSet, BrakingFrictionFactor) == 0x000A88, "Member 'UBaseAttributeSet::BrakingFrictionFactor' has a wrong offset!");
static_assert(offsetof(UBaseAttributeSet, GravityScale) == 0x000AA0, "Member 'UBaseAttributeSet::GravityScale' has a wrong offset!");
static_assert(offsetof(UBaseAttributeSet, SpeedRatio) == 0x000AB8, "Member 'UBaseAttributeSet::SpeedRatio' has a wrong offset!");
static_assert(offsetof(UBaseAttributeSet, DamageChangePhantom) == 0x000AD0, "Member 'UBaseAttributeSet::DamageChangePhantom' has a wrong offset!");
static_assert(offsetof(UBaseAttributeSet, AutoAttackSpeed) == 0x000AE8, "Member 'UBaseAttributeSet::AutoAttackSpeed' has a wrong offset!");
static_assert(offsetof(UBaseAttributeSet, CastAttackSpeed) == 0x000B00, "Member 'UBaseAttributeSet::CastAttackSpeed' has a wrong offset!");
static_assert(offsetof(UBaseAttributeSet, StatusBuildUp1Max) == 0x000B18, "Member 'UBaseAttributeSet::StatusBuildUp1Max' has a wrong offset!");
static_assert(offsetof(UBaseAttributeSet, StatusBuildUp1) == 0x000B30, "Member 'UBaseAttributeSet::StatusBuildUp1' has a wrong offset!");
static_assert(offsetof(UBaseAttributeSet, StatusBuildUp2Max) == 0x000B48, "Member 'UBaseAttributeSet::StatusBuildUp2Max' has a wrong offset!");
static_assert(offsetof(UBaseAttributeSet, StatusBuildUp2) == 0x000B60, "Member 'UBaseAttributeSet::StatusBuildUp2' has a wrong offset!");
static_assert(offsetof(UBaseAttributeSet, StatusBuildUp3Max) == 0x000B78, "Member 'UBaseAttributeSet::StatusBuildUp3Max' has a wrong offset!");
static_assert(offsetof(UBaseAttributeSet, StatusBuildUp3) == 0x000B90, "Member 'UBaseAttributeSet::StatusBuildUp3' has a wrong offset!");
static_assert(offsetof(UBaseAttributeSet, StatusBuildUp4Max) == 0x000BA8, "Member 'UBaseAttributeSet::StatusBuildUp4Max' has a wrong offset!");
static_assert(offsetof(UBaseAttributeSet, StatusBuildUp4) == 0x000BC0, "Member 'UBaseAttributeSet::StatusBuildUp4' has a wrong offset!");
static_assert(offsetof(UBaseAttributeSet, StatusBuildUp5Max) == 0x000BD8, "Member 'UBaseAttributeSet::StatusBuildUp5Max' has a wrong offset!");
static_assert(offsetof(UBaseAttributeSet, StatusBuildUp5) == 0x000BF0, "Member 'UBaseAttributeSet::StatusBuildUp5' has a wrong offset!");
static_assert(offsetof(UBaseAttributeSet, RageMax) == 0x000C08, "Member 'UBaseAttributeSet::RageMax' has a wrong offset!");
static_assert(offsetof(UBaseAttributeSet, Rage) == 0x000C20, "Member 'UBaseAttributeSet::Rage' has a wrong offset!");
static_assert(offsetof(UBaseAttributeSet, RageRecover) == 0x000C38, "Member 'UBaseAttributeSet::RageRecover' has a wrong offset!");
static_assert(offsetof(UBaseAttributeSet, RagePunishTime) == 0x000C50, "Member 'UBaseAttributeSet::RagePunishTime' has a wrong offset!");
static_assert(offsetof(UBaseAttributeSet, RageChange) == 0x000C68, "Member 'UBaseAttributeSet::RageChange' has a wrong offset!");
static_assert(offsetof(UBaseAttributeSet, RageReduce) == 0x000C80, "Member 'UBaseAttributeSet::RageReduce' has a wrong offset!");
static_assert(offsetof(UBaseAttributeSet, ToughRecoverDelayTime) == 0x000C98, "Member 'UBaseAttributeSet::ToughRecoverDelayTime' has a wrong offset!");

// Class KuroGAS.BaseCharacter
// 0x00D0 (0x0680 - 0x05B0)
class ABaseCharacter : public ACharacter
{
public:
	struct FVectorDouble                          CachedActorLocation;                               // 0x05B0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               CachedActorRotation;                               // 0x05C8(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_5D4[0xC];                                      // 0x05D4(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FQuat                                  CachedActorQuat;                                   // 0x05E0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                CachedActorScale;                                  // 0x05F0(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5FC[0x4];                                      // 0x05FC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransformDouble                       CachedActorTransform;                              // 0x0600(0x0040)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                CachedActorUp;                                     // 0x0640(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                CachedActorForward;                                // 0x064C(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                CachedActorVelocity;                               // 0x0658(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EntityIdInternal;                                  // 0x0664(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInitializeAttributes;                             // 0x0668(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_669[0x7];                                      // 0x0669(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UBaseAttributeSet*                      AttributeSet;                                      // 0x0670(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBaseAbilitySystemComponent*            AbilitySystemComponent;                            // 0x0678(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void CreateAttribute();
	void InitializeAttributeSet();
	void PreInit();
	void RefreshCachedTransform();
	void RefreshCachedVelocity();
	bool SetActorLocationAndRotationExceptSkelMesh(const struct FVectorDouble& NewLocation, const struct FRotator& NewRotation, bool bSweep, struct FHitResult* SweepHitResult, bool bTeleport, bool bIgnoreOverlap);
	bool SetActorTransformExceptSkelMesh(const struct FTransformDouble& NewTransform, bool bSweep, struct FHitResult* SweepHitResult, bool bTeleport, bool bIgnoreOverlap);

	bool ContainsAllTag(const struct FGameplayTagContainer& TagToCheck) const;
	bool ContainsAnyTag(const struct FGameplayTagContainer& TagToCheck) const;
	bool ContainsTag(const struct FGameplayTag& TagToCheck) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BaseCharacter">();
	}
	static class ABaseCharacter* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABaseCharacter>();
	}
};
static_assert(alignof(ABaseCharacter) == 0x000010, "Wrong alignment on ABaseCharacter");
static_assert(sizeof(ABaseCharacter) == 0x000680, "Wrong size on ABaseCharacter");
static_assert(offsetof(ABaseCharacter, CachedActorLocation) == 0x0005B0, "Member 'ABaseCharacter::CachedActorLocation' has a wrong offset!");
static_assert(offsetof(ABaseCharacter, CachedActorRotation) == 0x0005C8, "Member 'ABaseCharacter::CachedActorRotation' has a wrong offset!");
static_assert(offsetof(ABaseCharacter, CachedActorQuat) == 0x0005E0, "Member 'ABaseCharacter::CachedActorQuat' has a wrong offset!");
static_assert(offsetof(ABaseCharacter, CachedActorScale) == 0x0005F0, "Member 'ABaseCharacter::CachedActorScale' has a wrong offset!");
static_assert(offsetof(ABaseCharacter, CachedActorTransform) == 0x000600, "Member 'ABaseCharacter::CachedActorTransform' has a wrong offset!");
static_assert(offsetof(ABaseCharacter, CachedActorUp) == 0x000640, "Member 'ABaseCharacter::CachedActorUp' has a wrong offset!");
static_assert(offsetof(ABaseCharacter, CachedActorForward) == 0x00064C, "Member 'ABaseCharacter::CachedActorForward' has a wrong offset!");
static_assert(offsetof(ABaseCharacter, CachedActorVelocity) == 0x000658, "Member 'ABaseCharacter::CachedActorVelocity' has a wrong offset!");
static_assert(offsetof(ABaseCharacter, EntityIdInternal) == 0x000664, "Member 'ABaseCharacter::EntityIdInternal' has a wrong offset!");
static_assert(offsetof(ABaseCharacter, bInitializeAttributes) == 0x000668, "Member 'ABaseCharacter::bInitializeAttributes' has a wrong offset!");
static_assert(offsetof(ABaseCharacter, AttributeSet) == 0x000670, "Member 'ABaseCharacter::AttributeSet' has a wrong offset!");
static_assert(offsetof(ABaseCharacter, AbilitySystemComponent) == 0x000678, "Member 'ABaseCharacter::AbilitySystemComponent' has a wrong offset!");

// Class KuroGAS.BaseGameplayAbility
// 0x0008 (0x03C8 - 0x03C0)
class UBaseGameplayAbility : public UGameplayAbility
{
public:
	bool                                          StartOnGiven;                                      // 0x03C0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C1[0x7];                                      // 0x03C1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	float GetCallerMagnitudeByTag(const struct FGameplayTag& Tag);
	void PreAvatarSet();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BaseGameplayAbility">();
	}
	static class UBaseGameplayAbility* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBaseGameplayAbility>();
	}
};
static_assert(alignof(UBaseGameplayAbility) == 0x000008, "Wrong alignment on UBaseGameplayAbility");
static_assert(sizeof(UBaseGameplayAbility) == 0x0003C8, "Wrong size on UBaseGameplayAbility");
static_assert(offsetof(UBaseGameplayAbility, StartOnGiven) == 0x0003C0, "Member 'UBaseGameplayAbility::StartOnGiven' has a wrong offset!");

// Class KuroGAS.BaseGameplayEffectExecutionCalculation
// 0x0000 (0x0048 - 0x0048)
class UBaseGameplayEffectExecutionCalculation final : public UGameplayEffectExecutionCalculation
{
public:
	void ExecuteImplementation(int64 GameplayEffectId, float Level, int32 StackNum, const struct FGameplayEffectContextHandle& Context, class AActor* Instigator, class AActor* Target) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BaseGameplayEffectExecutionCalculation">();
	}
	static class UBaseGameplayEffectExecutionCalculation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBaseGameplayEffectExecutionCalculation>();
	}
};
static_assert(alignof(UBaseGameplayEffectExecutionCalculation) == 0x000008, "Wrong alignment on UBaseGameplayEffectExecutionCalculation");
static_assert(sizeof(UBaseGameplayEffectExecutionCalculation) == 0x000048, "Wrong size on UBaseGameplayEffectExecutionCalculation");

// Class KuroGAS.BaseGameplayModMagnitudeCalculation
// 0x0000 (0x0048 - 0x0048)
class UBaseGameplayModMagnitudeCalculation final : public UGameplayModMagnitudeCalculation
{
public:
	float CalculationImplementation(int64 GameplayEffectId, float Level, int32 stackNum, class AActor* Instigator, class AActor* Target) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BaseGameplayModMagnitudeCalculation">();
	}
	static class UBaseGameplayModMagnitudeCalculation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBaseGameplayModMagnitudeCalculation>();
	}
};
static_assert(alignof(UBaseGameplayModMagnitudeCalculation) == 0x000008, "Wrong alignment on UBaseGameplayModMagnitudeCalculation");
static_assert(sizeof(UBaseGameplayModMagnitudeCalculation) == 0x000048, "Wrong size on UBaseGameplayModMagnitudeCalculation");

// Class KuroGAS.DamageExecCalculation
// 0x0000 (0x0048 - 0x0048)
class UDamageExecCalculation final : public UGameplayEffectExecutionCalculation
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DamageExecCalculation">();
	}
	static class UDamageExecCalculation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDamageExecCalculation>();
	}
};
static_assert(alignof(UDamageExecCalculation) == 0x000008, "Wrong alignment on UDamageExecCalculation");
static_assert(sizeof(UDamageExecCalculation) == 0x000048, "Wrong size on UDamageExecCalculation");

// Class KuroGAS.GASBPLibrary
// 0x0000 (0x0030 - 0x0030)
class UGASBPLibrary final : public UBlueprintFunctionLibrary
{
public:
	static bool AddDataTableRowByName_EditorOnly(class UDataTable* DataTable, class FName Name_0, class UStruct* Data);
	static void AddEffectContextTarget(const struct FGameplayEffectContextHandle& EffectContext, class AActor* Actor);
	static void AddGameplayTag(struct FGameplayTagContainer& TagContainer, int32 TagHash);
	static struct FGameplayEffectSpecHandle AddGrantedTag(const struct FGameplayEffectSpecHandle& SpecHandle, int32 TagHash);
	static int32 AddTagToActor(class UAbilitySystemComponent* Asc, const int32 InTagHash, const int32 MarkTagHash);
	static void EnsureGameplayTagDataTableLoaded();
	static TArray<struct FAssetData> FindAllBlueprintAsset(class FName BaseClassName, const class FString& Path);
	static int32 FnvHash(const class FString& Str);
	static struct FGameplayTagContainer GetActiveBuffAssetTags(int32 HandleId);
	static struct FGameplayEffectContextHandle GetActiveBuffContextHandle(int32 HandleId);
	static class FString GetActiveBuffDebugAttributeString(int32 HandleId);
	static class FString GetActiveBuffDebugString(int32 HandleId);
	static struct FGameplayTagContainer GetActiveBuffGrantedTags(int32 HandleId);
	static int64 GetActiveBuffId(int32 HandleId);
	static class AActor* GetActiveBuffInstigator(int32 HandleId);
	static float GetActiveBuffLevel(int32 HandleId);
	static float GetActiveBuffPeriod(int32 HandleId);
	static float GetActiveBuffRemainingDuration(int32 HandleId);
	static int32 GetActiveBuffServerId(int32 HandleId);
	static int32 GetActiveBuffStackCount(int32 HandleId);
	static float GetActiveBuffTotalDuration(int32 HandleId);
	static struct FGameplayTagContainer GetActiveGameplayEffectAssetTags(const struct FActiveGameplayEffectHandle& ActiveHandle);
	static class FString GetActiveGameplayEffectDebugString(const struct FActiveGameplayEffectHandle& ActiveHandle);
	static struct FGameplayTagContainer GetActiveGameplayEffectGrantedTags(const struct FActiveGameplayEffectHandle& ActiveHandle);
	static struct FGameplayEffectContextHandle GetActiveGameplayEffectHandleEffectContext(const struct FActiveGameplayEffectHandle& Handle);
	static int64 GetActiveGameplayEffectHandleGeId(const struct FActiveGameplayEffectHandle& Handle);
	static class AActor* GetActiveGameplayEffectHandleInstigator(const struct FActiveGameplayEffectHandle& Handle);
	static float GetActiveGameplayEffectHandleLevel(const struct FActiveGameplayEffectHandle& Handle);
	static TArray<struct FGameplayAttribute> GetActiveGameplayEffectModifiedAttributes(const struct FActiveGameplayEffectHandle& ActiveHandle);
	static float GetActiveGameplayEffectPeriod(const struct FActiveGameplayEffectHandle& ActiveHandle);
	static int32 GetActiveGameplayEffectServerId(const struct FActiveGameplayEffectHandle& ActiveHandle);
	static void GetAllTagsByParentTags(class UAbilitySystemComponent* ASC, const struct FGameplayTag& Query, struct FGameplayTagContainer* Result);
	static class FName GetAssetPath(class UObject* Object);
	static struct FActiveGameplayEffectHandle GetGameplayAbilitySourceGE(const class UGameplayAbility* GameplayAbility);
	static class FString GetGameplayAbilitySystemActivatableAbilitiesDebugString(const class UAbilitySystemComponent* ASC);
	static void GetGameplayCueNotify(const struct FGameplayTag& GameplayTag, struct FSoftObjectPath* OutSoftObjectPath);
	static class AActor* GetGameplayEffectContextTarget(const struct FGameplayEffectContextHandle& handle);
	static struct FGameplayTag GetGameplayTagFromTagHash(int32 TagHash);
	static int32 GetGameplayTagId(const struct FGameplayTag& Tag);
	static void GetGameplayTags(TMap<int32, struct FGameplayTag>* Tags);
	static int64 GetNetworkGameplayTagNodeIndexHash();
	static void GetOwnedGameplayTags(const class UAbilitySystemComponent* ASC, struct FGameplayTagContainer* TargetContainer);
	static class FString GetUglyTag(const class FString& Str);
	static bool IsActiveBuffInhibited(int32 HandleId);
	static bool IsActiveGameplayEffectInhibited(const struct FActiveGameplayEffectHandle& ActiveHandle);
	static void IterateStructAndAssignAttributeSet(class UBaseAttributeSet* AttributeSet, class UStruct* Data);
	static struct FGameplayTagContainer MakeGameplayTagContainerFromTagHash(int32 TagHash);
	static bool RemoveActiveBuff(class UAbilitySystemComponent* Asc, int32 HandleId, int32 StacksToRemove);
	static void RemoveAllDurationGameplayEffects(class UAbilitySystemComponent* ASC);
	static void RemoveAllGameplayEffects(class UAbilitySystemComponent* ASC);
	static void RemoveBuffByTagFromActor(class UAbilitySystemComponent* Asc, const int32 InTagHash, const int32 MarkTagHash);
	static void RemoveTagFromActor(class UAbilitySystemComponent* Asc, const int32 InTagHash, const int32 MarkTagHash);
	static struct FGameplayEffectSpecHandle ResetGameplayEffectSpecPeriod(const struct FGameplayEffectSpecHandle& SpecHandle, float NewPeriod);
	static void SetAttributeValue(class UBaseAttributeSet* AttributeSet, class UStruct* InStruct);
	static void SetNeedSyncAttributes(const TSet<int32>& SourceNeedSyncAttributes);
	static bool SetRootComponent(class AActor* TargetActor, class USceneComponent* NewRootComponent);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GASBPLibrary">();
	}
	static class UGASBPLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGASBPLibrary>();
	}
};
static_assert(alignof(UGASBPLibrary) == 0x000008, "Wrong alignment on UGASBPLibrary");
static_assert(sizeof(UGASBPLibrary) == 0x000030, "Wrong size on UGASBPLibrary");

// Class KuroGAS.AbilityTask_WaitDelayForNextTick
// 0x0018 (0x00A0 - 0x0088)
class UAbilityTask_WaitDelayForNextTick final : public UAbilityTask
{
public:
	TMulticastInlineDelegate<void()>              OnFinish;                                          // 0x0088(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_98[0x8];                                       // 0x0098(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UAbilityTask_WaitDelayForNextTick* WaitDelayForNextTick(class UGameplayAbility* OwningAbility);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AbilityTask_WaitDelayForNextTick">();
	}
	static class UAbilityTask_WaitDelayForNextTick* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbilityTask_WaitDelayForNextTick>();
	}
};
static_assert(alignof(UAbilityTask_WaitDelayForNextTick) == 0x000008, "Wrong alignment on UAbilityTask_WaitDelayForNextTick");
static_assert(sizeof(UAbilityTask_WaitDelayForNextTick) == 0x0000A0, "Wrong size on UAbilityTask_WaitDelayForNextTick");
static_assert(offsetof(UAbilityTask_WaitDelayForNextTick, OnFinish) == 0x000088, "Member 'UAbilityTask_WaitDelayForNextTick::OnFinish' has a wrong offset!");

}

