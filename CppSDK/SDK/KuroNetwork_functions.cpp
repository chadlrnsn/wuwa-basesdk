#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: KuroNetwork

#include "Basic.hpp"

#include "KuroNetwork_classes.hpp"
#include "KuroNetwork_parameters.hpp"


namespace SDK
{

// Function KuroNetwork.KuroHttp.Get
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const class FString&                    URL                                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TMap<class FString, class FString>&HeaderParam                                            (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// TDelegate<void(bool bConnectedSuccessfully, int32 HttpResponseCode, const class FString& Data)>Handle                                                 (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// float                                   InTimeoutSecs                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKuroHttp::Get(const class FString& URL, const TMap<class FString, class FString>& HeaderParam, TDelegate<void(bool bConnectedSuccessfully, int32 HttpResponseCode, const class FString& Data)> Handle, float InTimeoutSecs)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroHttp", "Get");

	Params::KuroHttp_Get Parms{};

	Parms.URL = std::move(URL);
	Parms.HeaderParam = std::move(HeaderParam);
	Parms.Handle = Handle;
	Parms.InTimeoutSecs = InTimeoutSecs;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroNetwork.KuroHttp.GetDefaultHeader
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TMap<class FString, class FString>      ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

TMap<class FString, class FString> UKuroHttp::GetDefaultHeader()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroHttp", "GetDefaultHeader");

	Params::KuroHttp_GetDefaultHeader Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroNetwork.KuroHttp.Post
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const class FString&                    URL                                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TMap<class FString, class FString>&HeaderParam                                            (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// const class FString&                    Content                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TDelegate<void(bool bConnectedSuccessfully, int32 HttpResponseCode, const class FString& Data)>Handle                                                 (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// float                                   InTimeoutSecs                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKuroHttp::Post(const class FString& URL, const TMap<class FString, class FString>& HeaderParam, const class FString& Content, TDelegate<void(bool bConnectedSuccessfully, int32 HttpResponseCode, const class FString& Data)> Handle, float InTimeoutSecs)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroHttp", "Post");

	Params::KuroHttp_Post Parms{};

	Parms.URL = std::move(URL);
	Parms.HeaderParam = std::move(HeaderParam);
	Parms.Content = std::move(Content);
	Parms.Handle = Handle;
	Parms.InTimeoutSecs = InTimeoutSecs;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroNetwork.KuroHttp.PostAli
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const TMap<class FString, class FString>&QueryParameter                                         (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// TDelegate<void(bool bConnectedSuccessfully, int32 HttpResponseCode, const class FString& Data)>Handle                                                 (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// float                                   InTimeoutSecs                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKuroHttp::PostAli(const TMap<class FString, class FString>& QueryParameter, TDelegate<void(bool bConnectedSuccessfully, int32 HttpResponseCode, const class FString& Data)> Handle, float InTimeoutSecs)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroHttp", "PostAli");

	Params::KuroHttp_PostAli Parms{};

	Parms.QueryParameter = std::move(QueryParameter);
	Parms.Handle = Handle;
	Parms.InTimeoutSecs = InTimeoutSecs;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroNetwork.KuroHttp.PostRpt
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class FString&                    ContentStr                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    IsGlobal                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TDelegate<void(const class FString& Data, int32 LocalErrorCode, int32 RemoteErrorCode, int32 HttpResponseCode, bool bConnectedSuccessfully)>Handle                                                 (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// float                                   InTimeoutSecs                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKuroHttp::PostRpt(const class FString& ContentStr, bool IsGlobal, TDelegate<void(const class FString& Data, int32 LocalErrorCode, int32 RemoteErrorCode, int32 HttpResponseCode, bool bConnectedSuccessfully)> Handle, float InTimeoutSecs)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroHttp", "PostRpt");

	Params::KuroHttp_PostRpt Parms{};

	Parms.ContentStr = std::move(ContentStr);
	Parms.IsGlobal = IsGlobal;
	Parms.Handle = Handle;
	Parms.InTimeoutSecs = InTimeoutSecs;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroNetwork.KuroHttpServerRequestProxy.GetHeader
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const class FString&                    Key                                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class FString>*                  OutHeader                                              (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKuroHttpServerRequestProxy::GetHeader(const class FString& Key, TArray<class FString>* OutHeader)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KuroHttpServerRequestProxy", "GetHeader");

	Params::KuroHttpServerRequestProxy_GetHeader Parms{};

	Parms.Key = std::move(Key);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutHeader != nullptr)
		*OutHeader = std::move(Parms.OutHeader);

	return Parms.ReturnValue;
}


// Function KuroNetwork.KuroHttpServerRequestProxy.GetRequest
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UKuroHttpServerRequestProxy::GetRequest()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KuroHttpServerRequestProxy", "GetRequest");

	Params::KuroHttpServerRequestProxy_GetRequest Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroNetwork.KuroHttpServerRequestProxy.Response
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const class FString&                    Json                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const bool                              bSuccess                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKuroHttpServerRequestProxy::Response(const class FString& Json, const bool bSuccess)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KuroHttpServerRequestProxy", "Response");

	Params::KuroHttpServerRequestProxy_Response Parms{};

	Parms.Json = std::move(Json);
	Parms.bSuccess = bSuccess;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroNetwork.KuroHttpServerRouterProxy.BindRoute
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const class FString&                    ModuleName                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKuroHttpServerRouterProxy::BindRoute(const class FString& ModuleName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KuroHttpServerRouterProxy", "BindRoute");

	Params::KuroHttpServerRouterProxy_BindRoute Parms{};

	Parms.ModuleName = std::move(ModuleName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroNetwork.KuroHttpServerRouterProxy.CreateRouter
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const int32                             Port                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKuroHttpServerRouterProxy::CreateRouter(const int32 Port)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KuroHttpServerRouterProxy", "CreateRouter");

	Params::KuroHttpServerRouterProxy_CreateRouter Parms{};

	Parms.Port = Port;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroNetwork.KuroHttpServerRouterProxy.StartServer
// (Final, Native, Public, BlueprintCallable)

void UKuroHttpServerRouterProxy::StartServer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KuroHttpServerRouterProxy", "StartServer");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function KuroNetwork.KuroKcpClient.CloseTcpConnect
// (Final, Native, Public)

void UKuroKcpClient::CloseTcpConnect()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KuroKcpClient", "CloseTcpConnect");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function KuroNetwork.KuroKcpClient.HandleKcpConnect
// (Final, Native, Public)
// Parameters:
// const uint32                            NeedCrcCheck                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const uint32                            Conv                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKuroKcpClient::HandleKcpConnect(const uint32 NeedCrcCheck, const uint32 Conv)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KuroKcpClient", "HandleKcpConnect");

	Params::KuroKcpClient_HandleKcpConnect Parms{};

	Parms.NeedCrcCheck = NeedCrcCheck;
	Parms.Conv = Conv;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroNetwork.KuroKcpClient.HandleTcpConnected
// (Final, Native, Public)

void UKuroKcpClient::HandleTcpConnected()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KuroKcpClient", "HandleTcpConnected");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function KuroNetwork.KuroKcpClient.HandleTcpConnectFailed
// (Final, Native, Public)

void UKuroKcpClient::HandleTcpConnectFailed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KuroKcpClient", "HandleTcpConnectFailed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function KuroNetwork.KuroKcpClient.SendTcpMessage
// (Final, Native, Public, HasOutParams)
// Parameters:
// int16                                   RpcId                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int16                                   MsgId                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FArrayBuffer&              ArrayBuffer                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void UKuroKcpClient::SendTcpMessage(int16 RpcId, int16 MsgId, const struct FArrayBuffer& ArrayBuffer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KuroKcpClient", "SendTcpMessage");

	Params::KuroKcpClient_SendTcpMessage Parms{};

	Parms.RpcId = RpcId;
	Parms.MsgId = MsgId;
	Parms.ArrayBuffer = std::move(ArrayBuffer);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroNetwork.KuroKcpClient.SetEnType
// (Final, Native, Public)
// Parameters:
// uint8                                   Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int16                                   MsgId                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKuroKcpClient::SetEnType(uint8 Type, int16 MsgId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KuroKcpClient", "SetEnType");

	Params::KuroKcpClient_SetEnType Parms{};

	Parms.Type = Type;
	Parms.MsgId = MsgId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroNetwork.KuroKcpClient.SetK
// (Final, Native, Public, HasOutParams)
// Parameters:
// uint8                                   Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FArrayBuffer&              KeyBuffer                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKuroKcpClient::SetK(uint8 Type, const struct FArrayBuffer& KeyBuffer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KuroKcpClient", "SetK");

	Params::KuroKcpClient_SetK Parms{};

	Parms.Type = Type;
	Parms.KeyBuffer = std::move(KeyBuffer);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroNetwork.KuroKcpClient.SetKcpMtu
// (Final, Native, Public)
// Parameters:
// int32                                   Mtu                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKuroKcpClient::SetKcpMtu(int32 Mtu)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KuroKcpClient", "SetKcpMtu");

	Params::KuroKcpClient_SetKcpMtu Parms{};

	Parms.Mtu = Mtu;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroNetwork.KuroKcpClient.SetKcpNoDelay
// (Final, Native, Public)
// Parameters:
// int32                                   NoDelay                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Interval                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Resend                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Nc                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKuroKcpClient::SetKcpNoDelay(int32 NoDelay, int32 Interval, int32 Resend, int32 Nc)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KuroKcpClient", "SetKcpNoDelay");

	Params::KuroKcpClient_SetKcpNoDelay Parms{};

	Parms.NoDelay = NoDelay;
	Parms.Interval = Interval;
	Parms.Resend = Resend;
	Parms.Nc = Nc;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroNetwork.KuroKcpClient.SetKcpSegmentSize
// (Final, Native, Public)
// Parameters:
// int32                                   SegmentSize                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKuroKcpClient::SetKcpSegmentSize(int32 SegmentSize)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KuroKcpClient", "SetKcpSegmentSize");

	Params::KuroKcpClient_SetKcpSegmentSize Parms{};

	Parms.SegmentSize = SegmentSize;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroNetwork.KuroKcpClient.SetKcpStream
// (Final, Native, Public)
// Parameters:
// bool                                    bStream                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKuroKcpClient::SetKcpStream(bool bStream)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KuroKcpClient", "SetKcpStream");

	Params::KuroKcpClient_SetKcpStream Parms{};

	Parms.bStream = bStream;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroNetwork.KuroKcpClient.SetKcpWndSize
// (Final, Native, Public)
// Parameters:
// int32                                   SndWnd                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   RcvWnd                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKuroKcpClient::SetKcpWndSize(int32 SndWnd, int32 RcvWnd)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KuroKcpClient", "SetKcpWndSize");

	Params::KuroKcpClient_SetKcpWndSize Parms{};

	Parms.SndWnd = SndWnd;
	Parms.RcvWnd = RcvWnd;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroNetwork.KuroKcpClient.StartTcpConnect
// (Final, Native, Public)
// Parameters:
// const int32                             Port                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKuroKcpClient::StartTcpConnect(const int32 Port)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KuroKcpClient", "StartTcpConnect");

	Params::KuroKcpClient_StartTcpConnect Parms{};

	Parms.Port = Port;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroNetwork.KuroKcpClient.TickOutside
// (Final, Native, Public)
// Parameters:
// float                                   DeltaSeconds                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKuroKcpClient::TickOutside(float DeltaSeconds)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KuroKcpClient", "TickOutside");

	Params::KuroKcpClient_TickOutside Parms{};

	Parms.DeltaSeconds = DeltaSeconds;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroNetwork.KuroKcpClient.IsTcpConnectStart
// (Final, Native, Public, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKuroKcpClient::IsTcpConnectStart() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KuroKcpClient", "IsTcpConnectStart");

	Params::KuroKcpClient_IsTcpConnectStart Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroNetwork.KuroKcpTestWorker.OnConnectSuccess
// (Final, Native, Public)

void UKuroKcpTestWorker::OnConnectSuccess()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KuroKcpTestWorker", "OnConnectSuccess");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function KuroNetwork.KuroKcpTestWorker.OnRecvException
// (Final, Native, Public, HasOutParams)
// Parameters:
// int32                                   SeqNo                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int16                                   RpcId                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ErrorCode                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FArrayBuffer*                    MessageBuff                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void UKuroKcpTestWorker::OnRecvException(int32 SeqNo, int16 RpcId, int32 ErrorCode, struct FArrayBuffer* MessageBuff)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KuroKcpTestWorker", "OnRecvException");

	Params::KuroKcpTestWorker_OnRecvException Parms{};

	Parms.SeqNo = SeqNo;
	Parms.RpcId = RpcId;
	Parms.ErrorCode = ErrorCode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (MessageBuff != nullptr)
		*MessageBuff = std::move(Parms.MessageBuff);
}


// Function KuroNetwork.KuroKcpTestWorker.OnRecvPush
// (Final, Native, Public, HasOutParams)
// Parameters:
// int32                                   SeqNo                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint16                                  MessageId                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FArrayBuffer*                    MessageBuff                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void UKuroKcpTestWorker::OnRecvPush(int32 SeqNo, uint16 MessageId, struct FArrayBuffer* MessageBuff)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KuroKcpTestWorker", "OnRecvPush");

	Params::KuroKcpTestWorker_OnRecvPush Parms{};

	Parms.SeqNo = SeqNo;
	Parms.MessageId = MessageId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (MessageBuff != nullptr)
		*MessageBuff = std::move(Parms.MessageBuff);
}


// Function KuroNetwork.KuroKcpTestWorker.OnRecvResponse
// (Final, Native, Public, HasOutParams)
// Parameters:
// int32                                   SeqNo                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int16                                   RpcId                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint16                                  MessageId                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FArrayBuffer*                    MessageBuff                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void UKuroKcpTestWorker::OnRecvResponse(int32 SeqNo, int16 RpcId, uint16 MessageId, struct FArrayBuffer* MessageBuff)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KuroKcpTestWorker", "OnRecvResponse");

	Params::KuroKcpTestWorker_OnRecvResponse Parms{};

	Parms.SeqNo = SeqNo;
	Parms.RpcId = RpcId;
	Parms.MessageId = MessageId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (MessageBuff != nullptr)
		*MessageBuff = std::move(Parms.MessageBuff);
}


// Function KuroNetwork.KuroNetworkChange.GetNetworkType
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// uint8                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

uint8 UKuroNetworkChange::GetNetworkType()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KuroNetworkChange", "GetNetworkType");

	Params::KuroNetworkChange_GetNetworkType Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroNetwork.KuroNetworkDetection.DetectionFinish
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    bSuccess                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKuroNetworkDetection::DetectionFinish(bool bSuccess)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroNetworkDetection", "DetectionFinish");

	Params::KuroNetworkDetection_DetectionFinish Parms{};

	Parms.bSuccess = bSuccess;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroNetwork.KuroNetworkDetection.GetCurrentProxyAddress
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UKuroNetworkDetection::GetCurrentProxyAddress()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroNetworkDetection", "GetCurrentProxyAddress");

	Params::KuroNetworkDetection_GetCurrentProxyAddress Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroNetwork.KuroNetworkDetection.GetDetectionConfig
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class FString&                    ServerName                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UKuroNetworkDetection::GetDetectionConfig(const class FString& ServerName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroNetworkDetection", "GetDetectionConfig");

	Params::KuroNetworkDetection_GetDetectionConfig Parms{};

	Parms.ServerName = std::move(ServerName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroNetwork.KuroNetworkDetection.ResolveDomainFinish
// (Final, Native, Static, Public, BlueprintCallable)

void UKuroNetworkDetection::ResolveDomainFinish()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroNetworkDetection", "ResolveDomainFinish");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function KuroNetwork.KuroNetworkDetection.ResolveDomainName
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class FString&                    DomainName                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TDelegate<void(int32 ErrorCode)>        Callback                                               (Parm, ZeroConstructor, NativeAccessSpecifierPublic)

void UKuroNetworkDetection::ResolveDomainName(const class FString& DomainName, TDelegate<void(int32 ErrorCode)> Callback)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroNetworkDetection", "ResolveDomainName");

	Params::KuroNetworkDetection_ResolveDomainName Parms{};

	Parms.DomainName = std::move(DomainName);
	Parms.Callback = Callback;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroNetwork.KuroNetworkDetection.SetCDNConfig
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class FString&                    CDNConfig                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKuroNetworkDetection::SetCDNConfig(const class FString& CDNConfig)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroNetworkDetection", "SetCDNConfig");

	Params::KuroNetworkDetection_SetCDNConfig Parms{};

	Parms.CDNConfig = std::move(CDNConfig);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroNetwork.KuroNetworkDetection.TestUdpReachable
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const class FString&                    IpAddress                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<int32>&                    Ports                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// TDelegate<void(int32 SuccessCount, int32 ErrorCode)>ResultDelegate                                         (Parm, ZeroConstructor, NativeAccessSpecifierPublic)

void UKuroNetworkDetection::TestUdpReachable(const class FString& IpAddress, const TArray<int32>& Ports, TDelegate<void(int32 SuccessCount, int32 ErrorCode)> ResultDelegate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroNetworkDetection", "TestUdpReachable");

	Params::KuroNetworkDetection_TestUdpReachable Parms{};

	Parms.IpAddress = std::move(IpAddress);
	Parms.Ports = std::move(Ports);
	Parms.ResultDelegate = ResultDelegate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroNetwork.KuroTcpClient.CloseSocket
// (Final, Native, Public)

void UKuroTcpClient::CloseSocket()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KuroTcpClient", "CloseSocket");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function KuroNetwork.KuroTcpClient.Connect
// (Final, Native, Public)
// Parameters:
// const class FString&                    Addr                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Port                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKuroTcpClient::Connect(const class FString& Addr, int32 Port)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KuroTcpClient", "Connect");

	Params::KuroTcpClient_Connect Parms{};

	Parms.Addr = std::move(Addr);
	Parms.Port = Port;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroNetwork.KuroTcpClient.Disconnect
// (Final, Native, Public)

void UKuroTcpClient::Disconnect()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KuroTcpClient", "Disconnect");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function KuroNetwork.KuroTcpClient.Send
// (Final, Native, Public, HasOutParams)
// Parameters:
// const TArray<uint8>&                    Data                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void UKuroTcpClient::Send(const TArray<uint8>& Data)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KuroTcpClient", "Send");

	Params::KuroTcpClient_Send Parms{};

	Parms.Data = std::move(Data);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroNetwork.KuroTcpClient.ShutDownSocket
// (Final, Native, Public)

void UKuroTcpClient::ShutDownSocket()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KuroTcpClient", "ShutDownSocket");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function KuroNetwork.KuroTcpClient.TickOutside
// (Final, Native, Public)
// Parameters:
// float                                   DeltaSeconds                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKuroTcpClient::TickOutside(float DeltaSeconds)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KuroTcpClient", "TickOutside");

	Params::KuroTcpClient_TickOutside Parms{};

	Parms.DeltaSeconds = DeltaSeconds;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroNetwork.SendHttpRequest.HttpRequest
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class FString&                    URL                                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EHttpMethod                             Method                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    PostBody                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USendHttpRequest*                 ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USendHttpRequest* USendHttpRequest::HttpRequest(const class FString& URL, EHttpMethod Method, const class FString& PostBody)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SendHttpRequest", "HttpRequest");

	Params::SendHttpRequest_HttpRequest Parms{};

	Parms.URL = std::move(URL);
	Parms.Method = Method;
	Parms.PostBody = std::move(PostBody);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroNetwork.SendHttpRequest.HttpRequestEx
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class FString&                    URL                                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EHttpMethod                             Method                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    PostBody                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    HeaderParam                                            (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USendHttpRequest*                 ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USendHttpRequest* USendHttpRequest::HttpRequestEx(const class FString& URL, EHttpMethod Method, const class FString& PostBody, const class FString& HeaderParam)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SendHttpRequest", "HttpRequestEx");

	Params::SendHttpRequest_HttpRequestEx Parms{};

	Parms.URL = std::move(URL);
	Parms.Method = Method;
	Parms.PostBody = std::move(PostBody);
	Parms.HeaderParam = std::move(HeaderParam);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}

}

