#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: LGUI

#include "Basic.hpp"

#include "CoreUObject_structs.hpp"
#include "Engine_structs.hpp"
#include "MovieScene_structs.hpp"
#include "SlateCore_structs.hpp"


namespace SDK
{

// Enum LGUI.EButtonAudioStateTransferType
// NumValues: 0x0007
enum class EButtonAudioStateTransferType : uint8
{
	None                                     = 0,
	NormalToHighLight                        = 1,
	HighlightToNormal                        = 2,
	HighLightToPress                         = 3,
	PressToRelease                           = 4,
	DisabledPress                            = 5,
	EButtonAudioStateTransferType_MAX        = 6,
};

// Enum LGUI.EToggleState
// NumValues: 0x0004
enum class EToggleState : uint8
{
	ETT_UnChecked                            = 0,
	ETT_Checked                              = 1,
	ETT_UnDetermined                         = 2,
	ETT_MAX                                  = 3,
};

// Enum LGUI.EToggleAudioTransitionState
// NumValues: 0x0007
enum class EToggleAudioTransitionState : uint8
{
	ETT_None                                 = 0,
	ETT_NormalToHighLight                    = 1,
	ETT_HighlightedPress                     = 2,
	ETT_UncheckedClick                       = 3,
	ETT_CheckedClick                         = 4,
	ETT_DisabledPress                        = 5,
	ETT_MAX                                  = 6,
};

// Enum LGUI.ELGUIPointerInputType
// NumValues: 0x0004
enum class ELGUIPointerInputType : uint8
{
	Pointer                                  = 0,
	Navigation                               = 1,
	None                                     = 2,
	ELGUIPointerInputType_MAX                = 3,
};

// Enum LGUI.ELGUINavigationDirection
// NumValues: 0x0008
enum class ELGUINavigationDirection : uint8
{
	None                                     = 0,
	Left                                     = 1,
	Right                                    = 2,
	Up                                       = 3,
	Down                                     = 4,
	Next                                     = 5,
	Prev                                     = 6,
	ELGUINavigationDirection_MAX             = 7,
};

// Enum LGUI.NavigationComponentState
// NumValues: 0x0005
enum class ENavigationComponentState : uint8
{
	Select                                   = 0,
	NoSelect                                 = 1,
	Hide                                     = 2,
	Show                                     = 3,
	NavigationComponentState_MAX             = 4,
};

// Enum LGUI.UINavigationGroupMode
// NumValues: 0x0006
enum class EUINavigationGroupMode : uint8
{
	Awake                                    = 0,
	Destroy                                  = 1,
	Active                                   = 2,
	Hide                                     = 3,
	Navigation                               = 4,
	UINavigationGroupMode_MAX                = 5,
};

// Enum LGUI.EInputKeyType
// NumValues: 0x0005
enum class EInputKeyType : uint8
{
	None                                     = 0,
	KeyboardOrMouse                          = 1,
	Gamepad                                  = 2,
	Touch                                    = 3,
	EInputKeyType_MAX                        = 4,
};

// Enum LGUI.ESceneComponentRayDirection
// NumValues: 0x0007
enum class ESceneComponentRayDirection : uint8
{
	PositiveX                                = 0,
	NagtiveX                                 = 1,
	PositiveY                                = 2,
	NagtiveY                                 = 3,
	PositiveZ                                = 4,
	NagtiveZ                                 = 5,
	ESceneComponentRayDirection_MAX          = 6,
};

// Enum LGUI.EUIRaycastSortType
// NumValues: 0x0003
enum class EUIRaycastSortType : uint8
{
	DependOnUIDepth                          = 0,
	DependOnDistance                         = 1,
	EUIRaycastSortType_MAX                   = 2,
};

// Enum LGUI.EMouseButtonType
// NumValues: 0x000D
enum class EMouseButtonType : uint8
{
	Left                                     = 0,
	Middle                                   = 1,
	Right                                    = 2,
	UserDefined1                             = 3,
	UserDefined2                             = 4,
	UserDefined3                             = 5,
	UserDefined4                             = 6,
	UserDefined5                             = 7,
	UserDefined6                             = 8,
	UserDefined7                             = 9,
	UserDefined8                             = 10,
	NavigationChange                         = 11,
	EMouseButtonType_MAX                     = 12,
};

// Enum LGUI.EPointerEventType
// NumValues: 0x0011
enum class EPointerEventType : uint8
{
	Click                                    = 0,
	Enter                                    = 1,
	Exit                                     = 2,
	Down                                     = 3,
	Up                                       = 4,
	BeginDrag                                = 5,
	Drag                                     = 6,
	EndDrag                                  = 7,
	Scroll                                   = 8,
	DragEnter_DEPRECATED                     = 9,
	DragExit_DEPRECATED                      = 10,
	DragDrop                                 = 11,
	Select                                   = 12,
	Deselect                                 = 13,
	Navigate                                 = 14,
	Simulation                               = 15,
	EPointerEventType_MAX                    = 16,
};

// Enum LGUI.ELGUIEventFireType
// NumValues: 0x0004
enum class ELGUIEventFireType : uint8
{
	TargetActorAndAllItsComponents           = 0,
	OnlyTargetComponent                      = 1,
	OnlyTargetActor                          = 2,
	ELGUIEventFireType_MAX                   = 3,
};

// Enum LGUI.ELGUICanvasOverrideParameters
// NumValues: 0x0009
enum class ELGUICanvasOverrideParameters : uint8
{
	DefaltMaterials                          = 0,
	PixelPerfect                             = 1,
	DynamicPixelsPerUnit                     = 2,
	ClipType                                 = 3,
	AdditionalShaderChannels                 = 4,
	OnlyOwnerSee                             = 5,
	OwnerNoSee                               = 6,
	OverrideDisable                          = 7,
	ELGUICanvasOverrideParameters_MAX        = 8,
};

// Enum LGUI.ELGUICanvasAdditionalChannelType
// NumValues: 0x0006
enum class ELGUICanvasAdditionalChannelType : uint8
{
	Normal                                   = 0,
	Tangent                                  = 1,
	UV1                                      = 2,
	UV2                                      = 3,
	UV3                                      = 4,
	ELGUICanvasAdditionalChannelType_MAX     = 5,
};

// Enum LGUI.ELGUICanvasClipType
// NumValues: 0x0004
enum class ELGUICanvasClipType : uint8
{
	None                                     = 0,
	Rect                                     = 1,
	Texture                                  = 2,
	ELGUICanvasClipType_MAX                  = 3,
};

// Enum LGUI.ELGUIRenderMode
// NumValues: 0x0003
enum class ELGUIRenderMode : uint8
{
	ScreenSpaceOverlay                       = 0,
	WorldSpace                               = 1,
	ELGUIRenderMode_MAX                      = 2,
};

// Enum LGUI.LGUIScreenMatchMode
// NumValues: 0x0004
enum class ELGUIScreenMatchMode : uint8
{
	MatchWidthOrHeight                       = 0,
	Expand                                   = 1,
	Shrink                                   = 2,
	LGUIScreenMatchMode_MAX                  = 3,
};

// Enum LGUI.LGUIScaleMode
// NumValues: 0x0003
enum class ELGUIScaleMode : uint8
{
	ConstantPixelSize                        = 0,
	ScaleWithScreenSize                      = 1,
	LGUIScaleMode_MAX                        = 2,
};

// Enum LGUI.LGUIDrawableEventParameterType
// NumValues: 0x001A
enum class ELGUIDrawableEventParameterType : uint8
{
	None                                     = 0,
	Empty                                    = 1,
	Bool                                     = 2,
	Float                                    = 3,
	Double                                   = 4,
	Int8                                     = 5,
	UInt8                                    = 6,
	Int16                                    = 7,
	UInt16                                   = 8,
	Int32                                    = 9,
	UInt32                                   = 10,
	Int64                                    = 11,
	UInt64                                   = 12,
	Vector2                                  = 13,
	Vector3                                  = 14,
	Vector4                                  = 15,
	Color                                    = 16,
	LinearColor                              = 17,
	Quaternion                               = 18,
	String                                   = 19,
	Object                                   = 20,
	Actor                                    = 21,
	PointerEvent                             = 22,
	Class                                    = 23,
	Rotator                                  = 24,
	LGUIDrawableEventParameterType_MAX       = 25,
};

// Enum LGUI.Culture
// NumValues: 0x0014
enum class ECulture : uint8
{
	en                                       = 0,
	fr                                       = 1,
	it                                       = 2,
	de                                       = 3,
	es                                       = 4,
	es_419                                   = 5,
	ru                                       = 6,
	pl                                       = 7,
	ar                                       = 8,
	ko                                       = 9,
	ja                                       = 10,
	zh_Hans                                  = 11,
	zh_Hant                                  = 12,
	tr                                       = 13,
	pt                                       = 14,
	pt_BR                                    = 15,
	id                                       = 16,
	vi                                       = 17,
	th                                       = 18,
	Culture_MAX                              = 19,
};

// Enum LGUI.ELGUIDynamicFontDataType
// NumValues: 0x0003
enum class ELGUIDynamicFontDataType : uint8
{
	CustomFontFile                           = 0,
	UnrealFont                               = 1,
	ELGUIDynamicFontDataType_MAX             = 2,
};

// Enum LGUI.EPrefabVersion
// NumValues: 0x0007
enum class EPrefabVersion : uint8
{
	EPV_NoneVersion                          = 0,
	EPV_BasicVersion                         = 1,
	EPV_NestPrefab                           = 2,
	EPV_OtherPrefabActorReference            = 3,
	EPV_LastVersionPlusOne                   = 4,
	EPV_LastVersion                          = 3,
	EPV_MAX                                  = 5,
};

// Enum LGUI.ELGUIScreenSpaceUIAntiAliasing
// NumValues: 0x0006
enum class ELGUIScreenSpaceUIAntiAliasing : uint8
{
	Hidden                                   = 0,
	Disabled                                 = 1,
	SampleCount_2x                           = 2,
	SampleCount_4x                           = 4,
	SampleCount_8x                           = 8,
	ELGUIScreenSpaceUIAntiAliasing_MAX       = 9,
};

// Enum LGUI.ELGUIAtlasPackingType
// NumValues: 0x0003
enum class ELGUIAtlasPackingType : uint8
{
	Dynamic                                  = 0,
	Static                                   = 1,
	ELGUIAtlasPackingType_MAX                = 2,
};

// Enum LGUI.ELGUIAtlasTextureSizeType
// NumValues: 0x0007
enum class ELGUIAtlasTextureSizeType : uint8
{
	SIZE_256x256                             = 0,
	SIZE_512x512                             = 1,
	SIZE_1024x1024                           = 2,
	SIZE_2048x2048                           = 3,
	SIZE_4096x4096                           = 4,
	SIZE_8192x8192                           = 5,
	SIZE_MAX_0                               = 6,
};

// Enum LGUI.UITextOverflowType
// NumValues: 0x0007
enum class EUITextOverflowType : uint8
{
	HorizontalOverflow                       = 0,
	VerticalOverflow                         = 1,
	ClampContent                             = 2,
	HorizontalMinMax                         = 3,
	MaxHeightWidth                           = 4,
	BestFitClamp                             = 5,
	UITextOverflowType_MAX                   = 6,
};

// Enum LGUI.UITextFontStyle
// NumValues: 0x0005
enum class EUITextFontStyle : uint8
{
	None                                     = 0,
	Bold                                     = 1,
	Italic                                   = 2,
	BoldAndItalic                            = 3,
	UITextFontStyle_MAX                      = 4,
};

// Enum LGUI.UITextParagraphVerticalAlign
// NumValues: 0x0004
enum class EUITextParagraphVerticalAlign : uint8
{
	Top                                      = 0,
	Middle                                   = 1,
	Bottom                                   = 2,
	UITextParagraphVerticalAlign_MAX         = 3,
};

// Enum LGUI.UITextParagraphHorizontalAlign
// NumValues: 0x0004
enum class EUITextParagraphHorizontalAlign : uint8
{
	Left                                     = 0,
	Center                                   = 1,
	Right                                    = 2,
	UITextParagraphHorizontalAlign_MAX       = 3,
};

// Enum LGUI.ELGUIWorldSpaceInteractionSource
// NumValues: 0x0004
enum class ELGUIWorldSpaceInteractionSource : uint8
{
	World                                    = 0,
	Mouse                                    = 1,
	CenterScreen                             = 2,
	ELGUIWorldSpaceInteractionSource_MAX     = 3,
};

// Enum LGUI.ESequenceLoadState
// NumValues: 0x0004
enum class ESequenceLoadState : uint8
{
	SLS_None                                 = 0,
	SLS_Loading                              = 1,
	SLS_Loaded                               = 2,
	SLS_MAX                                  = 3,
};

// Enum LGUI.EUI2DLineRenderer_EndType
// NumValues: 0x0004
enum class EUI2DLineRenderer_EndType : uint8
{
	None                                     = 0,
	Cap                                      = 1,
	ConnectStartAndEnd                       = 2,
	EUI2DLineRenderer_MAX                    = 3,
};

// Enum LGUI.UIArtTextHorizontalAlign
// NumValues: 0x0004
enum class EUIArtTextHorizontalAlign : uint8
{
	Left                                     = 0,
	Center                                   = 1,
	Right                                    = 2,
	UIArtTextHorizontalAlign_MAX             = 3,
};

// Enum LGUI.EUIRenderableType
// NumValues: 0x0007
enum class EUIRenderableType : uint8
{
	None                                     = 0,
	UIBatchGeometryRenderable                = 1,
	UIPostProcessRenderable                  = 2,
	UIDirectMeshRenderable                   = 3,
	UINiagaraRenderable                      = 4,
	UISpineRenderable                        = 5,
	EUIRenderableType_MAX                    = 6,
};

// Enum LGUI.EComboBoxPosition
// NumValues: 0x0004
enum class EComboBoxPosition : uint8
{
	Top                                      = 0,
	Middle                                   = 1,
	Bottom                                   = 2,
	EComboBoxPosition_MAX                    = 3,
};

// Enum LGUI.EUICustomDepthStencilMaskSourceType
// NumValues: 0x0003
enum class EUICustomDepthStencilMaskSourceType : uint8
{
	CustomDepth                              = 0,
	CustomStencil                            = 1,
	EUICustomDepthStencilMaskSourceType_MAX  = 2,
};

// Enum LGUI.EUIDropdownHorizontalPosition
// NumValues: 0x0005
enum class EUIDropdownHorizontalPosition : uint8
{
	Left                                     = 0,
	Center                                   = 1,
	Right                                    = 2,
	Automatic                                = 3,
	EUIDropdownHorizontalPosition_MAX        = 4,
};

// Enum LGUI.EUIDropdownVerticalPosition
// NumValues: 0x0005
enum class EUIDropdownVerticalPosition : uint8
{
	Bottom                                   = 0,
	Middle                                   = 1,
	Top                                      = 2,
	Automatic                                = 3,
	EUIDropdownVerticalPosition_MAX          = 4,
};

// Enum LGUI.EUIEffectGradientColorDirection
// NumValues: 0x0006
enum class EUIEffectGradientColorDirection : uint8
{
	BottomToTop                              = 0,
	TopToBottom                              = 1,
	LeftToRight                              = 2,
	RightToLeft                              = 3,
	FourCornor                               = 4,
	EUIEffectGradientColorDirection_MAX      = 5,
};

// Enum LGUI.EToggleStateSwitch
// NumValues: 0x0007
enum class EToggleStateSwitch : uint8
{
	None                                     = 0,
	CheckedToUnChecked                       = 1,
	UnCheckedToChecked                       = 2,
	AnyToUnDetermined                        = 3,
	UnDeterminedToChecked                    = 4,
	UnDeterminedToUnChecked                  = 5,
	EToggleStateSwitch_MAX                   = 6,
};

// Enum LGUI.EToggleAnimationType
// NumValues: 0x0014
enum class EToggleAnimationType : uint8
{
	ETT_None                                 = 0,
	ETT_UnCheckedHover                       = 1,
	ETT_UnCheckedClick                       = 2,
	ETT_UnCheckedExit                        = 3,
	ETT_CheckedHover                         = 4,
	ETT_CheckedClick                         = 5,
	ETT_CheckedExit                          = 6,
	ETT_UnDeterminedHover                    = 7,
	ETT_UnDeterminedClick                    = 8,
	ETT_UnDeterminedExit                     = 9,
	ETT_SwitchToUnChecked                    = 10,
	ETT_SwitchToChecked                      = 11,
	ETT_AfterCheckedLoop                     = 12,
	ETT_SwitchToUndetermined                 = 13,
	ETT_HoverOtherOnChecked                  = 14,
	ETT_ExitHoverOtherOnChecked              = 15,
	ETT_CheckedDown                          = 16,
	ETT_UnCheckedDown                        = 17,
	ETT_UnDeterminedDown                     = 18,
	ETT_MAX                                  = 19,
};

// Enum LGUI.EToggleChangeStateResult
// NumValues: 0x0004
enum class EToggleChangeStateResult : uint8
{
	ECS_Success                              = 0,
	ECS_FailBySameResult                     = 1,
	ECS_FailByCanExecuteChange               = 2,
	ECS_MAX                                  = 3,
};

// Enum LGUI.EToggleStateInAnimation
// NumValues: 0x0005
enum class EToggleStateInAnimation : uint8
{
	None                                     = 0,
	UnChecked                                = 1,
	Checked                                  = 2,
	UnDetermined                             = 3,
	EToggleStateInAnimation_MAX              = 4,
};

// Enum LGUI.EToggleTransitionState
// NumValues: 0x000A
enum class EToggleTransitionState : uint8
{
	ETT_UnCheckedUnHover                     = 0,
	ETT_UnCheckedHover                       = 1,
	ETT_UnCheckedPressed                     = 2,
	ETT_CheckedUnHover                       = 3,
	ETT_CheckedHover                         = 4,
	ETT_CheckedPressed                       = 5,
	ETT_UnDeterminedUnHover                  = 6,
	ETT_UnDeterminedHover                    = 7,
	ETT_UnDeterminedPressed                  = 8,
	ETT_MAX                                  = 9,
};

// Enum LGUI.ESpriteTransitionType
// NumValues: 0x0003
enum class ESpriteTransitionType : uint8
{
	ESTT_ColorOnly                           = 0,
	ESTT_ColorAndSprite                      = 1,
	ESTT_MAX                                 = 2,
};

// Enum LGUI.ETextureTransitionType
// NumValues: 0x0003
enum class ETextureTransitionType : uint8
{
	ESTT_ColorOnly                           = 0,
	ESTT_ColorAndTexture                     = 1,
	ESTT_MAX                                 = 2,
};

// Enum LGUI.EFlyoutMenuHorizontalAlignment
// NumValues: 0x0004
enum class EFlyoutMenuHorizontalAlignment : uint8
{
	Left                                     = 0,
	Center                                   = 1,
	Right                                    = 2,
	EFlyoutMenuHorizontalAlignment_MAX       = 3,
};

// Enum LGUI.EFlyoutMenuVerticalPosition
// NumValues: 0x0003
enum class EFlyoutMenuVerticalPosition : uint8
{
	Top                                      = 0,
	Bottom                                   = 1,
	EFlyoutMenuVerticalPosition_MAX          = 2,
};

// Enum LGUI.EGridFitType
// NumValues: 0x0006
enum class EGridFitType : uint8
{
	EFT_None                                 = 0,
	EFT_HeightWidthFit                       = 1,
	EFT_HeightFit                            = 2,
	EFT_WidthFit                             = 3,
	EFT_FillByLast                           = 4,
	EFT_MAX                                  = 5,
};

// Enum LGUI.UiItemCornerType
// NumValues: 0x0005
enum class EUiItemCornerType : uint8
{
	BottomLeft                               = 0,
	TopLeft                                  = 1,
	TopRight                                 = 2,
	BottomRight                              = 3,
	UiItemCornerType_MAX                     = 4,
};

// Enum LGUI.UIItemType
// NumValues: 0x0004
enum class EUIItemType : uint8
{
	None                                     = 0,
	UIItem                                   = 1,
	UIBatchGeometryRenderable                = 2,
	UIItemType_MAX                           = 3,
};

// Enum LGUI.ELGUILayoutAlignmentType
// NumValues: 0x000A
enum class ELGUILayoutAlignmentType : uint8
{
	UpperLeft                                = 0,
	UpperCenter                              = 1,
	UpperRight                               = 2,
	MiddleLeft                               = 3,
	MiddleCenter                             = 4,
	MiddleRight                              = 5,
	LowerLeft                                = 6,
	LowerCenter                              = 7,
	LowerRight                               = 8,
	ELGUILayoutAlignmentType_MAX             = 9,
};

// Enum LGUI.ELayoutElementType
// NumValues: 0x0007
enum class ELayoutElementType : uint8
{
	AutoSize                                 = 0,
	IgnoreLayout                             = 1,
	ConstantSize                             = 2,
	RatioSize                                = 3,
	IgnoreControlSize                        = 4,
	ControlTextMaxWidthHeight                = 5,
	ELayoutElementType_MAX                   = 6,
};

// Enum LGUI.EUILayoutChangePositionAnimationType
// NumValues: 0x0003
enum class EUILayoutChangePositionAnimationType : uint8
{
	Immediately                              = 0,
	EaseAnimation                            = 1,
	EUILayoutChangePositionAnimationType_MAX = 2,
};

// Enum LGUI.ELGUILayoutDirectionType
// NumValues: 0x0003
enum class ELGUILayoutDirectionType : uint8
{
	Vertical                                 = 0,
	Horizontal                               = 1,
	ELGUILayoutDirectionType_MAX             = 2,
};

// Enum LGUI.UINavigationPriorityMode
// NumValues: 0x0006
enum class EUINavigationPriorityMode : uint8
{
	Distance                                 = 0,
	Direction                                = 1,
	DistanceDirection                        = 2,
	DirectionAngle                           = 3,
	DistanceOnlySameScroll                   = 4,
	UINavigationPriorityMode_MAX             = 5,
};

// Enum LGUI.UINavigationWrapMode
// NumValues: 0x0004
enum class EUINavigationWrapMode : uint8
{
	None                                     = 0,
	Wrap                                     = 1,
	Next                                     = 2,
	UINavigationWrapMode_MAX                 = 3,
};

// Enum LGUI.UIPolygonUVType
// NumValues: 0x0004
enum class EUIPolygonUVType : uint8
{
	SpriteRect                               = 0,
	HeightCenter                             = 1,
	StretchSpriteHeight                      = 2,
	UIPolygonUVType_MAX                      = 3,
};

// Enum LGUI.ESafeZoneAdaptionStrategy
// NumValues: 0x0005
enum class ESafeZoneAdaptionStrategy : uint8
{
	ESZAS_NoPadding                          = 0,
	ESZAS_SettledPadding                     = 1,
	ESZAS_SymSettledPadding                  = 2,
	ESZAS_CustomPadding                      = 3,
	ESZAS_MAX                                = 4,
};

// Enum LGUI.UIScrollbarDirectionType
// NumValues: 0x0005
enum class EUIScrollbarDirectionType : uint8
{
	LeftToRight                              = 0,
	RightToLeft                              = 1,
	BottomToTop                              = 2,
	TopToBottom                              = 3,
	UIScrollbarDirectionType_MAX             = 4,
};

// Enum LGUI.EOutOfBoundsType
// NumValues: 0x0004
enum class EOutOfBoundsType : uint8
{
	NotOut                                   = 0,
	OutOfBegin                               = 1,
	OutOfEnd                                 = 2,
	EOutOfBoundsType_MAX                     = 3,
};

// Enum LGUI.EScrollViewScrollbarVisibility
// NumValues: 0x0004
enum class EScrollViewScrollbarVisibility : uint8
{
	Permanent                                = 0,
	AutoHide                                 = 1,
	AutoHideAndExpandViewport                = 2,
	EScrollViewScrollbarVisibility_MAX       = 3,
};

// Enum LGUI.EStateTransferType
// NumValues: 0x000A
enum class EStateTransferType : uint8
{
	ESTTT_None                               = 0,
	ESTTT_NormalToHighLight                  = 1,
	ESTTT_HighlightToNormal                  = 2,
	ESTTT_HighLightToPress                   = 3,
	ESTTT_PressToHighLight                   = 4,
	ESTTT_HighLightToSelect                  = 5,
	ESTTT_SelectToNormal                     = 6,
	ESTTT_PressToNormal                      = 7,
	ESTTT_NormalToPress                      = 8,
	ESTTT_MAX                                = 9,
};

// Enum LGUI.EAnimationPlayMode
// NumValues: 0x0004
enum class EAnimationPlayMode : uint8
{
	EMOM_None                                = 0,
	EMOM_ReverseAnimation                    = 1,
	EMOM_CustomAnimation                     = 2,
	EMOM_MAX                                 = 3,
};

// Enum LGUI.EUISelectableInteractionState
// NumValues: 0x0006
enum class EUISelectableInteractionState : uint8
{
	None                                     = 0,
	PointerEnter                             = 1,
	PointerExit                              = 2,
	PointerDown                              = 3,
	PointerUp                                = 4,
	EUISelectableInteractionState_MAX        = 5,
};

// Enum LGUI.EUISelectableNavigationMode
// NumValues: 0x0004
enum class EUISelectableNavigationMode : uint8
{
	None                                     = 0,
	Auto                                     = 1,
	Explicit                                 = 2,
	EUISelectableNavigationMode_MAX          = 3,
};

// Enum LGUI.EUISelectableSelectionState
// NumValues: 0x0006
enum class EUISelectableSelectionState : uint8
{
	Normal                                   = 0,
	Highlighted                              = 1,
	Pressed                                  = 2,
	Disabled                                 = 3,
	Selected                                 = 4,
	EUISelectableSelectionState_MAX          = 5,
};

// Enum LGUI.UISelectableTransitionType
// NumValues: 0x0006
enum class EUISelectableTransitionType : uint8
{
	None                                     = 0,
	ColorTint                                = 1,
	SpriteSwap                               = 2,
	TransitionComponent                      = 3,
	ChangeActor                              = 4,
	UISelectableTransitionType_MAX           = 5,
};

// Enum LGUI.EStateTransitionType
// NumValues: 0x0003
enum class EStateTransitionType : uint8
{
	ImmediateSet                             = 0,
	Gradually                                = 1,
	EStateTransitionType_MAX                 = 2,
};

// Enum LGUI.EUISizeControlByAspectRatioMode
// NumValues: 0x0007
enum class EUISizeControlByAspectRatioMode : uint8
{
	None                                     = 0,
	WidthControlHeight                       = 1,
	HeightControlWidth                       = 2,
	FitInParent                              = 3,
	EnvelopeParent                           = 4,
	EnvelopeParentMin                        = 5,
	EUISizeControlByAspectRatioMode_MAX      = 6,
};

// Enum LGUI.UISliderDirectionType
// NumValues: 0x0005
enum class EUISliderDirectionType : uint8
{
	LeftToRight                              = 0,
	RightToLeft                              = 1,
	BottomToTop                              = 2,
	TopToBottom                              = 3,
	UISliderDirectionType_MAX                = 4,
};

// Enum LGUI.UISpriteFillOriginType_Radial360
// NumValues: 0x0005
enum class EUISpriteFillOriginType_Radial360 : uint8
{
	Bottom                                   = 0,
	Right                                    = 1,
	Top                                      = 2,
	Left                                     = 3,
	UISpriteFillOriginType_MAX               = 4,
};

// Enum LGUI.UISpriteFillOriginType_Radial180
// NumValues: 0x0005
enum class EUISpriteFillOriginType_Radial180 : uint8
{
	Bottom                                   = 0,
	Left                                     = 1,
	Top                                      = 2,
	Right                                    = 3,
	UISpriteFillOriginType_MAX               = 4,
};

// Enum LGUI.UISpriteFillOriginType_Radial90
// NumValues: 0x0005
enum class EUISpriteFillOriginType_Radial90 : uint8
{
	BottomLeft                               = 0,
	TopLeft                                  = 1,
	TopRight                                 = 2,
	BottomRight                              = 3,
	UISpriteFillOriginType_MAX               = 4,
};

// Enum LGUI.UISpriteFillMethod
// NumValues: 0x0006
enum class EUISpriteFillMethod : uint8
{
	Horizontal                               = 0,
	Vertical                                 = 1,
	Radial90                                 = 2,
	Radial180                                = 3,
	Radial360                                = 4,
	UISpriteFillMethod_MAX                   = 5,
};

// Enum LGUI.UISpriteType
// NumValues: 0x0008
enum class EUISpriteType : uint8
{
	Normal                                   = 0,
	Sliced                                   = 1,
	SlicedFrame                              = 2,
	Tiled                                    = 3,
	Filled                                   = 4,
	FilledSliced                             = 5,
	FilledSlicedFrame                        = 6,
	UISpriteType_MAX                         = 7,
};

// Enum LGUI.UIStaticMeshVertexColorType
// NumValues: 0x0004
enum class EUIStaticMeshVertexColorType : uint8
{
	MultiplyWithUIColor                      = 0,
	ReplaceByUIColor                         = 1,
	NotAffectByUIColor                       = 2,
	UIStaticMeshVertexColorType_MAX          = 3,
};

// Enum LGUI.ELGUITextInputType
// NumValues: 0x0006
enum class ELGUITextInputType : uint8
{
	Standard                                 = 0,
	IntegerNumber                            = 1,
	DecimalNumber                            = 2,
	Password                                 = 3,
	CustomFunction                           = 4,
	ELGUITextInputType_MAX                   = 5,
};

// Enum LGUI.UITextureType
// NumValues: 0x0006
enum class EUITextureType : uint8
{
	Normal                                   = 0,
	Sliced                                   = 1,
	SlicedFrame                              = 2,
	Tiled                                    = 3,
	Filled                                   = 4,
	UITextureType_MAX                        = 5,
};

// Enum LGUI.UIToggleTransitionType
// NumValues: 0x0006
enum class EUIToggleTransitionType : uint8
{
	None                                     = 0,
	Fade                                     = 1,
	ColorTint                                = 2,
	TransitionComponent                      = 3,
	ActiveActor                              = 4,
	UIToggleTransitionType_MAX               = 5,
};

// Enum LGUI.UIAnchorVerticalAlign
// NumValues: 0x0006
enum class EUIAnchorVerticalAlign : uint8
{
	None                                     = 0,
	Top                                      = 1,
	Middle                                   = 2,
	Bottom                                   = 3,
	Stretch                                  = 4,
	UIAnchorVerticalAlign_MAX                = 5,
};

// Enum LGUI.UIAnchorHorizontalAlign
// NumValues: 0x0006
enum class EUIAnchorHorizontalAlign : uint8
{
	None                                     = 0,
	Left                                     = 1,
	Center                                   = 2,
	Right                                    = 3,
	Stretch                                  = 4,
	UIAnchorHorizontalAlign_MAX              = 5,
};

// ScriptStruct LGUI.LGUIPrefabOverrideParameterData
// 0x0058 (0x0058 - 0x0000)
struct FLGUIPrefabOverrideParameterData final
{
public:
	TWeakObjectPtr<class UObject>                 Object;                                            // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class FName, struct FGuid>               MemberPropertyInfoMap;                             // 0x0008(0x0050)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLGUIPrefabOverrideParameterData) == 0x000008, "Wrong alignment on FLGUIPrefabOverrideParameterData");
static_assert(sizeof(FLGUIPrefabOverrideParameterData) == 0x000058, "Wrong size on FLGUIPrefabOverrideParameterData");
static_assert(offsetof(FLGUIPrefabOverrideParameterData, Object) == 0x000000, "Member 'FLGUIPrefabOverrideParameterData::Object' has a wrong offset!");
static_assert(offsetof(FLGUIPrefabOverrideParameterData, MemberPropertyInfoMap) == 0x000008, "Member 'FLGUIPrefabOverrideParameterData::MemberPropertyInfoMap' has a wrong offset!");

// ScriptStruct LGUI.UIArtTextInfo
// 0x0018 (0x0018 - 0x0000)
struct FUIArtTextInfo final
{
public:
	class FString                                 Character;                                         // 0x0000(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ULGUISpriteData_BaseObject*             SpriteData;                                        // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FUIArtTextInfo) == 0x000008, "Wrong alignment on FUIArtTextInfo");
static_assert(sizeof(FUIArtTextInfo) == 0x000018, "Wrong size on FUIArtTextInfo");
static_assert(offsetof(FUIArtTextInfo, Character) == 0x000000, "Member 'FUIArtTextInfo::Character' has a wrong offset!");
static_assert(offsetof(FUIArtTextInfo, SpriteData) == 0x000010, "Member 'FUIArtTextInfo::SpriteData' has a wrong offset!");

// ScriptStruct LGUI.LGUIDrawableEventData
// 0x0080 (0x0080 - 0x0000)
struct FLGUIDrawableEventData final
{
public:
	class AActor*                                 targetActor;                                       // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UClass*                                 componentClass;                                    // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   componentName;                                     // 0x0010(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   functionName;                                      // 0x001C(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELGUIDrawableEventParameterType               ParamType;                                         // 0x0028(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<uint8>                                 ParamBuffer;                                       // 0x0030(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	class UObject*                                ReferenceObject;                                   // 0x0040(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 ReferenceActor;                                    // 0x0048(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UClass*                                 ReferenceClass;                                    // 0x0050(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ReferenceString;                                   // 0x0058(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UseNativeParameter;                                // 0x0068(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_69[0x7];                                       // 0x0069(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UFunction*                              CacheFunction;                                     // 0x0070(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UObject*                                CacheTarget;                                       // 0x0078(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FLGUIDrawableEventData) == 0x000008, "Wrong alignment on FLGUIDrawableEventData");
static_assert(sizeof(FLGUIDrawableEventData) == 0x000080, "Wrong size on FLGUIDrawableEventData");
static_assert(offsetof(FLGUIDrawableEventData, targetActor) == 0x000000, "Member 'FLGUIDrawableEventData::targetActor' has a wrong offset!");
static_assert(offsetof(FLGUIDrawableEventData, componentClass) == 0x000008, "Member 'FLGUIDrawableEventData::componentClass' has a wrong offset!");
static_assert(offsetof(FLGUIDrawableEventData, componentName) == 0x000010, "Member 'FLGUIDrawableEventData::componentName' has a wrong offset!");
static_assert(offsetof(FLGUIDrawableEventData, functionName) == 0x00001C, "Member 'FLGUIDrawableEventData::functionName' has a wrong offset!");
static_assert(offsetof(FLGUIDrawableEventData, ParamType) == 0x000028, "Member 'FLGUIDrawableEventData::ParamType' has a wrong offset!");
static_assert(offsetof(FLGUIDrawableEventData, ParamBuffer) == 0x000030, "Member 'FLGUIDrawableEventData::ParamBuffer' has a wrong offset!");
static_assert(offsetof(FLGUIDrawableEventData, ReferenceObject) == 0x000040, "Member 'FLGUIDrawableEventData::ReferenceObject' has a wrong offset!");
static_assert(offsetof(FLGUIDrawableEventData, ReferenceActor) == 0x000048, "Member 'FLGUIDrawableEventData::ReferenceActor' has a wrong offset!");
static_assert(offsetof(FLGUIDrawableEventData, ReferenceClass) == 0x000050, "Member 'FLGUIDrawableEventData::ReferenceClass' has a wrong offset!");
static_assert(offsetof(FLGUIDrawableEventData, ReferenceString) == 0x000058, "Member 'FLGUIDrawableEventData::ReferenceString' has a wrong offset!");
static_assert(offsetof(FLGUIDrawableEventData, UseNativeParameter) == 0x000068, "Member 'FLGUIDrawableEventData::UseNativeParameter' has a wrong offset!");
static_assert(offsetof(FLGUIDrawableEventData, CacheFunction) == 0x000070, "Member 'FLGUIDrawableEventData::CacheFunction' has a wrong offset!");
static_assert(offsetof(FLGUIDrawableEventData, CacheTarget) == 0x000078, "Member 'FLGUIDrawableEventData::CacheTarget' has a wrong offset!");

// ScriptStruct LGUI.LGUIDrawableEvent
// 0x0018 (0x0018 - 0x0000)
struct FLGUIDrawableEvent
{
public:
	TArray<struct FLGUIDrawableEventData>         eventList;                                         // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	ELGUIDrawableEventParameterType               supportParameterType;                              // 0x0010(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLGUIDrawableEvent) == 0x000008, "Wrong alignment on FLGUIDrawableEvent");
static_assert(sizeof(FLGUIDrawableEvent) == 0x000018, "Wrong size on FLGUIDrawableEvent");
static_assert(offsetof(FLGUIDrawableEvent, eventList) == 0x000000, "Member 'FLGUIDrawableEvent::eventList' has a wrong offset!");
static_assert(offsetof(FLGUIDrawableEvent, supportParameterType) == 0x000010, "Member 'FLGUIDrawableEvent::supportParameterType' has a wrong offset!");

// ScriptStruct LGUI.LGUIDrawableEvent_Int64
// 0x0018 (0x0030 - 0x0018)
struct FLGUIDrawableEvent_Int64 final : public FLGUIDrawableEvent
{
public:
	uint8                                         Pad_18[0x18];                                      // 0x0018(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLGUIDrawableEvent_Int64) == 0x000008, "Wrong alignment on FLGUIDrawableEvent_Int64");
static_assert(sizeof(FLGUIDrawableEvent_Int64) == 0x000030, "Wrong size on FLGUIDrawableEvent_Int64");

// ScriptStruct LGUI.LGUIAtlasData
// 0x0070 (0x0070 - 0x0000)
struct FLGUIAtlasData final
{
public:
	TArray<TWeakObjectPtr<class UUISpriteBase>>   renderSpriteArray;                                 // 0x0000(0x0010)(Edit, ExportObject, ZeroConstructor, EditConst, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPublic)
	class UTexture2D*                             atlasTexture;                                      // 0x0010(0x0008)(Edit, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18[0x30];                                      // 0x0018(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class ULGUISpriteData*>                spriteDataArray;                                   // 0x0048(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	uint8                                         Pad_58[0x18];                                      // 0x0058(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLGUIAtlasData) == 0x000008, "Wrong alignment on FLGUIAtlasData");
static_assert(sizeof(FLGUIAtlasData) == 0x000070, "Wrong size on FLGUIAtlasData");
static_assert(offsetof(FLGUIAtlasData, renderSpriteArray) == 0x000000, "Member 'FLGUIAtlasData::renderSpriteArray' has a wrong offset!");
static_assert(offsetof(FLGUIAtlasData, atlasTexture) == 0x000010, "Member 'FLGUIAtlasData::atlasTexture' has a wrong offset!");
static_assert(offsetof(FLGUIAtlasData, spriteDataArray) == 0x000048, "Member 'FLGUIAtlasData::spriteDataArray' has a wrong offset!");

// ScriptStruct LGUI.LGUIMaterialArrayContainer
// 0x0010 (0x0010 - 0x0000)
struct FLGUIMaterialArrayContainer final
{
public:
	TArray<class UMaterialInstanceDynamic*>       MaterialList;                                      // 0x0000(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLGUIMaterialArrayContainer) == 0x000008, "Wrong alignment on FLGUIMaterialArrayContainer");
static_assert(sizeof(FLGUIMaterialArrayContainer) == 0x000010, "Wrong size on FLGUIMaterialArrayContainer");
static_assert(offsetof(FLGUIMaterialArrayContainer, MaterialList) == 0x000000, "Member 'FLGUIMaterialArrayContainer::MaterialList' has a wrong offset!");

// ScriptStruct LGUI.LGUIComponentReference
// 0x0028 (0x0028 - 0x0000)
struct FLGUIComponentReference final
{
public:
	TWeakObjectPtr<class AActor>                  targetActor;                                       // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UActorComponent>            targetComponentClass;                              // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   targetComonentName;                                // 0x0010(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class UActorComponent>         componentInstance;                                 // 0x001C(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLGUIComponentReference) == 0x000008, "Wrong alignment on FLGUIComponentReference");
static_assert(sizeof(FLGUIComponentReference) == 0x000028, "Wrong size on FLGUIComponentReference");
static_assert(offsetof(FLGUIComponentReference, targetActor) == 0x000000, "Member 'FLGUIComponentReference::targetActor' has a wrong offset!");
static_assert(offsetof(FLGUIComponentReference, targetComponentClass) == 0x000008, "Member 'FLGUIComponentReference::targetComponentClass' has a wrong offset!");
static_assert(offsetof(FLGUIComponentReference, targetComonentName) == 0x000010, "Member 'FLGUIComponentReference::targetComonentName' has a wrong offset!");
static_assert(offsetof(FLGUIComponentReference, componentInstance) == 0x00001C, "Member 'FLGUIComponentReference::componentInstance' has a wrong offset!");

// ScriptStruct LGUI.UIItemInfo
// 0x0001 (0x0001 - 0x0000)
struct FUIItemInfo final
{
public:
	uint8                                         Pad_0[0x1];                                        // 0x0000(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FUIItemInfo) == 0x000001, "Wrong alignment on FUIItemInfo");
static_assert(sizeof(FUIItemInfo) == 0x000001, "Wrong size on FUIItemInfo");

// ScriptStruct LGUI.RegisterRuntimeData
// 0x0020 (0x0020 - 0x0000)
struct FRegisterRuntimeData final
{
public:
	class AActor*                                 TargetActor;                                       // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UClass*                                 TargetComponentClass;                              // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ComponentName;                                     // 0x0010(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRegisterRuntimeData) == 0x000008, "Wrong alignment on FRegisterRuntimeData");
static_assert(sizeof(FRegisterRuntimeData) == 0x000020, "Wrong size on FRegisterRuntimeData");
static_assert(offsetof(FRegisterRuntimeData, TargetActor) == 0x000000, "Member 'FRegisterRuntimeData::TargetActor' has a wrong offset!");
static_assert(offsetof(FRegisterRuntimeData, TargetComponentClass) == 0x000008, "Member 'FRegisterRuntimeData::TargetComponentClass' has a wrong offset!");
static_assert(offsetof(FRegisterRuntimeData, ComponentName) == 0x000010, "Member 'FRegisterRuntimeData::ComponentName' has a wrong offset!");

// ScriptStruct LGUI.ComponentRegistryEditorData
// 0x0050 (0x0050 - 0x0000)
struct FComponentRegistryEditorData final
{
public:
	class FString                                 ExportName;                                        // 0x0000(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRegisterRuntimeData                   RuntimeCacheData;                                  // 0x0010(0x0020)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	class FString                                 ActorPath;                                         // 0x0030(0x0010)(Edit, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ActorType;                                         // 0x0040(0x0010)(Edit, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FComponentRegistryEditorData) == 0x000008, "Wrong alignment on FComponentRegistryEditorData");
static_assert(sizeof(FComponentRegistryEditorData) == 0x000050, "Wrong size on FComponentRegistryEditorData");
static_assert(offsetof(FComponentRegistryEditorData, ExportName) == 0x000000, "Member 'FComponentRegistryEditorData::ExportName' has a wrong offset!");
static_assert(offsetof(FComponentRegistryEditorData, RuntimeCacheData) == 0x000010, "Member 'FComponentRegistryEditorData::RuntimeCacheData' has a wrong offset!");
static_assert(offsetof(FComponentRegistryEditorData, ActorPath) == 0x000030, "Member 'FComponentRegistryEditorData::ActorPath' has a wrong offset!");
static_assert(offsetof(FComponentRegistryEditorData, ActorType) == 0x000040, "Member 'FComponentRegistryEditorData::ActorType' has a wrong offset!");

// ScriptStruct LGUI.RegisteredComponents
// 0x0010 (0x0010 - 0x0000)
struct FRegisteredComponents final
{
public:
	TArray<struct FComponentRegistryEditorData>   RegisteredData;                                    // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRegisteredComponents) == 0x000008, "Wrong alignment on FRegisteredComponents");
static_assert(sizeof(FRegisteredComponents) == 0x000010, "Wrong size on FRegisteredComponents");
static_assert(offsetof(FRegisteredComponents, RegisteredData) == 0x000000, "Member 'FRegisteredComponents::RegisteredData' has a wrong offset!");

// ScriptStruct LGUI.LGUIDelegateHandleWrapper
// 0x0008 (0x0008 - 0x0000)
struct alignas(0x08) FLGUIDelegateHandleWrapper final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLGUIDelegateHandleWrapper) == 0x000008, "Wrong alignment on FLGUIDelegateHandleWrapper");
static_assert(sizeof(FLGUIDelegateHandleWrapper) == 0x000008, "Wrong size on FLGUIDelegateHandleWrapper");

// ScriptStruct LGUI.LGUIDrawableEvent_Rotator
// 0x0018 (0x0030 - 0x0018)
struct FLGUIDrawableEvent_Rotator final : public FLGUIDrawableEvent
{
public:
	uint8                                         Pad_18[0x18];                                      // 0x0018(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLGUIDrawableEvent_Rotator) == 0x000008, "Wrong alignment on FLGUIDrawableEvent_Rotator");
static_assert(sizeof(FLGUIDrawableEvent_Rotator) == 0x000030, "Wrong size on FLGUIDrawableEvent_Rotator");

// ScriptStruct LGUI.LGUIDrawableEvent_Class
// 0x0018 (0x0030 - 0x0018)
struct FLGUIDrawableEvent_Class final : public FLGUIDrawableEvent
{
public:
	uint8                                         Pad_18[0x18];                                      // 0x0018(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLGUIDrawableEvent_Class) == 0x000008, "Wrong alignment on FLGUIDrawableEvent_Class");
static_assert(sizeof(FLGUIDrawableEvent_Class) == 0x000030, "Wrong size on FLGUIDrawableEvent_Class");

// ScriptStruct LGUI.LGUIDrawableEvent_PointerEvent
// 0x0018 (0x0030 - 0x0018)
struct FLGUIDrawableEvent_PointerEvent final : public FLGUIDrawableEvent
{
public:
	uint8                                         Pad_18[0x18];                                      // 0x0018(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLGUIDrawableEvent_PointerEvent) == 0x000008, "Wrong alignment on FLGUIDrawableEvent_PointerEvent");
static_assert(sizeof(FLGUIDrawableEvent_PointerEvent) == 0x000030, "Wrong size on FLGUIDrawableEvent_PointerEvent");

// ScriptStruct LGUI.LGUIDrawableEvent_Actor
// 0x0018 (0x0030 - 0x0018)
struct FLGUIDrawableEvent_Actor final : public FLGUIDrawableEvent
{
public:
	uint8                                         Pad_18[0x18];                                      // 0x0018(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLGUIDrawableEvent_Actor) == 0x000008, "Wrong alignment on FLGUIDrawableEvent_Actor");
static_assert(sizeof(FLGUIDrawableEvent_Actor) == 0x000030, "Wrong size on FLGUIDrawableEvent_Actor");

// ScriptStruct LGUI.LGUIDrawableEvent_Object
// 0x0018 (0x0030 - 0x0018)
struct FLGUIDrawableEvent_Object final : public FLGUIDrawableEvent
{
public:
	uint8                                         Pad_18[0x18];                                      // 0x0018(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLGUIDrawableEvent_Object) == 0x000008, "Wrong alignment on FLGUIDrawableEvent_Object");
static_assert(sizeof(FLGUIDrawableEvent_Object) == 0x000030, "Wrong size on FLGUIDrawableEvent_Object");

// ScriptStruct LGUI.LGUIDrawableEvent_String
// 0x0018 (0x0030 - 0x0018)
struct FLGUIDrawableEvent_String final : public FLGUIDrawableEvent
{
public:
	uint8                                         Pad_18[0x18];                                      // 0x0018(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLGUIDrawableEvent_String) == 0x000008, "Wrong alignment on FLGUIDrawableEvent_String");
static_assert(sizeof(FLGUIDrawableEvent_String) == 0x000030, "Wrong size on FLGUIDrawableEvent_String");

// ScriptStruct LGUI.LGUIDrawableEvent_Quaternion
// 0x0018 (0x0030 - 0x0018)
struct FLGUIDrawableEvent_Quaternion final : public FLGUIDrawableEvent
{
public:
	uint8                                         Pad_18[0x18];                                      // 0x0018(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLGUIDrawableEvent_Quaternion) == 0x000008, "Wrong alignment on FLGUIDrawableEvent_Quaternion");
static_assert(sizeof(FLGUIDrawableEvent_Quaternion) == 0x000030, "Wrong size on FLGUIDrawableEvent_Quaternion");

// ScriptStruct LGUI.LGUIDrawableEvent_LinearColor
// 0x0018 (0x0030 - 0x0018)
struct FLGUIDrawableEvent_LinearColor final : public FLGUIDrawableEvent
{
public:
	uint8                                         Pad_18[0x18];                                      // 0x0018(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLGUIDrawableEvent_LinearColor) == 0x000008, "Wrong alignment on FLGUIDrawableEvent_LinearColor");
static_assert(sizeof(FLGUIDrawableEvent_LinearColor) == 0x000030, "Wrong size on FLGUIDrawableEvent_LinearColor");

// ScriptStruct LGUI.LGUIDrawableEvent_Color
// 0x0018 (0x0030 - 0x0018)
struct FLGUIDrawableEvent_Color final : public FLGUIDrawableEvent
{
public:
	uint8                                         Pad_18[0x18];                                      // 0x0018(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLGUIDrawableEvent_Color) == 0x000008, "Wrong alignment on FLGUIDrawableEvent_Color");
static_assert(sizeof(FLGUIDrawableEvent_Color) == 0x000030, "Wrong size on FLGUIDrawableEvent_Color");

// ScriptStruct LGUI.LGUIDrawableEvent_Vector4
// 0x0018 (0x0030 - 0x0018)
struct FLGUIDrawableEvent_Vector4 final : public FLGUIDrawableEvent
{
public:
	uint8                                         Pad_18[0x18];                                      // 0x0018(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLGUIDrawableEvent_Vector4) == 0x000008, "Wrong alignment on FLGUIDrawableEvent_Vector4");
static_assert(sizeof(FLGUIDrawableEvent_Vector4) == 0x000030, "Wrong size on FLGUIDrawableEvent_Vector4");

// ScriptStruct LGUI.LGUIDrawableEvent_Vector3
// 0x0018 (0x0030 - 0x0018)
struct FLGUIDrawableEvent_Vector3 final : public FLGUIDrawableEvent
{
public:
	uint8                                         Pad_18[0x18];                                      // 0x0018(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLGUIDrawableEvent_Vector3) == 0x000008, "Wrong alignment on FLGUIDrawableEvent_Vector3");
static_assert(sizeof(FLGUIDrawableEvent_Vector3) == 0x000030, "Wrong size on FLGUIDrawableEvent_Vector3");

// ScriptStruct LGUI.LGUIDrawableEvent_Vector2
// 0x0018 (0x0030 - 0x0018)
struct FLGUIDrawableEvent_Vector2 final : public FLGUIDrawableEvent
{
public:
	uint8                                         Pad_18[0x18];                                      // 0x0018(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLGUIDrawableEvent_Vector2) == 0x000008, "Wrong alignment on FLGUIDrawableEvent_Vector2");
static_assert(sizeof(FLGUIDrawableEvent_Vector2) == 0x000030, "Wrong size on FLGUIDrawableEvent_Vector2");

// ScriptStruct LGUI.LGUIDrawableEvent_UInt64
// 0x0018 (0x0030 - 0x0018)
struct FLGUIDrawableEvent_UInt64 final : public FLGUIDrawableEvent
{
public:
	uint8                                         Pad_18[0x18];                                      // 0x0018(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLGUIDrawableEvent_UInt64) == 0x000008, "Wrong alignment on FLGUIDrawableEvent_UInt64");
static_assert(sizeof(FLGUIDrawableEvent_UInt64) == 0x000030, "Wrong size on FLGUIDrawableEvent_UInt64");

// ScriptStruct LGUI.LGUIDrawableEvent_UInt32
// 0x0018 (0x0030 - 0x0018)
struct FLGUIDrawableEvent_UInt32 final : public FLGUIDrawableEvent
{
public:
	uint8                                         Pad_18[0x18];                                      // 0x0018(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLGUIDrawableEvent_UInt32) == 0x000008, "Wrong alignment on FLGUIDrawableEvent_UInt32");
static_assert(sizeof(FLGUIDrawableEvent_UInt32) == 0x000030, "Wrong size on FLGUIDrawableEvent_UInt32");

// ScriptStruct LGUI.LGUIDrawableEvent_Int32
// 0x0018 (0x0030 - 0x0018)
struct FLGUIDrawableEvent_Int32 final : public FLGUIDrawableEvent
{
public:
	uint8                                         Pad_18[0x18];                                      // 0x0018(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLGUIDrawableEvent_Int32) == 0x000008, "Wrong alignment on FLGUIDrawableEvent_Int32");
static_assert(sizeof(FLGUIDrawableEvent_Int32) == 0x000030, "Wrong size on FLGUIDrawableEvent_Int32");

// ScriptStruct LGUI.LGUIDrawableEvent_UInt16
// 0x0018 (0x0030 - 0x0018)
struct FLGUIDrawableEvent_UInt16 final : public FLGUIDrawableEvent
{
public:
	uint8                                         Pad_18[0x18];                                      // 0x0018(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLGUIDrawableEvent_UInt16) == 0x000008, "Wrong alignment on FLGUIDrawableEvent_UInt16");
static_assert(sizeof(FLGUIDrawableEvent_UInt16) == 0x000030, "Wrong size on FLGUIDrawableEvent_UInt16");

// ScriptStruct LGUI.LGUIDrawableEvent_Int16
// 0x0018 (0x0030 - 0x0018)
struct FLGUIDrawableEvent_Int16 final : public FLGUIDrawableEvent
{
public:
	uint8                                         Pad_18[0x18];                                      // 0x0018(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLGUIDrawableEvent_Int16) == 0x000008, "Wrong alignment on FLGUIDrawableEvent_Int16");
static_assert(sizeof(FLGUIDrawableEvent_Int16) == 0x000030, "Wrong size on FLGUIDrawableEvent_Int16");

// ScriptStruct LGUI.LGUIDrawableEvent_UInt8
// 0x0018 (0x0030 - 0x0018)
struct FLGUIDrawableEvent_UInt8 final : public FLGUIDrawableEvent
{
public:
	uint8                                         Pad_18[0x18];                                      // 0x0018(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLGUIDrawableEvent_UInt8) == 0x000008, "Wrong alignment on FLGUIDrawableEvent_UInt8");
static_assert(sizeof(FLGUIDrawableEvent_UInt8) == 0x000030, "Wrong size on FLGUIDrawableEvent_UInt8");

// ScriptStruct LGUI.LGUIDrawableEvent_Int8
// 0x0018 (0x0030 - 0x0018)
struct FLGUIDrawableEvent_Int8 final : public FLGUIDrawableEvent
{
public:
	uint8                                         Pad_18[0x18];                                      // 0x0018(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLGUIDrawableEvent_Int8) == 0x000008, "Wrong alignment on FLGUIDrawableEvent_Int8");
static_assert(sizeof(FLGUIDrawableEvent_Int8) == 0x000030, "Wrong size on FLGUIDrawableEvent_Int8");

// ScriptStruct LGUI.LGUIDrawableEvent_Double
// 0x0018 (0x0030 - 0x0018)
struct FLGUIDrawableEvent_Double final : public FLGUIDrawableEvent
{
public:
	uint8                                         Pad_18[0x18];                                      // 0x0018(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLGUIDrawableEvent_Double) == 0x000008, "Wrong alignment on FLGUIDrawableEvent_Double");
static_assert(sizeof(FLGUIDrawableEvent_Double) == 0x000030, "Wrong size on FLGUIDrawableEvent_Double");

// ScriptStruct LGUI.LGUIDrawableEvent_Float
// 0x0018 (0x0030 - 0x0018)
struct FLGUIDrawableEvent_Float final : public FLGUIDrawableEvent
{
public:
	uint8                                         Pad_18[0x18];                                      // 0x0018(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLGUIDrawableEvent_Float) == 0x000008, "Wrong alignment on FLGUIDrawableEvent_Float");
static_assert(sizeof(FLGUIDrawableEvent_Float) == 0x000030, "Wrong size on FLGUIDrawableEvent_Float");

// ScriptStruct LGUI.LGUIDrawableEvent_Bool
// 0x0018 (0x0030 - 0x0018)
struct FLGUIDrawableEvent_Bool final : public FLGUIDrawableEvent
{
public:
	uint8                                         Pad_18[0x18];                                      // 0x0018(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLGUIDrawableEvent_Bool) == 0x000008, "Wrong alignment on FLGUIDrawableEvent_Bool");
static_assert(sizeof(FLGUIDrawableEvent_Bool) == 0x000030, "Wrong size on FLGUIDrawableEvent_Bool");

// ScriptStruct LGUI.LGUIDrawableEvent_Empty
// 0x0018 (0x0030 - 0x0018)
struct FLGUIDrawableEvent_Empty final : public FLGUIDrawableEvent
{
public:
	uint8                                         Pad_18[0x18];                                      // 0x0018(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLGUIDrawableEvent_Empty) == 0x000008, "Wrong alignment on FLGUIDrawableEvent_Empty");
static_assert(sizeof(FLGUIDrawableEvent_Empty) == 0x000030, "Wrong size on FLGUIDrawableEvent_Empty");

// ScriptStruct LGUI.LGUISubFontData
// 0x0030 (0x0030 - 0x0000)
struct FLGUISubFontData final
{
public:
	class UFontFace*                              unrealFont;                                        // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FInt32Range>                    CharacterRanges;                                   // 0x0008(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	ECulture                                      Cultures;                                          // 0x0018(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x3];                                       // 0x0019(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         VerticalOffset;                                    // 0x001C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_20[0x10];                                      // 0x0020(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLGUISubFontData) == 0x000008, "Wrong alignment on FLGUISubFontData");
static_assert(sizeof(FLGUISubFontData) == 0x000030, "Wrong size on FLGUISubFontData");
static_assert(offsetof(FLGUISubFontData, unrealFont) == 0x000000, "Member 'FLGUISubFontData::unrealFont' has a wrong offset!");
static_assert(offsetof(FLGUISubFontData, CharacterRanges) == 0x000008, "Member 'FLGUISubFontData::CharacterRanges' has a wrong offset!");
static_assert(offsetof(FLGUISubFontData, Cultures) == 0x000018, "Member 'FLGUISubFontData::Cultures' has a wrong offset!");
static_assert(offsetof(FLGUISubFontData, VerticalOffset) == 0x00001C, "Member 'FLGUISubFontData::VerticalOffset' has a wrong offset!");

// ScriptStruct LGUI.LGUICharData
// 0x0040 (0x0040 - 0x0000)
struct alignas(0x08) FLGUICharData final
{
public:
	uint16                                        width;                                             // 0x0000(0x0002)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint16                                        height;                                            // 0x0002(0x0002)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         xoffset;                                           // 0x0004(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         yoffset;                                           // 0x0008(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int16                                         xadvance;                                          // 0x000C(0x0002)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E[0x2];                                        // 0x000E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         uv0X;                                              // 0x0010(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         uv0Y;                                              // 0x0014(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         uv3X;                                              // 0x0018(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         uv3Y;                                              // 0x001C(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasRendered;                                      // 0x0020(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x1];                                       // 0x0021(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int16                                         descender;                                         // 0x0022(0x0002)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x1C];                                      // 0x0024(0x001C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLGUICharData) == 0x000008, "Wrong alignment on FLGUICharData");
static_assert(sizeof(FLGUICharData) == 0x000040, "Wrong size on FLGUICharData");
static_assert(offsetof(FLGUICharData, width) == 0x000000, "Member 'FLGUICharData::width' has a wrong offset!");
static_assert(offsetof(FLGUICharData, height) == 0x000002, "Member 'FLGUICharData::height' has a wrong offset!");
static_assert(offsetof(FLGUICharData, xoffset) == 0x000004, "Member 'FLGUICharData::xoffset' has a wrong offset!");
static_assert(offsetof(FLGUICharData, yoffset) == 0x000008, "Member 'FLGUICharData::yoffset' has a wrong offset!");
static_assert(offsetof(FLGUICharData, xadvance) == 0x00000C, "Member 'FLGUICharData::xadvance' has a wrong offset!");
static_assert(offsetof(FLGUICharData, uv0X) == 0x000010, "Member 'FLGUICharData::uv0X' has a wrong offset!");
static_assert(offsetof(FLGUICharData, uv0Y) == 0x000014, "Member 'FLGUICharData::uv0Y' has a wrong offset!");
static_assert(offsetof(FLGUICharData, uv3X) == 0x000018, "Member 'FLGUICharData::uv3X' has a wrong offset!");
static_assert(offsetof(FLGUICharData, uv3Y) == 0x00001C, "Member 'FLGUICharData::uv3Y' has a wrong offset!");
static_assert(offsetof(FLGUICharData, bHasRendered) == 0x000020, "Member 'FLGUICharData::bHasRendered' has a wrong offset!");
static_assert(offsetof(FLGUICharData, descender) == 0x000022, "Member 'FLGUICharData::descender' has a wrong offset!");

// ScriptStruct LGUI.LGUIPostTickFunction
// 0x0008 (0x0030 - 0x0028)
struct FLGUIPostTickFunction final : public FTickFunction
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLGUIPostTickFunction) == 0x000008, "Wrong alignment on FLGUIPostTickFunction");
static_assert(sizeof(FLGUIPostTickFunction) == 0x000030, "Wrong size on FLGUIPostTickFunction");

// ScriptStruct LGUI.LGUIBehaviourArrayContainer
// 0x0010 (0x0010 - 0x0000)
struct FLGUIBehaviourArrayContainer final
{
public:
	TArray<TWeakObjectPtr<class ULGUIBehaviour>>  LGUIBehaviourArray;                                // 0x0000(0x0010)(Edit, ExportObject, ZeroConstructor, EditConst, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLGUIBehaviourArrayContainer) == 0x000008, "Wrong alignment on FLGUIBehaviourArrayContainer");
static_assert(sizeof(FLGUIBehaviourArrayContainer) == 0x000010, "Wrong size on FLGUIBehaviourArrayContainer");
static_assert(offsetof(FLGUIBehaviourArrayContainer, LGUIBehaviourArray) == 0x000000, "Member 'FLGUIBehaviourArrayContainer::LGUIBehaviourArray' has a wrong offset!");

// ScriptStruct LGUI.ActorGuidAndPrefabContainer
// 0x0058 (0x0058 - 0x0000)
struct FActorGuidAndPrefabContainer final
{
public:
	class ULGUIPrefab*                            Prefab;                                            // 0x0000(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<struct FGuid, struct FGuid>              GuidFromPrefabToInstance;                          // 0x0008(0x0050)(Edit, EditConst, NativeAccessSpecifierPublic)
};
static_assert(alignof(FActorGuidAndPrefabContainer) == 0x000008, "Wrong alignment on FActorGuidAndPrefabContainer");
static_assert(sizeof(FActorGuidAndPrefabContainer) == 0x000058, "Wrong size on FActorGuidAndPrefabContainer");
static_assert(offsetof(FActorGuidAndPrefabContainer, Prefab) == 0x000000, "Member 'FActorGuidAndPrefabContainer::Prefab' has a wrong offset!");
static_assert(offsetof(FActorGuidAndPrefabContainer, GuidFromPrefabToInstance) == 0x000008, "Member 'FActorGuidAndPrefabContainer::GuidFromPrefabToInstance' has a wrong offset!");

// ScriptStruct LGUI.LGUISubPrefabData
// 0x00D8 (0x00D8 - 0x0000)
struct FLGUISubPrefabData final
{
public:
	struct FGuid                                  MasterPrefabGuid;                                  // 0x0000(0x0010)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGuid                                  UniqueStamp;                                       // 0x0010(0x0010)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ULGUIPrefabV2*                          PrefabAsset;                                       // 0x0020(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FLGUIPrefabOverrideParameterData> ObjectOverrideParameterArray;                      // 0x0028(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	TMap<struct FGuid, struct FGuid>              ObjMainGuidToSelfGuidMap;                          // 0x0038(0x0050)(Edit, EditConst, NativeAccessSpecifierPublic)
	TMap<struct FGuid, class UObject*>            SelfGuidObjMap;                                    // 0x0088(0x0050)(Edit, EditConst, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLGUISubPrefabData) == 0x000008, "Wrong alignment on FLGUISubPrefabData");
static_assert(sizeof(FLGUISubPrefabData) == 0x0000D8, "Wrong size on FLGUISubPrefabData");
static_assert(offsetof(FLGUISubPrefabData, MasterPrefabGuid) == 0x000000, "Member 'FLGUISubPrefabData::MasterPrefabGuid' has a wrong offset!");
static_assert(offsetof(FLGUISubPrefabData, UniqueStamp) == 0x000010, "Member 'FLGUISubPrefabData::UniqueStamp' has a wrong offset!");
static_assert(offsetof(FLGUISubPrefabData, PrefabAsset) == 0x000020, "Member 'FLGUISubPrefabData::PrefabAsset' has a wrong offset!");
static_assert(offsetof(FLGUISubPrefabData, ObjectOverrideParameterArray) == 0x000028, "Member 'FLGUISubPrefabData::ObjectOverrideParameterArray' has a wrong offset!");
static_assert(offsetof(FLGUISubPrefabData, ObjMainGuidToSelfGuidMap) == 0x000038, "Member 'FLGUISubPrefabData::ObjMainGuidToSelfGuidMap' has a wrong offset!");
static_assert(offsetof(FLGUISubPrefabData, SelfGuidObjMap) == 0x000088, "Member 'FLGUISubPrefabData::SelfGuidObjMap' has a wrong offset!");

// ScriptStruct LGUI.GuidObjBiMap
// 0x00A0 (0x00A0 - 0x0000)
struct FGuidObjBiMap final
{
public:
	TMap<struct FGuid, class UObject*>            AllGuidToObjMap;                                   // 0x0000(0x0050)(NativeAccessSpecifierPublic)
	TMap<class UObject*, struct FGuid>            AllObjToGuidMap;                                   // 0x0050(0x0050)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FGuidObjBiMap) == 0x000008, "Wrong alignment on FGuidObjBiMap");
static_assert(sizeof(FGuidObjBiMap) == 0x0000A0, "Wrong size on FGuidObjBiMap");
static_assert(offsetof(FGuidObjBiMap, AllGuidToObjMap) == 0x000000, "Member 'FGuidObjBiMap::AllGuidToObjMap' has a wrong offset!");
static_assert(offsetof(FGuidObjBiMap, AllObjToGuidMap) == 0x000050, "Member 'FGuidObjBiMap::AllObjToGuidMap' has a wrong offset!");

// ScriptStruct LGUI.ActorBindings
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x08) FActorBindings final
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FActorBindings) == 0x000008, "Wrong alignment on FActorBindings");
static_assert(sizeof(FActorBindings) == 0x000010, "Wrong size on FActorBindings");

// ScriptStruct LGUI.ActorBindingInfo
// 0x0018 (0x0018 - 0x0000)
struct FActorBindingInfo final
{
public:
	TWeakObjectPtr<class AActor>                  Actor;                                             // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGuid                                  ObjectGUID;                                        // 0x0008(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FActorBindingInfo) == 0x000004, "Wrong alignment on FActorBindingInfo");
static_assert(sizeof(FActorBindingInfo) == 0x000018, "Wrong size on FActorBindingInfo");
static_assert(offsetof(FActorBindingInfo, Actor) == 0x000000, "Member 'FActorBindingInfo::Actor' has a wrong offset!");
static_assert(offsetof(FActorBindingInfo, ObjectGUID) == 0x000008, "Member 'FActorBindingInfo::ObjectGUID' has a wrong offset!");

// ScriptStruct LGUI.LGUIAtlasSettings
// 0x0008 (0x0008 - 0x0000)
struct FLGUIAtlasSettings final
{
public:
	ELGUIAtlasTextureSizeType                     atlasTextureInitialSize;                           // 0x0000(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          atlasTextureUseSRGB;                               // 0x0001(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETextureFilter                                atlasTextureFilter;                                // 0x0002(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3[0x1];                                        // 0x0003(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         spaceBetweenSprites;                               // 0x0004(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLGUIAtlasSettings) == 0x000004, "Wrong alignment on FLGUIAtlasSettings");
static_assert(sizeof(FLGUIAtlasSettings) == 0x000008, "Wrong size on FLGUIAtlasSettings");
static_assert(offsetof(FLGUIAtlasSettings, atlasTextureInitialSize) == 0x000000, "Member 'FLGUIAtlasSettings::atlasTextureInitialSize' has a wrong offset!");
static_assert(offsetof(FLGUIAtlasSettings, atlasTextureUseSRGB) == 0x000001, "Member 'FLGUIAtlasSettings::atlasTextureUseSRGB' has a wrong offset!");
static_assert(offsetof(FLGUIAtlasSettings, atlasTextureFilter) == 0x000002, "Member 'FLGUIAtlasSettings::atlasTextureFilter' has a wrong offset!");
static_assert(offsetof(FLGUIAtlasSettings, spaceBetweenSprites) == 0x000004, "Member 'FLGUIAtlasSettings::spaceBetweenSprites' has a wrong offset!");

// ScriptStruct LGUI.LGUIFixedInfo
// 0x0020 (0x0020 - 0x0000)
struct FLGUIFixedInfo final
{
public:
	int32                                         ResolutionWidth;                                   // 0x0000(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ResolutionHeight;                                  // 0x0004(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                OverlayLocation;                                   // 0x0008(0x000C)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               OverlayRotation;                                   // 0x0014(0x000C)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLGUIFixedInfo) == 0x000004, "Wrong alignment on FLGUIFixedInfo");
static_assert(sizeof(FLGUIFixedInfo) == 0x000020, "Wrong size on FLGUIFixedInfo");
static_assert(offsetof(FLGUIFixedInfo, ResolutionWidth) == 0x000000, "Member 'FLGUIFixedInfo::ResolutionWidth' has a wrong offset!");
static_assert(offsetof(FLGUIFixedInfo, ResolutionHeight) == 0x000004, "Member 'FLGUIFixedInfo::ResolutionHeight' has a wrong offset!");
static_assert(offsetof(FLGUIFixedInfo, OverlayLocation) == 0x000008, "Member 'FLGUIFixedInfo::OverlayLocation' has a wrong offset!");
static_assert(offsetof(FLGUIFixedInfo, OverlayRotation) == 0x000014, "Member 'FLGUIFixedInfo::OverlayRotation' has a wrong offset!");

// ScriptStruct LGUI.LGUISpriteInfo
// 0x0034 (0x0034 - 0x0000)
struct FLGUISpriteInfo final
{
public:
	uint16                                        width;                                             // 0x0000(0x0002)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint16                                        height;                                            // 0x0002(0x0002)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint16                                        borderLeft;                                        // 0x0004(0x0002)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint16                                        borderRight;                                       // 0x0006(0x0002)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint16                                        borderTop;                                         // 0x0008(0x0002)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint16                                        borderBottom;                                      // 0x000A(0x0002)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int16                                         paddingLeft;                                       // 0x000C(0x0002)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int16                                         paddingRight;                                      // 0x000E(0x0002)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int16                                         paddingTop;                                        // 0x0010(0x0002)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int16                                         paddingBottom;                                     // 0x0012(0x0002)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         uv0X;                                              // 0x0014(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         uv0Y;                                              // 0x0018(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         uv3X;                                              // 0x001C(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         uv3Y;                                              // 0x0020(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         buv0X;                                             // 0x0024(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         buv0Y;                                             // 0x0028(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         buv3X;                                             // 0x002C(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         buv3Y;                                             // 0x0030(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLGUISpriteInfo) == 0x000004, "Wrong alignment on FLGUISpriteInfo");
static_assert(sizeof(FLGUISpriteInfo) == 0x000034, "Wrong size on FLGUISpriteInfo");
static_assert(offsetof(FLGUISpriteInfo, width) == 0x000000, "Member 'FLGUISpriteInfo::width' has a wrong offset!");
static_assert(offsetof(FLGUISpriteInfo, height) == 0x000002, "Member 'FLGUISpriteInfo::height' has a wrong offset!");
static_assert(offsetof(FLGUISpriteInfo, borderLeft) == 0x000004, "Member 'FLGUISpriteInfo::borderLeft' has a wrong offset!");
static_assert(offsetof(FLGUISpriteInfo, borderRight) == 0x000006, "Member 'FLGUISpriteInfo::borderRight' has a wrong offset!");
static_assert(offsetof(FLGUISpriteInfo, borderTop) == 0x000008, "Member 'FLGUISpriteInfo::borderTop' has a wrong offset!");
static_assert(offsetof(FLGUISpriteInfo, borderBottom) == 0x00000A, "Member 'FLGUISpriteInfo::borderBottom' has a wrong offset!");
static_assert(offsetof(FLGUISpriteInfo, paddingLeft) == 0x00000C, "Member 'FLGUISpriteInfo::paddingLeft' has a wrong offset!");
static_assert(offsetof(FLGUISpriteInfo, paddingRight) == 0x00000E, "Member 'FLGUISpriteInfo::paddingRight' has a wrong offset!");
static_assert(offsetof(FLGUISpriteInfo, paddingTop) == 0x000010, "Member 'FLGUISpriteInfo::paddingTop' has a wrong offset!");
static_assert(offsetof(FLGUISpriteInfo, paddingBottom) == 0x000012, "Member 'FLGUISpriteInfo::paddingBottom' has a wrong offset!");
static_assert(offsetof(FLGUISpriteInfo, uv0X) == 0x000014, "Member 'FLGUISpriteInfo::uv0X' has a wrong offset!");
static_assert(offsetof(FLGUISpriteInfo, uv0Y) == 0x000018, "Member 'FLGUISpriteInfo::uv0Y' has a wrong offset!");
static_assert(offsetof(FLGUISpriteInfo, uv3X) == 0x00001C, "Member 'FLGUISpriteInfo::uv3X' has a wrong offset!");
static_assert(offsetof(FLGUISpriteInfo, uv3Y) == 0x000020, "Member 'FLGUISpriteInfo::uv3Y' has a wrong offset!");
static_assert(offsetof(FLGUISpriteInfo, buv0X) == 0x000024, "Member 'FLGUISpriteInfo::buv0X' has a wrong offset!");
static_assert(offsetof(FLGUISpriteInfo, buv0Y) == 0x000028, "Member 'FLGUISpriteInfo::buv0Y' has a wrong offset!");
static_assert(offsetof(FLGUISpriteInfo, buv3X) == 0x00002C, "Member 'FLGUISpriteInfo::buv3X' has a wrong offset!");
static_assert(offsetof(FLGUISpriteInfo, buv3Y) == 0x000030, "Member 'FLGUISpriteInfo::buv3Y' has a wrong offset!");

// ScriptStruct LGUI.LGUITextRuleItem
// 0x0010 (0x0018 - 0x0008)
struct FLGUITextRuleItem final : public FTableRowBase
{
public:
	class FString                                 KeyWord;                                           // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLGUITextRuleItem) == 0x000008, "Wrong alignment on FLGUITextRuleItem");
static_assert(sizeof(FLGUITextRuleItem) == 0x000018, "Wrong size on FLGUITextRuleItem");
static_assert(offsetof(FLGUITextRuleItem, KeyWord) == 0x000008, "Member 'FLGUITextRuleItem::KeyWord' has a wrong offset!");

// ScriptStruct LGUI.LevelSequencerActor
// 0x0020 (0x0020 - 0x0000)
struct FLevelSequencerActor final
{
public:
	TArray<class AUIBaseActor*>                   TargetActors;                                      // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	class ALevelSequenceActor*                    LvlSequencerActor;                                 // 0x0010(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18[0x8];                                       // 0x0018(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLevelSequencerActor) == 0x000008, "Wrong alignment on FLevelSequencerActor");
static_assert(sizeof(FLevelSequencerActor) == 0x000020, "Wrong size on FLevelSequencerActor");
static_assert(offsetof(FLevelSequencerActor, TargetActors) == 0x000000, "Member 'FLevelSequencerActor::TargetActors' has a wrong offset!");
static_assert(offsetof(FLevelSequencerActor, LvlSequencerActor) == 0x000010, "Member 'FLevelSequencerActor::LvlSequencerActor' has a wrong offset!");

// ScriptStruct LGUI.LGUILevelSequenceBindings
// 0x0050 (0x0050 - 0x0000)
struct FLGUILevelSequenceBindings final
{
public:
	TMap<struct FGuid, class UObject*>            BindingsMap;                                       // 0x0000(0x0050)(Edit, EditConst, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLGUILevelSequenceBindings) == 0x000008, "Wrong alignment on FLGUILevelSequenceBindings");
static_assert(sizeof(FLGUILevelSequenceBindings) == 0x000050, "Wrong size on FLGUILevelSequenceBindings");
static_assert(offsetof(FLGUILevelSequenceBindings, BindingsMap) == 0x000000, "Member 'FLGUILevelSequenceBindings::BindingsMap' has a wrong offset!");

// ScriptStruct LGUI.SequenceInfo
// 0x0038 (0x0038 - 0x0000)
struct FSequenceInfo final
{
public:
	struct FSoftObjectPath                        LevelSequence;                                     // 0x0000(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseAsHardRef;                                     // 0x0020(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ChildrenInteractiveDuringPlaying;                  // 0x0021(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          BlockAllEventWhilePlaying;                         // 0x0022(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_23[0x1];                                       // 0x0023(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	struct FMovieSceneSequencePlaybackSettings    PlaySetting;                                       // 0x0024(0x0014)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSequenceInfo) == 0x000008, "Wrong alignment on FSequenceInfo");
static_assert(sizeof(FSequenceInfo) == 0x000038, "Wrong size on FSequenceInfo");
static_assert(offsetof(FSequenceInfo, LevelSequence) == 0x000000, "Member 'FSequenceInfo::LevelSequence' has a wrong offset!");
static_assert(offsetof(FSequenceInfo, bUseAsHardRef) == 0x000020, "Member 'FSequenceInfo::bUseAsHardRef' has a wrong offset!");
static_assert(offsetof(FSequenceInfo, ChildrenInteractiveDuringPlaying) == 0x000021, "Member 'FSequenceInfo::ChildrenInteractiveDuringPlaying' has a wrong offset!");
static_assert(offsetof(FSequenceInfo, BlockAllEventWhilePlaying) == 0x000022, "Member 'FSequenceInfo::BlockAllEventWhilePlaying' has a wrong offset!");
static_assert(offsetof(FSequenceInfo, PlaySetting) == 0x000024, "Member 'FSequenceInfo::PlaySetting' has a wrong offset!");

// ScriptStruct LGUI.LGUIGeometryVertex
// 0x0048 (0x0048 - 0x0000)
struct FLGUIGeometryVertex final
{
public:
	struct FVector                                position;                                          // 0x0000(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FColor                                 color;                                             // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              uv0;                                               // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              uv1;                                               // 0x0018(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              uv2;                                               // 0x0020(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              uv3;                                               // 0x0028(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                normal;                                            // 0x0030(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                tagent;                                            // 0x003C(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLGUIGeometryVertex) == 0x000004, "Wrong alignment on FLGUIGeometryVertex");
static_assert(sizeof(FLGUIGeometryVertex) == 0x000048, "Wrong size on FLGUIGeometryVertex");
static_assert(offsetof(FLGUIGeometryVertex, position) == 0x000000, "Member 'FLGUIGeometryVertex::position' has a wrong offset!");
static_assert(offsetof(FLGUIGeometryVertex, color) == 0x00000C, "Member 'FLGUIGeometryVertex::color' has a wrong offset!");
static_assert(offsetof(FLGUIGeometryVertex, uv0) == 0x000010, "Member 'FLGUIGeometryVertex::uv0' has a wrong offset!");
static_assert(offsetof(FLGUIGeometryVertex, uv1) == 0x000018, "Member 'FLGUIGeometryVertex::uv1' has a wrong offset!");
static_assert(offsetof(FLGUIGeometryVertex, uv2) == 0x000020, "Member 'FLGUIGeometryVertex::uv2' has a wrong offset!");
static_assert(offsetof(FLGUIGeometryVertex, uv3) == 0x000028, "Member 'FLGUIGeometryVertex::uv3' has a wrong offset!");
static_assert(offsetof(FLGUIGeometryVertex, normal) == 0x000030, "Member 'FLGUIGeometryVertex::normal' has a wrong offset!");
static_assert(offsetof(FLGUIGeometryVertex, tagent) == 0x00003C, "Member 'FLGUIGeometryVertex::tagent' has a wrong offset!");

// ScriptStruct LGUI.AudioPlayInfo
// 0x0048 (0x0048 - 0x0000)
struct FAudioPlayInfo final
{
public:
	struct FSoftObjectPath                        AkAudioEvent;                                      // 0x0000(0x0020)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TDelegate<void(const class FString& eventName)> OnPostAudioEvent;                                  // 0x0020(0x0028)(Edit, ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAudioPlayInfo) == 0x000008, "Wrong alignment on FAudioPlayInfo");
static_assert(sizeof(FAudioPlayInfo) == 0x000048, "Wrong size on FAudioPlayInfo");
static_assert(offsetof(FAudioPlayInfo, AkAudioEvent) == 0x000000, "Member 'FAudioPlayInfo::AkAudioEvent' has a wrong offset!");
static_assert(offsetof(FAudioPlayInfo, OnPostAudioEvent) == 0x000020, "Member 'FAudioPlayInfo::OnPostAudioEvent' has a wrong offset!");

// ScriptStruct LGUI.UIDropdownOptionData
// 0x0030 (0x0030 - 0x0000)
struct FUIDropdownOptionData final
{
public:
	class FString                                 TextOrConfigTableName;                             // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ULGUISpriteData_BaseObject*             Sprite;                                            // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TextId;                                            // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 SecondText;                                        // 0x0020(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FUIDropdownOptionData) == 0x000008, "Wrong alignment on FUIDropdownOptionData");
static_assert(sizeof(FUIDropdownOptionData) == 0x000030, "Wrong size on FUIDropdownOptionData");
static_assert(offsetof(FUIDropdownOptionData, TextOrConfigTableName) == 0x000000, "Member 'FUIDropdownOptionData::TextOrConfigTableName' has a wrong offset!");
static_assert(offsetof(FUIDropdownOptionData, Sprite) == 0x000010, "Member 'FUIDropdownOptionData::Sprite' has a wrong offset!");
static_assert(offsetof(FUIDropdownOptionData, TextId) == 0x000018, "Member 'FUIDropdownOptionData::TextId' has a wrong offset!");
static_assert(offsetof(FUIDropdownOptionData, SecondText) == 0x000020, "Member 'FUIDropdownOptionData::SecondText' has a wrong offset!");

// ScriptStruct LGUI.RenderableSlot
// 0x0020 (0x0020 - 0x0000)
struct FRenderableSlot final
{
public:
	class UUIBatchGeometryRenderable*             Renderable;                                        // 0x0000(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x18];                                       // 0x0008(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRenderableSlot) == 0x000008, "Wrong alignment on FRenderableSlot");
static_assert(sizeof(FRenderableSlot) == 0x000020, "Wrong size on FRenderableSlot");
static_assert(offsetof(FRenderableSlot, Renderable) == 0x000000, "Member 'FRenderableSlot::Renderable' has a wrong offset!");

// ScriptStruct LGUI.RenderableCollection
// 0x0010 (0x0010 - 0x0000)
struct FRenderableCollection final
{
public:
	TArray<struct FRenderableSlot>                RenderableSlots;                                   // 0x0000(0x0010)(ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRenderableCollection) == 0x000008, "Wrong alignment on FRenderableCollection");
static_assert(sizeof(FRenderableCollection) == 0x000010, "Wrong size on FRenderableCollection");
static_assert(offsetof(FRenderableCollection, RenderableSlots) == 0x000000, "Member 'FRenderableCollection::RenderableSlots' has a wrong offset!");

// ScriptStruct LGUI.LoadingPathRenderableMap
// 0x0050 (0x0050 - 0x0000)
struct FLoadingPathRenderableMap final
{
public:
	TMap<struct FSoftObjectPath, struct FRenderableCollection> LoadingPathRenderableMap;                          // 0x0000(0x0050)(ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLoadingPathRenderableMap) == 0x000008, "Wrong alignment on FLoadingPathRenderableMap");
static_assert(sizeof(FLoadingPathRenderableMap) == 0x000050, "Wrong size on FLoadingPathRenderableMap");
static_assert(offsetof(FLoadingPathRenderableMap, LoadingPathRenderableMap) == 0x000000, "Member 'FLoadingPathRenderableMap::LoadingPathRenderableMap' has a wrong offset!");

// ScriptStruct LGUI.ToggleTransitionEditSetting
// 0x0001 (0x0001 - 0x0000)
struct FToggleTransitionEditSetting
{
public:
	uint8                                         bEnableUnDetermined : 1;                           // 0x0000(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bCustomUnCheckedHover : 1;                         // 0x0000(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bCustomUnCheckedPressed : 1;                       // 0x0000(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bCustomCheckedHover : 1;                           // 0x0000(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bCustomCheckedPressed : 1;                         // 0x0000(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bCustomUnDeterminedHover : 1;                      // 0x0000(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bCustomUnDeterminePressed : 1;                     // 0x0000(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
};
static_assert(alignof(FToggleTransitionEditSetting) == 0x000001, "Wrong alignment on FToggleTransitionEditSetting");
static_assert(sizeof(FToggleTransitionEditSetting) == 0x000001, "Wrong size on FToggleTransitionEditSetting");

// ScriptStruct LGUI.ExtendToggleColorTransition
// 0x0027 (0x0028 - 0x0001)
struct FExtendToggleColorTransition final : public FToggleTransitionEditSetting
{
public:
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FColor                                 UnCheckedUnHoverColor;                             // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FColor                                 UnCheckedHoverColor;                               // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FColor                                 UnCheckedPressedColor;                             // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FColor                                 CheckedUnHoverColor;                               // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FColor                                 CheckedHoverColor;                                 // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FColor                                 CheckedPressedColor;                               // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FColor                                 UnDeterminedUnHoverColor;                          // 0x001C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FColor                                 UnDeterminedHoverColor;                            // 0x0020(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FColor                                 UnDeterminedPressedColor;                          // 0x0024(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FExtendToggleColorTransition) == 0x000004, "Wrong alignment on FExtendToggleColorTransition");
static_assert(sizeof(FExtendToggleColorTransition) == 0x000028, "Wrong size on FExtendToggleColorTransition");
static_assert(offsetof(FExtendToggleColorTransition, UnCheckedUnHoverColor) == 0x000004, "Member 'FExtendToggleColorTransition::UnCheckedUnHoverColor' has a wrong offset!");
static_assert(offsetof(FExtendToggleColorTransition, UnCheckedHoverColor) == 0x000008, "Member 'FExtendToggleColorTransition::UnCheckedHoverColor' has a wrong offset!");
static_assert(offsetof(FExtendToggleColorTransition, UnCheckedPressedColor) == 0x00000C, "Member 'FExtendToggleColorTransition::UnCheckedPressedColor' has a wrong offset!");
static_assert(offsetof(FExtendToggleColorTransition, CheckedUnHoverColor) == 0x000010, "Member 'FExtendToggleColorTransition::CheckedUnHoverColor' has a wrong offset!");
static_assert(offsetof(FExtendToggleColorTransition, CheckedHoverColor) == 0x000014, "Member 'FExtendToggleColorTransition::CheckedHoverColor' has a wrong offset!");
static_assert(offsetof(FExtendToggleColorTransition, CheckedPressedColor) == 0x000018, "Member 'FExtendToggleColorTransition::CheckedPressedColor' has a wrong offset!");
static_assert(offsetof(FExtendToggleColorTransition, UnDeterminedUnHoverColor) == 0x00001C, "Member 'FExtendToggleColorTransition::UnDeterminedUnHoverColor' has a wrong offset!");
static_assert(offsetof(FExtendToggleColorTransition, UnDeterminedHoverColor) == 0x000020, "Member 'FExtendToggleColorTransition::UnDeterminedHoverColor' has a wrong offset!");
static_assert(offsetof(FExtendToggleColorTransition, UnDeterminedPressedColor) == 0x000024, "Member 'FExtendToggleColorTransition::UnDeterminedPressedColor' has a wrong offset!");

// ScriptStruct LGUI.ToggleAnimationPlayInfo
// 0x0048 (0x0048 - 0x0000)
struct FToggleAnimationPlayInfo final
{
public:
	struct FSequenceInfo                          Animation;                                         // 0x0000(0x0038)(Edit, NativeAccessSpecifierPublic)
	float                                         PlayRate;                                          // 0x0038(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPlayReverse;                                      // 0x003C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3D[0x3];                                       // 0x003D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         JumpToFrame;                                       // 0x0040(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FToggleAnimationPlayInfo) == 0x000008, "Wrong alignment on FToggleAnimationPlayInfo");
static_assert(sizeof(FToggleAnimationPlayInfo) == 0x000048, "Wrong size on FToggleAnimationPlayInfo");
static_assert(offsetof(FToggleAnimationPlayInfo, Animation) == 0x000000, "Member 'FToggleAnimationPlayInfo::Animation' has a wrong offset!");
static_assert(offsetof(FToggleAnimationPlayInfo, PlayRate) == 0x000038, "Member 'FToggleAnimationPlayInfo::PlayRate' has a wrong offset!");
static_assert(offsetof(FToggleAnimationPlayInfo, bPlayReverse) == 0x00003C, "Member 'FToggleAnimationPlayInfo::bPlayReverse' has a wrong offset!");
static_assert(offsetof(FToggleAnimationPlayInfo, JumpToFrame) == 0x000040, "Member 'FToggleAnimationPlayInfo::JumpToFrame' has a wrong offset!");

// ScriptStruct LGUI.ToggleStateAnimation
// 0x00A0 (0x00A0 - 0x0000)
struct FToggleStateAnimation final
{
public:
	TMap<EToggleStateInAnimation, struct FToggleAnimationPlayInfo> StateToAnimation;                                  // 0x0000(0x0050)(Edit, NativeAccessSpecifierPublic)
	bool                                          bDifferSelectedState;                              // 0x0050(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_51[0x7];                                       // 0x0051(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FToggleAnimationPlayInfo               UniAnimation;                                      // 0x0058(0x0048)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FToggleStateAnimation) == 0x000008, "Wrong alignment on FToggleStateAnimation");
static_assert(sizeof(FToggleStateAnimation) == 0x0000A0, "Wrong size on FToggleStateAnimation");
static_assert(offsetof(FToggleStateAnimation, StateToAnimation) == 0x000000, "Member 'FToggleStateAnimation::StateToAnimation' has a wrong offset!");
static_assert(offsetof(FToggleStateAnimation, bDifferSelectedState) == 0x000050, "Member 'FToggleStateAnimation::bDifferSelectedState' has a wrong offset!");
static_assert(offsetof(FToggleStateAnimation, UniAnimation) == 0x000058, "Member 'FToggleStateAnimation::UniAnimation' has a wrong offset!");

// ScriptStruct LGUI.RenderableAdditionalInfo
// 0x000C (0x000C - 0x0000)
struct FRenderableAdditionalInfo final
{
public:
	uint8                                         bIsGray : 1;                                       // 0x0000(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bIsColorRevert : 1;                                // 0x0000(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bUseChangeColor : 1;                               // 0x0000(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FColor                                 ChangeColor;                                       // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpriteRotation;                                    // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRenderableAdditionalInfo) == 0x000004, "Wrong alignment on FRenderableAdditionalInfo");
static_assert(sizeof(FRenderableAdditionalInfo) == 0x00000C, "Wrong size on FRenderableAdditionalInfo");
static_assert(offsetof(FRenderableAdditionalInfo, ChangeColor) == 0x000004, "Member 'FRenderableAdditionalInfo::ChangeColor' has a wrong offset!");
static_assert(offsetof(FRenderableAdditionalInfo, SpriteRotation) == 0x000008, "Member 'FRenderableAdditionalInfo::SpriteRotation' has a wrong offset!");

// ScriptStruct LGUI.SpriteTransitionOfState
// 0x0020 (0x0020 - 0x0000)
struct FSpriteTransitionOfState final
{
public:
	class ULGUISpriteData_BaseObject*             Sprite;                                            // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FColor                                 Color;                                             // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bSnapSize : 1;                                     // 0x000C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRenderableAdditionalInfo              AdditionInfo;                                      // 0x0010(0x000C)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSpriteTransitionOfState) == 0x000008, "Wrong alignment on FSpriteTransitionOfState");
static_assert(sizeof(FSpriteTransitionOfState) == 0x000020, "Wrong size on FSpriteTransitionOfState");
static_assert(offsetof(FSpriteTransitionOfState, Sprite) == 0x000000, "Member 'FSpriteTransitionOfState::Sprite' has a wrong offset!");
static_assert(offsetof(FSpriteTransitionOfState, Color) == 0x000008, "Member 'FSpriteTransitionOfState::Color' has a wrong offset!");
static_assert(offsetof(FSpriteTransitionOfState, AdditionInfo) == 0x000010, "Member 'FSpriteTransitionOfState::AdditionInfo' has a wrong offset!");

// ScriptStruct LGUI.ExtendToggleSpriteTransitionState
// 0x0127 (0x0128 - 0x0001)
struct FExtendToggleSpriteTransitionState final : public FToggleTransitionEditSetting
{
public:
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSpriteTransitionOfState               UnCheckedUnHoverState;                             // 0x0008(0x0020)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FSpriteTransitionOfState               UnCheckedHoverState;                               // 0x0028(0x0020)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FSpriteTransitionOfState               UnCheckedPressedState;                             // 0x0048(0x0020)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FSpriteTransitionOfState               CheckedUnHoverState;                               // 0x0068(0x0020)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FSpriteTransitionOfState               CheckedHoverState;                                 // 0x0088(0x0020)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FSpriteTransitionOfState               CheckedPressedState;                               // 0x00A8(0x0020)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FSpriteTransitionOfState               UnDetermineUnHoverState;                           // 0x00C8(0x0020)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FSpriteTransitionOfState               UnDetermineHoverState;                             // 0x00E8(0x0020)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FSpriteTransitionOfState               UnDeterminePressedState;                           // 0x0108(0x0020)(Edit, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FExtendToggleSpriteTransitionState) == 0x000008, "Wrong alignment on FExtendToggleSpriteTransitionState");
static_assert(sizeof(FExtendToggleSpriteTransitionState) == 0x000128, "Wrong size on FExtendToggleSpriteTransitionState");
static_assert(offsetof(FExtendToggleSpriteTransitionState, UnCheckedUnHoverState) == 0x000008, "Member 'FExtendToggleSpriteTransitionState::UnCheckedUnHoverState' has a wrong offset!");
static_assert(offsetof(FExtendToggleSpriteTransitionState, UnCheckedHoverState) == 0x000028, "Member 'FExtendToggleSpriteTransitionState::UnCheckedHoverState' has a wrong offset!");
static_assert(offsetof(FExtendToggleSpriteTransitionState, UnCheckedPressedState) == 0x000048, "Member 'FExtendToggleSpriteTransitionState::UnCheckedPressedState' has a wrong offset!");
static_assert(offsetof(FExtendToggleSpriteTransitionState, CheckedUnHoverState) == 0x000068, "Member 'FExtendToggleSpriteTransitionState::CheckedUnHoverState' has a wrong offset!");
static_assert(offsetof(FExtendToggleSpriteTransitionState, CheckedHoverState) == 0x000088, "Member 'FExtendToggleSpriteTransitionState::CheckedHoverState' has a wrong offset!");
static_assert(offsetof(FExtendToggleSpriteTransitionState, CheckedPressedState) == 0x0000A8, "Member 'FExtendToggleSpriteTransitionState::CheckedPressedState' has a wrong offset!");
static_assert(offsetof(FExtendToggleSpriteTransitionState, UnDetermineUnHoverState) == 0x0000C8, "Member 'FExtendToggleSpriteTransitionState::UnDetermineUnHoverState' has a wrong offset!");
static_assert(offsetof(FExtendToggleSpriteTransitionState, UnDetermineHoverState) == 0x0000E8, "Member 'FExtendToggleSpriteTransitionState::UnDetermineHoverState' has a wrong offset!");
static_assert(offsetof(FExtendToggleSpriteTransitionState, UnDeterminePressedState) == 0x000108, "Member 'FExtendToggleSpriteTransitionState::UnDeterminePressedState' has a wrong offset!");

// ScriptStruct LGUI.TextTransitionInfoOfState
// 0x000C (0x000C - 0x0000)
struct FTextTransitionInfoOfState final
{
public:
	struct FColor                                 FontColor;                                         // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Size;                                              // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EUITextFontStyle                              fontStyle;                                         // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSetFontColor;                                     // 0x0009(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSetFontSize;                                      // 0x000A(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSetFontStyle;                                     // 0x000B(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTextTransitionInfoOfState) == 0x000004, "Wrong alignment on FTextTransitionInfoOfState");
static_assert(sizeof(FTextTransitionInfoOfState) == 0x00000C, "Wrong size on FTextTransitionInfoOfState");
static_assert(offsetof(FTextTransitionInfoOfState, FontColor) == 0x000000, "Member 'FTextTransitionInfoOfState::FontColor' has a wrong offset!");
static_assert(offsetof(FTextTransitionInfoOfState, Size) == 0x000004, "Member 'FTextTransitionInfoOfState::Size' has a wrong offset!");
static_assert(offsetof(FTextTransitionInfoOfState, fontStyle) == 0x000008, "Member 'FTextTransitionInfoOfState::fontStyle' has a wrong offset!");
static_assert(offsetof(FTextTransitionInfoOfState, bSetFontColor) == 0x000009, "Member 'FTextTransitionInfoOfState::bSetFontColor' has a wrong offset!");
static_assert(offsetof(FTextTransitionInfoOfState, bSetFontSize) == 0x00000A, "Member 'FTextTransitionInfoOfState::bSetFontSize' has a wrong offset!");
static_assert(offsetof(FTextTransitionInfoOfState, bSetFontStyle) == 0x00000B, "Member 'FTextTransitionInfoOfState::bSetFontStyle' has a wrong offset!");

// ScriptStruct LGUI.ExtendToggleTextTransitionState
// 0x006F (0x0070 - 0x0001)
struct FExtendToggleTextTransitionState final : public FToggleTransitionEditSetting
{
public:
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTextTransitionInfoOfState             UnCheckUnHoverState;                               // 0x0004(0x000C)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FTextTransitionInfoOfState             UnCheckHoverState;                                 // 0x0010(0x000C)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FTextTransitionInfoOfState             UnCheckPressedState;                               // 0x001C(0x000C)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FTextTransitionInfoOfState             CheckUnHoverState;                                 // 0x0028(0x000C)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FTextTransitionInfoOfState             CheckHoverState;                                   // 0x0034(0x000C)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FTextTransitionInfoOfState             CheckPressedState;                                 // 0x0040(0x000C)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FTextTransitionInfoOfState             UnDetermineUnHoverState;                           // 0x004C(0x000C)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FTextTransitionInfoOfState             UnDetermineHoverState;                             // 0x0058(0x000C)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FTextTransitionInfoOfState             UnDeterminePressedState;                           // 0x0064(0x000C)(Edit, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FExtendToggleTextTransitionState) == 0x000004, "Wrong alignment on FExtendToggleTextTransitionState");
static_assert(sizeof(FExtendToggleTextTransitionState) == 0x000070, "Wrong size on FExtendToggleTextTransitionState");
static_assert(offsetof(FExtendToggleTextTransitionState, UnCheckUnHoverState) == 0x000004, "Member 'FExtendToggleTextTransitionState::UnCheckUnHoverState' has a wrong offset!");
static_assert(offsetof(FExtendToggleTextTransitionState, UnCheckHoverState) == 0x000010, "Member 'FExtendToggleTextTransitionState::UnCheckHoverState' has a wrong offset!");
static_assert(offsetof(FExtendToggleTextTransitionState, UnCheckPressedState) == 0x00001C, "Member 'FExtendToggleTextTransitionState::UnCheckPressedState' has a wrong offset!");
static_assert(offsetof(FExtendToggleTextTransitionState, CheckUnHoverState) == 0x000028, "Member 'FExtendToggleTextTransitionState::CheckUnHoverState' has a wrong offset!");
static_assert(offsetof(FExtendToggleTextTransitionState, CheckHoverState) == 0x000034, "Member 'FExtendToggleTextTransitionState::CheckHoverState' has a wrong offset!");
static_assert(offsetof(FExtendToggleTextTransitionState, CheckPressedState) == 0x000040, "Member 'FExtendToggleTextTransitionState::CheckPressedState' has a wrong offset!");
static_assert(offsetof(FExtendToggleTextTransitionState, UnDetermineUnHoverState) == 0x00004C, "Member 'FExtendToggleTextTransitionState::UnDetermineUnHoverState' has a wrong offset!");
static_assert(offsetof(FExtendToggleTextTransitionState, UnDetermineHoverState) == 0x000058, "Member 'FExtendToggleTextTransitionState::UnDetermineHoverState' has a wrong offset!");
static_assert(offsetof(FExtendToggleTextTransitionState, UnDeterminePressedState) == 0x000064, "Member 'FExtendToggleTextTransitionState::UnDeterminePressedState' has a wrong offset!");

// ScriptStruct LGUI.TextureTransitionOfState
// 0x0020 (0x0020 - 0x0000)
struct FTextureTransitionOfState final
{
public:
	struct FColor                                 Color;                                             // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UTexture*                               Texture;                                           // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSnapSize;                                         // 0x0010(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRenderableAdditionalInfo              AdditionalInfo;                                    // 0x0014(0x000C)(Edit, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTextureTransitionOfState) == 0x000008, "Wrong alignment on FTextureTransitionOfState");
static_assert(sizeof(FTextureTransitionOfState) == 0x000020, "Wrong size on FTextureTransitionOfState");
static_assert(offsetof(FTextureTransitionOfState, Color) == 0x000000, "Member 'FTextureTransitionOfState::Color' has a wrong offset!");
static_assert(offsetof(FTextureTransitionOfState, Texture) == 0x000008, "Member 'FTextureTransitionOfState::Texture' has a wrong offset!");
static_assert(offsetof(FTextureTransitionOfState, bSnapSize) == 0x000010, "Member 'FTextureTransitionOfState::bSnapSize' has a wrong offset!");
static_assert(offsetof(FTextureTransitionOfState, AdditionalInfo) == 0x000014, "Member 'FTextureTransitionOfState::AdditionalInfo' has a wrong offset!");

// ScriptStruct LGUI.ExtendToggleTextureTransitionState
// 0x0127 (0x0128 - 0x0001)
struct FExtendToggleTextureTransitionState final : public FToggleTransitionEditSetting
{
public:
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTextureTransitionOfState              UnCheckUnHoverState;                               // 0x0008(0x0020)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FTextureTransitionOfState              UnCheckHoverState;                                 // 0x0028(0x0020)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FTextureTransitionOfState              UnCheckPressedState;                               // 0x0048(0x0020)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FTextureTransitionOfState              CheckUnHoverState;                                 // 0x0068(0x0020)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FTextureTransitionOfState              CheckHoverState;                                   // 0x0088(0x0020)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FTextureTransitionOfState              CheckPressedState;                                 // 0x00A8(0x0020)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FTextureTransitionOfState              UnDetermineUnHoverState;                           // 0x00C8(0x0020)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FTextureTransitionOfState              UnDetermineHoverState;                             // 0x00E8(0x0020)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FTextureTransitionOfState              UnDeterminePressedState;                           // 0x0108(0x0020)(Edit, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FExtendToggleTextureTransitionState) == 0x000008, "Wrong alignment on FExtendToggleTextureTransitionState");
static_assert(sizeof(FExtendToggleTextureTransitionState) == 0x000128, "Wrong size on FExtendToggleTextureTransitionState");
static_assert(offsetof(FExtendToggleTextureTransitionState, UnCheckUnHoverState) == 0x000008, "Member 'FExtendToggleTextureTransitionState::UnCheckUnHoverState' has a wrong offset!");
static_assert(offsetof(FExtendToggleTextureTransitionState, UnCheckHoverState) == 0x000028, "Member 'FExtendToggleTextureTransitionState::UnCheckHoverState' has a wrong offset!");
static_assert(offsetof(FExtendToggleTextureTransitionState, UnCheckPressedState) == 0x000048, "Member 'FExtendToggleTextureTransitionState::UnCheckPressedState' has a wrong offset!");
static_assert(offsetof(FExtendToggleTextureTransitionState, CheckUnHoverState) == 0x000068, "Member 'FExtendToggleTextureTransitionState::CheckUnHoverState' has a wrong offset!");
static_assert(offsetof(FExtendToggleTextureTransitionState, CheckHoverState) == 0x000088, "Member 'FExtendToggleTextureTransitionState::CheckHoverState' has a wrong offset!");
static_assert(offsetof(FExtendToggleTextureTransitionState, CheckPressedState) == 0x0000A8, "Member 'FExtendToggleTextureTransitionState::CheckPressedState' has a wrong offset!");
static_assert(offsetof(FExtendToggleTextureTransitionState, UnDetermineUnHoverState) == 0x0000C8, "Member 'FExtendToggleTextureTransitionState::UnDetermineUnHoverState' has a wrong offset!");
static_assert(offsetof(FExtendToggleTextureTransitionState, UnDetermineHoverState) == 0x0000E8, "Member 'FExtendToggleTextureTransitionState::UnDetermineHoverState' has a wrong offset!");
static_assert(offsetof(FExtendToggleTextureTransitionState, UnDeterminePressedState) == 0x000108, "Member 'FExtendToggleTextureTransitionState::UnDeterminePressedState' has a wrong offset!");

// ScriptStruct LGUI.PredefColor
// 0x0018 (0x0020 - 0x0008)
struct FPredefColor final : public FTableRowBase
{
public:
	struct FColor                                 Color;                                             // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 Comment;                                           // 0x0010(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPredefColor) == 0x000008, "Wrong alignment on FPredefColor");
static_assert(sizeof(FPredefColor) == 0x000020, "Wrong size on FPredefColor");
static_assert(offsetof(FPredefColor, Color) == 0x000008, "Member 'FPredefColor::Color' has a wrong offset!");
static_assert(offsetof(FPredefColor, Comment) == 0x000010, "Member 'FPredefColor::Comment' has a wrong offset!");

// ScriptStruct LGUI.CircleClipParameters
// 0x0010 (0x0010 - 0x0000)
struct FCircleClipParameters final
{
public:
	float                                         ClipTextureHideThreshhold;                         // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ClipTextureHideFeather;                            // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ClipAngle;                                         // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UseTwoWayClip;                                     // 0x000C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCircleClipParameters) == 0x000004, "Wrong alignment on FCircleClipParameters");
static_assert(sizeof(FCircleClipParameters) == 0x000010, "Wrong size on FCircleClipParameters");
static_assert(offsetof(FCircleClipParameters, ClipTextureHideThreshhold) == 0x000000, "Member 'FCircleClipParameters::ClipTextureHideThreshhold' has a wrong offset!");
static_assert(offsetof(FCircleClipParameters, ClipTextureHideFeather) == 0x000004, "Member 'FCircleClipParameters::ClipTextureHideFeather' has a wrong offset!");
static_assert(offsetof(FCircleClipParameters, ClipAngle) == 0x000008, "Member 'FCircleClipParameters::ClipAngle' has a wrong offset!");
static_assert(offsetof(FCircleClipParameters, UseTwoWayClip) == 0x00000C, "Member 'FCircleClipParameters::UseTwoWayClip' has a wrong offset!");

// ScriptStruct LGUI.FoldableMargins
// 0x0020 (0x0020 - 0x0000)
struct FFoldableMargins final
{
public:
	struct FMargin                                SquareMargin;                                      // 0x0000(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FMargin                                NarrowMargin;                                      // 0x0010(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFoldableMargins) == 0x000004, "Wrong alignment on FFoldableMargins");
static_assert(sizeof(FFoldableMargins) == 0x000020, "Wrong size on FFoldableMargins");
static_assert(offsetof(FFoldableMargins, SquareMargin) == 0x000000, "Member 'FFoldableMargins::SquareMargin' has a wrong offset!");
static_assert(offsetof(FFoldableMargins, NarrowMargin) == 0x000010, "Member 'FFoldableMargins::NarrowMargin' has a wrong offset!");

// ScriptStruct LGUI.AnimationPlayInfo
// 0x0048 (0x0048 - 0x0000)
struct FAnimationPlayInfo final
{
public:
	EAnimationPlayMode                            PlayMode;                                          // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EStateTransferType                            ReverseType;                                       // 0x0001(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x6];                                        // 0x0002(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSequenceInfo                          Animation;                                         // 0x0008(0x0038)(Edit, NativeAccessSpecifierPublic)
	float                                         PlayRate;                                          // 0x0040(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAnimationPlayInfo) == 0x000008, "Wrong alignment on FAnimationPlayInfo");
static_assert(sizeof(FAnimationPlayInfo) == 0x000048, "Wrong size on FAnimationPlayInfo");
static_assert(offsetof(FAnimationPlayInfo, PlayMode) == 0x000000, "Member 'FAnimationPlayInfo::PlayMode' has a wrong offset!");
static_assert(offsetof(FAnimationPlayInfo, ReverseType) == 0x000001, "Member 'FAnimationPlayInfo::ReverseType' has a wrong offset!");
static_assert(offsetof(FAnimationPlayInfo, Animation) == 0x000008, "Member 'FAnimationPlayInfo::Animation' has a wrong offset!");
static_assert(offsetof(FAnimationPlayInfo, PlayRate) == 0x000040, "Member 'FAnimationPlayInfo::PlayRate' has a wrong offset!");

// ScriptStruct LGUI.AnchorInfo
// 0x0020 (0x0020 - 0x0000)
struct FAnchorInfo final
{
public:
	class AUIBaseActor*                           TargetActor;                                       // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 AnchorBone;                                        // 0x0008(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              Offset;                                            // 0x0018(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAnchorInfo) == 0x000008, "Wrong alignment on FAnchorInfo");
static_assert(sizeof(FAnchorInfo) == 0x000020, "Wrong size on FAnchorInfo");
static_assert(offsetof(FAnchorInfo, TargetActor) == 0x000000, "Member 'FAnchorInfo::TargetActor' has a wrong offset!");
static_assert(offsetof(FAnchorInfo, AnchorBone) == 0x000008, "Member 'FAnchorInfo::AnchorBone' has a wrong offset!");
static_assert(offsetof(FAnchorInfo, Offset) == 0x000018, "Member 'FAnchorInfo::Offset' has a wrong offset!");

// ScriptStruct LGUI.SpriteTransitionInfo
// 0x0080 (0x0080 - 0x0000)
struct FSpriteTransitionInfo final
{
public:
	struct FSpriteTransitionOfState               NormalTransition;                                  // 0x0000(0x0020)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FSpriteTransitionOfState               HighlightedTransition;                             // 0x0020(0x0020)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FSpriteTransitionOfState               PressedTransition;                                 // 0x0040(0x0020)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FSpriteTransitionOfState               DisabledTransition;                                // 0x0060(0x0020)(Edit, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSpriteTransitionInfo) == 0x000008, "Wrong alignment on FSpriteTransitionInfo");
static_assert(sizeof(FSpriteTransitionInfo) == 0x000080, "Wrong size on FSpriteTransitionInfo");
static_assert(offsetof(FSpriteTransitionInfo, NormalTransition) == 0x000000, "Member 'FSpriteTransitionInfo::NormalTransition' has a wrong offset!");
static_assert(offsetof(FSpriteTransitionInfo, HighlightedTransition) == 0x000020, "Member 'FSpriteTransitionInfo::HighlightedTransition' has a wrong offset!");
static_assert(offsetof(FSpriteTransitionInfo, PressedTransition) == 0x000040, "Member 'FSpriteTransitionInfo::PressedTransition' has a wrong offset!");
static_assert(offsetof(FSpriteTransitionInfo, DisabledTransition) == 0x000060, "Member 'FSpriteTransitionInfo::DisabledTransition' has a wrong offset!");

// ScriptStruct LGUI.TextTransitionInfo
// 0x0030 (0x0030 - 0x0000)
struct FTextTransitionInfo final
{
public:
	struct FTextTransitionInfoOfState             NormalTransition;                                  // 0x0000(0x000C)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FTextTransitionInfoOfState             HighlightedTransition;                             // 0x000C(0x000C)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FTextTransitionInfoOfState             PressedTransition;                                 // 0x0018(0x000C)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FTextTransitionInfoOfState             DisabledTransition;                                // 0x0024(0x000C)(Edit, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTextTransitionInfo) == 0x000004, "Wrong alignment on FTextTransitionInfo");
static_assert(sizeof(FTextTransitionInfo) == 0x000030, "Wrong size on FTextTransitionInfo");
static_assert(offsetof(FTextTransitionInfo, NormalTransition) == 0x000000, "Member 'FTextTransitionInfo::NormalTransition' has a wrong offset!");
static_assert(offsetof(FTextTransitionInfo, HighlightedTransition) == 0x00000C, "Member 'FTextTransitionInfo::HighlightedTransition' has a wrong offset!");
static_assert(offsetof(FTextTransitionInfo, PressedTransition) == 0x000018, "Member 'FTextTransitionInfo::PressedTransition' has a wrong offset!");
static_assert(offsetof(FTextTransitionInfo, DisabledTransition) == 0x000024, "Member 'FTextTransitionInfo::DisabledTransition' has a wrong offset!");

// ScriptStruct LGUI.TextureTransitionInfo
// 0x0080 (0x0080 - 0x0000)
struct FTextureTransitionInfo final
{
public:
	struct FTextureTransitionOfState              NormalTransition;                                  // 0x0000(0x0020)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FTextureTransitionOfState              HighlightedTransition;                             // 0x0020(0x0020)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FTextureTransitionOfState              PressedTransition;                                 // 0x0040(0x0020)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FTextureTransitionOfState              DisabledTransition;                                // 0x0060(0x0020)(Edit, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTextureTransitionInfo) == 0x000008, "Wrong alignment on FTextureTransitionInfo");
static_assert(sizeof(FTextureTransitionInfo) == 0x000080, "Wrong size on FTextureTransitionInfo");
static_assert(offsetof(FTextureTransitionInfo, NormalTransition) == 0x000000, "Member 'FTextureTransitionInfo::NormalTransition' has a wrong offset!");
static_assert(offsetof(FTextureTransitionInfo, HighlightedTransition) == 0x000020, "Member 'FTextureTransitionInfo::HighlightedTransition' has a wrong offset!");
static_assert(offsetof(FTextureTransitionInfo, PressedTransition) == 0x000040, "Member 'FTextureTransitionInfo::PressedTransition' has a wrong offset!");
static_assert(offsetof(FTextureTransitionInfo, DisabledTransition) == 0x000060, "Member 'FTextureTransitionInfo::DisabledTransition' has a wrong offset!");

// ScriptStruct LGUI.UIWidget
// 0x0040 (0x0040 - 0x0000)
struct FUIWidget final
{
public:
	int32                                         depth;                                             // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FColor                                 color;                                             // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              pivot;                                             // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EUIAnchorHorizontalAlign                      anchorHAlign;                                      // 0x0010(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EUIAnchorVerticalAlign                        anchorVAlign;                                      // 0x0011(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12[0x2];                                       // 0x0012(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         anchorOffsetX;                                     // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         anchorOffsetY;                                     // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         width;                                             // 0x001C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         height;                                            // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         stretchLeft;                                       // 0x0024(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         stretchRight;                                      // 0x0028(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         stretchTop;                                        // 0x002C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         stretchBottom;                                     // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AnchorXPercent;                                    // 0x0034(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AnchorYPercent;                                    // 0x0038(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ShowXPercent;                                      // 0x003C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ShowYPercent;                                      // 0x003D(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3E[0x2];                                       // 0x003E(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FUIWidget) == 0x000004, "Wrong alignment on FUIWidget");
static_assert(sizeof(FUIWidget) == 0x000040, "Wrong size on FUIWidget");
static_assert(offsetof(FUIWidget, depth) == 0x000000, "Member 'FUIWidget::depth' has a wrong offset!");
static_assert(offsetof(FUIWidget, color) == 0x000004, "Member 'FUIWidget::color' has a wrong offset!");
static_assert(offsetof(FUIWidget, pivot) == 0x000008, "Member 'FUIWidget::pivot' has a wrong offset!");
static_assert(offsetof(FUIWidget, anchorHAlign) == 0x000010, "Member 'FUIWidget::anchorHAlign' has a wrong offset!");
static_assert(offsetof(FUIWidget, anchorVAlign) == 0x000011, "Member 'FUIWidget::anchorVAlign' has a wrong offset!");
static_assert(offsetof(FUIWidget, anchorOffsetX) == 0x000014, "Member 'FUIWidget::anchorOffsetX' has a wrong offset!");
static_assert(offsetof(FUIWidget, anchorOffsetY) == 0x000018, "Member 'FUIWidget::anchorOffsetY' has a wrong offset!");
static_assert(offsetof(FUIWidget, width) == 0x00001C, "Member 'FUIWidget::width' has a wrong offset!");
static_assert(offsetof(FUIWidget, height) == 0x000020, "Member 'FUIWidget::height' has a wrong offset!");
static_assert(offsetof(FUIWidget, stretchLeft) == 0x000024, "Member 'FUIWidget::stretchLeft' has a wrong offset!");
static_assert(offsetof(FUIWidget, stretchRight) == 0x000028, "Member 'FUIWidget::stretchRight' has a wrong offset!");
static_assert(offsetof(FUIWidget, stretchTop) == 0x00002C, "Member 'FUIWidget::stretchTop' has a wrong offset!");
static_assert(offsetof(FUIWidget, stretchBottom) == 0x000030, "Member 'FUIWidget::stretchBottom' has a wrong offset!");
static_assert(offsetof(FUIWidget, AnchorXPercent) == 0x000034, "Member 'FUIWidget::AnchorXPercent' has a wrong offset!");
static_assert(offsetof(FUIWidget, AnchorYPercent) == 0x000038, "Member 'FUIWidget::AnchorYPercent' has a wrong offset!");
static_assert(offsetof(FUIWidget, ShowXPercent) == 0x00003C, "Member 'FUIWidget::ShowXPercent' has a wrong offset!");
static_assert(offsetof(FUIWidget, ShowYPercent) == 0x00003D, "Member 'FUIWidget::ShowYPercent' has a wrong offset!");

// ScriptStruct LGUI.WidgetTransitionInfo
// 0x0104 (0x0104 - 0x0000)
struct FWidgetTransitionInfo final
{
public:
	uint8                                         bCustomNormalTransition : 1;                       // 0x0000(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bCustomHighlightedTransition : 1;                  // 0x0000(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bCustomPressedTransition : 1;                      // 0x0000(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bCustomDisabledTransition : 1;                     // 0x0000(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FUIWidget                              NormalTransition;                                  // 0x0004(0x0040)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FUIWidget                              HighlightedTransition;                             // 0x0044(0x0040)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FUIWidget                              PressedTransition;                                 // 0x0084(0x0040)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FUIWidget                              DisabledTransition;                                // 0x00C4(0x0040)(Edit, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FWidgetTransitionInfo) == 0x000004, "Wrong alignment on FWidgetTransitionInfo");
static_assert(sizeof(FWidgetTransitionInfo) == 0x000104, "Wrong size on FWidgetTransitionInfo");
static_assert(offsetof(FWidgetTransitionInfo, NormalTransition) == 0x000004, "Member 'FWidgetTransitionInfo::NormalTransition' has a wrong offset!");
static_assert(offsetof(FWidgetTransitionInfo, HighlightedTransition) == 0x000044, "Member 'FWidgetTransitionInfo::HighlightedTransition' has a wrong offset!");
static_assert(offsetof(FWidgetTransitionInfo, PressedTransition) == 0x000084, "Member 'FWidgetTransitionInfo::PressedTransition' has a wrong offset!");
static_assert(offsetof(FWidgetTransitionInfo, DisabledTransition) == 0x0000C4, "Member 'FWidgetTransitionInfo::DisabledTransition' has a wrong offset!");

}

