#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: KuroComponent

#include "Basic.hpp"


namespace SDK
{

// Enum KuroComponent.EAnimPerfTestSkelMeshLifeCycle
// NumValues: 0x0003
enum class EAnimPerfTestSkelMeshLifeCycle : uint8
{
	Transient                                = 0,
	KeepInLevel                              = 1,
	EAnimPerfTestSkelMeshLifeCycle_MAX       = 2,
};

// Enum KuroComponent.EAnimPerfTestBornFrom
// NumValues: 0x0004
enum class EAnimPerfTestBornFrom : uint8
{
	PlayerStart                              = 0,
	Pawn                                     = 1,
	Owner                                    = 2,
	EAnimPerfTestBornFrom_MAX                = 3,
};

// Enum KuroComponent.EAnimPerfTestAnimSeqFilterMethod
// NumValues: 0x0006
enum class EAnimPerfTestAnimSeqFilterMethod : uint8
{
	Specific                                 = 0,
	Contains                                 = 1,
	StartsWith                               = 2,
	EndsWith                                 = 3,
	EqualsTo                                 = 4,
	EAnimPerfTestAnimSeqFilterMethod_MAX     = 5,
};

// Enum KuroComponent.EAnimPerfTestRandomGenActorGroup
// NumValues: 0x0003
enum class EAnimPerfTestRandomGenActorGroup : uint8
{
	SpecificSkeletalMeshes                   = 0,
	AllSkeletalMeshes                        = 1,
	EAnimPerfTestRandomGenActorGroup_MAX     = 2,
};

// Enum KuroComponent.EAnimPerfTestActorsGenMethod
// NumValues: 0x0004
enum class EAnimPerfTestActorsGenMethod : uint8
{
	GenFromTemplate                          = 0,
	GenRandomly                              = 1,
	GenAll                                   = 2,
	EAnimPerfTestActorsGenMethod_MAX         = 3,
};

// Enum KuroComponent.EShapeType
// NumValues: 0x0005
enum class EShapeType : uint8
{
	Box                                      = 0,
	Sphere                                   = 1,
	Sector                                   = 2,
	Cylinder                                 = 3,
	EShapeType_MAX                           = 4,
};

// Enum KuroComponent.EKuroSceneItemStopRotateMethod
// NumValues: 0x0004
enum class EKuroSceneItemStopRotateMethod : uint8
{
	KeepCurrent                              = 0,
	JumpToStart                              = 1,
	JumpToEnd                                = 2,
	EKuroSceneItemStopRotateMethod_MAX       = 3,
};

// Enum KuroComponent.ESplineMoveSubType
// NumValues: 0x0003
enum class ESplineMoveSubType : uint8
{
	SplineMoveWithStaticTimeDisCurve         = 0,
	SplineMoveWithDynamicSpeed               = 1,
	ESplineMoveSubType_MAX                   = 2,
};

// Enum KuroComponent.ESplineRunState
// NumValues: 0x0004
enum class ESplineRunState : uint8
{
	None                                     = 0,
	Trip                                     = 1,
	ReturnTrip                               = 2,
	ESplineRunState_MAX                      = 3,
};

// Enum KuroComponent.ESimpleRunState
// NumValues: 0x0004
enum class ESimpleRunState : uint8
{
	Stop                                     = 0,
	Run                                      = 1,
	Wait                                     = 2,
	ESimpleRunState_MAX                      = 3,
};

// ScriptStruct KuroComponent.RotateStepInfo
// 0x0030 (0x0030 - 0x0000)
struct alignas(0x10) FRotateStepInfo final
{
public:
	uint8                                         Pad_0[0x28];                                       // 0x0000(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            RotateCurve;                                       // 0x0028(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRotateStepInfo) == 0x000010, "Wrong alignment on FRotateStepInfo");
static_assert(sizeof(FRotateStepInfo) == 0x000030, "Wrong size on FRotateStepInfo");
static_assert(offsetof(FRotateStepInfo, RotateCurve) == 0x000028, "Member 'FRotateStepInfo::RotateCurve' has a wrong offset!");

// ScriptStruct KuroComponent.TargetRotationData
// 0x0038 (0x0038 - 0x0000)
struct FTargetRotationData final
{
public:
	class AActor*                                 TargetActor;                                       // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FRotateStepInfo>                StepInfos;                                         // 0x0010(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_20[0x18];                                      // 0x0020(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTargetRotationData) == 0x000008, "Wrong alignment on FTargetRotationData");
static_assert(sizeof(FTargetRotationData) == 0x000038, "Wrong size on FTargetRotationData");
static_assert(offsetof(FTargetRotationData, TargetActor) == 0x000000, "Member 'FTargetRotationData::TargetActor' has a wrong offset!");
static_assert(offsetof(FTargetRotationData, StepInfos) == 0x000010, "Member 'FTargetRotationData::StepInfos' has a wrong offset!");

// ScriptStruct KuroComponent.SplineMoveStaticTimeDisData
// 0x0020 (0x0020 - 0x0000)
struct FSplineMoveStaticTimeDisData final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            TimeDisCurve;                                      // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10[0x10];                                      // 0x0010(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSplineMoveStaticTimeDisData) == 0x000008, "Wrong alignment on FSplineMoveStaticTimeDisData");
static_assert(sizeof(FSplineMoveStaticTimeDisData) == 0x000020, "Wrong size on FSplineMoveStaticTimeDisData");
static_assert(offsetof(FSplineMoveStaticTimeDisData, TimeDisCurve) == 0x000008, "Member 'FSplineMoveStaticTimeDisData::TimeDisCurve' has a wrong offset!");

// ScriptStruct KuroComponent.SplineMoveDynamicSpeedData
// 0x0010 (0x0010 - 0x0000)
struct FSplineMoveDynamicSpeedData final
{
public:
	float                                         TargetSpeed;                                       // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Acceleration;                                      // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CurrentSpeed;                                      // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EndDis;                                            // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSplineMoveDynamicSpeedData) == 0x000004, "Wrong alignment on FSplineMoveDynamicSpeedData");
static_assert(sizeof(FSplineMoveDynamicSpeedData) == 0x000010, "Wrong size on FSplineMoveDynamicSpeedData");
static_assert(offsetof(FSplineMoveDynamicSpeedData, TargetSpeed) == 0x000000, "Member 'FSplineMoveDynamicSpeedData::TargetSpeed' has a wrong offset!");
static_assert(offsetof(FSplineMoveDynamicSpeedData, Acceleration) == 0x000004, "Member 'FSplineMoveDynamicSpeedData::Acceleration' has a wrong offset!");
static_assert(offsetof(FSplineMoveDynamicSpeedData, CurrentSpeed) == 0x000008, "Member 'FSplineMoveDynamicSpeedData::CurrentSpeed' has a wrong offset!");
static_assert(offsetof(FSplineMoveDynamicSpeedData, EndDis) == 0x00000C, "Member 'FSplineMoveDynamicSpeedData::EndDis' has a wrong offset!");

// ScriptStruct KuroComponent.SplineMoveData
// 0x0068 (0x0068 - 0x0000)
struct FSplineMoveData final
{
public:
	class USplineComponent*                       Spline;                                            // 0x0000(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x30];                                       // 0x0008(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSplineMoveStaticTimeDisData           StaticTimeDisData;                                 // 0x0038(0x0020)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FSplineMoveDynamicSpeedData            DynamicSpeedData;                                  // 0x0058(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSplineMoveData) == 0x000008, "Wrong alignment on FSplineMoveData");
static_assert(sizeof(FSplineMoveData) == 0x000068, "Wrong size on FSplineMoveData");
static_assert(offsetof(FSplineMoveData, Spline) == 0x000000, "Member 'FSplineMoveData::Spline' has a wrong offset!");
static_assert(offsetof(FSplineMoveData, StaticTimeDisData) == 0x000038, "Member 'FSplineMoveData::StaticTimeDisData' has a wrong offset!");
static_assert(offsetof(FSplineMoveData, DynamicSpeedData) == 0x000058, "Member 'FSplineMoveData::DynamicSpeedData' has a wrong offset!");

// ScriptStruct KuroComponent.SimpleMoveData
// 0x0090 (0x0090 - 0x0000)
struct alignas(0x08) FSimpleMoveData final
{
public:
	uint8                                         Pad_0[0x90];                                       // 0x0000(0x0090)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSimpleMoveData) == 0x000008, "Wrong alignment on FSimpleMoveData");
static_assert(sizeof(FSimpleMoveData) == 0x000090, "Wrong size on FSimpleMoveData");

}

